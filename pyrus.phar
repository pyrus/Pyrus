<?php
if (!class_exists('Phar')) {
    if (!class_exists('PHP_Archive')) {
?><?php
/**
 * PHP_Archive Class (implements .phar)
 *
 * @package PHP_Archive
 * @category PHP
 */
/**
 * PHP_Archive Class (implements .phar)
 *
 * PHAR files a singular archive from which an entire application can run.
 * To use it, simply package it using {@see PHP_Archive_Creator} and use phar://
 * URIs to your includes. i.e. require_once 'phar://config.php' will include config.php
 * from the root of the PHAR file.
 *
 * Gz code borrowed from the excellent File_Archive package by Vincent Lascaux.
 *
 * @copyright Copyright David Shafik and Synaptic Media 2004. All rights reserved.
 * @author Davey Shafik <davey@synapticmedia.net>
 * @author Greg Beaver <cellog@php.net>
 * @link http://www.synapticmedia.net Synaptic Media
 * @version $Id: Archive.php,v 1.52 2007/09/01 20:28:14 cellog Exp $
 * @package PHP_Archive
 * @category PHP
 */
 
class PHP_Archive
{
    const GZ = 0x00001000;
    const BZ2 = 0x00002000;
    const SIG = 0x00010000;
    const SHA1 = 0x0002;
    const MD5 = 0x0001;
    /**
     * Whether this archive is compressed with zlib
     *
     * @var bool
     */
    private $_compressed;
    /**
     * @var string Real path to the .phar archive
     */
    private $_archiveName = null;
    /**
     * Current file name in the phar
     * @var string
     */
    protected $currentFilename = null;
    /**
     * Length of current file in the phar
     * @var string
     */
    protected $internalFileLength = null;
    /**
     * Current file statistics (size, creation date, etc.)
     * @var string
     */
    protected $currentStat = null;
    /**
     * @var resource|null Pointer to open .phar
     */
    protected $fp = null;
    /**
     * @var int Current Position of the pointer
     */
    protected $position = 0;

    /**
     * Map actual realpath of phars to meta-data about the phar
     *
     * Data is indexed by the alias that is used by internal files.  In other
     * words, if a file is included via:
     * <code>
     * require_once 'phar://PEAR.phar/PEAR/Installer.php';
     * </code>
     * then the alias is "PEAR.phar"
     * 
     * Information stored is a boolean indicating whether this .phar is compressed
     * with zlib, another for bzip2, phar-specific meta-data, and
     * the precise offset of internal files
     * within the .phar, used with the {@link $_manifest} to load actual file contents
     * @var array
     */
    private static $_pharMapping = array();
    /**
     * Map real file paths to alias used
     *
     * @var array
     */
    private static $_pharFiles = array();
    /**
     * File listing for the .phar
     * 
     * The manifest is indexed per phar.
     * 
     * Files within the .phar are indexed by their relative path within the
     * .phar.  Each file has this information in its internal array
     *
     * - 0 = uncompressed file size
     * - 1 = timestamp of when file was added to phar
     * - 2 = offset of file within phar relative to internal file's start
     * - 3 = compressed file size (actual size in the phar)
     * @var array
     */
    private static $_manifest = array();
    /**
     * Absolute offset of internal files within the .phar, indexed by absolute
     * path to the .phar
     *
     * @var array
     */
    private static $_fileStart = array();
    /**
     * file name of the phar
     *
     * @var string
     */
    private $_basename;


    /**
     * Default MIME types used for the web front controller
     *
     * @var array
     */
    public static $defaultmimes = array(
            'aif' => 'audio/x-aiff',
            'aiff' => 'audio/x-aiff',
            'arc' => 'application/octet-stream',
            'arj' => 'application/octet-stream',
            'art' => 'image/x-jg',
            'asf' => 'video/x-ms-asf',
            'asx' => 'video/x-ms-asf',
            'avi' => 'video/avi',
            'bin' => 'application/octet-stream',
            'bm' => 'image/bmp',
            'bmp' => 'image/bmp',
            'bz2' => 'application/x-bzip2',
            'css' => 'text/css',
            'doc' => 'application/msword',
            'dot' => 'application/msword',
            'dv' => 'video/x-dv',
            'dvi' => 'application/x-dvi',
            'eps' => 'application/postscript',
            'exe' => 'application/octet-stream',
            'gif' => 'image/gif',
            'gz' => 'application/x-gzip',
            'gzip' => 'application/x-gzip',
            'htm' => 'text/html',
            'html' => 'text/html',
            'ico' => 'image/x-icon',
            'jpe' => 'image/jpeg',
            'jpg' => 'image/jpeg',
            'jpeg' => 'image/jpeg',
            'js' => 'application/x-javascript',
            'log' => 'text/plain',
            'mid' => 'audio/x-midi',
            'mov' => 'video/quicktime',
            'mp2' => 'audio/mpeg',
            'mp3' => 'audio/mpeg3',
            'mpg' => 'audio/mpeg',
            'pdf' => 'aplication/pdf',
            'png' => 'image/png',
            'rtf' => 'application/rtf',
            'tif' => 'image/tiff',
            'tiff' => 'image/tiff',
            'txt' => 'text/plain',
            'xml' => 'text/xml',
        );

    public static $defaultphp = array(
        'php' => true
        );

    public static $defaultphps = array(
        'phps' => true
        );

    public static $deny = array('/.+\.inc$/');

    public static function viewSource($archive, $file)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        if (self::_fileExists($archive, $_GET['viewsource'])) {
            $source = highlight_file('phar://@ALIAS@/' .
                $_GET['viewsource'], true);
            header('Content-Type: text/html');
            header('Content-Length: ' . strlen($source));
            echo '<html><head><title>Source of ',
                htmlspecialchars($_GET['viewsource']), '</title></head>';
            echo '<body><h1>Source of ',
                htmlspecialchars($_GET['viewsource']), '</h1>';
            if (isset($_GET['introspect'])) {
                echo '<a href="', htmlspecialchars($_SERVER['PHP_SELF']),
                    '?introspect=', urlencode(htmlspecialchars($_GET['introspect'])),
                    '">Return to ', htmlspecialchars($_GET['introspect']), '</a><br />';
            }
            echo $source;
            return false;
        } else {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        
    }

    public static function introspect($archive, $dir)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        if (!$dir) {
            $dir = '/';
        }
        $dir = self::processFile($dir);
        if ($dir[0] != '/') {
            $dir = '/' . $dir;
        }
        try {
            $self = htmlspecialchars($_SERVER['PHP_SELF']);
            $iterate = new DirectoryIterator('phar://@ALIAS@' . $dir);
            echo '<html><head><title>Introspect ', htmlspecialchars($dir),
                '</title></head><body><h1>Introspect ', htmlspecialchars($dir),
                '</h1><ul>';
            if ($dir != '/') {
                echo '<li><a href="', $self, '?introspect=',
                    htmlspecialchars(dirname($dir)), '">..</a></li>';
            }
            foreach ($iterate as $entry) {
                if ($entry->isDot()) continue;
                $name = self::processFile($entry->getPathname());
                $name = str_replace('phar://@ALIAS@/', '', $name);
                if ($entry->isDir()) {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '/</a> [directory]</li>';
                } else {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($dir)), '&viewsource=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '</a></li>';
                }
            }
            return false;
        } catch (Exception $e) {
            echo '<html><head><title>Directory not found: ',
                htmlspecialchars($dir), '</title></head>',
                '<body><h1>Directory not found: ', htmlspecialchars($dir), '</h1>',
                '<p>Try <a href="', htmlspecialchars($_SERVER['PHP_SELF']), '?introspect=/">',
                'This link</a></p></body></html>';
            return false;
        }
    }

    public static function webFrontController($initfile)
    {
        if (isset($_SERVER) && isset($_SERVER['REQUEST_URI'])) {
            $uri = parse_url($_SERVER['REQUEST_URI']);
            $archive = realpath($_SERVER['SCRIPT_FILENAME']);
            $subpath = str_replace('/' . basename($archive), '', $uri['path']);
            if (!$subpath || $subpath == '/') {
                if (isset($_GET['viewsource'])) {
                    return self::viewSource($archive, $_GET['viewsource']);
                }
                if (isset($_GET['introspect'])) {
                    return self::introspect($archive, $_GET['introspect']);
                }
                $subpath = '/' . $initfile;
            }
            if (!self::_fileExists($archive, substr($subpath, 1))) {
                header("HTTP/1.0 404 Not Found");
                return false;
            }
            foreach (self::$deny as $pattern) {
                if (preg_match($pattern, $subpath)) {
                    header("HTTP/1.0 404 Not Found");
                    return false;
                }
            }
            $inf = pathinfo(basename($subpath));
            if (!isset($inf['extension'])) {
                header('Content-Type: text/plain');
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://@ALIAS@' . $subpath);
                return false;
            }
            if (isset(self::$defaultphp[$inf['extension']])) {
                include 'phar://@ALIAS@' . $subpath;
                return false;
            }
            if (isset(self::$defaultmimes[$inf['extension']])) {
                header('Content-Type: ' . self::$defaultmimes[$inf['extension']]);
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://@ALIAS@' . $subpath);
                return false;
            }
            if (isset(self::$defaultphps[$inf['extension']])) {
                header('Content-Type: text/html');
                $c = highlight_file('phar://@ALIAS@' . $subpath, true);
                header('Content-Length: ' . strlen($c));
                echo $c;
                return false;
            }
            header('Content-Type: text/plain');
            header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
            readfile('phar://@ALIAS@' . $subpath);
        }
    }

    /**
     * Detect end of stub
     *
     * @param string $buffer stub past '__HALT_'.'COMPILER();'
     * @return end of stub, prior to length of manifest.
     */
    private static final function _endOfStubLength($buffer)
    {
        $pos = 0;
        if (!strlen($buffer)) {
            return $pos;
        }
        if (($buffer[0] == ' ' || $buffer[0] == "\n") && @substr($buffer, 1, 2) == '?>')
        {
            $pos += 3;
            if ($buffer[$pos] == "\r" && $buffer[$pos+1] == "\n") {
                $pos += 2;
            }
            else if ($buffer[$pos] == "\n") {
                $pos += 1;
            }
        }
        return $pos;
    }

    /**
     * Allows loading an external Phar archive without include()ing it
     *
     * @param string $file  phar package to load
     * @param string $alias alias to use
     * @throws Exception
     */
    public static final function loadPhar($file, $alias = NULL)
    {
        $file = realpath($file);
        if ($file) {
            $fp = fopen($file, 'rb');
            $buffer = '';
            while (!feof($fp)) {
                $buffer .= fread($fp, 8192);
                // don't break phars
                if ($pos = strpos($buffer, '__HALT_COMPI' . 'LER();')) {
                    $buffer .= fread($fp, 5);
                    fclose($fp);
                    $pos += 18;
                    $pos += self::_endOfStubLength(substr($buffer, $pos));
                    return self::_mapPhar($file, $pos, $alias);
                }
            }
            fclose($fp);
        }
    }

    /**
     * Map a full real file path to an alias used to refer to the .phar
     *
     * This function can only be called from the initialization of the .phar itself.
     * Any attempt to call from outside the .phar or to re-alias the .phar will fail
     * as a security measure.
     * @param string $alias
     * @param int $dataoffset the value of __COMPILER_HALT_OFFSET__
     */
    public static final function mapPhar($alias = NULL, $dataoffset = NULL)
    {
        try {
            $trace = debug_backtrace();
            $file = $trace[0]['file'];
            // this ensures that this is safe
            if (!in_array($file, get_included_files())) {
                die('SECURITY ERROR: PHP_Archive::mapPhar can only be called from within ' .
                    'the phar that initiates it');
            }
            $file = realpath($file);
            if (!isset($dataoffset)) {
                $dataoffset = constant('__COMPILER_HALT_OFFSET'.'__');
                $fp = fopen($file, 'rb');
                fseek($fp, $dataoffset, SEEK_SET);
                $dataoffset = $dataoffset + self::_endOfStubLength(fread($fp, 5));
                fclose($fp);
            }

            self::_mapPhar($file, $dataoffset);
        } catch (Exception $e) {
            die($e->getMessage());
        }
    }

    /**
     * Sub-function, allows recovery from errors
     *
     * @param unknown_type $file
     * @param unknown_type $dataoffset
     */
    private static function _mapPhar($file, $dataoffset, $alias = NULL)
    {
        $file = realpath($file);
        if (isset(self::$_manifest[$file])) {
            return;
        }
        if (!is_array(self::$_pharMapping)) {
            self::$_pharMapping = array();
        }
        $fp = fopen($file, 'rb');
        // seek to __HALT_COMPILER_OFFSET__
        fseek($fp, $dataoffset);
        $manifest_length = unpack('Vlen', fread($fp, 4));
        $manifest = '';
        $last = '1';
        while (strlen($last) && strlen($manifest) < $manifest_length['len']) {
            $read = 8192;
            if ($manifest_length['len'] - strlen($manifest) < 8192) {
                $read = $manifest_length['len'] - strlen($manifest);
            }
            $last = fread($fp, $read);
            $manifest .= $last;
        }
        if (strlen($manifest) < $manifest_length['len']) {
            throw new Exception('ERROR: manifest length read was "' . 
                strlen($manifest) .'" should be "' .
                $manifest_length['len'] . '"');
        }
        $info = self::_unserializeManifest($manifest);
        if ($info['alias']) {
            $alias = $info['alias'];
            $explicit = true;
        } else {
            if (!isset($alias)) {
                $alias = $file;
            }
            $explicit = false;
        }
        self::$_manifest[$file] = $info['manifest'];
        $compressed = $info['compressed'];
        self::$_fileStart[$file] = ftell($fp);
        fclose($fp);
        if ($compressed & 0x00001000) {
            if (!function_exists('gzinflate')) {
                throw new Exception('Error: zlib extension is not enabled - gzinflate() function needed' .
                    ' for compressed .phars');
            }
        }
        if ($compressed & 0x00002000) {
            if (!function_exists('bzdecompress')) {
                throw new Exception('Error: bzip2 extension is not enabled - bzdecompress() function needed' .
                    ' for compressed .phars');
            }
        }
        if (isset(self::$_pharMapping[$alias])) {
            throw new Exception('ERROR: PHP_Archive::mapPhar has already been called for alias "' .
                $alias . '" cannot re-alias to "' . $file . '"');
        }
        self::$_pharMapping[$alias] = array($file, $compressed, $dataoffset, $explicit,
            $info['metadata']);
        self::$_pharFiles[$file] = $alias;
    }

    /**
     * extract the manifest into an internal array
     *
     * @param string $manifest
     * @return false|array
     */
    private static function _unserializeManifest($manifest)
    {
        // retrieve the number of files in the manifest
        $info = unpack('V', substr($manifest, 0, 4));
        $apiver = substr($manifest, 4, 2);
        $apiver = bin2hex($apiver);
        $apiver_dots = hexdec($apiver[0]) . '.' . hexdec($apiver[1]) . '.' . hexdec($apiver[2]);
        $majorcompat = hexdec($apiver[0]);
        $calcapi = explode('.', self::APIVersion());
        if ($calcapi[0] != $majorcompat) {
            throw new Exception('Phar is incompatible API version ' . $apiver_dots . ', but ' .
                'PHP_Archive is API version '.self::APIVersion());
        }
        if ($calcapi[0] === '0') {
            if (self::APIVersion() != $apiver_dots) {
                throw new Exception('Phar is API version ' . $apiver_dots .
                    ', but PHP_Archive is API version '.self::APIVersion(), E_USER_ERROR);
            }
        }
        $flags = unpack('V', substr($manifest, 6, 4));
        $ret = array('compressed' => $flags & 0x00003000);
        // signature is not verified by default in PHP_Archive, phar is better
        $ret['hassignature'] = $flags & 0x00010000;
        $aliaslen = unpack('V', substr($manifest, 10, 4));
        if ($aliaslen) {
            $ret['alias'] = substr($manifest, 14, $aliaslen[1]);
        } else {
            $ret['alias'] = false;
        }
        $manifest = substr($manifest, 14 + $aliaslen[1]);
        $metadatalen = unpack('V', substr($manifest, 0, 4));
        if ($metadatalen[1]) {
            $ret['metadata'] = unserialize(substr($manifest, 4, $metadatalen[1]));
            $manifest = substr($manifest, 4 + $metadatalen[1]);
        } else {
            $ret['metadata'] = null;
            $manifest = substr($manifest, 4);
        }
        $offset = 0;
        $start = 0;
        for ($i = 0; $i < $info[1]; $i++) {
            // length of the file name
            $len = unpack('V', substr($manifest, $start, 4));
            $start += 4;
            // file name
            $savepath = substr($manifest, $start, $len[1]);
            $start += $len[1];
            // retrieve manifest data:
            // 0 = uncompressed file size
            // 1 = timestamp of when file was added to phar
            // 2 = compressed filesize
            // 3 = crc32
            // 4 = flags
            // 5 = metadata length
            $ret['manifest'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($manifest, $start, 24)));
            $ret['manifest'][$savepath][3] = sprintf('%u', $ret['manifest'][$savepath][3]
                & 0xffffffff);
            if ($ret['manifest'][$savepath][5]) {
                $ret['manifest'][$savepath][6] = unserialize(substr($manifest, $start + 24,
                    $ret['manifest'][$savepath][5]));
            } else {
                $ret['manifest'][$savepath][6] = null;
            }
            $ret['manifest'][$savepath][7] = $offset;
            $offset += $ret['manifest'][$savepath][2];
            $start += 24 + $ret['manifest'][$savepath][5];
        }
        return $ret;
    }

    /**
     * @param string
     */
    private static function processFile($path)
    {
        if ($path == '.') {
            return '';
        }
        $std = str_replace("\\", "/", $path);
        while ($std != ($std = ereg_replace("[^\/:?]+/\.\./", "", $std))) ;
        $std = str_replace("/./", "", $std);
        if (strlen($std) > 1 && $std[0] == '/') {
            $std = substr($std, 1);
        }
        if (strncmp($std, "./", 2) == 0) {
            return substr($std, 2);
        } else {
            return $std;
        }
    }

    /**
     * Seek in the master archive to a matching file or directory
     * @param string
     */
    protected function selectFile($path, $allowdirs = true)
    {
        $std = self::processFile($path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            $this->_setCurrentFile($path);
            return true;
        }
        if (!$allowdirs) {
            return 'Error: "' . $path . '" is not a file in phar "' . $this->_basename . '"';
        }
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if (empty($std) ||
                  //$std is a directory
                  strncmp($std.'/', $path, strlen($std)+1) == 0) {
                $this->currentFilename = $this->internalFileLength = $this->currentStat = null;
                return true;
            }
        }
        return 'Error: "' . $path . '" not found in phar "' . $this->_basename . '"';
    }

    private function _setCurrentFile($path)
    {
        $this->currentStat = array(
            2 => 0100444, // file mode, readable by all, writeable by none
            4 => 0, // uid
            5 => 0, // gid
            7 => self::$_manifest[$this->_archiveName][$path][0], // size
            9 => self::$_manifest[$this->_archiveName][$path][1], // creation time
            );
        $this->currentFilename = $path;
        $this->internalFileLength = self::$_manifest[$this->_archiveName][$path][2];
        // seek to offset of file header within the .phar
        if (is_resource(@$this->fp)) {
            fseek($this->fp, self::$_fileStart[$this->_archiveName] + self::$_manifest[$this->_archiveName][$path][7]);
        }
    }

    private static function _fileExists($archive, $path)
    {
        return isset(self::$_manifest[$archive]) &&
            isset(self::$_manifest[$archive][$path]);
    }

    private static function _filesize($archive, $path)
    {
        return self::$_manifest[$archive][$path][0];
    }

    /**
     * Seek to a file within the master archive, and extract its contents
     * @param string
     * @return array|string an array containing an error message string is returned
     *                      upon error, otherwise the file contents are returned
     */
    public function extractFile($path)
    {
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            return array('Error: cannot open phar "' . $this->_archiveName . '"');
        }
        if (($e = $this->selectFile($path, false)) === true) {
            $data = '';
            $count = $this->internalFileLength;
            while ($count) {
                if ($count < 8192) {
                    $data .= @fread($this->fp, $count);
                    $count = 0;
                } else {
                    $count -= 8192;
                    $data .= @fread($this->fp, 8192);
                }
            }
            @fclose($this->fp);
            if (self::$_manifest[$this->_archiveName][$path][4] & self::GZ) {
                $data = gzinflate($data);
            } elseif (self::$_manifest[$this->_archiveName][$path][4] & self::BZ2) {
                $data = bzdecompress($data);
            }
            if (!isset(self::$_manifest[$this->_archiveName][$path]['ok'])) {
                if (strlen($data) != $this->currentStat[7]) {
                    return array("Not valid internal .phar file (size error {$size} != " .
                        $this->currentStat[7] . ")");
                }
                if (self::$_manifest[$this->_archiveName][$path][3] != sprintf("%u", crc32($data) & 0xffffffff)) {
                    return array("Not valid internal .phar file (checksum error)");
                }
                self::$_manifest[$this->_archiveName][$path]['ok'] = true;
            }
            return $data;
        } else {
            @fclose($this->fp);
            return array($e);
        }
    }

    /**
     * Parse urls like phar:///fullpath/to/my.phar/file.txt
     *
     * @param string $file
     * @return false|array
     */
    static protected function parseUrl($file)
    {
        if (substr($file, 0, 7) != 'phar://') {
            return false;
        }
        $file = substr($file, 7);
    
        $ret = array('scheme' => 'phar');
        $pos_p = strpos($file, '.phar.php');
        $pos_z = strpos($file, '.phar.gz');
        $pos_b = strpos($file, '.phar.bz2');
        if ($pos_p) {
            if ($pos_z) {
                return false;
            }
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar.php'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_z) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.gz'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_b) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.bz2'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif (($pos_p = strpos($file, ".phar")) !== false) {
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } else {
            return false;
        }
        if (!$ret['path']) {
            $ret['path'] = '/';
        }
        return $ret;
    }
    
    /**
     * Locate the .phar archive in the include_path and detect the file to open within
     * the archive.
     *
     * Possible parameters are phar://pharname.phar/filename_within_phar.ext
     * @param string a file within the archive
     * @return string the filename within the .phar to retrieve
     */
    public function initializeStream($file)
    {
        $file = self::processFile($file);
        $info = @parse_url($file);
        if (!$info) {
            $info = self::parseUrl($file);
        }
        if (!$info) {
            return false;
        }
        if (!isset($info['host'])) {
            // malformed internal file
            return false;
        }
        if (!isset(self::$_pharFiles[$info['host']]) &&
              !isset(self::$_pharMapping[$info['host']])) {
            try {
                self::loadPhar($info['host']);
                // use alias from here out
                $info['host'] = self::$_pharFiles[$info['host']];
            } catch (Exception $e) {
                return false;
            }
        }
        if (!isset($info['path'])) {
            return false;
        } elseif (strlen($info['path']) > 1) {
            $info['path'] = substr($info['path'], 1);
        }
        if (isset(self::$_pharMapping[$info['host']])) {
            $this->_basename = $info['host'];
            $this->_archiveName = self::$_pharMapping[$info['host']][0];
            $this->_compressed = self::$_pharMapping[$info['host']][1];
        } elseif (isset(self::$_pharFiles[$info['host']])) {
            $this->_archiveName = $info['host'];
            $this->_basename = self::$_pharFiles[$info['host']];
            $this->_compressed = self::$_pharMapping[$this->_basename][1];
        }
        $file = $info['path'];
        return $file;
    }

    /**
     * Open the requested file - PHP streams API
     *
     * @param string $file String provided by the Stream wrapper
     * @access private
     */
    public function stream_open($file)
    {
        return $this->_streamOpen($file);
    }

    /**
     * @param string filename to opne, or directory name
     * @param bool if true, a directory will be matched, otherwise only files
     *             will be matched
     * @uses trigger_error()
     * @return bool success of opening
     * @access private
     */
    private function _streamOpen($file, $searchForDir = false)
    {
        $path = $this->initializeStream($file);
        if (!$path) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
        }
        if (is_array($this->file = $this->extractFile($path))) {
            trigger_error($this->file[0], E_USER_ERROR);
            return false;
        }
        if ($path != $this->currentFilename) {
            if (!$searchForDir) {
                trigger_error("Cannot open '$file', is a directory", E_USER_ERROR);
                return false;
            } else {
                $this->file = '';
                return true;
            }
        }

        if (!is_null($this->file) && $this->file !== false) {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Read the data - PHP streams API
     *
     * @param int
     * @access private
     */
    public function stream_read($count)
    {
        $ret = substr($this->file, $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }
    
    /**
     * Whether we've hit the end of the file - PHP streams API
     * @access private
     */
    function stream_eof()
    {
        return $this->position >= $this->currentStat[7];
    }
    
    /**
     * For seeking the stream - PHP streams API
     * @param int
     * @param SEEK_SET|SEEK_CUR|SEEK_END
     * @access private
     */
    public function stream_seek($pos, $whence)
    {
        switch ($whence) {
            case SEEK_SET:
                if ($pos < 0) {
                    return false;
                }
                $this->position = $pos;
                break;
            case SEEK_CUR:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position += $pos;
                break;
            case SEEK_END:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position = $pos + $this->currentStat[7];
                break;
            default:
                return false;
        }
        return true;
    }
    
    /**
     * The current position in the stream - PHP streams API
     * @access private
     */
    public function stream_tell()
    {
        return $this->position;
    }

    /**
     * The result of an fstat call, returns mod time from creation, and file size -
     * PHP streams API
     * @uses _stream_stat()
     * @access private
     */
    public function stream_stat()
    {
        return $this->_stream_stat();
    }

    /**
     * Retrieve statistics on a file or directory within the .phar
     * @param string file/directory to stat
     * @access private
     */
    public function _stream_stat($file = null)
    {
        $std = $file ? self::processFile($file) : $this->currentFilename;
        if ($file) {
            if (isset(self::$_manifest[$this->_archiveName][$file])) {
                $this->_setCurrentFile($file);
                $isdir = false;
            } else {
                do {
                    $isdir = false;
                    if ($file == '/') {
                        break;
                    }
                    foreach (self::$_manifest[$this->_archiveName] as $path => $info) {
                        if (strpos($path, $file) === 0) {
                            if (strlen($path) > strlen($file) &&
                                  $path[strlen($file)] == '/') {
                                break 2;
                            }
                        }
                    }
                    // no files exist and no directories match this string
                    return false;
                } while (false);
                $isdir = true;
            }
        } else {
            $isdir = false; // open streams must be files
        }
        $mode = $isdir ? 0040444 : 0100444;
        // 040000 = dir, 010000 = file
        // everything is readable, nothing is writeable
        return array(
           0, 0, $mode, 0, 0, 0, 0, 0, 0, 0, 0, 0, // non-associative indices
           'dev' => 0, 'ino' => 0,
           'mode' => $mode,
           'nlink' => 0, 'uid' => 0, 'gid' => 0, 'rdev' => 0, 'blksize' => 0, 'blocks' => 0,
           'size' => $this->currentStat[7],
           'atime' => $this->currentStat[9],
           'mtime' => $this->currentStat[9],
           'ctime' => $this->currentStat[9],
           );
    }

    /**
     * Stat a closed file or directory - PHP streams API
     * @param string
     * @param int
     * @access private
     */
    public function url_stat($url, $flags)
    {
        $path = $this->initializeStream($url);
        return $this->_stream_stat($path);
    }

    /**
     * Open a directory in the .phar for reading - PHP streams API
     * @param string directory name
     * @access private
     */
    public function dir_opendir($path)
    {
        $info = @parse_url($path);
        if (!$info) {
            $info = self::parseUrl($path);
            if (!$info) {
                trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                    E_USER_ERROR);
                return false;
            }
        }
        $path = !empty($info['path']) ?
            $info['host'] . $info['path'] : $info['host'] . '/';
        $path = $this->initializeStream('phar://' . $path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                E_USER_ERROR);
            return false;
        }
        if ($path == false) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
            return false;
        }
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            trigger_error('Error: cannot open phar "' . $this->_archiveName . '"');
            return false;
        }
        $this->_dirFiles = array();
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if ($path == '/') {
                if (strpos($file, '/')) {
                    $a = explode('/', $file);
                    $this->_dirFiles[array_shift($a)] = true;
                } else {
                    $this->_dirFiles[$file] = true;
                }
            } elseif (strpos($file, $path) === 0) {
                $fname = substr($file, strlen($path) + 1);
                if (strpos($fname, '/')) {
                    // this is a directory
                    $a = explode('/', $fname);
                    $this->_dirFiles[array_shift($a)] = true;
                } elseif ($file[strlen($path)] == '/') {
                    // this is a file
                    $this->_dirFiles[$fname] = true;
                }
            }
        }
        @fclose($this->fp);
        if (!count($this->_dirFiles)) {
            return false;
        }
        @uksort($this->_dirFiles, 'strnatcmp');
        return true;
    }

    /**
     * Read the next directory entry - PHP streams API
     * @access private
     */
    public function dir_readdir()
    {
        $ret = key($this->_dirFiles);
        @next($this->_dirFiles);
        if (!$ret) {
            return false;
        }
        return $ret;
    }

    /**
     * Close a directory handle opened with opendir() - PHP streams API
     * @access private
     */
    public function dir_closedir()
    {
        $this->_dirFiles = array();
        return true;
    }

    /**
     * Rewind to the first directory entry - PHP streams API
     * @access private
     */
    public function dir_rewinddir()
    {
        @reset($this->_dirFiles);
        return true;
    }

    /**
     * API version of this class
     * @return string
     */
    public static final function APIVersion()
    {
        return '1.0.0';
    }

    /**
     * Retrieve Phar-specific metadata for a Phar archive
     *
     * @param string $phar full path to Phar archive, or alias
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getPharMetadata($phar)
    {
        if (isset(self::$_pharFiles[$phar])) {
            $phar = self::$_pharFiles[$phar];
        }
        if (!isset(self::$_pharMapping[$phar])) {
            throw new Exception('Unknown Phar archive: "' . $phar . '"');
        }
        return self::$_pharMapping[$phar][4];
    }

    /**
     * Retrieve File-specific metadata for a Phar archive file
     *
     * @param string $phar full path to Phar archive, or alias
     * @param string $file relative path to file within Phar archive
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getFileMetadata($phar, $file)
    {
        if (!isset(self::$_pharFiles[$phar])) {
            if (!isset(self::$_pharMapping[$phar])) {
                throw new Exception('Unknown Phar archive: "' . $phar . '"');
            }
            $phar = self::$_pharMapping[$phar][0];
        }
        if (!isset(self::$_manifest[$phar])) {
            throw new Exception('Unknown Phar: "' . $phar . '"');
        }
        $file = self::processFile($file);
        if (!isset(self::$_manifest[$phar][$file])) {
            throw new Exception('Unknown file "' . $file . '" within Phar "'. $phar . '"');
        }
        return self::$_manifest[$phar][$file][6];
    }

    /**
     * @return list of supported signature algorithmns.
     */
    public static function getsupportedsignatures()
    {
        $ret = array('MD5', 'SHA-1');
        if (extension_loaded('hash')) {
            $ret[] = 'SHA-256';
            $ret[] = 'SHA-512';
        }
        return $ret;
    }
}
?><?php
    }
    if (!in_array('phar', stream_get_wrappers(), true)) {
        stream_wrapper_register('phar', 'PHP_Archive');
    }
}
define('PYRUS_PHAR_FILE', __FILE__);
include 'phar://' . __FILE__ . '/__index.php';
__HALT_COMPILER(); ?>
øW  3         5   s:45:"package-pear2.php.net-PEAR2_Pyrus-2.0.0a1.xml";   __index.php˛   c¿bH˛   ,O∏#∂      -   package-pear2.php.net-PEAR2_Pyrus-2.0.0a1.xmlçe  c¿bHçe  “¸"}∂         data/pear2.php.net/PEAR2_Pyrus/    c¿bH        ˇ      .   data/pear2.php.net/PEAR2_Pyrus/channel-1.0.xsd∫  c¿bH∫  ä≤vw∂      .   data/pear2.php.net/PEAR2_Pyrus/package-2.0.xsd‚M  c¿bH‚M  °+"”∂      .   data/pear2.php.net/PEAR2_Pyrus/package-2.1.xsd‰P  c¿bH‰P  ºØ,v∂      
   src/PEAR2/    c¿bH        ˇ         src/PEAR2/Pyrus.phpm  c¿bHm  ^≈¡‚∂         src/PEAR2/Pyrus/    c¿bH        ˇ         src/PEAR2/Pyrus/Channel.php0L  c¿bH0L  Âß≥∂∂         src/PEAR2/Pyrus/Channel/    c¿bH        ˇ          src/PEAR2/Pyrus/Channel/Base.phpó	  c¿bHó	  =ê/®∂      %   src/PEAR2/Pyrus/Channel/Exception.phpŒ  c¿bHŒ  Ma-ö∂      #   src/PEAR2/Pyrus/Channel/IMirror.php‡  c¿bH‡  ô*(å∂      "   src/PEAR2/Pyrus/Channel/Mirror.php'  c¿bH'  Kﬁ≤∂      #   src/PEAR2/Pyrus/ChannelRegistry.phpY  c¿bHY  k‰GÄ∂          src/PEAR2/Pyrus/ChannelRegistry/    c¿bH        ˇ      (   src/PEAR2/Pyrus/ChannelRegistry/Base.phpG=  c¿bHG=  ¶LA∂      (   src/PEAR2/Pyrus/ChannelRegistry/Channel/    c¿bH        ˇ      1   src/PEAR2/Pyrus/ChannelRegistry/Channel/Pear1.phph
  c¿bHh
  …Î]∂      2   src/PEAR2/Pyrus/ChannelRegistry/Channel/Sqlite.php9  c¿bH9  √†|¡∂      /   src/PEAR2/Pyrus/ChannelRegistry/Channel/Xml.phpp
  c¿bHp
  ’ï§∂      -   src/PEAR2/Pyrus/ChannelRegistry/Exception.php  c¿bH  ˜<^∂      '   src/PEAR2/Pyrus/ChannelRegistry/Mirror/    c¿bH        ˇ      1   src/PEAR2/Pyrus/ChannelRegistry/Mirror/Sqlite.php  c¿bH  ËXL∂      .   src/PEAR2/Pyrus/ChannelRegistry/Mirror/Xml.php¨	  c¿bH¨	  {·§ö∂      2   src/PEAR2/Pyrus/ChannelRegistry/ParseException.phpî  c¿bHî  Æ:c∂      )   src/PEAR2/Pyrus/ChannelRegistry/Pear1.phpC  c¿bHC  ‡æí∂      *   src/PEAR2/Pyrus/ChannelRegistry/Sqlite.php.  c¿bH.  ‘ÑZ¡∂      '   src/PEAR2/Pyrus/ChannelRegistry/Xml.php
  c¿bH
  ÷7Åı∂         src/PEAR2/Pyrus/Config.phpPà  c¿bHPà  ßØóÏ∂         src/PEAR2/Pyrus/Config/    c¿bH        ˇ      $   src/PEAR2/Pyrus/Config/Exception.php›  c¿bH›  ∑æ„∂      #   src/PEAR2/Pyrus/Config/Snapshot.php!  c¿bH!  x√º∂         src/PEAR2/Pyrus/Dependency/    c¿bH        ˇ      (   src/PEAR2/Pyrus/Dependency/Exception.phpÿ  c¿bHÿ  PÎõ}∂      (   src/PEAR2/Pyrus/Dependency/Validator.phpaó  c¿bHaó  r∂      !   src/PEAR2/Pyrus/DirectedGraph.phpâ  c¿bHâ  \U˘∂         src/PEAR2/Pyrus/DirectedGraph/    c¿bH        ˇ      +   src/PEAR2/Pyrus/DirectedGraph/Exception.phpﬂ  c¿bHﬂ  ú≈ßq∂      (   src/PEAR2/Pyrus/DirectedGraph/Vertex.phpÓ  c¿bHÓ  p^Õ«∂         src/PEAR2/Pyrus/Downloader.phpû<  c¿bHû<  /£∂         src/PEAR2/Pyrus/Exception.php«  c¿bH«  $ΩÙ<∂      $   src/PEAR2/Pyrus/FileTransactions.php$  c¿bH$  ®svÀ∂      !   src/PEAR2/Pyrus/FileTransactions/    c¿bH        ˇ      0   src/PEAR2/Pyrus/FileTransactions/Installedas.phpı	  c¿bHı	  Nœ∂Œ∂      +   src/PEAR2/Pyrus/FileTransactions/Rename.phpL
  c¿bHL
  Ô«j∂      *   src/PEAR2/Pyrus/FileTransactions/Rmdir.php‰  c¿bH‰  ¨%K∂         src/PEAR2/Pyrus/IChannel.php¡  c¿bH¡  xy¡∂      $   src/PEAR2/Pyrus/IChannelRegistry.phpY  c¿bHY  “7|î∂      $   src/PEAR2/Pyrus/IFileTransaction.phpi  c¿bHi  ((∂         src/PEAR2/Pyrus/ILog.php”  c¿bH”  æ/∂         src/PEAR2/Pyrus/Installer.php„P  c¿bH„P  øÚx∂         src/PEAR2/Pyrus/Installer/    c¿bH        ˇ      '   src/PEAR2/Pyrus/Installer/Exception.phpﬂ  c¿bHﬂ  ™/P∂      "   src/PEAR2/Pyrus/Installer/Role.phpÕ  c¿bHÕ  i¸∂         src/PEAR2/Pyrus/Installer/Role/    c¿bH        ˇ      )   src/PEAR2/Pyrus/Installer/Role/Common.phpn"  c¿bHn"  oÈ”∂      '   src/PEAR2/Pyrus/Installer/Role/Data.php⁄  c¿bH⁄  /ÿ“∂      '   src/PEAR2/Pyrus/Installer/Role/Data.xml¥  c¿bH¥  Õ†åQ∂      &   src/PEAR2/Pyrus/Installer/Role/Doc.php◊  c¿bH◊  ®πkP∂      &   src/PEAR2/Pyrus/Installer/Role/Doc.xml≥  c¿bH≥  A‚êé∂      ,   src/PEAR2/Pyrus/Installer/Role/Exception.php‹  c¿bH‹  &üFí∂      &   src/PEAR2/Pyrus/Installer/Role/Ext.php◊  c¿bH◊  Hë◊∂      &   src/PEAR2/Pyrus/Installer/Role/Ext.xmlM  c¿bHM  $®Fƒ∂      &   src/PEAR2/Pyrus/Installer/Role/Php.php◊  c¿bH◊  î,ñ∂      &   src/PEAR2/Pyrus/Installer/Role/Php.xmlª  c¿bHª  ÈÄ!Ë∂      )   src/PEAR2/Pyrus/Installer/Role/Script.php‡  c¿bH‡  ›äÑ∂      )   src/PEAR2/Pyrus/Installer/Role/Script.xmlæ  c¿bHæ  –Tƒ∂      &   src/PEAR2/Pyrus/Installer/Role/Src.php<  c¿bH<  zÿ|∂      &   src/PEAR2/Pyrus/Installer/Role/Src.xml	  c¿bH	  ≥ª«∂      '   src/PEAR2/Pyrus/Installer/Role/Test.php⁄  c¿bH⁄  l∆∑–∂      '   src/PEAR2/Pyrus/Installer/Role/Test.xml¥  c¿bH¥  ˚|∂      &   src/PEAR2/Pyrus/Installer/Role/Www.php⁄  c¿bH⁄  àˇÅ∂      &   src/PEAR2/Pyrus/Installer/Role/Www.xml•  c¿bH•  ˝$P$∂         src/PEAR2/Pyrus/IPackage.php≠  c¿bH≠  b
o#∂         src/PEAR2/Pyrus/IRegistry.php  c¿bH  !–∂         src/PEAR2/Pyrus/Log.phpx  c¿bHx  ÿ+V8∂         src/PEAR2/Pyrus/OSGuess.phpô,  c¿bHô,  √›ΩÕ∂         src/PEAR2/Pyrus/Package.phpy  c¿bHy  1RMl∂         src/PEAR2/Pyrus/Package/    c¿bH        ˇ          src/PEAR2/Pyrus/Package/Base.php  c¿bH  (v∫ﬁ∂      #   src/PEAR2/Pyrus/Package/Creator.php'  c¿bH'  xÅóû∂          src/PEAR2/Pyrus/Package/Creator/    c¿bH        ˇ      -   src/PEAR2/Pyrus/Package/Creator/Exception.phpÎ  c¿bHÎ  ¯¯[Ú∂      0   src/PEAR2/Pyrus/Package/Creator/TaskIterator.php¿  c¿bH¿   êÙã∂      &   src/PEAR2/Pyrus/Package/Dependency.phpè3  c¿bHè3  Øœ_]∂      %   src/PEAR2/Pyrus/Package/Exception.php‘  c¿bH‘  Ê1‰∂      $   src/PEAR2/Pyrus/Package/ICreator.phpπ  c¿bHπ  ñµS∂      .   src/PEAR2/Pyrus/Package/InstalledException.php˛  c¿bH˛  '~Ö2∂          src/PEAR2/Pyrus/Package/Phar.phpÉ  c¿bHÉ  ¯Ï…ﬁ∂         src/PEAR2/Pyrus/Package/Phar/    c¿bH        ˇ      *   src/PEAR2/Pyrus/Package/Phar/Exception.php„  c¿bH„  +cé¶∂      "   src/PEAR2/Pyrus/Package/Remote.phpÛC  c¿bHÛC  ﬂäZö∂         src/PEAR2/Pyrus/Package/Tar.phpº,  c¿bHº,  ¥°’À∂         src/PEAR2/Pyrus/Package/Tar/    c¿bH        ˇ      )   src/PEAR2/Pyrus/Package/Tar/Exception.php‡  c¿bH‡  yG8O∂         src/PEAR2/Pyrus/Package/Xml.phpÄ  c¿bHÄ  ü∫ ∂         src/PEAR2/Pyrus/Package/Zip.php£  c¿bH£  ¥£;Å∂         src/PEAR2/Pyrus/Package/Zip/    c¿bH        ˇ      )   src/PEAR2/Pyrus/Package/Zip/Exception.php‡  c¿bH‡  ∆Ó0¡∂         src/PEAR2/Pyrus/PackageFile.php  c¿bH  Õc‡m∂         src/PEAR2/Pyrus/PackageFile/    c¿bH        ˇ      )   src/PEAR2/Pyrus/PackageFile/Exception.phpﬂ  c¿bHﬂ  !‘V∂      *   src/PEAR2/Pyrus/PackageFile/IValidator.php  c¿bH  ÉÕö∂      #   src/PEAR2/Pyrus/PackageFile/Parser/    c¿bH        ˇ      )   src/PEAR2/Pyrus/PackageFile/Parser/v2.phpe  c¿bHe  ã˘.∂      "   src/PEAR2/Pyrus/PackageFile/v2.phpiò  c¿bHiò  9
À∂         src/PEAR2/Pyrus/PackageFile/v2/    c¿bH        ˇ      -   src/PEAR2/Pyrus/PackageFile/v2/Compatible.php¥$  c¿bH¥$  9&˘∂      *   src/PEAR2/Pyrus/PackageFile/v2/Compatible/    c¿bH        ˇ      7   src/PEAR2/Pyrus/PackageFile/v2/Compatible/Exception.php  c¿bH  yzZ∂      /   src/PEAR2/Pyrus/PackageFile/v2/Dependencies.phpYK  c¿bHYK  √”π∂      ,   src/PEAR2/Pyrus/PackageFile/v2/Dependencies/    c¿bH        ˇ      9   src/PEAR2/Pyrus/PackageFile/v2/Dependencies/Exception.php  c¿bH  UƒB+∂      ,   src/PEAR2/Pyrus/PackageFile/v2/Developer.phpÉ   c¿bHÉ   ë;∂      )   src/PEAR2/Pyrus/PackageFile/v2/Developer/    c¿bH        ˇ      6   src/PEAR2/Pyrus/PackageFile/v2/Developer/Exception.php  c¿bH  Õw∂      (   src/PEAR2/Pyrus/PackageFile/v2/Files.phpM  c¿bHM  „ëà‰∂      %   src/PEAR2/Pyrus/PackageFile/v2/Files/    c¿bH        ˇ      2   src/PEAR2/Pyrus/PackageFile/v2/Files/Exception.php  c¿bH  ÄG6√∂      *   src/PEAR2/Pyrus/PackageFile/v2/Release.php-1  c¿bH-1  (ˆıÅ∂      '   src/PEAR2/Pyrus/PackageFile/v2/Release/    c¿bH        ˇ      4   src/PEAR2/Pyrus/PackageFile/v2/Release/Exception.php	  c¿bH	  uWA∂      )   src/PEAR2/Pyrus/PackageFile/v2/Remote.phpÌ  c¿bHÌ  ¡,‰É∂      ,   src/PEAR2/Pyrus/PackageFile/v2/Validator.php'u  c¿bH'u  Q£ ƒ∂      '   src/PEAR2/Pyrus/PackageFile/v2Iterator/    c¿bH        ˇ      /   src/PEAR2/Pyrus/PackageFile/v2Iterator/File.phpÃ  c¿bHÃ  ≤ ÕÌ∂      <   src/PEAR2/Pyrus/PackageFile/v2Iterator/FileAttribsFilter.php:  c¿bH:  CO¬h∂      7   src/PEAR2/Pyrus/PackageFile/v2Iterator/FileContents.phpÔ	  c¿bHÔ	  0?ë¡∂      <   src/PEAR2/Pyrus/PackageFile/v2Iterator/FileContentsMulti.phpj  c¿bHj  ´x@Ê∂      A   src/PEAR2/Pyrus/PackageFile/v2Iterator/FileInstallationFilter.php<  c¿bH<  ≠’Ωk∂      2   src/PEAR2/Pyrus/PackageFile/v2Iterator/FileTag.phpa  c¿bHa  ï’∫ü∂      <   src/PEAR2/Pyrus/PackageFile/v2Iterator/PackagingIterator.phpû  c¿bHû  ßUQä∂         src/PEAR2/Pyrus/Registry.php˚  c¿bH˚  zÅø0∂         src/PEAR2/Pyrus/Registry/    c¿bH        ˇ      !   src/PEAR2/Pyrus/Registry/Base.php´  c¿bH´  	9É£∂      $   src/PEAR2/Pyrus/Registry/Channel.php˙  c¿bH˙  /ÚÉ∂      #   src/PEAR2/Pyrus/Registry/Config.php÷  c¿bH÷  Ûn=Y∂      &   src/PEAR2/Pyrus/Registry/Exception.php›  c¿bH›  Ó}i∂      $   src/PEAR2/Pyrus/Registry/Package.php  c¿bH  ªâ´N∂      "   src/PEAR2/Pyrus/Registry/Pear1.php01  c¿bH01  k˚$Ù∂         src/PEAR2/Pyrus/Registry/Pear1/    c¿bH        ˇ      *   src/PEAR2/Pyrus/Registry/Pear1/Package.php≤  c¿bH≤  Y1¯∂      #   src/PEAR2/Pyrus/Registry/Sqlite.phprg  c¿bHrg  ´i»∂          src/PEAR2/Pyrus/Registry/Sqlite/    c¿bH        ˇ      +   src/PEAR2/Pyrus/Registry/Sqlite/Creator.php¥I  c¿bH¥I  Î:Ò⁄∂      +   src/PEAR2/Pyrus/Registry/Sqlite/Package.php‹  c¿bH‹  ∞ÙîZ∂          src/PEAR2/Pyrus/Registry/Xml.php¥  c¿bH¥  QK∂         src/PEAR2/Pyrus/REST.phpå3  c¿bHå3  Hã¯≈∂         src/PEAR2/Pyrus/REST/    c¿bH        ˇ         src/PEAR2/Pyrus/REST/10.phpWp  c¿bHWp  Z.Z◊∂         src/PEAR2/Pyrus/REST/11.phpS'  c¿bHS'  …Ì°Ù∂         src/PEAR2/Pyrus/REST/13.phpâ(  c¿bHâ(  ∞¶ÌÃ∂      "   src/PEAR2/Pyrus/REST/Exception.php   c¿bH   «€ÒB∂      &   src/PEAR2/Pyrus/REST/HTTPException.php‹  c¿bH‹  DÑ:∂         src/PEAR2/Pyrus/ScriptFrontend/    c¿bH        ˇ      +   src/PEAR2/Pyrus/ScriptFrontend/Commands.phpÏ1  c¿bHÏ1  È„£∂         src/PEAR2/Pyrus/Task/    c¿bH        ˇ         src/PEAR2/Pyrus/Task/Common.php  c¿bH  Ωìö∂      "   src/PEAR2/Pyrus/Task/Exception.php—  c¿bH—  Zá
]∂      *   src/PEAR2/Pyrus/Task/Postinstallscript.phpõ6  c¿bHõ6  ](®≥∂      '   src/PEAR2/Pyrus/Task/Postinstallscript/    c¿bH        ˇ      -   src/PEAR2/Pyrus/Task/Postinstallscript/rw.phpı  c¿bHı  Ë¥–‰∂          src/PEAR2/Pyrus/Task/Replace.phpY  c¿bHY  î]≥©∂         src/PEAR2/Pyrus/Task/Replace/    c¿bH        ˇ      #   src/PEAR2/Pyrus/Task/Replace/rw.php¯  c¿bH¯  Ä≤∂          src/PEAR2/Pyrus/Task/Unixeol.php/  c¿bH/  º‡úö∂         src/PEAR2/Pyrus/Task/Unixeol/    c¿bH        ˇ      #   src/PEAR2/Pyrus/Task/Unixeol/rw.php  c¿bH  ƒÙìç∂      #   src/PEAR2/Pyrus/Task/Windowseol.php(  c¿bH(  7EÂ∂          src/PEAR2/Pyrus/Task/Windowseol/    c¿bH        ˇ      &   src/PEAR2/Pyrus/Task/Windowseol/rw.php  c¿bH  1Ï⁄∂         src/PEAR2/Pyrus/test.phpπ  c¿bHπ  ä¥∂         src/PEAR2/Pyrus/test1.phpî  c¿bHî  ∂D˚7∂         src/PEAR2/Pyrus/test2.php  c¿bH  qè∂         src/PEAR2/Pyrus/Uninstaller.phpT(  c¿bHT(  UOAœ∂         src/PEAR2/Pyrus/Validate.phpæO  c¿bHæO  µç[∂         src/PEAR2/Pyrus/Validate/    c¿bH        ˇ      &   src/PEAR2/Pyrus/Validate/Exception.phpG  c¿bHG  s~◊∂         src/PEAR2/Pyrus/Validator/    c¿bH        ˇ      "   src/PEAR2/Pyrus/Validator/PECL.php£  c¿bH£  *Êî∂         src/PEAR2/Pyrus/XMLParser.phpÿ  c¿bHÿ  ñqf¬∂         src/PEAR2/Pyrus/XMLParser/    c¿bH        ˇ      '   src/PEAR2/Pyrus/XMLParser/Exception.php›  c¿bH›  J+ñr∂         src/PEAR2/Pyrus/XMLWriter.php⁄#  c¿bH⁄#  
‘{ﬂ∂         src/PEAR2/Pyrus/XMLWriter/    c¿bH        ˇ      '   src/PEAR2/Pyrus/XMLWriter/Exception.php›  c¿bH›  ÀÔ<Ö∂         test/pear2.php.net/PEAR2_Pyrus/    c¿bH        ˇ      ,   test/pear2.php.net/PEAR2_Pyrus/clean.php.incY  c¿bHY  |≈¥∂      5   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/    c¿bH        ˇ      B   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/run-tests.logñ   c¿bHñ   myÆ∂      B   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/setup.php.incä   c¿bHä   ®Å7∂      >   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/test.diff  c¿bH  q^]∂      =   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/test.exp
   c¿bH
   O’A§∂      =   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/test.logü  c¿bHü  üAõS∂      =   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/test.out^  c¿bH^  }ä≤∂      =   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/test.php◊  c¿bH◊  "Øm∂      >   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/test.phpt}  c¿bH}  _Ä|⁄∂      5   test/pear2.php.net/PEAR2_Pyrus/Config/configSnapshot/    c¿bH        ˇ      B   test/pear2.php.net/PEAR2_Pyrus/Config/configSnapshot/setup.php.incä   c¿bHä   ®Å7∂      >   test/pear2.php.net/PEAR2_Pyrus/Config/configSnapshot/test.diffw  c¿bHw  ›¥˙∫∂      =   test/pear2.php.net/PEAR2_Pyrus/Config/configSnapshot/test.exp
   c¿bH
   O’A§∂      =   test/pear2.php.net/PEAR2_Pyrus/Config/configSnapshot/test.logﬁ  c¿bHﬁ  )ôÑË∂      =   test/pear2.php.net/PEAR2_Pyrus/Config/configSnapshot/test.outù  c¿bHù  ö"à;∂      =   test/pear2.php.net/PEAR2_Pyrus/Config/configSnapshot/test.phpç
  c¿bHç
  '-Ñå∂      >   test/pear2.php.net/PEAR2_Pyrus/Config/configSnapshot/test.phpt3  c¿bH3  ¶è]∂      8   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/    c¿bH        ˇ      B   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/basic.phptl  c¿bHl  NM≠X∂      H   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/bin_dir.env.phpte  c¿bHe  \:´∂      I   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/bin_dir.env2.phptî  c¿bHî  °t:Ñ∂      H   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/bin_dir.win.phpt™  c¿bH™  –âÇp∂      N   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/extension_dir.env.phptq  c¿bHq  K1ï∂      O   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/extension_dir.env2.phptÎ  c¿bHÎ  DﬂÎ£∂      N   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/extension_dir.ini.phpt≠  c¿bH≠  +°.¬∂      E   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/setup.php.incµ  c¿bHµ  3*∂      5   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/    c¿bH        ˇ      G   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/badsystemfile.diffÕ  c¿bHÕ  ‹M”í∂      F   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/badsystemfile.exp
   c¿bH
   O’A§∂      F   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/badsystemfile.logº  c¿bHº  ( J∂      F   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/badsystemfile.out{  c¿bH{  >.Ú∂      F   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/badsystemfile.php^  c¿bH^  W©J∂      G   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/badsystemfile.phpt  c¿bH  	NπÊ∂      E   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/baduserfile.phpt  c¿bH  ‹íåC∂      B   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/defaults.diff»  c¿bH»  ®@Q∏∂      A   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/defaults.exp
   c¿bH
   O’A§∂      A   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/defaults.log∑  c¿bH∑  Ju¨ë∂      A   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/defaults.outv  c¿bHv  nﬂ,∂      A   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/defaults.phpM  c¿bHM  ôpﬂÄ∂      B   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/defaults.phpt  c¿bH  	S3æ∂      H   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/goodsystemfile.diff  c¿bH  5_nr∂      G   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/goodsystemfile.exp   c¿bH   ≠\'ù∂      G   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/goodsystemfile.logÂ  c¿bHÂ  h‡Dí∂      G   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/goodsystemfile.outü  c¿bHü  îµÃ∂      G   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/goodsystemfile.phpò  c¿bHò  }´¥˚∂      H   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/goodsystemfile.phptS  c¿bHS  ÁEÿæ∂      I   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/gooduser.mypath.diff*  c¿bH*  ¡”ço∂      H   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/gooduser.mypath.exp
   c¿bH
   O’A§∂      H   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/gooduser.mypath.log›  c¿bH›  ﬁÜ"∂      H   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/gooduser.mypath.outú  c¿bHú  ªË∂      H   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/gooduser.mypath.phpN  c¿bHN  Â€t∂      I   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/gooduser.mypath.phpt  c¿bH  oí–¡∂      F   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/gooduserfile.phpt  c¿bH  Ë…Ü€∂      B   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/setup.php.inc◊  c¿bH◊  pùA∂      =   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/    c¿bH        ˇ      G   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/basic.diff≤  c¿bH≤  N?∂      F   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/basic.exp
   c¿bH
   O’A§∂      F   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/basic.log{  c¿bH{  =≤e∂      F   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/basic.out:  c¿bH:  Ü√ûR∂      F   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/basic.php  c¿bH  ˙fÑ∂      G   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/basic.phpt  c¿bH  j¯Úƒ∂      J   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/setup.php.inc9  c¿bH9  'ıjm∂      3   test/pear2.php.net/PEAR2_Pyrus/Config/setup.php.ince   c¿bHe   €i±∂      -   test/pear2.php.net/PEAR2_Pyrus/DirectedGraph/    c¿bH        ˇ      7   test/pear2.php.net/PEAR2_Pyrus/DirectedGraph/basic.phptÃ  c¿bHÃ  1jÂ∂      8   test/pear2.php.net/PEAR2_Pyrus/DirectedGraph/cycles.phptò  c¿bHò  @øºª∂      :   test/pear2.php.net/PEAR2_Pyrus/DirectedGraph/setup.php.incj   c¿bHj   ˆ–¯∂      >   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/packages/    c¿bH        ˇ      I   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/packages/package.xmlÎ&  c¿bHÎ&  ÜA¢Ô∂      J   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/packages/package2.xmlºV  c¿bHºV  QΩúê∂      B   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/setup.php.incˆ  c¿bHˆ  ˜ÏD∂      B   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/test_2.0.phptõ´ c¿bHõ´ ∞@92∂      B   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/test_2.1.phptˇ c¿bHˇ uê≥∂      0   test/pear2.php.net/PEAR2_Pyrus/Registry/Current/    c¿bH        ˇ      >   test/pear2.php.net/PEAR2_Pyrus/Registry/Current/singleton.phpt¬  c¿bH¬  ’æ›D∂      5   test/pear2.php.net/PEAR2_Pyrus/Registry/setup.php.incg   c¿bHg   óÌı∂      ,   test/pear2.php.net/PEAR2_Pyrus/run-tests.logy  c¿bHy  (!Oï∂      5   test/pear2.php.net/PEAR2_Pyrus/test_framework.php.incÁ  c¿bHÁ  8ÛF∂      )   test/pear2.php.net/PEAR2_Pyrus/XMLParser/    c¿bH        ˇ      5   test/pear2.php.net/PEAR2_Pyrus/XMLParser/attribs.phptÁ  c¿bHÁ  k&n∂      =   test/pear2.php.net/PEAR2_Pyrus/XMLParser/attribs_content.phptn  c¿bHn  ‚wiÒ∂      3   test/pear2.php.net/PEAR2_Pyrus/XMLParser/cdata.phpt  c¿bH  {û∏(∂      6   test/pear2.php.net/PEAR2_Pyrus/XMLParser/childtag.phpt  c¿bH  WŸXH∂      >   test/pear2.php.net/PEAR2_Pyrus/XMLParser/childtag_attribs.phpt}  c¿bH}  ·”ÿ¿∂      >   test/pear2.php.net/PEAR2_Pyrus/XMLParser/childtag_content.phpt=  c¿bH=  *UÙ˛∂      F   test/pear2.php.net/PEAR2_Pyrus/XMLParser/childtag_sibling_attribs.phpt≤  c¿bH≤  TX[∂      3   test/pear2.php.net/PEAR2_Pyrus/XMLParser/empty.phptÙ   c¿bHÙ   T2Ê∂      :   test/pear2.php.net/PEAR2_Pyrus/XMLParser/recursivetag.phptﬂ  c¿bHﬂ  ™◊ÜL∂      6   test/pear2.php.net/PEAR2_Pyrus/XMLParser/setup.php.inc¢   c¿bH¢   œ:ŸÏ∂      9   test/pear2.php.net/PEAR2_Pyrus/XMLParser/siblingtags.phpt+  c¿bH+  ≈=Èµ∂      )   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/    c¿bH        ˇ      5   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/attribs.phpt  c¿bH  ™u&Œ∂      =   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/attribs_content.phptá  c¿bHá  7-BÃ∂      6   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/childtag.phpt4  c¿bH4  5N≈∂      >   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/childtag_attribs.phptò  c¿bHò  ∞¯‘∂      >   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/childtag_content.phptX  c¿bHX  í.,∂      F   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/childtag_sibling_attribs.phpt—  c¿bH—  nÄ–Ó∂      3   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/empty.phpt  c¿bH  ]~x,∂      :   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/recursivetag.phpt  c¿bH  ™°[∂      6   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/setup.php.incÖ   c¿bHÖ   ?>Ú*∂      9   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/siblingtags.phptK  c¿bHK  vqa∂         src/PEAR2/Autoload.php7	  c¿bH7	  Æ&&…∂         src/PEAR2/MultiErrors.phpN  c¿bHN  <¡±∂         src/PEAR2/Exception.php 0  c¿bH 0  zb√2∂         src/PEAR2/MultiErrors/    c¿bH        ˇ      #   src/PEAR2/MultiErrors/Exception.phpB   c¿bHB   ˙«z≤∂         src/PEAR2/HTTP/    c¿bH        ˇ         src/PEAR2/HTTP/Request.php˘  c¿bH˘  ML@ñ∂         src/PEAR2/HTTP/Request/    c¿bH        ˇ      "   src/PEAR2/HTTP/Request/Adapter.phpS  c¿bHS  [®h…∂         src/PEAR2/HTTP/Request/Adapter/    c¿bH        ˇ      ,   src/PEAR2/HTTP/Request/Adapter/Phpsocket.phpÎ,  c¿bHÎ,  —ê~¶∂      ,   src/PEAR2/HTTP/Request/Adapter/Phpstream.php˜  c¿bH˜  Sö¯ƒ∂      $   src/PEAR2/HTTP/Request/Exception.phpE   c¿bHE   5≈ˆ,∂      "   src/PEAR2/HTTP/Request/Headers.phpŸ  c¿bHŸ  =2d∂      #   src/PEAR2/HTTP/Request/Response.phpD  c¿bHD  t5¸Ò∂         src/PEAR2/HTTP/Request/Uri.php¡  c¿bH¡  m[∫\∂      <?php
function __autoload($class)
{
    include 'phar://' . PYRUS_PHAR_FILE . '/src/' . implode('/', explode('_', $class)) . '.php';
}
$frontend = new PEAR2_Pyrus_ScriptFrontend_Commands;
@array_shift($_SERVER['argv']);
$frontend->run($_SERVER['argv']);
<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://pear.php.net/dtd/package-2.1" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.1" xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0     http://pear.php.net/dtd/tasks-1.0.xsd     http://pear.php.net/dtd/package-2.1     http://pear.php.net/dtd/package-2.1.xsd">
 <name>PEAR2_Pyrus</name>
 <channel>pear2.php.net</channel>
 <summary>Pyrus is the package manager and installer for PHP 5.3 or newer
</summary>
 <description>
Pyrus provides the means to install and manage installations for
packages built using package.xml version 2.0 or newer.  Pyrus is
redesigned from the ground up for PHP 5.3 or newer, and provides
significant improvements over the older PEAR Installer.

To use Pyrus, in this development series of releases, you need to
instantiate a simple script that creates a package and installs it:

&lt;?php
// use full path if include_path is not set up
include 'PEAR2/Autoload.php';
$config = PEAR2_Pyrus_Config::singleton('/where/to/install');
// this can be a url to a remote package, a local .tgz, .zip or package.xml
$p = new PEAR2_Pyrus_Package('thingtoinstall');
try {
    PEAR2_Pyrus_Installer::begin();
    PEAR2_Pyrus_Installer::prepare($p);
    PEAR2_Pyrus_Installer::commit();
} catch (Exception $e) {
    PEAR2_Pyrus_Installer::rollback();
    echo $e;
}
?&gt;</description>
 <lead>
  <name>Gregory Beaver</name>
  <user>cellog</user>
  <email>cellog@php.net</email>
  <active>yes</active>
 </lead>
 <date>2008-06-25</date>
 <time>17:01:58</time>
 <version>
  <release>2.0.0a1</release>
  <api>0.1.0</api>
 </version>
 <stability>
  <release>alpha</release>
  <api>alpha</api>
 </stability>
 <license uri="http://www.opensource.org/licenses/bsd-license.php">New BSD License</license>
 <notes>Initial development release, no frontend is included</notes>
 <contents>
  <dir name="/">
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/siblingtags.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/recursivetag.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/empty.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/childtag_sibling_attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/childtag_content.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/childtag_attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/childtag.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/attribs_content.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/siblingtags.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/recursivetag.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/empty.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/childtag_sibling_attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/childtag_content.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/childtag_attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/childtag.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/cdata.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/attribs_content.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//test_framework.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//run-tests.log" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Registry/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Registry/Current/singleton.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//PackageFile_Parser_v2/test_2.1.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//PackageFile_Parser_v2/test_2.0.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//PackageFile_Parser_v2/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//PackageFile_Parser_v2/packages/package2.xml" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//PackageFile_Parser_v2/packages/package.xml" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//DirectedGraph/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//DirectedGraph/cycles.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//DirectedGraph/basic.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setCascadingRegistries/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setCascadingRegistries/basic.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setCascadingRegistries/basic.php" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setCascadingRegistries/basic.out" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setCascadingRegistries/basic.log" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setCascadingRegistries/basic.exp" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setCascadingRegistries/basic.diff" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/gooduserfile.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/gooduser.mypath.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/gooduser.mypath.php" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/gooduser.mypath.out" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/gooduser.mypath.log" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/gooduser.mypath.exp" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/gooduser.mypath.diff" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/goodsystemfile.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/goodsystemfile.php" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/goodsystemfile.out" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/goodsystemfile.log" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/goodsystemfile.exp" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/goodsystemfile.diff" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/defaults.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/defaults.php" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/defaults.out" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/defaults.log" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/defaults.exp" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/defaults.diff" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/baduserfile.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/badsystemfile.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/badsystemfile.php" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/badsystemfile.out" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/badsystemfile.log" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/badsystemfile.exp" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/badsystemfile.diff" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/extension_dir.ini.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/extension_dir.env2.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/extension_dir.env.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/bin_dir.win.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/bin_dir.env2.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/bin_dir.env.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/basic.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/configSnapshot/test.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/configSnapshot/test.php" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/configSnapshot/test.out" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/configSnapshot/test.log" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/configSnapshot/test.exp" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/configSnapshot/test.diff" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/configSnapshot/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/addConfigValue/test.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/addConfigValue/test.php" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/addConfigValue/test.out" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/addConfigValue/test.log" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/addConfigValue/test.exp" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/addConfigValue/test.diff" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/addConfigValue/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/addConfigValue/run-tests.log" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//clean.php.inc" baseinstalldir="/"/>
   <file role="php" name="src/PEAR2/Pyrus/XMLWriter/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/XMLWriter.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/XMLParser/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/XMLParser.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Validator/PECL.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Validate/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Validate.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Uninstaller.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/test2.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/test1.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/test.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Windowseol/rw.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Windowseol.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Unixeol/rw.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Unixeol.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Replace/rw.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Replace.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Postinstallscript/rw.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Postinstallscript.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Common.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ScriptFrontend/Commands.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST/HTTPException.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST/13.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST/11.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST/10.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Xml.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Sqlite/Package.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Sqlite/Creator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Sqlite.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Pear1/Package.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Pear1.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Package.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Config.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Channel.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Base.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/PackagingIterator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/FileTag.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/FileInstallationFilter.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/FileContentsMulti.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/FileContents.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/FileAttribsFilter.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/File.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Validator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Remote.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Release/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Release.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Files/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Files.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Developer/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Developer.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Dependencies/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Dependencies.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Compatible/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Compatible.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/Parser/v2.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/IValidator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Zip/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Zip.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Xml.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Tar/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Tar.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Remote.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Phar/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Phar.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/InstalledException.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/ICreator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Dependency.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Creator/TaskIterator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Creator/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Creator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Base.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/OSGuess.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Log.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/IRegistry.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/IPackage.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Www.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Www.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Test.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Test.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Src.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Src.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Script.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Script.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Php.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Php.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Ext.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Ext.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Doc.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Doc.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Data.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Data.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Common.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ILog.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/IFileTransaction.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/IChannelRegistry.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/IChannel.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/FileTransactions/Rmdir.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/FileTransactions/Rename.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/FileTransactions/Installedas.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/FileTransactions.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Downloader.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/DirectedGraph/Vertex.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/DirectedGraph/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/DirectedGraph.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Dependency/Validator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Dependency/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Config/Snapshot.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Config/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Config.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Xml.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Sqlite.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Pear1.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/ParseException.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Mirror/Xml.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Mirror/Sqlite.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Channel/Xml.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Channel/Sqlite.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Channel/Pear1.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Base.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Channel/Mirror.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Channel/IMirror.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Channel/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Channel/Base.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Channel.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus.php" baseinstalldir="PEAR2"/>
   <file role="data" name="data/pear2.php.net/PEAR2_Pyrus/package-2.1.xsd" baseinstalldir="/"/>
   <file role="data" name="data/pear2.php.net/PEAR2_Pyrus/package-2.0.xsd" baseinstalldir="/"/>
   <file role="data" name="data/pear2.php.net/PEAR2_Pyrus/channel-1.0.xsd" baseinstalldir="/"/>
  </dir>
 </contents>
 <dependencies>
  <required>
   <php>
    <min>5.2.0</min>
   </php>
   <pearinstaller>
    <min>2.0.0a1</min>
   </pearinstaller>
  </required>
 </dependencies>
 <phprelease/>
</package>
<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ch="http://pear.php.net/channel-1.0" targetNamespace="http://pear.php.net/channel-1.0" elementFormDefault="qualified">
 <xs:complexType name="function">
  <xs:simpleContent>
   <xs:extension base="xs:string">
    <xs:attribute name="version" use="required">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:pattern value="[0-9]+\.[0-9]+"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:attribute>
   </xs:extension>
  </xs:simpleContent>
 </xs:complexType>
 <xs:complexType name="functions">
  <xs:sequence>
   <xs:element name="function" type="ch:function" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType>
 <xs:complexType name="serverinternals">
  <xs:sequence>
   <xs:element name="xmlrpc" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
   <xs:element name="rest" minOccurs="0">
    <xs:complexType>
     <xs:sequence>
      <xs:element name="baseurl" maxOccurs="unbounded">
       <xs:complexType>
        <xs:simpleContent>
         <xs:extension base="xs:string">
          <xs:attribute name="type" type="xs:string" use="required"/>
         </xs:extension>
        </xs:simpleContent>
       </xs:complexType>
      </xs:element>
     </xs:sequence>
    </xs:complexType>
   </xs:element>
   <xs:element name="soap" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
  </xs:sequence>
  <xs:attribute name="port" type="xs:int" default="80"/>
  <xs:attribute name="ssl">
   <xs:simpleType>
    <xs:restriction base="xs:string">
     <xs:enumeration value="yes"/>
    </xs:restriction>
   </xs:simpleType>
  </xs:attribute>
 </xs:complexType>
 <xs:complexType name="mirrorinternals">
  <xs:sequence>
   <xs:element name="xmlrpc" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
   <xs:element name="rest" minOccurs="0">
    <xs:complexType>
     <xs:sequence>
      <xs:element name="baseurl" maxOccurs="unbounded">
       <xs:complexType>
        <xs:simpleContent>
         <xs:extension base="xs:string">
          <xs:attribute name="type" type="xs:string" use="required"/>
         </xs:extension>
        </xs:simpleContent>
       </xs:complexType>
      </xs:element>
     </xs:sequence>
    </xs:complexType>
   </xs:element>
   <xs:element name="soap" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
  </xs:sequence>
  <xs:attribute name="port" type="xs:int" default="80"/>
  <xs:attribute name="host" use="required"/>
  <xs:attribute name="ssl">
   <xs:simpleType>
    <xs:restriction base="xs:string">
     <xs:enumeration value="yes"/>
    </xs:restriction>
   </xs:simpleType>
  </xs:attribute>
 </xs:complexType>
 <xs:complexType name="server">
  <xs:sequence>
   <xs:element name="primary">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:serverinternals"/>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
   <xs:element name="mirror" type="ch:mirrorinternals" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType>
 <xs:complexType name="validatepackage">
  <xs:simpleContent>
   <xs:extension base="xs:string">
    <xs:attribute name="version"/>
   </xs:extension>
  </xs:simpleContent>
 </xs:complexType>
 <xs:simpleType name="channelname">
  <xs:restriction base="xs:string">
   <xs:pattern value="[A-Za-z][a-zA-Z0-9_.]+|__uri"/>
  </xs:restriction>
 </xs:simpleType>
 <xs:element name="channel">
  <xs:complexType>
   <xs:sequence>
     <xs:element name="name" type="ch:channelname"/>
    <xs:choice>
     <xs:sequence minOccurs="1" maxOccurs="1">
      <xs:element name="suggestedalias" type="ch:channelname"/>
      <xs:element name="summary" type="xs:string"/>
     </xs:sequence>
     <xs:sequence minOccurs="1" maxOccurs="1">
      <xs:element name="summary" type="xs:string"/>
      <xs:element name="suggestedalias" minOccurs="0" type="ch:channelname"/>
     </xs:sequence>
    </xs:choice>
    <xs:element name="validatepackage" minOccurs="0">
     <xs:complexType>
      <xs:simpleContent>
       <xs:restriction base="ch:validatepackage">
        <xs:pattern value="[A-Za-z][a-zA-Z0-9_]+"/>
       </xs:restriction>
      </xs:simpleContent>
     </xs:complexType>
    </xs:element>
    <xs:element name="servers" type="ch:server"/>
   </xs:sequence>
   <xs:attribute name="version" use="required">
    <xs:simpleType>
     <xs:restriction base="xs:string">
      <xs:pattern value="[0-9]+\.[0-9]+"/>
     </xs:restriction>
    </xs:simpleType>
   </xs:attribute>
  </xs:complexType>
 </xs:element>
</xs:schema>
<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSpy v2005 rel. 3 U (http://www.altova.com) by Gregory Beaver (The Chiara String Quartet) -->
<!-- edited with XMLSPY v2004 rel. 4 U (http://www.xmlspy.com) by Greg Beaver (The Chiara String Quartet) -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://pear.php.net/dtd/package-2.0" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" targetNamespace="http://pear.php.net/dtd/package-2.0" elementFormDefault="qualified" attributeFormDefault="unqualified" xml:lang="EN">
 <xs:element name="package">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:choice>
     <xs:element ref="channel"/>
     <xs:element ref="uri"/>
    </xs:choice>
    <xs:element ref="extends" minOccurs="0"/>
    <xs:element ref="summary"/>
    <xs:element ref="description"/>
    <xs:element ref="lead" maxOccurs="unbounded"/>
    <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="contributor" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="helper" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="date"/>
    <xs:element ref="time" minOccurs="0"/>
    <xs:element ref="version"/>
    <xs:element ref="stability"/>
    <xs:element ref="license"/>
    <xs:element ref="notes"/>
    <xs:element ref="contents"/>
    <xs:element ref="compatible" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="dependencies"/>
    <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usesrole" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usestask" minOccurs="0" maxOccurs="unbounded"/>
    <xs:choice minOccurs="0">
     <xs:element ref="srcpackage"/>
     <xs:element name="srcuri" type="xs:anyURI">
      <xs:annotation>
       <xs:documentation>uri of the package that contains the source of this extension</xs:documentation>
      </xs:annotation>
     </xs:element>
    </xs:choice>
    <xs:choice>
     <xs:element ref="phprelease" maxOccurs="unbounded"/>
     <xs:element ref="extsrcrelease" maxOccurs="unbounded"/>
     <xs:element ref="extbinrelease" maxOccurs="unbounded"/>
     <xs:element ref="bundle"/>
    </xs:choice>
    <xs:element ref="changelog" minOccurs="0"/>
   </xs:sequence>
   <xs:attribute name="version" type="xs:string" fixed="2.0"/>
   <xs:attribute name="packagerversion" type="version"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="name" type="xs:string">
  <xs:annotation>
   <xs:documentation>this is ignored if the release type is bundle</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="summary" type="xs:string"/>
 <xs:element name="description" type="xs:string"/>
 <xs:element name="lead">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="developer">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="contributor">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="helper">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="date" type="xs:date"/>
 <xs:element name="version">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" type="version"/>
    <xs:element name="api" type="version"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="license">
  <xs:complexType>
   <xs:simpleContent>
    <xs:extension base="xs:string">
     <xs:attribute name="uri" type="xs:anyURI"/>
     <xs:attribute name="filesource" type="xs:string"/>
    </xs:extension>
   </xs:simpleContent>
  </xs:complexType>
 </xs:element>
 <xs:element name="stability">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="snapshot"/>
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
    <xs:element name="api">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="notes" type="xs:string"/>
 <xs:element name="contents">
  <xs:complexType>
   <xs:choice>
    <xs:element ref="dir" maxOccurs="unbounded"/>
    <xs:element ref="bundledpackage" maxOccurs="unbounded"/>
   </xs:choice>
  </xs:complexType>
 </xs:element>
 <xs:element name="dir">
  <xs:complexType>
   <xs:choice>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="dir" maxOccurs="unbounded"/>
     <xs:element ref="file" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="file" maxOccurs="unbounded"/>
     <xs:element ref="dir" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
   </xs:choice>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="name" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="file">
  <xs:complexType>
   <xs:choice>
    <xs:any namespace="http://pear.php.net/dtd/tasks-1.0" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
   </xs:choice>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="role" type="xs:string" use="required"/>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="md5sum" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="install">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="as" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="ignore">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="phprelease">
  <xs:annotation>
   <xs:documentation>for php script releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extsrcrelease">
  <xs:annotation>
   <xs:documentation>for extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="configureoption" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element name="binarypackage" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extbinrelease">
  <xs:annotation>
   <xs:documentation>for compiled extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="bundle">
  <xs:annotation>
   <xs:documentation>for bundling several releases together in one release</xs:documentation>
  </xs:annotation>
  <xs:complexType/>
 </xs:element>
 <xs:element name="filelist">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="install" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="ignore" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="dependencies">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="required"/>
    <xs:element ref="optional" minOccurs="0"/>
    <xs:element ref="group" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="nodefault">
  <xs:annotation>
   <xs:documentation>tells the installer not to install the default dependency group</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="required">
  <xs:annotation>
   <xs:documentation>absolute required dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php"/>
    <xs:element ref="pearinstaller"/>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="arch" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="group">
  <xs:annotation>
   <xs:documentation>all other optional dependency groups</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="hint" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="optional">
  <xs:annotation>
   <xs:documentation>simple optional dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="changelog">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" minOccurs="1" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="lead" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element name="version">
        <xs:complexType>
         <xs:sequence>
          <xs:element name="release" type="xs:string"/>
          <xs:element name="api" type="xs:string"/>
         </xs:sequence>
        </xs:complexType>
       </xs:element>
       <xs:element ref="stability"/>
       <xs:element ref="date"/>
       <xs:element ref="license"/>
       <xs:element ref="notes"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:simpleType name="version">
  <xs:annotation>
   <xs:documentation>version string regex</xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="[0-9]+(\.[0-9]+)*([a-zA-Z]+[0-9]*)?"/>
  </xs:restriction>
 </xs:simpleType>
 <xs:element name="extension">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="min" minOccurs="0"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="pearinstaller">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="php">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="installconditions">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php" minOccurs="0"/>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0"/>
    <xs:element ref="arch" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="exclude" type="version"/>
 <xs:element name="configureoption">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="default" type="xs:string"/>
   <xs:attribute name="prompt" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="arch">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="pattern"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extends" type="xs:string"/>
 <xs:element name="time" type="xs:time"/>
 <xs:element name="compatible">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="name"/>
    <xs:element name="channel"/>
    <xs:element ref="min"/>
    <xs:element ref="max"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="min" type="version"/>
 <xs:element name="max" type="version"/>
 <xs:element name="user" type="xs:string"/>
 <xs:element name="email" type="xs:string"/>
 <xs:element name="active">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:enumeration value="yes"/>
    <xs:enumeration value="no"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="recommended" type="version"/>
 <xs:element name="channel">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:pattern value="[A-Za-z][a-zA-Z0-9_.]+"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="uri" type="xs:anyURI"/>
 <xs:element name="pattern" type="xs:string"/>
 <xs:element name="conflicts"/>
 <xs:element name="os">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="srcpackage" type="xs:string">
  <xs:annotation>
   <xs:documentation>name of the package that contains the source of this extension (can be the same if the source and binaries are in the same package)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="srcchannel" type="xs:string"/>
 <xs:element name="bundledpackage" type="xs:string"/>
 <xs:element name="filename" type="xs:string"/>
 <xs:element name="providesextension" type="xs:string">
  <xs:annotation>
   <xs:documentation>if a package can provide one or more compatible extensions (dblib/sybase/mssql for instance)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="usesrole">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="role"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="usestask">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="task"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="role" type="xs:string"/>
 <xs:element name="task" type="xs:string"/>
</xs:schema>
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://pear.php.net/dtd/package-2.1" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" targetNamespace="http://pear.php.net/dtd/package-2.1" elementFormDefault="qualified" attributeFormDefault="unqualified" xml:lang="EN">
 <xs:element name="package">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:choice>
     <xs:element ref="channel"/>
     <xs:element ref="uri"/>
    </xs:choice>
    <xs:element ref="extends" minOccurs="0"/>
    <xs:element ref="summary"/>
    <xs:element ref="description"/>
    <xs:element ref="lead" maxOccurs="unbounded"/>
    <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="contributor" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="helper" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="date"/>
    <xs:element ref="time" minOccurs="0"/>
    <xs:element ref="version"/>
    <xs:element ref="stability"/>
    <xs:element ref="license"/>
    <xs:element ref="notes"/>
    <xs:element ref="contents"/>
    <xs:element ref="compatible" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="dependencies"/>
    <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usesrole" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usestask" minOccurs="0" maxOccurs="unbounded"/>
    <xs:choice minOccurs="0">
     <xs:element ref="srcpackage"/>
     <xs:element name="srcuri" type="xs:anyURI">
      <xs:annotation>
       <xs:documentation>uri of the package that contains the source of this extension</xs:documentation>
      </xs:annotation>
     </xs:element>
    </xs:choice>
    <xs:choice>
     <xs:element ref="phprelease" maxOccurs="unbounded"/>
     <xs:element ref="extsrcrelease" maxOccurs="unbounded"/>
     <xs:element ref="extbinrelease" maxOccurs="unbounded"/>
     <xs:element ref="bundle"/>
     <xs:element ref="zendextsrcrelease" maxOccurs="unbounded"/>
     <xs:element ref="zendextbinrelease" maxOccurs="unbounded"/>
    </xs:choice>
    <xs:element ref="changelog" minOccurs="0"/>
   </xs:sequence>
   <xs:attribute name="version" type="xs:string" fixed="2.1"/>
   <xs:attribute name="packagerversion" type="version"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="name" type="xs:string">
  <xs:annotation>
   <xs:documentation>this is ignored if the release type is bundle</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="summary" type="xs:string"/>
 <xs:element name="description" type="xs:string"/>
 <xs:element name="lead">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="developer">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="contributor">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="helper">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="date" type="xs:date"/>
 <xs:element name="version">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" type="version"/>
    <xs:element name="api" type="version"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="license">
  <xs:complexType>
   <xs:simpleContent>
    <xs:extension base="xs:string">
     <xs:attribute name="uri" type="xs:anyURI"/>
     <xs:attribute name="filesource" type="xs:string"/>
    </xs:extension>
   </xs:simpleContent>
  </xs:complexType>
 </xs:element>
 <xs:element name="stability">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="snapshot"/>
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
    <xs:element name="api">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="notes" type="xs:string"/>
 <xs:element name="contents">
  <xs:complexType>
   <xs:choice>
    <xs:element ref="dir" maxOccurs="unbounded"/>
    <xs:element ref="bundledpackage" maxOccurs="unbounded"/>
   </xs:choice>
  </xs:complexType>
 </xs:element>
 <xs:element name="dir">
  <xs:complexType>
   <xs:choice>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="dir" maxOccurs="unbounded"/>
     <xs:element ref="file" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="file" maxOccurs="unbounded"/>
     <xs:element ref="dir" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
   </xs:choice>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="name" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="file">
  <xs:complexType>
   <xs:choice>
    <xs:any namespace="http://pear.php.net/dtd/tasks-1.0" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
   </xs:choice>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="role" type="xs:string" use="required"/>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="md5sum" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="install">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="as" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="ignore">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="phprelease">
  <xs:annotation>
   <xs:documentation>for php script releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extsrcrelease">
  <xs:annotation>
   <xs:documentation>for extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="configureoption" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element name="binarypackage" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="zendextsrcrelease">
  <xs:annotation>
   <xs:documentation>for zend extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="configureoption" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element name="binarypackage" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extbinrelease">
  <xs:annotation>
   <xs:documentation>for compiled extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="zendextbinrelease">
  <xs:annotation>
   <xs:documentation>for compiled zend extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="bundle">
  <xs:annotation>
   <xs:documentation>for bundling several releases together in one release</xs:documentation>
  </xs:annotation>
  <xs:complexType/>
 </xs:element>
 <xs:element name="filelist">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="install" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="ignore" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="dependencies">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="required"/>
    <xs:element ref="optional" minOccurs="0"/>
    <xs:element ref="group" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="nodefault">
  <xs:annotation>
   <xs:documentation>tells the installer not to install the default dependency group</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="required">
  <xs:annotation>
   <xs:documentation>absolute required dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php"/>
    <xs:element ref="pearinstaller"/>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="arch" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="group">
  <xs:annotation>
   <xs:documentation>all other optional dependency groups</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="hint" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="optional">
  <xs:annotation>
   <xs:documentation>simple optional dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="changelog">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" minOccurs="1" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="lead" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element name="version">
        <xs:complexType>
         <xs:sequence>
          <xs:element name="release" type="xs:string"/>
          <xs:element name="api" type="xs:string"/>
         </xs:sequence>
        </xs:complexType>
       </xs:element>
       <xs:element ref="stability"/>
       <xs:element ref="date"/>
       <xs:element ref="license"/>
       <xs:element ref="notes"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:simpleType name="version">
  <xs:annotation>
   <xs:documentation>version string regex</xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="[0-9]+(\.[0-9]+)*([a-zA-Z]+[0-9]*)?"/>
  </xs:restriction>
 </xs:simpleType>
 <xs:element name="extension">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="min" minOccurs="0"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="pearinstaller">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="php">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="installconditions">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php" minOccurs="0"/>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0"/>
    <xs:element ref="arch" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="exclude" type="version"/>
 <xs:element name="configureoption">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="default" type="xs:string"/>
   <xs:attribute name="prompt" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="arch">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="pattern"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extends" type="xs:string"/>
 <xs:element name="time" type="xs:time"/>
 <xs:element name="compatible">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="name"/>
    <xs:element name="channel"/>
    <xs:element ref="min"/>
    <xs:element ref="max"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="min" type="version"/>
 <xs:element name="max" type="version"/>
 <xs:element name="user" type="xs:string"/>
 <xs:element name="email" type="xs:string"/>
 <xs:element name="active">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:enumeration value="yes"/>
    <xs:enumeration value="no"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="recommended" type="version"/>
 <xs:element name="channel">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:pattern value="[A-Za-z][a-zA-Z0-9_.]+"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="uri" type="xs:anyURI"/>
 <xs:element name="pattern" type="xs:string"/>
 <xs:element name="conflicts"/>
 <xs:element name="os">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="srcpackage" type="xs:string">
  <xs:annotation>
   <xs:documentation>name of the package that contains the source of this extension (can be the same if the source and binaries are in the same package)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="srcchannel" type="xs:string"/>
 <xs:element name="bundledpackage" type="xs:string"/>
 <xs:element name="filename" type="xs:string"/>
 <xs:element name="providesextension" type="xs:string">
  <xs:annotation>
   <xs:documentation>if a package can provide one or more compatible extensions (dblib/sybase/mssql for instance)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="usesrole">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="role"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="usestask">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="task"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="role" type="xs:string"/>
 <xs:element name="task" type="xs:string"/>
</xs:schema>
<?php
/**
 * PEAR2_Pyrus
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Pyrus.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus
{
    static function getDataPath()
    {
        static $val = false;
        if ($val) return $val;
        $val = dirname(dirname(dirname(__FILE__))) . '/data/pear2.php.net/PEAR2_Pyrus';
        return $val;
    }
}
?>
<?php
/**
 * PEAR2_Pyrus_Channel
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Pyrus.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Channel implements PEAR2_Pyrus_IChannel
{
    /**
     * Supported channel.xml versions, for parsing
     * @var array
     */
    protected $supportedVersions = array('1.0');

    /**
     * Parsed channel information
     * @var array
     */
    protected $channelInfo = array(
        'attribs' => array(
            'version' => '1.0',
            'xmlns' => 'http://pear.php.net/channel-1.0',
        ),
    );

    public $rootAttributes = array(
            'version' => '1.0',
            'xmlns' => 'http://pear.php.net/channel-1.0',
        );

    private $_xml;

    /**
     * Construct a PEAR2_Pyrus channel object
     *
     * @param string $data Raw channel xml
     */
    function __construct($data)
    {
        $parser = new PEAR2_Pyrus_XMLParser;
        $schema = PEAR2_Pyrus::getDataPath() . '/channel-1.0.xsd';
        // for running out of svn
        if (!file_exists($schema)) {
            $schema = dirname(__FILE__) . '/../../data/channel-1.0.xsd';
        }
        try {
            if (is_array($data)) {
                $this->channelInfo = $data;
                $this->validate();
            } else {
                $this->channelInfo = $parser->parseString($data, $schema);
                $this->channelInfo = $this->channelInfo['channel'];
            }
            // Reset root attributes.
            $this->channelInfo['attribs'] = $this->rootAttributes;
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Channel_Exception('Invalid channel.xml', $e);
        }
    }

    /**
     * Validate the xml against the channel schema.
     *
     */
    function validate()
    {
        if (!isset($this->_xml)) {
            $this->__toString();
        }
        $a = new PEAR2_Pyrus_XMLParser;
        $schema = PEAR2_Pyrus::getDataPath() . '/channel-1.0.xsd';
        // for running out of cvs
        if (!file_exists($schema)) {
            $schema = dirname(__FILE__) . '/../../data/channel-1.0.xsd';
        }
        try {
            $a->parseString($this->_xml, $schema);
            return true;
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Channel_Exception('Invalid channel.xml', $e);
        }
    }

    /**
     * Returns the raw xml for the channel file.
     *
     * @return string
     */
    function __toString()
    {
        if (!isset($this->_xml)) {
            $this->_xml = (string) new PEAR2_Pyrus_XMLWriter(array('channel'=>$this->channelInfo));
        }
        return $this->_xml;
    }

    function toChannelObject()
    {
        return $this;
    }

    /**
     * @return string|false
     */
    function getName()
    {
        if (isset($this->channelInfo['name'])) {
            return $this->channelInfo['name'];
        }

        return false;
    }

    /**
     * @return string|false
     */
    function getServer()
    {
        if (isset($this->channelInfo['name'])) {
            return $this->channelInfo['name'];
        }

        return false;
    }

    /**
     * @return string|false
     */
    function getSummary()
    {
        if (isset($this->channelInfo['summary'])) {
            return $this->channelInfo['summary'];
        }

        return false;
    }

    /**
     * @return int|80 port number to connect to
     */
    function getPort()
    {
        if (isset($this->channelInfo['servers']['primary']['attribs']['port'])) {
            return $this->channelInfo['servers']['primary']['attribs']['port'];
        }

        if ($this->getSSL()) {
            return 443;
        }

        return 80;
    }

    /**
     * @return bool Determines whether secure sockets layer (SSL) is used to connect to this channel
     */
    function getSSL()
    {
        if (isset($this->channelInfo['servers']['primary']['attribs']['ssl'])) {
            return true;
        }

        return false;
    }

    /**
     * @param string xmlrpc or soap
     */
    function getPath($protocol)
    {
        if (!in_array($protocol, array('xmlrpc', 'soap'))) {
            throw new PEAR2_Pyrus_Channel_Exception('Unknown protocol: ' .
                $protocol);
        }
        if (isset($this->channelInfo['servers']['primary'][$protocol]['attribs']['path'])) {
            return $this->channelInfo['servers']['primary'][$protocol]['attribs']['path'];
        }
        return $protocol . '.php';
    }

    /**
     * @param string protocol type (xmlrpc, soap)
     * @return array|false
     */
    function getFunctions($protocol)
    {
        if (!in_array($protocol, array('rest', 'xmlrpc', 'soap'), true)) {
            throw new PEAR2_Pyrus_Channel_Exception('Unknown protocol: ' .
                $protocol);
        }
        if ($this->getName() == '__uri') {
            return false;
        }
        if ($protocol == 'rest') return $this->getREST();
        if (isset($this->channelInfo['servers']['primary'][$protocol]['function'])) {
            return $this->channelInfo['servers']['primary'][$protocol]['function'];
        }

        return false;
    }

    /**
     * @param string protocol type
     * @param string protocol name
     * @param string version
     * @return boolean
     */
    function supports($type, $name = null, $version = '1.0')
    {
        $protocols = $this->getFunctions($type);
        if (!$protocols) {
            return false;
        }

        foreach ($protocols as $protocol) {
            if ($protocol['attribs']['version'] != $version) {
                continue;
            }

            if ($name === null) {
                return true;
            }

            if ($protocol['_content'] != $name) {
                continue;
            }

            return true;
        }

        return false;
    }

    /**
     * Determines whether a channel supports Representational State Transfer (REST) protocols
     * for retrieving channel information
     * @return bool
     */
    function supportsREST()
    {
        return isset($this->channelInfo['servers']['primary']['rest']);
    }

    function getREST()
    {
        if (isset($this->channelInfo['servers']['primary']['rest'])) {
            return $this->channelInfo['servers']['primary']['rest']['baseurl'];
        }

        return false;
    }

    /**
     * Get the URL to access a base resource.
     *
     * Hyperlinks in the returned xml will be used to retrieve the proper information
     * needed.  This allows extreme extensibility and flexibility in implementation
     * @param string Resource Type to retrieve
     */
    function getBaseURL($resourceType)
    {
        $rest = $this->getREST();
        if (!isset($rest['baseurl'][0])) {
            $rest['baseurl'] = array($rest['baseurl']);
        }

        foreach ($rest['baseurl'] as $baseurl) {
            if (strtolower($baseurl['attribs']['type']) == strtolower($resourceType)) {
                return $baseurl['_content'];
            }
        }

        return false;
    }

    function __get($value)
    {
        switch ($value) {
            case 'mirrors' :
                if (!isset($this->channelInfo['servers']['mirror'])) {
                    return array();
                }
                if (!isset($this->channelInfo['servers']['mirror'][0])) {
                    return array(
                      $this->channelInfo['servers']['mirror']['attribs']['host'] =>
                      new PEAR2_Pyrus_Channel_Mirror(
                          $this->channelInfo['servers']['mirror'], $this));
                }
                $ret = array();

                foreach ($this->channelInfo['servers']['mirror'] as $i => $mir) {
                    $ret[$mir['attribs']['host']] = new PEAR2_Pyrus_Channel_Mirror(
                          $this->channelInfo['servers']['mirror'][$i], $this);
                }
                return $ret;
        }
        if (method_exists($this, "get$value")) {
            $gv = "get$value";
            return $this->$gv();
        }
    }

    function __set($var, $value)
    {
        if (method_exists($this, "set$var")) {
            $sv = "set$var";
            $this->$sv($value);
        }
    }

    /**
     * Empty all xmlrpc definitions
     */
    function resetXmlrpc()
    {
        if (isset($this->channelInfo['servers']['primary']['xmlrpc'])) {
            unset($this->channelInfo['servers']['primary']['xmlrpc']);
        }
    }

    /**
     * Empty all SOAP definitions
     */
    function resetSOAP()
    {
        if (isset($this->channelInfo['servers']['primary']['soap'])) {
            unset($this->channelInfo['servers']['primary']['soap']);
        }
    }

    /**
     * Empty all REST definitions
     */
    function resetREST()
    {
        if (isset($this->channelInfo['servers']['primary']['rest'])) {
            unset($this->channelInfo['servers']['primary']['rest']);
        }
    }

    /**
     * @param string
     * @return string|false
     * @error PEAR_CHANNELFILE_ERROR_NO_NAME
     * @error PEAR_CHANNELFILE_ERROR_INVALID_NAME
     */
    function setName($name)
    {
        if (empty($name)) {
            throw new PEAR2_Pyrus_Channel_Exception('Primary server must be non-empty');
            return false;
        } elseif (!$this->validChannelServer($name)) {
            throw new PEAR2_Pyrus_Channel_Exception('Primary server "' . $name .
                '" is not a valid channel server');
        }
        $this->channelInfo['name'] = $name;
    }

    /**
     * Test whether a string contains a valid channel server.
     * @param string $ver the package version to test
     * @return bool
     */
    static function validChannelServer($server)
    {
        if ($server == '__uri') {
            return true;
        }

        $regex = '/^[a-z0-9\-]+(?:\.[a-z0-9\-]+)*(\/[a-z0-9\-]+)*\\z/i';
        return (bool) preg_match($regex, $server);
    }

    /**
     * Set the socket number (port) that is used to connect to this channel
     * @param integer
     */
    function setPort($port)
    {
        $this->channelInfo['servers']['primary']['attribs']['port'] = $port;
    }

    /**
     * Set the socket number (port) that is used to connect to this channel
     * @param bool Determines whether to turn on SSL support or turn it off
     */
    function setSSL($ssl = true)
    {
        if ($ssl) {
            $this->channelInfo['servers']['primary']['attribs']['ssl'] = 'yes';
        } elseif (isset($this->channelInfo['servers']['primary']['attribs']['ssl'])) {
            unset($this->channelInfo['servers']['primary']['attribs']['ssl']);
        }
    }

    /**
     * Set the path to the entry point for a protocol
     * @param xmlrpc|soap
     * @param string
     */
    function setPath($protocol, $path)
    {
        if (!in_array($protocol, array('xmlrpc', 'soap'))) {
            throw new PEAR2_Pyrus_Channel_Exception('Unknown protocol: ' . $protocol);
        }
        $this->channelInfo['servers']['primary'][$protocol]['attribs']['path'] = $path;
    }

    /**
     * @param string
     * @return boolean success
     * @error PEAR_CHANNELFILE_ERROR_NO_SUMMARY
     * @warning PEAR_CHANNELFILE_ERROR_MULTILINE_SUMMARY
     */
    function setSummary($summary)
    {
        if (empty($summary)) {
            throw new PEAR2_Pyrus_Channel_Exception('Channel summary cannot be empty');
        } elseif (strpos(trim($summary), "\n") !== false) {
            // not sure what to do about this yet
            $this->_validateWarning(PEAR_CHANNELFILE_ERROR_MULTILINE_SUMMARY,
                array('summary' => $summary));
        }
        $this->channelInfo['summary'] = $summary;
        return true;
    }

    /**
     * @param string
     * @param boolean determines whether the alias is in channel.xml or local
     * @return boolean success
     */
    function setAlias($alias, $local = false)
    {
        if (!$this->validChannelServer($alias)) {
            throw new PEAR2_Pyrus_Channel_Exception('Primary server "' . $server . '" is not a valid channel server');
        }

        $a = $local ? 'localalias' : 'suggestedalias';
        $this->channelInfo[$a] = $alias;
        return true;
    }

    /**
     * @return string
     */
    function getAlias()
    {
        if (isset($this->channelInfo['localalias'])) {
            return $this->channelInfo['localalias'];
        }
        if (isset($this->channelInfo['suggestedalias'])) {
            return $this->channelInfo['suggestedalias'];
        }
        if (isset($this->channelInfo['name'])) {
            return $this->channelInfo['name'];
        }
        return '';
    }

    /**
     * Set the package validation object if it differs from PEAR's default
     * The class must be includeable via changing _ in the classname to path separator,
     * but no checking of this is made.
     * @param string|false pass in false to reset to the default packagename regex
     * @return boolean success
     */
    function setValidationPackage($validateclass, $version)
    {
        if (empty($validateclass)) {
            unset($this->channelInfo['validatepackage']);
        }
        $this->channelInfo['validatepackage'] = array('_content' => $validateclass);
        $this->channelInfo['validatepackage']['attribs'] = array('version' => $version);
    }

    /**
     * Add a protocol to the provides section
     * @param string protocol type
     * @param string protocol version
     * @param string protocol name
     * @return bool
     */
    function addFunction($type, $version, $name)
    {
        if (!in_array($type, array('xmlrpc', 'soap'))) {
            throw new PEAR2_Pyrus_Channel_Exception('Unknown protocol: ' .
                $type);
        }
        $set = array('attribs' => array('version' => $version), '_content' => $name);
        if (!isset($this->channelInfo['servers']['primary'][$type]['function'])) {
            if (!isset($this->channelInfo['servers'])) {
                $this->channelInfo['servers'] = array('primary' =>
                    array($type => array()));
            } elseif (!isset($this->channelInfo['servers']['primary'])) {
                $this->channelInfo['servers']['primary'] = array($type => array());
            }
            $this->channelInfo['servers']['primary'][$type]['function'] = $set;
        } elseif (!isset($this->channelInfo['servers']['primary'][$type]['function'][0])) {
            $this->channelInfo['servers']['primary'][$type]['function'] = array(
                $this->channelInfo['servers']['primary'][$type]['function']);
        }
        $this->channelInfo['servers']['primary'][$type]['function'][] = $set;
    }

    /**
     * @param string Resource Type this url links to
     * @param string URL
     */
    function setBaseURL($resourceType, $url)
    {
        $set = array('attribs' => array('type' => $resourceType), '_content' => $url);
        if (!isset($this->channelInfo['servers']['primary']['rest'])) {
            $this->channelInfo['servers']['primary']['rest'] = array();
        }
        if (!isset($this->channelInfo['servers']['primary']['rest']['baseurl'])) {
            $this->channelInfo['servers']['primary']['rest']['baseurl'] = $set;
            return;
        } elseif (!isset($this->channelInfo['servers']['primary']['rest']['baseurl'][0])) {
            $this->channelInfo['servers']['primary']['rest']['baseurl'] = array($this->channelInfo['servers']['primary']['rest']['baseurl']);
        }
        foreach ($this->channelInfo['servers']['primary']['rest']['baseurl'] as $i => $url) {
            if ($url['attribs']['type'] == $resourceType) {
                $this->channelInfo['servers']['primary']['rest']['baseurl'][$i] = $set;
                return;
            }
        }
        $this->channelInfo['servers']['primary']['rest']['baseurl'][] = $set;
    }

    /**
     * @param string mirror server
     * @param int mirror http port
     * @return boolean
     */
    function addMirror($server, $port = null)
    {
        if ($this->channelInfo['name'] == '__uri') {
            return false; // the __uri channel cannot have mirrors by definition
        }

        $set = array('attribs' => array('host' => $server));
        if (is_numeric($port)) {
            $set['attribs']['port'] = $port;
        }

        if (!isset($this->channelInfo['servers']['mirror'])) {
            $this->channelInfo['servers']['mirror'] = $set;
            return true;
        }

        if (!isset($this->channelInfo['servers']['mirror'][0])) {
            $this->channelInfo['servers']['mirror'] =
                array($this->channelInfo['servers']['mirror']);
        }

        $this->channelInfo['servers']['mirror'][] = $set;
        return true;
    }

    /**
     * Retrieve the name of the validation package for this channel
     * @return string|false
     */
    function getValidationPackage()
    {
        if (!$this->validate()) {
            return false;
        }

        if (!isset($this->channelInfo['validatepackage'])) {
            return array('attribs' => array('version' => 'default'),
                '_content' => 'PEAR2_Pyrus_Validate');
        }

        return $this->channelInfo['validatepackage'];
    }

    function getArray()
    {
        return $this->_channelInfo;
    }

    /**
     * Retrieve the object that can be used for custom validation
     * @param string|false the name of the package to validate.  If the package is
     *                     the channel validation package, PEAR_Validate is returned
     * @return PEAR_Validate|false false is returned if the validation package
     *         cannot be located
     */
    function getValidationObject($package = false)
    {
        if (!$this->validate()) {
            return false;
        }

        if (isset($this->channelInfo['validatepackage'])) {
            if ($package == $this->channelInfo['validatepackage']) {
                // channel validation packages are always validated by PEAR_Validate
                $val = new PEAR2_Pyrus_Validate;
                return $val;
            }

            if (!class_exists(str_replace('.', '_',
                  $this->channelInfo['validatepackage']['_content']), true)) {
                return false;
            }

            $vclass = str_replace('.', '_',
                $this->channelInfo['validatepackage']['_content']);
            $val = new $vclass;
        } else {
            $val = new PEAR2_Pyrus_Validate;
        }

        return $val;
    }

    /**
     * This function is used by the channel updater and retrieves a value set by
     * the registry, or the current time if it has not been set
     * @return string
     */
    function lastModified()
    {
        if (isset($this->channelInfo['_lastmodified'])) {
            return $this->channelInfo['_lastmodified'];
        }

        return time();
    }
}
<?php
/**
 * PEAR2_Pyrus_Channel_Base
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for a PEAR channel in Pyrus
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
abstract class PEAR2_Pyrus_Channel_Base implements PEAR2_Pyrus_IChannel
{
    /**
     * Determines whether a mirror supports Representational State Transfer (REST) protocols
     * for retrieving channel information
     * @return bool
     */
    function supportsREST()
    {
        return (bool) $this->getREST();
    }

    /**
     * Get the URL to access a base resource.
     *
     * Hyperlinks in the returned xml will be used to retrieve the proper information
     * needed.  This allows extreme extensibility and flexibility in implementation
     * @param string Resource Type to retrieve
     */
    function getBaseURL($resourceType)
    {
        $rest = $this->getREST();
        if (!$rest) {
            return false;
        }
        if (!isset($rest['baseurl'][0])) {
            $rest['baseurl'] = array($rest['baseurl']);
        }
        foreach ($rest['baseurl'] as $baseurl) {
            if (strtolower($baseurl['attribs']['type']) == strtolower($resourceType)) {
                return $baseurl['_content'];
            }
        }
        return false;
    }

    /**
     * @param string protocol type
     * @param string protocol name
     * @param string version
     * @return boolean
     */
    function supports($type, $name = null, $version = '1.0')
    {
        $protocols = $this->getFunctions($type);
        if (!$protocols) {
            return false;
        }
        foreach ($protocols as $protocol) {
            if ($protocol['attribs']['version'] != $version) {
                continue;
            }
            if ($name === null) {
                return true;
            }
            if ($protocol['_content'] != $name) {
                continue;
            }
            return true;
        }
        return false;
    }
}<?php
/**
 * PEAR2_Pyrus_Channel_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for channels
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Channel_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Channel_IMirror
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for channel mirrors
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_Channel_IMirror
{
    public function getChannel();
}<?php
/**
 * PEAR2_Pyrus_Channel_Mirror
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class for a PEAR2 channel mirror
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Channel_Mirror extends PEAR2_Pyrus_Channel implements PEAR2_Pyrus_Channel_IMirror
{
    private $_info;
    /**
     * Parent channel object
     *
     * @var PEAR2_Pyrus_Channel
     */
    protected $parentChannel;
    function __construct(&$mirrorarray, PEAR2_Pyrus_IChannel $parent)
    {
        if ($parent->getName() == '__uri') {
            throw new PEAR2_Pyrus_Channel_Exception('__uri channel cannot have mirrors');
        }
        $this->_info = &$mirrorarray;
        $this->parentChannel = $parent;
    }

    function getChannel()
    {
        return $this->parentChannel->getName();
    }

    /**
     * @return string|false
     */
    function getName()
    {
        if (isset($this->_info['attribs']['host'])) {
            return $this->_info['attribs']['host'];
        }

        return false;
    }

    /**
     * @return int|80 port number to connect to
     */
    function getPort()
    {
        if (isset($this->_info['attribs']['port'])) {
            return $this->_info['attribs']['port'];
        }

        if ($this->getSSL()) {
            return 443;
        }

        return 80;
    }

    /**
     * @return bool Determines whether secure sockets layer (SSL) is used to connect to this channel
     */
    function getSSL()
    {
        if (isset($this->_info['attribs']['ssl'])) {
            return true;
        }

        return false;
    }


    /**
     * @param string xmlrpc or soap
     */
    function getPath($protocol)
    {
        if (!in_array($protocol, array('xmlrpc', 'soap'))) {
            return false;
        }

        if (isset($this->_info[$protocol]['attribs']['path'])) {
            return $this->_info[$protocol]['attribs']['path'];
        }

        return $protocol . '.php';
    }

    /**
     * @param string protocol type (xmlrpc, soap)
     * @return array|false
     */
    function getFunctions($protocol)
    {
        if (!in_array($protocol, array('rest', 'xmlrpc', 'soap'), true)) {
            throw new PEAR2_Pyrus_Channel_Exception('Unknown protocol: ' .
                $protocol);
        }
        if ($this->parentChannel->getName() == '__uri') {
            return false;
        }

        if (isset($this->_info[$protocol]['function'])) {
            return $this->_info[$protocol]['function'];
        }
    }

    function getREST()
    {
        if (isset($this->_info['rest'])) {
            return $this->_info['rest'];
        }

        return false;
    }

    /**
     * Determines whether a channel supports Representational State Transfer (REST) protocols
     * for retrieving channel information
     * @return bool
     */
    function supportsREST()
    {
        return isset($this->_info['rest']);
    }

    /**
     * Empty all protocol definitions
     * @param string protocol type (xmlrpc, soap)
     */
    function resetFunctions($type)
    {
        if (isset($this->_info[$type])) {
            unset($this->_info[$type]);
        }
    }

    function setName($name)
    {
        if (empty($name)) {
            throw new PEAR2_Pyrus_Channel_Exception('Mirror server must be non-empty');
            return false;
        } elseif (!$this->validChannelServer($name)) {
            throw new PEAR2_Pyrus_Channel_Exception('Mirror server "' . $name .
                '" for channel "' . parent::getName() . '" is not a valid channel server');
        }
        $this->_info['attribs']['host'] = $name;
    }

    function setPort($port)
    {
        $this->_info['attribs']['port'] = $port;
    }

    function setSSL($ssl = true)
    {
        if (!$ssl) {
            if (isset($this->_info['attribs']['ssl'])) {
                unset($this->_info['attribs']['ssl']);
            }
        } else {
            $this->_info['attribs']['ssl'] = 'yes';
        }
    }

    /**
     * Set the path to the entry point for a protocol
     * @param xmlrpc|soap
     * @param string
     */
    function setPath($protocol, $path)
    {
        if (!in_array($protocol, array('xmlrpc', 'soap'))) {
            throw new PEAR2_Pyrus_Channel_Exception('Unknown protocol: ' .
                $protocol);
        }
        $this->_info[$protocol]['attribs']['path'] = $path;
    }

    /**
     * Empty all xmlrpc definitions
     */
    function resetXmlrpc()
    {
        if (isset($this->_info['xmlrpc'])) {
            unset($this->_info['xmlrpc']);
        }
    }

    /**
     * Empty all SOAP definitions
     */
    function resetSOAP()
    {
        if (isset($this->_info['soap'])) {
            unset($this->_info['soap']);
        }
    }

    /**
     * Empty all REST definitions
     */
    function resetREST()
    {
        if (isset($this->_info['rest'])) {
            unset($this->_info['rest']);
        }
    }

    /**
     * Add a protocol to a mirror's provides section
     * @param string mirror name (server)
     * @param string protocol type
     * @param string protocol version
     * @param string protocol name, if any
     */
    function addFunction($type, $version, $name)
    {
        if (!in_array($type, array('xmlrpc', 'soap'))) {
            throw new PEAR2_Pyrus_Channel_Exception('Unknown protocol: ' .
                $type);
        }
        $set = array('attribs' => array('version' => $version), '_content' => $name);

        if (!isset($this->_info[$type]['function'])) {
            $this->_info[$type]['function'] = $set;
        } elseif (!isset($this->_info[$type]['function'][0])) {
            $this->_info[$type]['function'] = array($this->_info[$type]['function']);
        }
        $this->_info[$type]['function'][] = $set;
    }

    /**
     * @param string Resource Type this url links to
     * @param string URL
     */
    function setBaseURL($resourceType, $url)
    {
        $set = array('attribs' => array('type' => $resourceType), '_content' => $url);
        if (!isset($this->_info['rest'])) {
            $this->_info['rest'] = array();
        }

        if (!isset($this->_info['rest']['baseurl'])) {
            $this->_info['rest']['baseurl'] = $set;
            return;
        } elseif (!isset($this->_info['rest']['baseurl'][0])) {
            $this->_info['rest']['baseurl'] = array($this->_info['rest']['baseurl']);
        }

        foreach ($this->_info['rest']['baseurl'] as $i => $url) {
            if ($url['attribs']['type'] == $resourceType) {
                $this->_info['rest']['baseurl'][$i] = $set;
                return;
            }
        }
        $this->_info['rest']['baseurl'][] = $set;
    }
}<?php
/**
 * PEAR2_Pyrus_ChannelRegistry
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Pyrus.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry implements ArrayAccess, IteratorAggregate, PEAR2_Pyrus_IChannelRegistry
{
    /**
     * Class to instantiate for singleton.
     *
     * This is useful for unit-testing and for extending the registry
     * @var string
     */
    static public $className = 'PEAR2_Pyrus_ChannelRegistry';
    /**
     * The parent registry
     *
     * This is used to implement cascading registries
     * @var PEAR2_Pyrus_ChannelRegistry
     */
    protected $parent;
    protected $path;
    protected $readonly;
    private $_registries = array();

    public function __construct($path, $registries = array('Sqlite', 'Xml'), $readonly = false)
    {
        $this->path = $path;
        $this->readonly = $readonly;
        $exceptions = array();
        foreach ($registries as $registry) {
            try {
                $registry = ucfirst($registry);
                $registry = "PEAR2_Pyrus_ChannelRegistry_$registry";
                if (!class_exists($registry, true)) {
                    $exceptions[] = new PEAR2_Pyrus_ChannelRegistry_Exception(
                        'Unknown channel registry type: ' . $registry);
                    continue;
                }
                $this->_registries[] = new $registry($path, $readonly);
            } catch (PEAR2_Pyrus_ChannelRegistry_Exception $e) {
                $exceptions[] = $e;
            }
        }
        if (!count($this->_registries)) {
            throw new PEAR2_Pyrus_Registry_Exception(
                'Unable to initialize registry for path "' . $path . '"',
                $exceptions);
        }
    }

    public function setParent(PEAR2_Pyrus_ChannelRegistry $parent = null)
    {
        $this->parent = $parent;
    }

    public function add(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel, registry is read-only');
        }
        foreach ($this->_registries as $reg) {
            $reg->add($channel);
        }
    }

    public function update(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot update channel, registry is read-only');
        }
        foreach ($this->_registries as $reg) {
            $reg->update($channel);
        }
    }

    public function delete(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel, registry is read-only');
        }
        switch ($channel->name) {
            case 'pear.php.net' :
            case 'pear2.php.net' :
            case 'pecl.php.net' :
            case '__uri' :
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel ' .
                    $channel->name);
        }
        foreach ($this->_registries as $reg) {
            $reg->delete($channel);
        }
    }

    public function get($channel, $strict = true)
    {
        try {
            return $this->_registries[0]->get($channel, $strict);
        } catch (Exception $e) {
            // don't fail on the default channels, these should always exist
            switch ($channel) {
                case 'pear.php.net' :
                    return $this->_registries[0]->getPearChannel();
                case 'pear2.php.net' :
                    return $this->_registries[0]->getPear2Channel();
                case 'pecl.php.net' :
                    return $this->_registries[0]->getPeclChannel();
                case '__uri' :
                    return $this->_registries[0]->getUriChannel();
            }
            throw $e;
        }
    }

    public function exists($channel, $strict = true)
    {
        if (!$this->_registries[0]->exists($channel, $strict)) {
            switch ($channel) {
                case 'pear.php.net' :
                case 'pear2.php.net' :
                case 'pecl.php.net' :
                case '__uri' :
                    return true;
            }
            if (!$strict) {
                switch ($channel) {
                    case 'pear' :
                    case 'pear2' :
                    case 'pecl' :
                        return true;
                }
            }
            return false;
        }
        return true;
    }

    public function parseName($name)
    {
        foreach ($this->_registries as $reg) {
            try {
                return $reg->parseName($name);
            } catch (Exception $e) {
                continue;
            }
        }
        if ($this->parent) {
            return $this->parent->parseName($name);
        }
        // recycle last exception
        throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unable to process package name', $e);
    }

    public function parsedNameToString($name)
    {
        foreach ($this->_registries as $reg) {
            try {
                return $reg->parsedNameToString($name);
            } catch (Exception $e) {
                continue;
            }
        }
        if ($this->parent) {
            return $this->parent->parsedNameToString($name);
        }
        // recycle last exception
        throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unable to convert to package name string', $e);
    }

    public function listChannels()
    {
        return $this->_registries[0]->listChannels();
    }

    public function offsetGet($offset)
    {
        return $this->get($offset);
    }

    public function offsetSet($offset, $value)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel, registry is read-only');
        }
        foreach ($this->_registries as $reg) {
            $reg->add($offset, $value);
        }
    }

    public function offsetExists($offset)
    {
        return $this->exists($offset);
    }

    public function offsetUnset($offset)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel, registry is read-only');
        }
        foreach ($this->_registries as $reg) {
            $reg->delete($offset);
        }
    }

    public function __call($method, $args)
    {
        return call_user_func_array(array($this->_registries[0], $method), $args);
    }

    public function getIterator()
    {
        return $this->_registries[0];
    }

    public function getParent()
    {
        return $this->parent;
    }

    public function getPath()
    {
        return $this->path;
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Base
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Pyrus managed channel registries
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
abstract class PEAR2_Pyrus_ChannelRegistry_Base
    implements PEAR2_Pyrus_IChannelRegistry, Iterator
{
    /**
     * Parse a package name, or validate a parsed package name array
     * @param string|array pass in an array of format
     *                     array(
     *                      'package' => 'pname',
     *                     ['channel' => 'channame',]
     *                     ['version' => 'version',]
     *                     ['state' => 'state',]
     *                     ['group' => 'groupname'])
     *                     or a string of format
     *                     [channel://][channame/]pname[-version|-state][/group=groupname]
     *
     * @return array
     */
    public function parseName($param, $defaultchannel = 'pear.php.net')
    {
        $saveparam = $param;
        if (is_array($param)) {
            // convert to string for error messages
            $saveparam = self::parsedNameToString($param);
            // process the array
            if (!isset($param['package'])) {
                throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): array $param ' .
                    'must contain a valid package name in index "param"', 'package');
            }
            if (!isset($param['uri'])) {
                if (!isset($param['channel'])) {
                    $param['channel'] = $defaultchannel;
                }
            } else {
                $param['channel'] = '__uri';
            }
        } else {
            $components = @parse_url((string) $param);
            if (isset($components['scheme'])) {
                if ($components['scheme'] == 'http') {
                    // uri package
                    $param = array('uri' => $param, 'channel' => '__uri');
                } elseif($components['scheme'] != 'channel') {
                    throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): only channel:// uris may ' .
                        'be downloaded, not "' . $param . '"', 'scheme');
                }
            }
            if (!isset($components['path'])) {
                throw new PEAR2_Registry_Exception('parsePackageName(): array $param ' .
                    'must contain a valid package name in "' . $param . '"');
            }
            if (isset($components['host'])) {
                // remove the leading "/"
                $components['path'] = substr($components['path'], 1);
            }
            if (!isset($components['scheme'])) {
                if (strpos($components['path'], '/') !== false) {
                    if ($components['path']{0} == '/') {
                        throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): this is not ' .
                            'a package name, it begins with "/" in "' . $param . '"', 'invalid');
                    }
                    $parts = explode('/', $components['path']);
                    $components['host'] = array_shift($parts);
                    if (count($parts) > 1) {
                        $components['path'] = array_pop($parts);
                        $components['host'] .= '/' . implode('/', $parts);
                    } else {
                        $components['path'] = implode('/', $parts);
                    }
                } else {
                    $components['host'] = $defaultchannel;
                }
            } else {
                if (strpos($components['path'], '/')) {
                    $parts = explode('/', $components['path']);
                    $components['path'] = array_pop($parts);
                    $components['host'] .= '/' . implode('/', $parts);
                }
            }

            if (is_array($param)) {
                $param['package'] = $components['path'];
            } else {
                $param = array(
                    'package' => $components['path']
                    );
                if (isset($components['host'])) {
                    $param['channel'] = $components['host'];
                }
            }
            if (isset($components['fragment'])) {
                $param['group'] = $components['fragment'];
            }
            if (isset($components['user'])) {
                $param['user'] = $components['user'];
            }
            if (isset($components['pass'])) {
                $param['pass'] = $components['pass'];
            }
            if (isset($components['query'])) {
                parse_str($components['query'], $param['opts']);
            }
            // check for extension
            $pathinfo = pathinfo($param['package']);
            if (isset($pathinfo['extension']) &&
                  in_array(strtolower($pathinfo['extension']), array('tgz', 'tar'))) {
                $param['extension'] = $pathinfo['extension'];
                $param['package'] = substr($pathinfo['basename'], 0,
                    strlen($pathinfo['basename']) - 4);
            }
            // check for version
            if (strpos($param['package'], '-')) {
                $test = explode('-', $param['package']);
                if (count($test) != 2) {
                    throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): only one version/state ' .
                        'delimiter "-" is allowed in "' . $saveparam . '"', 'invalid');
                }
                list($param['package'], $param['version']) = $test;
            }
        }
        // validation
        $info = $this->exists($param['channel'], false);
        if (!$info) {
            throw new PEAR2_Pyrus_ChannelRegistry_ParseException('unknown channel "' . $param['channel'] .
                '" in "' . $saveparam . '"', 'channel');
        }
        try {
            $chan = $this->get($param['channel'], false);
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_ChannelRegistry_ParseException("Exception: corrupt registry, could not " .
                "retrieve channel " . $param['channel'] . " information", 'other', $e);
        }
        $param['channel'] = $chan->getName();
        $validate = $chan->getValidationObject(false);
        $vpackage = $chan->getValidationPackage(false);
        // validate package name
        if (!$validate->validPackageName($param['package'], $vpackage['_content'])) {
            throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): invalid package name "' .
                $param['package'] . '" in "' . $saveparam . '"', 'package');
        }
        if (isset($param['group'])) {
            if (!PEAR2_Pyrus_Validate::validGroupName($param['group'])) {
                throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): dependency group "' . $param['group'] .
                    '" is not a valid group name in "' . $saveparam . '"', 'group');
            }
        }
        if (isset($param['state'])) {
            if (!in_array(strtolower($param['state']), $validate->getValidStates())) {
                throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): state "' . $param['state']
                    . '" is not a valid state in "' . $saveparam . '"', 'version/state');
            }
        }
        if (isset($param['version'])) {
            if (isset($param['state'])) {
                throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): cannot contain both ' .
                    'a version and a stability (state) in "' . $saveparam . '"',
                    'version/state');
            }
            // check whether version is actually a state
            if (in_array(strtolower($param['version']), $validate->getValidStates())) {
                $param['state'] = strtolower($param['version']);
                unset($param['version']);
            } else {
                if (!$validate->validVersion($param['version'])) {
                    throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): "' . $param['version'] .
                        '" is neither a valid version nor a valid state in "' .
                        $saveparam . '"', 'version/state');
                }
            }
        }
        return $param;
    }

    /**
     * @param array
     * @return string
     */
    function parsedNameToString($parsed, $brief = false)
    {
        if (is_string($parsed)) {
            return $parsed;
        }
        if (is_object($parsed)) {
            $p = $parsed;
            $parsed = array(
                'package' => $p->getPackage(),
                'channel' => $p->getChannel(),
                'version' => $p->getVersion(),
            );
        }
        if (isset($parsed['uri'])) {
            return $parsed['uri'];
        }
        if ($brief) {
            if ($channel = $this->getAlias($parsed['channel'])) {
                return $channel . '/' . $parsed['package'];
            }
        }
        $upass = '';
        if (isset($parsed['user'])) {
            $upass = $parsed['user'];
            if (isset($parsed['pass'])) {
                $upass .= ':' . $parsed['pass'];
            }
            $upass = "$upass@";
        }
        $ret = 'channel://' . $upass . $parsed['channel'] . '/' . $parsed['package'];
        if (isset($parsed['version']) || isset($parsed['state'])) {
            $ver = isset($parsed['version']) ? $parsed['version'] : '';
            $ver .= isset($parsed['state']) ? $parsed['state'] : '';
            $ret .= '-' . $ver;
        }
        if (isset($parsed['extension'])) {
            $ret .= '.' . $parsed['extension'];
        }
        if (isset($parsed['opts'])) {
            $ret .= '?';
            foreach ($parsed['opts'] as $name => $value) {
                $parsed['opts'][$name] = "$name=$value";
            }
            $ret .= implode('&', $parsed['opts']);
        }
        if (isset($parsed['group'])) {
            $ret .= '#' . $parsed['group'];
        }
        return $ret;
    }

    function current()
    {
        return $this->get(current($this->channelList));
    }

    function key()
    {
        return key($this->channelList);
    }

    function valid()
    {
        return current($this->channelList);
    }

    function next()
    {
        return next($this->channelList);
    }

    function rewind()
    {
        $this->channelList = $this->listChannels();
    }

    public function getPearChannel()
    {
        return new PEAR2_Pyrus_Channel('<?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>pear.php.net</name>
 <suggestedalias>pear</suggestedalias>
 <summary>PHP Extension and Application Repository</summary>
 <servers>
  <primary>
   <rest>

    <baseurl type="REST1.0">http://pear.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://pear.php.net/rest/</baseurl>
    <baseurl type="REST1.2">http://pear.php.net/rest/</baseurl>
    <baseurl type="REST1.3">http://pear.php.net/rest/</baseurl>
   </rest>
  </primary>
  <mirror host="us.pear.php.net">

   <rest>
    <baseurl type="REST1.0">http://us.pear.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://us.pear.php.net/rest/</baseurl>
    <baseurl type="REST1.2">http://us.pear.php.net/rest/</baseurl>
    <baseurl type="REST1.3">http://us.pear.php.net/rest/</baseurl>
   </rest>
  </mirror>

  <mirror host="de.pear.php.net" ssl="yes" port="3452">
   <rest>
    <baseurl type="REST1.0">https://de.pear.php.net:3452/rest/</baseurl>
    <baseurl type="REST1.1">https://de.pear.php.net:3452/rest/</baseurl>
    <baseurl type="REST1.2">https://de.pear.php.net:3452/rest/</baseurl>
    <baseurl type="REST1.3">https://de.pear.php.net:3452/rest/</baseurl>
   </rest>

  </mirror>
 </servers>
</channel>
');
    }

    public function getPear2Channel()
    {
        return new PEAR2_Pyrus_Channel('<?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>pear2.php.net</name>
 <suggestedalias>pear2</suggestedalias>
 <summary>PEAR packages for PHP 5.3+ installed by Pyrus</summary>
 <servers>
  <primary>
   <rest>

    <baseurl type="REST1.0">http://pear2.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://pear2.php.net/rest/</baseurl>
    <baseurl type="REST1.2">http://pear2.php.net/rest/</baseurl>
    <baseurl type="REST1.3">http://pear2.php.net/rest/</baseurl>
   </rest>
  </primary>
 </servers>
</channel>
');
    }

    public function getPeclChannel()
    {
        return new PEAR2_Pyrus_Channel('<?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>pecl.php.net</name>
 <suggestedalias>pecl</suggestedalias>
 <summary>PHP Extension Community Library</summary>
 <validatepackage version="1.0">PEAR_Validator_PECL</validatepackage>
 <servers>
  <primary>

   <xmlrpc>
    <function version="1.0">logintest</function>
    <function version="1.0">package.listLatestReleases</function>
    <function version="1.0">package.listAll</function>
    <function version="1.0">package.info</function>
    <function version="1.0">package.getDownloadURL</function>

    <function version="1.0">package.getDepDownloadURL</function>
    <function version="1.0">package.search</function>
    <function version="1.0">channel.listAll</function>
   </xmlrpc>
   <rest>
    <baseurl type="REST1.0">http://pecl.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://pecl.php.net/rest/</baseurl>

   </rest>
  </primary>
 </servers>
</channel>
');
    }

    public function getUriChannel()
    {
        return new PEAR2_Pyrus_Channel('<?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>__uri</name>
 <suggestedalias>__uri</suggestedalias>
 <summary>Pseudo-channel for static packages</summary>
 <servers>
  <primary>
   <xmlrpc>
    <function version="1.0">****</function>
   </xmlrpc>
  </primary>
 </servers>
</channel>
');
    }

    /**
     * Set up default channels, for uninitialized channel registries
     */
    protected function initDefaultChannels()
    {
        $pear = $this->getPearChannel();
        $pear2 = $this->getPear2Channel();
        $pecl = $this->getPeclChannel();
        $__uri = $this->getUriChannel();
        $this->add($pear);
        $this->add($pear2);
        $this->add($pecl);
        $this->add($__uri);
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Channel_Pear1
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/PEAR2/Pyrus/
 */

/**
 * A class that represents individual channels within an XML channel registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/PEAR2/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Channel_Pear1 extends PEAR2_Pyrus_Channel implements Countable
{
    private $_parent;
    function __construct(PEAR2_Pyrus_ChannelRegistry_Pear1 $parent, $data)
    {
        $this->_parent = $parent;
        parent::__construct($data);
    }

    public function toChannelObject()
    {
        $chan = new PEAR2_Pyrus_Channel((string) $this);
        return $chan;
    }

    function count()
    {
        $reg = new PEAR2_Pyrus_Registry($this->_parent->getPath());
        return count($reg->listPackages($this->_parent->name));
    }

    public function resetXmlrpc()
    {
        parent::resetXmlrpc();
        $this->_parent->update($this);
    }

    public function resetSOAP()
    {
        parent::resetSOAP();
        $this->_parent->update($this);
    }

    public function resetREST()
    {
        parent::resetREST();
        $this->_parent->update($this);
    }

    public function setName($name)
    {
        parent::setName($name);
        $this->_parent->update($this);
    }

    public function setPort($port)
    {
        parent::setPort($port);
        $this->_parent->update($this);
    }

    public function setSSL($ssl = true)
    {
        parent::setSSL($ssl);
        $this->_parent->update($this);
    }

    public function setPath($protocol, $path)
    {
        parent::setPath($protocol, $path);
        $this->_parent->update($this);
    }

    public function addFunction($type, $version, $name)
    {
        parent::addFunction($type, $version, $name);
        $this->_parent->update($this);
    }

    public function setBaseUrl($resourceType, $url)
    {
        parent::setBaseURL($resourceType, $url);
        $this->_parent->update($this);
    }

    public function setAlias($alias)
    {
        @unlink($this->_parent->getAliasFile($this->getAlias()));
        parent::setAlias($alias);
        file_put_contents($this->getAliasFile($alias), $this->getName());
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Channel_Sqlite
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * A class for handling a channel entry within an Sqlite channel registry.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Channel_Sqlite implements PEAR2_Pyrus_IChannel, Countable
{
    /**
     * The database resource
     *
     * @var SQLiteDatabase
     */
    protected $database;
    protected $mirror;
    private $_path;
    protected $channelname;

    function __construct(SQLiteDatabase $db, $channel)
    {
        $channel = strtolower($channel);
        $this->database = $db;
        $this->channelname = $this->mirror = $channel;
        $sql = 'SELECT channel FROM channels WHERE channel = "' . sqlite_escape_string($channel) . '"';
        if (!$this->database->singleQuery($sql)) {
            $sql = 'SELECT channel FROM channels WHERE alias = "' . sqlite_escape_string($channel) . '"';
            if (!($channel = $this->database->singleQuery($sql))) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Channel ' .
                    $this->channelname . ' does not exist');
            }
            $this->channelname = $channel;
        }
    }

    function count()
    {
        $sql = 'SELECT COUNT(*) FROM packages WHERE channel = "' . sqlite_escape_string($this->channelname) . '"';
        return $this->database->singleQuery($sql);
    }

    function getName()
    {
        return $this->channelname;
    }

    function setAlias($alias)
    {
        $error = '';
        $sql   = 'UPDATE channels SET alias = \'' . sqlite_escape_string($alias) . '\'';
        if (!@$this->database->queryExec($sql, $error)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot set channel ' .
                $this->channelname . ' alias to ' . $alias . ': ' . $error);
        }
    }

    function getSummary()
    {
        $sql = 'SELECT summary FROM channels WHERE channel = \'' . sqlite_escape_string($this->channelname) . '\'';
        return $this->database->singleQuery($sql);
    }

    /**
     * @return int|80 port number to connect to
     */
    function getPort()
    {
        $sql = 'SELECT port FROM channel_servers WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\'';
        return $this->database->singleQuery($sql);
    }

    function getSSL($mirror = false)
    {
        $sql = 'SELECT ssl FROM channel_servers WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\'';
        return $this->database->singleQuery($sql);
    }

    /**
     * @param string xmlrpc or soap
     */
    function getPath($protocol)
    {
        if (!in_array($protocol, array('xmlrpc', 'soap'))) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unknown protocol: ' .
                $protocol);
        }

        $sql = 'SELECT ' . $protocol . 'path FROM channel_servers WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\'';
        $a = $this->database->singleQuery($sql);
        if (!$a) {
            return $protocol . '.php';
        }
    }

    /**
     * @param string protocol type (xmlrpc, soap)
     * @return array|false
     */
    function getFunctions($protocol)
    {
        if (!in_array($protocol, array('xmlrpc', 'soap'))) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unknown protocol: ' .
                $protocol);
        }

        $sql = 'SELECT * FROM channel_server_' . $protocol . '
            WHERE channel = \'' . sqlite_escape_string($this->channelname) . '\ AND
            server = \'' . sqlite_escape_string($this->mirror) . '\'';
        $functions = $this->database->arrayQuery($sql, SQLITE_ASSOC);
        $ret = array();
        foreach ($functions as $func) {
            $ret[] = array('attribs' => array('version' => $func['version']), '_content' => $func['function']);
        }
        return $ret;
    }

    function getValidationPackage()
    {
        $sql = 'SELECT validatepackage ' .
              'FROM channels WHERE ' .
              'channel=\'' . sqlite_escape_string($this->channelname) . '\'';
        $r = $this->database->singleQuery($sql);
            if ($r == 'PEAR_Validate' || $r == 'PEAR_Validate_PECL') {
                return array('attribs' => array('version' => '1.0'), '_content' => str_replace('PEAR_', 'PEAR2_Pyrus_', $r));
            }

            $sql = 'SELECT validatepackageversion ' .
              'FROM channels WHERE ' .
              'channel=\'' . sqlite_escape_string($this->channelname) . '\'';
            $v = $this->database->singleQuery($sql);
            return array('attribs' => array('version' => $v), '_content' => $r);
    }

    public function getREST()
    {
        $sql = 'SELECT * FROM channel_server_rest WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\'';
        $urls = $this->database->arrayQuery($sql, SQLITE_ASSOC);
        $ret = array();
        foreach ($urls as $url) {
            $ret[] = array('attribs' => array('type' => $url['type']), '_content' => $url['baseurl']);
        }
    }

    public function getValidationObject($package = false)
    {
        $a = $this->getValidationPackage($package);
        $b = $a['_content'];
        return new $b;
    }

    function __get($value)
    {
        switch ($value) {
            case 'mirrors' :
                $ret = array($this->channelname => $this);
                $sql = 'SELECT server FROM channel_servers
                      WHERE channel = \'' . sqlite_escape_string($this->channelname) . '\'
                      AND server != \'' . sqlite_escape_string($this->channelname) . '\'';
                foreach ($this->database->arrayQuery($sql) as $mirror) {
                    $ret[$mirror['server']] = new PEAR2_Pyrus_ChannelRegistry_Mirror_Sqlite($this->database, $mirror['server'], $this);
            }
            return $ret;
        }

        if (method_exists($this, "get$value")) {
            $gv = "get$value";
            return $this->$gv();
        }
    }

    function __set($var, $value)
    {
        if (method_exists($this, "set$var")) {
            $sv = "set$var";
            $this->$sv($value);
        }
    }

    public function toChannelObject()
    {
        $a = new PEAR2_Pyrus_Channel;
        $a->setName($this->getName());
        $a->setSummary($this->getSummary());
        $a->setPort($this->getPort());
        $a->setSSL($this->getSSL());
        $a->setValidationPackage();
    }

    public function __toString()
    {
        return $this->toChannelObject()->__toString();
    }

    function getMirrors()
    {
        $sql = 'SELECT server, ssl, port FROM
            channel_servers WHERE channel = \'' . sqlite_escape_string($this->channelname) .
            '\' AND server <> channel';
        return $this->database->arrayQuery($sql, SQLITE_ASSOC);
    }

    public function supportsREST()
    {
        $sql = '
            SELECT COUNT(*) FROM channel_server_rest WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\'';
        return (bool) $this->database->singleQuery($sql);
    }

    public function supports($protocol, $name = null, $version = '1.0')
    {
        if (!in_array($protocol, array('xmlrpc', 'soap'))) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unknown protocol: ' .
                $protocol);
        }

        if ($name === null) {
            $sql = 'SELECT COUNT(*) FROM channel_server_' . $protocol . '
                WHERE
                  channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
                  server = \'' . sqlite_escape_string($this->mirror) . '\'';
            return (bool) $this->database->singleQuery($sql);
        }

        $sql = '
            SELECT COUNT(*) FROM channel_server_' . $protocol . ' WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\' AND
              function = \'' . sqlite_escape_string($name) . '\' AND
              version = \'' . sqlite_escape_string($version) . '\'';
        return (bool) $this->database->singleQuery($sql);
    }

    /**
     * Get the URL to access a base resource.
     *
     * Hyperlinks in the returned xml will be used to retrieve the proper information
     * needed.  This allows extreme extensibility and flexibility in implementation
     * @param string Resource Type to retrieve
     */
    function getBaseURL($resourceType)
    {
        $sql = '
            SELECT baseurl FROM channel_server_rest WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\' AND
              type = \'' . sqlite_escape_string($resourceType) . '\'';
        return $this->database->singleQuery($sql);
    }

    /**
     * Empty all xmlrpc definitions
     */
    function resetXmlrpc()
    {
        $sql = '
            DELETE FROM channel_server_xmlrpc WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\'';
        return $this->database->queryExec($sql);
    }

    /**
     * Empty all SOAP definitions
     */
    function resetSOAP()
    {
        $sql = '
            DELETE FROM channel_server_soap WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\'';
        return $this->database->queryExec($sql);
    }

    /**
     * Empty all REST definitions
     */
    function resetREST()
    {
        $sql = '
            DELETE FROM channel_server_rest WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server=  \'' . sqlite_escape_string($this->mirror) . '\'';
        return $this->database->queryExec($sql);
    }

    function setName($name)
    {
        throw new PEAR2_Pyrus_ChannelRegistry_Exception(
            'Cannot change channel name of a registered channel');
    }

    function setPort($port)
    {
        $sql = '
            UPDATE channel_servers SET port=\'' . sqlite_escape_string($port) . '\'WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\'';
        return $this->database->queryExec($sql);
    }

    function setSSL($ssl = true)
    {
        $ssl = $ssl ? '1' : '0';
        $sql = '
            UPDATE channel_servers SET ssl=\'' . $ssl . '\'WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\'';
        return $this->database->queryExec($sql);
    }

    function setPath($protocol, $path)
    {
        if (!in_array($protocol, array('xmlrpc', 'soap'))) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unknown protocol: ' .
                $protocol);
        }

        $sql = '
            UPDATE channel_server_' . $protocol . '
            SET path = \'' . sqlite_escape_string($path) . '\'WHERE
              channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
              server = \'' . sqlite_escape_string($this->mirror) . '\'';
        return $this->database->queryExec($sql);
    }

    function addFunction($type, $version, $name)
    {
        if (!in_array($type, array('xmlrpc', 'soap'))) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unknown protocol: ' .
                $type);
        }

        $sql = '
            INSERT INTO channel_server_' . $type . '
             (channel, server, function, version)
             VALUES(\'' . sqlite_escape_string($this->channelname) . '\',
                    \'' . sqlite_escape_string($this->mirror) . '\',
                    \'' . sqlite_escape_string($name) . '\',
                    \'' . sqlite_escape_string($version) . '\'';
        if (!$this->database->queryExec($sql)) {
            $sql = '
                UPDATE channel_server_' . $type . '
                SET version = \'' . sqlite_escape_string($version) . '\' WHERE
                    channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
                    function = \'' . sqlite_escape_string($name) . '\' AND
                    server = \'' . sqlite_escape_string($this->mirror) . '\'';
            $this->database->queryExec($sql);
        }
    }

    function setBaseUrl($resourceType, $url)
    {
        $sql = '
            INSERT INTO channel_server_rest
             (channel, server, type, baseurl)
             VALUES(\'' . sqlite_escape_string($this->channelname) . '\',
                    \'' . sqlite_escape_string($this->mirror) . '\',
                    \'' . sqlite_escape_string($resourceType) . '\',
                    \'' . sqlite_escape_string($url) . '\'';
        if (!$this->database->queryExec($sql)) {
            $sql = '
                UPDATE channel_server_rest
                SET baseurl = \'' . sqlite_escape_string($url) . '\' WHERE
                    channel = \'' . sqlite_escape_string($this->channelname) . '\' AND
                    type = \'' . sqlite_escape_string($resourceType) . '\' AND
                    server = \'' . sqlite_escape_string($this->mirror) . '\'';
            $this->database->queryExec($sql);
        }
    }

    function getAlias()
    {
        $sql = 'SELECT alias FROM channels WHERE channel = \'' . sqlite_escape_string($this->channelname) . '\'';
        return $this->database->singleQuery($sql);
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Channel_Xml
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * A class that represents individual channels within an XML channel registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Channel_Xml extends PEAR2_Pyrus_Channel implements Countable
{
    private $_parent;
    function __construct(PEAR2_Pyrus_ChannelRegistry_Xml $parent, $data)
    {
        $this->_parent = $parent;
        parent::__construct($data);
    }

    public function toChannelObject()
    {
        $chan = new PEAR2_Pyrus_Channel((string) $this);
        return $chan;
    }

    function count()
    {
        $reg = new PEAR2_Pyrus_Registry($this->_parent->getPath());
        return count($reg->listPackages($this->_parent->name));
    }

    public function resetXmlrpc()
    {
        parent::resetXmlrpc();
        $this->_parent->update($this);
    }

    public function resetSOAP()
    {
        parent::resetSOAP();
        $this->_parent->update($this);
    }

    public function resetREST()
    {
        parent::resetREST();
        $this->_parent->update($this);
    }

    public function setName($name)
    {
        parent::setName($name);
        $this->_parent->update($this);
    }

    public function setPort($port)
    {
        parent::setPort($port);
        $this->_parent->update($this);
    }

    public function setSSL($ssl = true)
    {
        parent::setSSL($ssl);
        $this->_parent->update($this);
    }

    public function setPath($protocol, $path)
    {
        parent::setPath($protocol, $path);
        $this->_parent->update($this);
    }

    public function addFunction($type, $version, $name)
    {
        parent::addFunction($type, $version, $name);
        $this->_parent->update($this);
    }

    public function setBaseUrl($resourceType, $url)
    {
        parent::setBaseURL($resourceType, $url);
        $this->_parent->update($this);
    }

    public function setAlias($alias)
    {
        @unlink($this->_parent->getAliasFile($this->getAlias()));
        parent::setAlias($alias);
        file_put_contents($this->getAliasFile($alias), $this->getName());
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Exceptions with a Pyrus channel registry.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Exception extends PEAR2_Exception
{
}<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Mirror_Sqlite
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Represents a mirror within a Sqlite channel registry.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Mirror_Sqlite extends PEAR2_Pyrus_ChannelRegistry_Channel_Sqlite implements PEAR2_Pyrus_Channel_IMirror
{
    private $_channel;
    private $_parent;

    function __construct(SQLiteDatabase $db, $mirror, PEAR2_Pyrus_IChannel $parent)
    {
        if ($parent->getName() == '__uri') {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('__uri channel cannot have mirrors');
        }
        $this->_channel = $parent->getName();
        parent::__construct($db, $this->_channel);
        $this->mirror = $mirror;
        $this->_parent = $parent;
    }

    function getChannel()
    {
        return $this->_channel;
    }

    function toChannelObject()
    {
        return $parent;
    }

    /**
     * @return string|false
     */
    function getName()
    {
        return $this->mirror;
    }
}<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Mirror_Xml
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * A class for handling mirrors within an xml based channel registry.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Mirror_Xml extends PEAR2_Pyrus_Channel_Mirror
{
    private $_parent;
    function __construct(&$mirrorarray, PEAR2_Pyrus_IChannel $parent,
                         PEAR2_Pyrus_ChannelRegistry $reg)
    {
        parent::__construct($mirrorarray, $parent);
        $this->_parent = $reg;
    }

    public function toChannelObject()
    {
        $chan = new PEAR2_Pyrus_Channel((string) $this->parentChannel);
        return $chan;
    }

    public function resetXmlrpc()
    {
        parent::resetXmlrpc();
        $this->_parent->update($this->parentChannel);
    }

    public function resetSOAP()
    {
        parent::resetSOAP();
        $this->_parent->update($this->parentChannel);
    }

    public function resetREST()
    {
        parent::resetREST();
        $this->_parent->update($this->parentChannel);
    }

    public function setName($name)
    {
        parent::setName($name);
        $this->_parent->update($this->parentChannel);
    }

    public function setPort($port)
    {
        parent::setPort($port);
        $this->_parent->update($this->parentChannel);
    }

    public function setSSL($ssl = true)
    {
        parent::setSSL($ssl);
        $this->_parent->update($this->parentChannel);
    }

    public function setPath($protocol, $path)
    {
        parent::setPath($protocol, $path);
        $this->_parent->update($this->parentChannel);
    }

    public function addFunction($type, $version, $name)
    {
        parent::addFunction($type, $version, $name);
        $this->_parent->update($this->parentChannel);
    }

    public function setBaseUrl($resourceType, $url)
    {
        parent::setBaseURL($resourceType, $url);
        $this->_parent->update($this->parentChannel);
    }
}<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_ParseException
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Exceptions when parsing channel registry.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_ParseException extends PEAR2_Exception
{
    public $why;

    function __construct($message, $why)
    {
        $this->why = $why;
        parent::__construct($message);
    }
}<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Pear1
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Gregory Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/PEAR2/Pyrus
 */

/**
 * This is the central registry, that is used for all installer options,
 * stored in .reg files for PEAR 1 compatibility
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Gregory Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/PEAR2/Pyrus
 */
class PEAR2_Pyrus_ChannelRegistry_Pear1 extends PEAR2_Pyrus_ChannelRegistry_Base
{
    private $_path;
    private $_channelPath;
    private $_aliasPath;
    protected $readonly;
    function __construct($path, $readonly = false)
    {
        $this->readonly = $readonly;
        $this->_path = $path;
        $this->_channelPath = $path . DIRECTORY_SEPARATOR . '.channels';
        $this->_aliasPath = $path . DIRECTORY_SEPARATOR . '.alias';
        if (!file_exists($this->_channelPath) || !is_dir($this->_channelPath)) {
            if ($readonly) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot initialize ' .
                    'PEAR1 channel registry, directory does not exist and registry is read-only');
            }
            if (!@mkdir($this->_channelPath, 0755, true)) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot initialize ' .
                    'PEAR1 channel registry, channel directory could not be initialized');
            }
        }

        if (!file_exists($this->_aliasPath) || !is_dir($this->_aliasPath)) {
            if ($readonly) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot initialize ' .
                    'PEAR1 channel registry, aliasdirectory does not exist and registry is read-only');
            }
            if (!@mkdir($this->_aliasPath, 0755, true)) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot initialize ' .
                    'PEAR1 channel registry, channel aliasdirectory could not be initialized');
            }
        }
        if (!$this->readonly) {
            if (!$this->exists('pear.php.net')) {
                $this->initDefaultChannels();
            }
        }
    }

    private function _channelFileName($channel, $noaliases = false)
    {
        if (!$noaliases) {
            $c = $this->_channelAliasFileName($channel);
            if (file_exists($c)) {
                $channel = implode('', file($c));
            }
        }
        return $this->_path . DIRECTORY_SEPARATOR . str_replace('/', '_',
            strtolower($channel)) . '.reg';
    }

    private function _channelAliasFileName($alias)
    {
        return $this->_path . DIRECTORY_SEPARATOR . '.alias' .
              DIRECTORY_SEPARATOR . str_replace('/', '_', strtolower($alias)) . '.txt';
    }

    public function add(PEAR2_Pyrus_IChannel $channel, $update = false)
    {
        if (!is_writeable($path . DIRECTORY_SEPARATOR . '.channels')) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel ' .
                $channel->name . ', channel already exists, use update to change');
        }
        $channel->validate();
        if ($this->exists($channel->name)) {
            if (!$update) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel ' .
                    $channel->name . ', channel already exists, use update to change');
            }
            $checker = $this->get($channel->name);
            if ($channel->alias != $checker->alias) {
                if (file_exists($this->_channelAliasFileName($checker->alias))) {
                    @unlink($this->_channelAliasFileName($checker->alias));
                }
            }
        }
        if ($channel->alias != $channel->name) {
            if (file_exists($this->_channelAliasFileName($channel->alias)) &&
                  $this->_channelFromAlias($channel->alias) != $channel->name) {
                $channel->alias = $channel->name;
            }
            $fp = @fopen($this->_channelAliasFileName($channel->alias), 'w');
            if (!$fp) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add/update channel ' .
                    $channel->name . ', unable to open PEAR1 alias file');
            }
            fwrite($fp, $channel->name);
            fclose($fp);
        }
        $fp = @fopen($this->_channelFileName($channel->getName()), 'wb');
        if (!$fp) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add/update channel ' .
                $channel->name . ', unable to open PEAR1 channel registry file');
        }
        $info = (string) $channel->toChannelObject();
        $parser = new PEAR2_Pyrus_XMLParser;
        $info = $parser->parseString($info);
        $info = $info['channel'];
        if ($lastmodified) {
            $info['_lastmodified'] = $lastmodified;
        } else {
            $info['_lastmodified'] = date('r');
        }
        fwrite($fp, serialize($info));
        fclose($fp);
        return true;
    }

    public function update(PEAR2_Pyrus_IChannel $channel)
    {
        return $this->add($channel, true);
    }

    public function delete(PEAR2_Pyrus_IChannel $channel)
    {
        if (in_array($channel->name,
                     array('pear.php.net', 'pear2.php.net', 'pecl.php.net', '__uri'))){
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete default channel ' .
                $channel->name);
        }
        if (!$this->exists($channel->name)) {
            return true;
        }
        if (count($this->get($channel->name))) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete default channel ' .
                $channel->name . ', packages are installed');
        }
    }

    public function get($channel, $strict = true)
    {
        if (!$this->exists($channel, $strict)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Channel ' . $channel .
                ' does not exist');
        }
        $cont = file_get_contents($this->_channelFileName($channel, $strict));
        $a = @unserialize($cont);
        if (!$a || !is_array($a)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Channel ' . $channel .
                ' PEAR1 registry file is corrupt');
        }
        try {
            $chan = new PEAR2_Pyrus_ChannelFile_Channel_Pear1($a);
            return $chan;
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Channel ' . $channel .
                ' PEAR1 registry file is invalid channel information', $e);
        }
    }

    public function exists($channel, $strict = true)
    {
        $chan = $this->_channelFileName($channel);
        if (file_exists($chan)) {
            return true;
        }
        return false;
    }

    function listChannels()
    {
        $ret = array();
        foreach (new RegexIterator(new DirectoryIterator($this->_channelPath),
                                '/^(.+?)\.xml/', RegexIterator::GET_MATCH) as $file) {
            $ret[] = $this->get(str_replace('_', '/', $file));
        }
        return $ret;
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Sqlite
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * An implementation of a Pyrus channel registry using Sqlite as the storage
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Sqlite extends PEAR2_Pyrus_ChannelRegistry_Base
{
    /**
     * The database resource
     *
     * @var SQLiteDatabase
     */
    static protected $databases = array();
    protected $readonly;
    private $_path;

    /**
     * Initialize the registry
     *
     * @param unknown_type $path
     */
    function __construct($path, $readonly = false)
    {
        $this->readonly = $readonly;
        if ($path && $path != ':memory:') {
            if (dirname($path . '.pear2registry') != $path) {
                $path = $path . DIRECTORY_SEPARATOR . '.pear2registry';
            }
        }
        $this->_path = $path;
        $this->_init($path, $readonly);
    }

    public function getPath()
    {
        return $this->_path;
    }

    private function _init($path, $readonly)
    {
        if (isset(self::$databases[$path]) && self::$databases[$path]) {
            return;
        }
        $error = '';
        if (!$path) {
            $path = ':memory:';
        } elseif (!file_exists(dirname($path))) {
            if ($readonly) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot create SQLite registry, registry is read-only');
            }
            @mkdir(dirname($path), 0755, true);
        }

        if ($readonly && !file_exists($path)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot create SQLite registry, registry is read-only');
        }

        self::$databases[$path] = new SQLiteDatabase($path, 0666, $error);
        if (!self::$databases[$path]) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot open SQLite registry: ' . $error);
        }

        $sql = 'SELECT version FROM pearregistryversion';
        if (@self::$databases[$path]->singleQuery($sql) == '1.0.0') {
            $sql = 'SELECT COUNT(*) FROM channels';
            if (!self::$databases[$path]->singleQuery($sql)) {
                $this->initDefaultChannels();
                return;
            }
            return;
        }

        $a = new PEAR2_Pyrus_Registry_Sqlite_Creator;
        $a->create(self::$databases[$path]);
        $this->initDefaultChannels();
    }

    function exists($channel, $strict = true)
    {
        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite channel registry for ' . $this->_path);
        }

        $sql = 'SELECT channel FROM channels WHERE alias = "' . sqlite_escape_string($channel) . '"';
        if (!$strict && $a = self::$databases[$this->_path]->singleQuery($sql)) {
            return true;
        }

        $sql = 'SELECT channel FROM channels WHERE channel = "' . sqlite_escape_string($channel) . '"';
        if ($a = self::$databases[$this->_path]->singleQuery($sql)) {
            return true;
        }

        return false;
    }

    function add(PEAR2_Pyrus_IChannel $channel, $update = false)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel, registry is read-only');
        }

        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite channel registry for ' . $this->_path);
        }

        $sql = 'SELECT channel FROM channels WHERE channel = "' . $channel->getName() . '"';
        if (self::$databases[$this->_path]->singleQuery($sql)) {
            if (!$update) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' .
                    $channel->getName() . ' has already been discovered');
            }
        } elseif ($update) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' .
                $channel->getName() . ' is unknown');
        }

        $validate = $channel->getValidationPackage();
        self::$databases[$this->_path]->queryExec('BEGIN');
        $sql = '
            INSERT INTO channels
            (channel, summary, suggestedalias, alias, validatepackageversion,
            validatepackage, lastmodified)
            VALUES(
            "' . $channel->getName() . '",
            "' . sqlite_escape_string($channel->getSummary()) . '",
            "' . $channel->getAlias() . '",
            "' . $channel->getAlias() . '",
            "' . $validate['attribs']['version'] . '",
            "' . $validate['_content'] . '",
            \'' . sqlite_escape_string(serialize($channel->lastModified())) . '\'
            )';
        if (!@self::$databases[$this->_path]->queryExec($sql)) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: channel ' . $channel->getName() .
                ' could not be added to the registry');
        }

        $sql = '
            INSERT INTO channel_servers
            (channel, server, ssl, port, xmlrpcpath, soappath)
            VALUES(
            "' . $channel->getName() . '",
            "' . $channel->getName() . '",
            ' . ($channel->getSSL() ? 1 : '0') . ',
            ' . $channel->getPort() . ',
            "' . sqlite_escape_string($channel->getSummary('xmlrpc')) . '",
            "' . sqlite_escape_string($channel->getPath('soap')) . '"
            )';
        if (!@self::$databases[$this->_path]->queryExec($sql)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' . $channel->getName() .
                ' could not be added to the registry');
        }

        foreach (array('xmlrpc', 'soap', 'rest') as $protocol) {
            $functions = $channel->getFunctions($protocol);
            if (!$functions) {
                continue;
            }

            if (!is_array($functions)) {
                $functions = array($functions);
            }

            $attrib = $protocol == 'rest' ? 'type' : 'version';
            foreach ($functions as $function) {
                $sql = '
                    INSERT INTO channel_server_' . $protocol . '
                    (channel, server, ' . ($protocol == 'rest' ? 'baseurl' : 'function') .
                     ', ' . $attrib . ')
                    VALUES(
                    "' . $channel->getName() . '",
                    "' . $channel->getName() . '",
                    "' . $function['_content'] . '",
                    "' . $function['attribs'][$attrib] . '"
                    )';
                if (!@self::$databases[$this->_path]->queryExec($sql)) {
                    throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' . $channel->getName() .
                        ' could not be added to the registry');
                }
            }
        }

        $mirrors = $channel->mirrors;
        if (count($mirrors)) {
            foreach ($mirrors as $mirror) {
                $sql = '
                    INSERT INTO channel_servers
                    (channel, server, ssl, port, xmlrpcpath, soappath)
                    VALUES(
                    "' . $channel->getName() . '",
                    "' . $mirror->getName() . '",
                    ' . ($mirror->getSSL() ? 1 : '0') . ',
                    ' . $mirror->getPort() . ',
                    "' . sqlite_escape_string($mirror->getSummary('xmlrpc')) . '",
                    "' . sqlite_escape_string($mirror->getPath('soap')) . '"
                    )';
                if (!@self::$databases[$this->_path]->queryExec($sql)) {
                    throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' . $channel->getName() .
                        ' could not be added to the registry');
                }

                foreach (array('xmlrpc', 'soap', 'rest') as $protocol) {
                    $functions = $mirror->getFunctions($protocol);
                    if (!$functions) {
                        continue;
                    }

                    if (!isset($functions[0])) {
                        $functions = array($functions);
                    }

                    $attrib = $protocol == 'rest' ? 'type' : 'version';
                    foreach ($functions as $function) {
                        $sql = '
                            INSERT INTO channel_server_' . $protocol . '
                            (channel, server, ' . ($protocol == 'rest' ? 'baseurl' : 'function') .
                             ', ' . $attrib . ')
                            VALUES(
                            "' . $channel->getName() . '",
                            "' . $mirror->getName() . '",
                            "' . $function['_content'] . '",
                            "' . $function['attribs'][$attrib] . '"
                            )';
                        if (!@self::$databases[$this->_path]->queryExec($sql)) {
                            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' . $channel->getName() .
                                ' could not be added to the registry');
                        }
                    }
                }
            }
        }

        self::$databases[$this->_path]->queryExec('COMMIT');
    }

    function update(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot update channel, registry is read-only');
        }

        return $this->add($channel, true);
    }

    function get($channel, $strict = true)
    {
        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite channel registry for ' . $this->_path);
        }

        if (!$this->exists($channel, $strict)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unknown channel: ' . $channel);
        }

        return new PEAR2_Pyrus_ChannelRegistry_Channel_Sqlite(self::$databases[$this->_path], $channel);
    }

    function delete(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel, registry is read-only');
        }

        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite channel registry for ' . $this->_path);
        }

        $error = '';
        $sql = 'DELETE FROM channels WHERE channel="' . sqlite_escape_string($channel->getName()) . '"';
        if (!@self::$databases[$this->_path]->queryExec($sql, $error)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot delete channel ' .
                $channel->getName() . ': ' . $error);
        }
    }

    public function listChannels()
    {
        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite channel registry for ' . $this->_path);
        }

        $ret = array();
        $sql = 'SELECT channel FROM channel ORDER BY channel';
        foreach (self::$databases[$this->_path]->arrayQuery($sql, SQLITE_NUM) as $res) {
            $ret[] = $res[0];
        }
        return $ret;
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Xml
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * An implementation of a Pyrus channel registry within XML files.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Xml extends PEAR2_Pyrus_ChannelRegistry_Base
{
    protected $readonly;
    private $_path;

    /**
     * Initialize the registry
     *
     * @param string $path
     */
    function __construct($path, $readonly = false)
    {
        $this->readonly = $readonly;
        $this->_path = $path;
        if (!$this->readonly) {
            if (!$this->exists('pear.php.net')) {
                $this->initDefaultChannels();
            }
        }
    }

    public function getPath()
    {
        return $this->_path;
    }

    /**
     * Convert a name into a path-friendly name
     *
     * @param string $name
     */
    private function _mung($name)
    {
        return str_replace(array('/', '\\'), array('##', '###'), $name);
    }

    private function _unmung($name)
    {
        return str_replace(array('##', '###'), array('/', '\\'), $name);
    }

    protected function getChannelFile($channel)
    {
        if ($channel instanceof PEAR2_Pyrus_IChannel) {
            $channel = $channel->getName();
        }
        return $this->_path . DIRECTORY_SEPARATOR . 'channel-' .
            $this->_mung($channel) . '.xml';
    }

    protected function getAliasFile($alias)
    {
        return $this->_path . DIRECTORY_SEPARATOR . 'channelalias-' .
            $this->_mung($alias) . '.txt';
    }

    function exists($channel, $strict = true)
    {
        if (file_exists($this->getChannelFile($channel))) {
            return true;
        }
        if ($strict) {
            return false;
        }
        return file_exists($this->getAliasFile($channel));
    }

    function add(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel, registry is read-only');
        }
        $file = $this->getChannelFile($channel);
        if (@file_exists($file)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' .
                $channel->getName() . ' has already been discovered');
        }
        file_put_contents($file, (string) $channel);
        $alias = $channel->getAlias();
        file_put_contents($this->getAliasFile($alias), $channel->getName());
    }

    function update(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot update channel, registry is read-only');
        }
        $file = $this->getChannelFile($channel);
        if (!@file_exists($file)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' .
                $channel->getName() . ' is unknown');
        }
        file_put_contents($file, (string) $channel);
        $alias = $channel->getAlias();
        file_put_contents($this->getAliasFile($alias), $channel->getName());
    }

    function delete(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel, registry is read-only');
        }
        @unlink($this->getChannelFile($channel));
        @unlink($this->getAliasFile($channel->getAlias()));
    }

    function get($channel, $strict = true)
    {
        if ($this->exists($channel, $strict)) {
            $data = @file_get_contents($this->getChannelFile($channel));
            return new PEAR2_Pyrus_ChannelRegistry_Channel_Xml($this, $data);
        } else {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unknown channel: ' . $channel);
        }
    }

    function __get($value)
     {
         switch ($value) {
             case 'mirrors' :
                 if (!isset($this->_channelInfo['servers']['mirror'][0])) {
                     return array(new PEAR2_Pyrus_Channel_Mirror(
                                   $this->_channelInfo['servers']['mirror'], $this,
                                  $this->_parent));
                 }
                 $ret = array();
                 foreach ($this->_channelInfo['servers']['mirror'] as $i => $mir) {
                     $ret[$mir['attribs']['host']] = new PEAR2_Pyrus_Channel_Mirror(
                           $this->_channelInfo['servers']['mirror'][$i], $this,
                           $this->_parent);
                }
                return $ret;
        }
        if (method_exists($this, "get$value")) {
            $gv = "get$value";
            return $this->$gv();
        }
    }

    function __set($var, $value)
    {
        if (method_exists($this, "set$var")) {
            $sv = "set$var";
            $this->$sv($value);
        }
    }

    function listChannels()
    {
        $ret = array();
        foreach (new RegexIterator(new DirectoryIterator($this->_path),
                                '/channel-(.+?)\.xml/', RegexIterator::GET_MATCH) as $file) {
            $ret[] = $this->get($this->_unmung($file));
        }
        return $ret;
    }
}
<?php
/**
 * PEAR2_Pyrus_Config
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Pyrus's master configuration manager
 *
 * Unlike PEAR version 1.x, the new Pyrus configuration manager is tightly bound
 * to include_path, and will search through include_path for system configuration
 * Pyrus installations.
 *
 * The User configuration file will be looked for in these locations:
 *
 * Unix:
 *
 * - home directory
 * - current directory
 *
 * Windows:
 *
 * - local settings directory on windows for the current user.
 *   This is looked up directly in the windows registry using COM
 * - current directory
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Config
{
    /**
     * location of PEAR2 installation
     *
     * @var string
     */
    protected $pearDir;

    /**
     * location of user-specific configuration file
     *
     * @var string
     */
    protected $userFile;

    /**
     * registry for this {@link $pearDir} value
     *
     * @var PEAR2_Pyrus_Registry
     */
    protected $myregistry;

    /**
     * channel registry for this {@link $pearDir} value
     *
     * @var PEAR2_Pyrus_Channel_Registry
     */
    protected $mychannelRegistry;

    /**
     * configuration values for this configuration object
     *
     * @var string
     */
    protected $values;

    /**
     * mapping of path => PEAR2 configuration objects
     *
     * @var array
     */
    static protected $configs = array();

    /**
     * The last instantiated configuration
     *
     * @var PEAR2_Pyrus_Config
     */
    static protected $current;

    /**
     * Default values for custom configuration values set by custom file roles.
     * @var array
     */
    static protected $customDefaults = array();

    /**
     * Default values for configuration.
     *
     * @php_dir@ is automatically replaced with the current
     * PEAR2 configuration location
     * @var array
     */
    static protected $defaults =
        array(
            'php_dir' => '@php_dir@/src', // pseudo-value in this implementation
            'ext_dir' => '@php_dir@/ext_dir',
            'doc_dir' => '@php_dir@/docs',
            'bin_dir' => PHP_BINDIR,
            'data_dir' => '@php_dir@/data', // pseudo-value in this implementation
            'cfg_dir' => '@php_dir@/cfg',
            'www_dir' => '@php_dir@/www',
            'test_dir' => '@php_dir@/tests',
            'php_bin' => '',
            'php_ini' => '',
            'default_channel' => 'pear2.php.net',
            'preferred_mirror' => 'pear2.php.net',
            'auto_discover' => 0,
            'http_proxy' => '',
            'cache_dir' => '@php_dir@/cache',
            'temp_dir' => '@php_dir@/temp',
            'download_dir' => '@php_dir@/downloads',
            'username' => '',
            'password' => '',
            'verbose' => 1,
            'preferred_state' => 'stable',
            'umask' => '0022',
            'cache_ttl' => 3600,
            'sig_type' => '',
            'sig_bin' => '',
            'sig_keyid' => '',
            'sig_keydir' => '',
            'my_pear_path' => '@php_dir@',
        );

    /**
     * Mapping of user configuration file path => config values
     *
     * @var array
     */
    static protected $userConfigs = array();

    /**
     * Configuration variable names that are bound to the PEAR installation
     *
     * These are values that should not change for different users
     * @var array
     */
    static protected $pearConfigNames = array(
            'php_dir', // pseudo-value in this implementation
            'ext_dir',
            'cfg_dir',
            'doc_dir',
            'bin_dir',
            'data_dir', // pseudo-value in this implementation
            'www_dir',
            'test_dir',
            'php_bin',
            'php_ini',
        );

    /**
     * Custom configuration variable names that are bound to the PEAR installation
     *
     * These are values that should not change for different users, and are
     * set by custom file roles
     * @var array
     */
    static protected $customPearConfigNames = array();

    /**
     * Configuration variable names that are user-specific
     *
     * These are values that are user preferences rather than
     * information necessary for installation on the filesystem.
     * @var array
     */
    static protected $userConfigNames = array(
            'default_channel',
            'preferred_mirror',
            'auto_discover',
            'http_proxy',
            'cache_dir',
            'temp_dir',
            'download_dir',
            'username',
            'password',
            'verbose',
            'preferred_state',
            'umask',
            'cache_ttl',
            'sig_type',
            'sig_bin',
            'sig_keyid',
            'sig_keydir',
            'my_pear_path', // PATH_SEPARATOR-separated list of PEAR repositories to manage
        );
    /**
     * Configuration variable names that are user-specific
     *
     * These are values that are user preferences rather than
     * information necessary for installation on the filesystem, and
     * are set up by custom file roles
     * @var array
     */
    static protected $customUserConfigNames = array();

    /**
     * __get variables that cannot be used as custom config values
     * @var array
     */
    static protected $magicVars = array('registry',
                                        'channelregistry',
                                        'systemvars',
                                        'uservars',
                                        'mainsystemvars',
                                        'mainuservars',
                                        'userfile',
                                        'path');
    /**
     * Set up default configuration values that need to be determined at runtime
     *
     * The ext_dir variable, bin_dir variable, and php_ini are set up in
     * this method.
     */
    protected static function constructDefaults()
    {
        static $called = false;
        if ($called) {
            return;
        }

        $called = true;
        // set up default ext_dir
        if (getenv('PHP_PEAR_EXTENSION_DIR')) {
            self::$defaults['ext_dir'] = getenv('PHP_PEAR_EXTENSION_DIR');
            PEAR2_Pyrus_Log::log(5, 'used PHP_PEAR_EXTENSION_DIR environment variable');
        } elseif (ini_get('extension_dir')) {
            self::$defaults['ext_dir'] = ini_get('extension_dir');
            PEAR2_Pyrus_Log::log(5, 'used ini_get(extension_dir)');
        } elseif (defined('PEAR_EXTENSION_DIR')) {
            self::$defaults['ext_dir'] = PEAR_EXTENSION_DIR;
            PEAR2_Pyrus_Log::log(5, 'used PEAR_EXTENSION_DIR constant');
        }

        // set up default bin_dir
        if (getenv('PHP_PEAR_BIN_DIR')) {
            self::$defaults['bin_dir'] = getenv('PHP_PEAR_BIN_DIR');
            PEAR2_Pyrus_Log::log(5, 'used PHP_PEAR_BIN_DIR environment variable');
        } elseif (PATH_SEPARATOR == ';') {
            // we're on windows, and shouldn't use PHP_BINDIR
            do {
                if (!isset($_ENV) || !isset($_ENV['PATH'])) {
                    $path = getenv('PATH');
                } else {
                    $path = $_ENV['PATH'];
                }

                if (!$path) {
                    PEAR2_Pyrus_Log::log(5, 'used PHP_BINDIR on windows for bin_dir default');
                    break; // can't get PATH, so use PHP_BINDIR
                }

                $paths = explode(';', $path);
                foreach ($paths as $path) {
                    if ($path != '.' && is_writable($path)) {
                        // this place will do
                        PEAR2_Pyrus_Log::log(5, 'used ' . $path . ' for default bin_dir');
                        self::$defaults['bin_dir'] = $path;
                    }
                }
            } while (false);
        } else {
            PEAR2_Pyrus_Log::log(5, 'used PHP_BINDIR for bin_dir default');
        }

        foreach (self::$pearConfigNames as $name) {
            // make sure we've got valid paths for the underlying OS
            self::$defaults[$name] = str_replace('/', DIRECTORY_SEPARATOR,
                                                 self::$defaults[$name]);
        }

        foreach (self::$userConfigNames as $name) {
            // make sure we've got valid paths for the underlying OS
            self::$defaults[$name] = str_replace('/', DIRECTORY_SEPARATOR,
                                                 self::$defaults[$name]);
        }

        self::$defaults['php_ini'] = php_ini_loaded_file();
        if (self::$defaults['php_ini']) {
            PEAR2_Pyrus_Log::log(5, 'Used ' . self::$defaults['php_ini'] . ' for php.ini location');
        } else {
            PEAR2_Pyrus_Log::log(5, 'Could not find php.ini');
        }
    }

    /**
     * parse a configuration for a PEAR2 installation
     *
     * @param string $pearDirectory This can be either a single path, or a
     *                              PATH_SEPARATOR-separated list of directories
     * @param string $userfile
     */
    protected function __construct($pearDirectory = false, $userfile = false)
    {
        self::constructDefaults();
        if ($pearDirectory) {
            $pearDirectory = str_replace('\\', '/', $pearDirectory);
            $pearDirectory = str_replace('//', '/', $pearDirectory);
            $pearDirectory = str_replace('/', DIRECTORY_SEPARATOR, $pearDirectory);
        }

        $this->loadUserSettings($pearDirectory, $userfile);
        $this->loadConfigFile($pearDirectory);
        self::$configs[$pearDirectory] = $this;
        $this->pearDir = $pearDirectory;

        // Always set the current config to the most recently created one.
        self::$current = $this;
    }

    /**
     * Retrieve configuration for a PEAR2 installation
     *
     * @param string $pearDirectory
     * @param string $userfile
     * @return PEAR2_Pyrus_Config
     */
    static public function singleton($pearDirectory = false, $userfile = false)
    {
        if (isset(self::$configs[$pearDirectory])) {
            return self::$configs[$pearDirectory];
        }

        self::$configs[$pearDirectory] = new PEAR2_Pyrus_Config($pearDirectory, $userfile);
        return self::$configs[$pearDirectory];
    }

    /**
     * set the path to scan for pyrus installations
     */
    public function setCascadingRegistries($path)
    {
        $paths = explode(PATH_SEPARATOR, $path);
        $ret = $paths[0];
        if (count($paths) == 1) {
            // add registries within include_path by default
            // if explicit path is specified, user knows what they
            // are doing, don't add include_path
            PEAR2_Pyrus_Log::log(1, 'Automatically cascading include_path');
            $extra = explode(PATH_SEPARATOR, get_include_path());
            foreach ($extra as &$path) {
                if (substr($path, strlen($path) - 3) == 'src' && $path[strlen($path) - 4] == DIRECTORY_SEPARATOR) {
                    // include_path goes to the php_dir which is always src, so our config
                    // file is in the parent directory.
                    $path = dirname($path);
                }
            }
            array_unshift($extra, $ret);
            $paths = $extra;
        }

        $paths = array_unique($paths);
        $start = true;
        foreach ($paths as $path) {
            try {
                if ($path === '.') continue;
                $a = PEAR2_Pyrus_Registry::$className;
                $reg = new $a($path, array('Sqlite', 'Xml'), !$start);

                if ($start) {
                    $this->myregistry = $reg;
                }

                $reg->setParent(); // clear any previous parent
                $b = PEAR2_Pyrus_ChannelRegistry::$className;
                $regc = new $b($path, array('Sqlite', 'Xml'), !$start);
                if ($start) {
                    $this->mychannelRegistry = $regc;
                }

                $start = false;
                $regc->setParent(); // clear any previous parent
                if (isset($last)) {
                    $last->setParent($reg);
                    $lastc->setParent($regc);
                }

                $last = $reg;
                $lastc = $regc;
            } catch (Exception $e) {
                if ($start) {
                    throw new PEAR2_Pyrus_Config_Exception(
                        'Cannot initialize primary registry in path ' .
                        $path, $e);
                } else {
                    // silently skip this registry
                    continue;
                }
            }
        }
        return $ret;
    }

    /**
     * Retrieve the currently active primary configuration
     * @return PEAR2_Pyrus_Config
     */
    static public function current()
    {
        if (isset(self::$current)) {
            return self::$current;
        }
        // default
        return PEAR2_Pyrus_Config::singleton();
    }

    /**
     * determines where user-specific configuration files should be saved.
     *
     * On unix, this is ~user/ or a location in /tmp based on the current directory.
     * On windows, this is your Documents and Settings folder.
     * @return string
     */
    protected function locateLocalSettingsDirectory()
    {
        if (class_exists('COM', false)) {
            $shell = new COM('Wscript.Shell');
            $value = $shell->SpecialFolders('MyDocuments');
            return $value;
        }

        if (isset($_ENV['HOME'])) {
            return $_ENV['HOME'];
        } elseif ($e = getenv('HOME')) {
            return $e;
        }

        return '/tmp/' . md5($_ENV['PWD']);
    }

    /**
     * Load the user configuration file
     *
     * This loads exclusively the user config
     */
    protected function loadUserSettings($pearDirectory, $userfile = false)
    {
        if (!$userfile) {
            if (class_exists('COM', false)) {
                $userfile = $this->locateLocalSettingsDirectory() . DIRECTORY_SEPARATOR .
                    'pear' . DIRECTORY_SEPARATOR . 'pearconfig.xml';
            } else {
                $userfile = $this->locateLocalSettingsDirectory() . DIRECTORY_SEPARATOR .
                    '.pear' . DIRECTORY_SEPARATOR . 'pearconfig.xml';
            }

            if (!file_exists($userfile)) {
                $test = realpath(getcwd() . DIRECTORY_SEPARATOR . 'pearconfig.xml');
                if ($test && file_exists($test)) {
                    PEAR2_Pyrus_Log::log(5, 'Found user configuration file in current directory' .
                        $userfile);
                    $userfile = $test;
                }
            } else {
                PEAR2_Pyrus_Log::log(5, 'Found default user configuration file ' .
                    $userfile);
            }
        } else {
            PEAR2_Pyrus_Log::log(5, 'Using explicit user configuration file ' . $userfile);
        }

        $this->userFile = $userfile;
        if (!$userfile || !file_exists($userfile)) {
            PEAR2_Pyrus_Log::log(5, 'User configuration file ' . $userfile . ' not found');
            return;
        }

        if (isset(self::$userConfigs[$userfile])) {
            return;
        }

        libxml_use_internal_errors(true);
        libxml_clear_errors();
        $x = simplexml_load_file($userfile);
        if (!$x) {
            $errors = libxml_get_errors();
            $e = new PEAR2_MultiErrors;
            foreach ($errors as $err) {
                $e->E_ERROR[] = new PEAR2_Pyrus_Config_Exception(trim($err->message));
            }
            libxml_clear_errors();
            throw new PEAR2_Pyrus_Config_Exception(
                'Unable to parse invalid user PEAR configuration at "' . $userfile . '"',
                $e);
        }

        $unsetvalues = array_diff(array_keys((array) $x), array_merge(self::$userConfigNames, self::$customUserConfigNames));
        // remove values that are not recognized user config variables
        foreach ($unsetvalues as $value) {
            if ($value == '@attributes') {
                continue;
            }
            PEAR2_Pyrus_Log::log(5, 'Removing unrecognized user configuration value ' .
                $value);
            unset($x->$value);
        }

        if (!$x->my_pear_path) {
            if (!$pearDirectory) {
                $pearDirectory = getcwd();
            }
            $pearDirectory = $this->setCascadingRegistries((string)$pearDirectory);
            $x->my_pear_path = $pearDirectory;
            PEAR2_Pyrus_Log::log(5, 'Assuming my_pear_path is ' . $pearDirectory);
        } else {
            if (!$pearDirectory) {
                $pearDirectory = $this->setCascadingRegistries((string) $x->my_pear_path);
            } else {
                // ensure that $pearDirectory is a part of this cascading directory path
                $pearDirectory = $this->setCascadingRegistries((string)$pearDirectory .
                        PATH_SEPARATOR . $x->my_pear_path);
            }
        }

        self::$userConfigs[$userfile] = (array) $x;
        return $pearDirectory;
    }

    /**
     * Extract configuration from system + user configuration files
     *
     * Configuration is stored in XML format, in two locations.
     *
     * The system configuration contains all of the important directory
     * configuration variables like data_dir, and the location of php.ini and
     * the php executable php.exe or php.  This configuration is tightly bound
     * to the repository, and cannot be moved.  As such, php_dir is auto-defined
     * as dirname(/path/to/pear/.config), or /path/to/pear.
     *
     * Only 1 user configuration file is allowed, and contains user-specific
     * settings, including the locations where to download package releases
     * and where to cache files downloaded from the internet.  If false is passed
     * in, PEAR2_Pyrus_Config will attempt to guess at the config file location as
     * documented in the class docblock {@link PEAR2_Pyrus_Config}.
     * @param string $pearDirectory
     * @param string|false $userfile
     */
    protected function loadConfigFile($pearDirectory)
    {
        if (isset(self::$configs[$pearDirectory]) ||
              !file_exists($pearDirectory . DIRECTORY_SEPARATOR . '.config')) {
            PEAR2_Pyrus_Log::log(5, 'Configuration not found for ' . $pearDirectory .
                ', assuming defaults');
            return;
        }

        PEAR2_Pyrus_Log::log(5, 'Loading configuration for ' . $pearDirectory);
        libxml_use_internal_errors(true);
        libxml_clear_errors();
        $x = simplexml_load_file($pearDirectory . DIRECTORY_SEPARATOR . '.config');
        if (!$x) {
            $errors = libxml_get_errors();
            $e = new PEAR2_MultiErrors;
            foreach ($errors as $err) {
                $e->E_ERROR[] = new PEAR2_Pyrus_Config_Exception(trim($err->message));
            }
            libxml_clear_errors();
            throw new PEAR2_Pyrus_Config_Exception(
                'Unable to parse invalid PEAR configuration at "' . $pearDirectory . '"',
                $e);
        }

        $unsetvalues = array_diff(array_keys((array) $x), array_merge(self::$pearConfigNames, self::$customPearConfigNames));
        // remove values that are not recognized system config variables
        foreach ($unsetvalues as $value) {
            if ($value == '@attributes') {
                continue;
            }

            if ($value === 'php_dir' || $value === 'data_dir') {
                unset($x->$value); // both of these are abstract
            }

            PEAR2_Pyrus_Log::log(5, 'Removing unrecognized configuration value ' .
                $value);
            unset($x->$value);
        }
        $this->values = (array) $x;
    }

    /**
     * Save both the user configuration file and the system file
     *
     * If the userfile is not passed in, it is saved in the default
     * location which is either in ~/.pear/pearconfig.xml or on Windows
     * in the Documents and Settings directory
     * @param string $userfile path to alternate user configuration file
     */
    function saveConfig($userfile = false)
    {
        if (!$userfile) {
            if ($this->userFile) {
                $userfile = $this->userFile;
            } else {
                // FIXME any reason why we don't name it .pear on windows ?
                $pear = class_exists('COM', false) ? 'pear' : '.pear';
                $userfile = $this->locateLocalSettingsDirectory() . DIRECTORY_SEPARATOR .
                        $pear . DIRECTORY_SEPARATOR . 'pearconfig.xml';
            }
        }

        $userfile = str_replace('\\', '/', $userfile);
        $userfile = str_replace('//', '/', $userfile);
        $userfile = str_replace('/', DIRECTORY_SEPARATOR, $userfile);
        $test     = $userfile;
        while ($test && !file_exists($test)) {
            $test = dirname($test);
        }

        if (!is_writable($test)) {
            throw new PEAR2_Pyrus_Config_Exception('Cannot save configuration, no' .
                ' filesystem permissions to modify user configuration file ' . $userfile);
        }

        $test = $this->pearDir . '.config';
        while ($test && !file_exists($test)) {
            $test = dirname($test);
        }

        if (!is_writable($test)) {
            throw new PEAR2_Pyrus_Config_Exception('Cannot save configuration, no' .
                ' filesystem permissions to modify PEAR directory ' . $this->pearDir . '.config');
        }

        $x = simplexml_load_string('<pearconfig version="1.0"></pearconfig>');
        foreach (self::$userConfigNames as $var) {
            $x->$var = (string) $this->$var;
        }

        foreach (self::$customUserConfigNames as $var) {
            $x->$var = (string) $this->$var;
        }

        $userfiledir = dirname($userfile);
        if (!file_exists($userfiledir) && !@mkdir($userfiledir, 0777, true)) {
            throw new PEAR2_Pyrus_Config_Exception(
                'Unable to create directory ' . $userfiledir . ' to save ' .
                'user configuration ' . $userfile);
        }
        file_put_contents($userfile, $x->asXML());

        $system = $this->pearDir . '.config';
        if (dirname($system) != $this->pearDir) {
            $system = $this->pearDir . DIRECTORY_SEPARATOR . '.config';
        }

        if (!file_exists(dirname($system)) && !@mkdir(dirname($system), 0777, true)) {
            throw new PEAR2_Pyrus_Config_Exception(
                'Unable to create directory ' . dirname($system) . ' to save ' .
                'system configuration ' . $system);
        }

        $x = simplexml_load_string('<pearconfig version="1.0"></pearconfig>');
        $path = dirname($system) . DIRECTORY_SEPARATOR;
        foreach (self::$pearConfigNames as $var) {
            if ($var === 'php_dir' || $var === 'data_dir') {
                continue; // both of these are abstract
            }
            $x->$var = $this->$var;
            file_put_contents($path . $var . '.txt', $this->$var);
        }

        foreach (self::$customPearConfigNames as $var) {
            $x->$var = $this->$var;
            file_put_contents($path . $var . '.txt', $this->$var);
        }
        file_put_contents($system, $x->asXML());
    }

    /**
     * Save a snapshot of the current config, and return the file name
     *
     * If the latest snapshot is the same as the existing configuration,
     * simply return the filename
     * @return string basename of the snapshot file of the current configuration
     */
    static public function configSnapshot()
    {
        $conf = self::current();
        $snapshotdir = $conf->pearDir . DIRECTORY_SEPARATOR . '.configsnapshots';
        if (!file_exists($snapshotdir)) {
            // this will be simple - no snapshots exist yet
            if (!@mkdir($snapshotdir, 0755, true)) {
                throw new PEAR2_Pyrus_Config_Exception(
                    'Unable to create directory ' . $snapshotdir . ' to save ' .
                    'system configuration snapshots');
            }

            $snapshot = 'configsnapshot-' . date('Y-m-d H:i:s') . '.xml';
            $x = simplexml_load_string('<pearconfig version="1.0"></pearconfig>');
            foreach (self::$pearConfigNames as $var) {
                $x->$var = $conf->$var;
            }

            foreach (self::$customPearConfigNames as $var) {
                $x->$var = $conf->$var;
            }

            PEAR2_Pyrus_Log::log(5, 'Saving configuration snapshot ' . $snapshot);
            file_put_contents($snapshotdir . DIRECTORY_SEPARATOR . $snapshot, $x->asXML());
            return $snapshot;
        }
        // scan existing snapshots, if any, for a match
        $dir = opendir($snapshotdir);
        while (false !== ($snapshot = readdir($dir))) {
            if ($snapshot[0] == '.') continue;
            $x = simplexml_load_file($snapshotdir . DIRECTORY_SEPARATOR . $snapshot);
            foreach (self::$pearConfigNames as $var) {
                if ($x->$var != $conf->$var) continue 2;
            }

            foreach (self::$customPearConfigNames as $var) {
                if (!isset($x->var) || $x->$var != $conf->$var) continue 2;
            }

            // found a match
            PEAR2_Pyrus_Log::log(5, 'Found matching configuration snapshot ' . $snapshot);
            return $snapshot;
        }
        PEAR2_Pyrus_Log::log(5, 'No matching configuration snapshot found');
        // no matches found
        $snapshot = 'configsnapshot-' . date('Y-m-d H:i:s') . '.xml';
        // save the snapshot
        $x = simplexml_load_string('<pearconfig version="1.0"></pearconfig>');
        foreach (self::$pearConfigNames as $var) {
            $x->$var = $conf->$var;
        }

        foreach (self::$customPearConfigNames as $var) {
            $x->$var = $conf->$var;
        }

        PEAR2_Pyrus_Log::log(5, 'Saving configuration snapshot ' . $snapshot);
        file_put_contents($snapshotdir . DIRECTORY_SEPARATOR . $snapshot, $x->asXML());
        return $snapshot;
    }

    /**
     * Load a configuration
     */
    static public function addConfigValue($key, $default, $system = true)
    {
        if (in_array($key, self::$magicVars, true)) {
            throw new PEAR2_Pyrus_Config_Exception('Invalid custom configuration variable, already in use for retrieving configuration information');
        }

        if (!preg_match('/^[a-z0-9-_]+\\z/', $key)) {
            throw new PEAR2_Pyrus_Config_Exception('Invalid custom configuration variable name "'.  $key . '"');
        }

        if ($system) {
            if (isset(self::$pearConfigNames[$key])) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing configuration value "' . $key . '"');
            }

            if (isset(self::$customPearConfigNames[$key])) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing custom configuration value "' . $key . '"');
            }

            if (isset(self::$userConfigNames[$key])) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing user configuration value "' . $key . '" with system value');
            }

            if (isset(self::$customUserConfigNames[$key])) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing custom user configuration value "' . $key . '" with system value');
            }
            $var = 'customPearConfigNames';
        } else {
            if (isset(self::$userConfigNames[$key])) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing configuration value "' . $key . '"');
            }

            if (isset(self::$customUserConfigNames[$key])) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing custom configuration value "' . $key . '"');
            }

            if (isset(self::$pearConfigNames[$key])) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing configuration value "' . $key . '" with user value');
            }

            if (isset(self::$customPearConfigNames[$key])) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing custom configuration value "' . $key . '" with user value');
            }
            $var = 'customUserConfigNames';
        }
        self::${$var}[count(self::${$var})] = $key;
        self::$customDefaults[$key] = $default;
    }

    public function __get($key)
    {
        if (in_array($key, array_merge(self::$pearConfigNames, self::$userConfigNames,
                                          self::$customPearConfigNames,
                                          self::$customUserConfigNames))) {
            if ((!isset(self::$userConfigs[$this->userFile][$key])
                && !isset($this->values[$key])) || $key === 'php_dir'
                || $key === 'data_dir'
            ) {
                if (isset(self::$defaults[$key])) {
                    PEAR2_Pyrus_Log::log(5, 'Replacing @php_dir@ for config variable ' .
                                         $key .
                        ' default value "' . self::$defaults[$key] . '"');
                    return str_replace('@php_dir@', $this->pearDir, self::$defaults[$key]);
                } else {
                    PEAR2_Pyrus_Log::log(5, 'Replacing @php_dir@ for config variable ' .
                                         $key .
                        ' default value "' . self::$customDefaults[$key] . '"');
                    return str_replace('@php_dir@', $this->pearDir,
                                       self::$customDefaults[$key]);
                }
            }

            if (in_array($key, array_merge(self::$pearConfigNames,
                                             self::$customPearConfigNames))) {
                PEAR2_Pyrus_Log::log(5, 'Replacing @php_dir@ for config variable ' . $key .
                    ' value "' . $this->values[$key] . '"');
                return str_replace('@php_dir@', $this->pearDir,
                    $this->values[$key]);
            }

            return self::$userConfigs[$this->userFile][$key];
        }

        if ($key == 'registry') {
            return $this->myregistry;
        }

        if ($key == 'channelregistry') {
            return $this->mychannelRegistry;
        }

        if ($key == 'systemvars') {
            return array_merge(self::$pearConfigNames, self::$customPearConfigNames);
        }

        if ($key == 'uservars') {
            return array_merge(self::$userConfigNames, self::$customUserConfigNames);
        }

        if ($key == 'mainsystemvars') {
            return self::$pearConfigNames;
        }

        if ($key == 'mainuservars') {
            return self::$userConfigNames;
        }

        if ($key == 'userfile') {
            return $this->userFile;
        }

        if ($key == 'path') {
            return $this->pearDir;
        }

        if ($key == 'customsystemvars') {
            return self::$customPearConfigNames;
        }

        if ($key == 'customuservars') {
            return self::$customUserConfigNames;
        }

        throw new PEAR2_Pyrus_Config_Exception(
            'Unknown configuration variable "' . $key . '" in location ' .
            $this->pearDir);
    }

    public function __unset($key)
    {
        if (in_array($key, self::$magicVars, true)) {
            throw new PEAR2_Pyrus_Config_Exception('Cannot unset magic value ' . $key);
        }

        if ($key === 'php_dir' || $key === 'data_dir') {
            throw new PEAR2_Pyrus_Config_Exception('Cannot unset ' . $key);
        }

        if (isset($this->values[$key])) {
            unset($this->values[$key]);
            return;
        }

        if (isset(self::$userConfigs[$this->userFile][$key])) {
            unset(self::$userConfigs[$this->userFile][$key]);
        }
    }

    public function __isset($key)
    {
        if (in_array($key, self::$magicVars, true)) {
            return true;
        }

        if ($key === 'php_dir' || $key === 'data_dir') {
            return true;
        }

        if (in_array($key, self::$pearConfigNames)
            || in_array($key, self::$customPearConfigNames)) {
            return isset($this->values[$key]);
        }

        return isset(self::$userConfigs[$this->userFile][$key]);
    }

    public function __set($key, $value)
    {
        if (in_array($key, self::$magicVars, true)) {
            throw new PEAR2_Pyrus_Config_Exception('Cannot set magic configuration variable ' . $key);
        }

        if ($key == 'php_dir' || $key == 'data_dir') {
            throw new PEAR2_Pyrus_Config_Exception('Cannot set php_dir, move the repository');
        }

        if (!isset(self::$defaults[$key]) && !isset(self::$customDefaults[$key])) {
            throw new PEAR2_Pyrus_Config_Exception(
                'Unknown configuration variable "' . $key . '" in location ' .
                $this->pearDir);
        }

        if (in_array($key, self::$pearConfigNames)
            || in_array($key, self::$customPearConfigNames)) {
            $this->values[$key] = $value;
        }

        self::$userConfigs[$this->userFile][$key] = $value;
    }

    /**
     * Parse a string to determine which package file is requested
     *
     * This differentiates between the three kinds of packages:
     *
     *  - local files
     *  - remote static URLs
     *  - dynamic abstract package names
     * @param string $pname
     * @return string|array A string is returned if this is a file, otherwise an array
     *                      containing information is returned
     */
    static public function parsePackageName($pname, $assumeabstract = false)
    {
        if (!$assumeabstract && @file_exists($pname) && @is_file($pname)) {
            return $pname;
        }
        return self::current()->channelregistry->parseName($pname);
    }

    static public function parsedPackageNameToString($name)
    {
        return self::current()->channelregistry->parsedNameToString($name);
    }
}
<?php
/**
 * PEAR2_Pyrus_Config_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus configuration
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Config_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Config
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Pyrus's master configuration manager
 *
 * Unlike PEAR version 1.x, the new Pyrus configuration manager is tightly bound
 * to include_path, and will search through include_path for system configuration
 * Pyrus installations.
 *
 * The User configuration file will be looked for in these locations:
 *
 * Unix:
 *
 * - home directory
 * - current directory
 *
 * Windows:
 *
 * - local settings directory on windows for the current user.
 *   This is looked up directly in the windows registry using COM
 * - current directory
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Config_Snapshot extends PEAR2_Pyrus_Config
{
    /**
     * parse a configuration for a PEAR2 installation
     *
     * @param string $pearDirectory This can be either a single path, or a
     *                              PATH_SEPARATOR-separated list of directories
     * @param string $userfile
     */
    public function __construct($snapshot, PEAR2_Pyrus_Config $config = null)
    {
        self::constructDefaults();
        if (!$config) {
            $config = PEAR2_Pyrus_Config::current();
        }
        $this->loadConfigFile($config, $snapshot);
        $this->pearDir = $pearDirectory;
    }

    /**
     * Extract configuration from system + user configuration files
     *
     * Configuration is stored in XML format, in two locations.
     *
     * The system configuration contains all of the important directory
     * configuration variables like data_dir, and the location of php.ini and
     * the php executable php.exe or php.  This configuration is tightly bound
     * to the repository, and cannot be moved.  As such, php_dir is auto-defined
     * as dirname(/path/to/pear/.config), or /path/to/pear.
     *
     * Only 1 user configuration file is allowed, and contains user-specific
     * settings, including the locations where to download package releases
     * and where to cache files downloaded from the internet.  If false is passed
     * in, PEAR2_Pyrus_Config will attempt to guess at the config file location as
     * documented in the class docblock {@link PEAR2_Pyrus_Config}.
     * @param string $pearDirectory
     * @param string|false $userfile
     */
    protected function loadConfigFile($pearDirectory, $snapshot)
    {
        if (isset(self::$configs[$pearDirectory]) ||
              !file_exists($pearDirectory . DIRECTORY_SEPARATOR . '.config')) {
            throw new PEAR2_Pyrus_Config_Exception('Cannot retrieve config snapshot ' .
                                                   $snapshot . ' from non-existent ' .
                                                   'configuration ' . $pearDirectory);
        }
        $snapshotdir = $pearDirectory . DIRECTORY_SEPARATOR . '.configsnapshots';
        $snapshot = $snapshotdir . DIRECTORY_SEPARATOR . $snapshot;
        if (!file_exists($snapshot)) {
            if (preg_match('/^\\d{4}\\-\\d{2}\\-\\d{2} \\d{2}:\\d{2}:\\d{2}$/', $snapshot)) {
                // passed a date, locate a matching snapshot
                $us = new DateTime($snapshot);
                $dir = new RegexIterator(
                    new RecursiveDirectoryIterator($snapshotdir), '/\\d{4}\\-\\d{2}\\-\\d{2} \\d{2}:\\d{2}:\\d{2}/',
                    RegexIterator::MATCH,
                    RegexIterator::USE_KEY);
                foreach ($dir as $match) {
                    $matches[] = $match;
                }
                usort($matches, array(self, 'datediff'));
                unset($match);
                foreach ($matches as $match) {
                    $diff = $us->diff(new DateTime($match))->format("%r%s");
                    if (!$diff) {
                        // found a snapshot match
                        break;
                    }
                    if (!isset($last)) {
                        if ($diff > 0) {
                            // oldest snapshot is newer than us, resort to default config
                            return parent::loadConfigFile($pearDirectory);
                        }
                        $last = $match;
                        continue;
                    }

                    if ($diff < 0) {
                        $last = $match;
                        continue;
                    }
                    // the current snapshot is newer than our install
                    // the last snapshot was the one we used
                    $match = $last;
                    break;
                }
                if (!isset($match)) {
                    // no config snapshots
                    return parent::loadConfigFile($pearDirectory);
                }
                $snapshot = $snapshotdir . DIRECTORY_SEPARATOR . 'configsnapshot-' .
                    $match . '.xml';
            }
            if (!file_exists($snapshot)) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot retrieve non-existent config ' .
                                                   'snapshot ' . $snapshot);
            }
        }

        PEAR2_Pyrus_Log::log(5, 'Loading configuration snapshot ' .
                             $snapshot . ' for ' . $pearDirectory);

        libxml_use_internal_errors(true);
        libxml_clear_errors();
        $x = simplexml_load_file($snapshot);
        if (!$x) {
            $errors = libxml_get_errors();
            $e = new PEAR2_MultiErrors;
            foreach ($errors as $err) {
                $e->E_ERROR[] = new PEAR2_Pyrus_Config_Exception(trim($err->message));
            }
            libxml_clear_errors();
            throw new PEAR2_Pyrus_Config_Exception(
                'Unable to parse invalid PEAR configuration snapshot at "' .
                $pearDirectory . '"', $e);
        }
        $unsetvalues = array_diff(array_keys((array) $x),
                array_merge(self::$pearConfigNames, self::$customPearConfigNames));
        // remove values that are not recognized system config variables
        foreach ($unsetvalues as $value)
        {
            if ($value == '@attributes') {
                continue;
            }
            if ($value === 'php_dir' || $value === 'data_dir') {
                unset($x->$value); // both of these are abstract
            }
            PEAR2_Pyrus_Log::log(5, 'Removing unrecognized configuration value ' .
                $value);
            unset($x->$value);
        }
        $this->values = (array) $x;
    }

    function datediff($a, $b)
    {
        $us = new DateTime($a);
        $diff = $us->diff(new DateTime($match))->format("%r%s");
        if (!$diff) return 0;
        if ($diff > 0) return 1;
        return -1;
    }

    /**
     * Save both the user configuration file and the system file
     *
     * If the userfile is not passed in, it is saved in the default
     * location which is either in ~/.pear/pearconfig.xml or on Windows
     * in the Documents and Settings directory
     * @param string $userfile path to alternate user configuration file
     */
    function saveConfig($userfile = false)
    {
    }

    /**
     * Save a snapshot of the current config, and return the file name
     *
     * If the latest snapshot is the same as the existing configuration,
     * simply return the filename
     * @return string basename of the snapshot file of the current configuration
     */
    static public function configSnapshot()
    {
    }
}
<?php
/**
 * PEAR2_Pyrus_Dependency_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for dependencies
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Dependency_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Dependency_Validator, advanced dependency validation
 *
 * PHP versions 4 and 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Dependency check for PEAR packages
 *
 * This class handles both version 1.0 and 2.0 dependencies
 * WARNING: *any* changes to this class must be duplicated in the
 * test_PEAR_Dependency2 class found in tests/PEAR_Dependency2/setup.php.inc,
 * or unit tests will not actually validate the changes
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Dependency_Validator
{
    /**
     * @var PEAR2_MultiErrors
     */
    protected $errs;
    /**
     * One of the PEAR2_Pyrus_Validate::* states
     * @see PEAR2_Pyrus_Validate::NORMAL
     * @var integer
     */
    var $_state;
    /**
     * Command-line options to install/upgrade/uninstall commands
     * @param array
     */
    var $_options;
    /**
     * @var PEAR2_Pyrus_OSGuess
     */
    var $_os;
    /**
     * @var PEAR2_Pyrus_Registry
     */
    protected $registry;
    /**
     * @var PEAR2_Pyrus_Config
     */
    var $_config;
    /**
     * Package to validate
     * @var PEAR2_Pyrus_Package
     */
    var $_currentPackage;
    /**
     * @param PEAR2_Pyrus_Package
     * @param int installation state (one of PEAR2_Pyrus_Validate::*)
     * @param PEAR2_MultiErrors
     */
    function __construct($package, $state = PEAR2_Pyrus_Validate::INSTALLING,
                         PEAR2_MultiErrors $errs)
    {
        $this->_config = PEAR2_Pyrus_Config::current();
        $this->registry = $this->_config->registry;
        $this->_options = PEAR2_Pyrus_Installer::$options;
        $this->_state = $state;
        $this->_os = new PEAR2_Pyrus_OSGuess;
        $this->_currentPackage = $package;
        $this->errs = $errs;
    }

    function _getExtraString($dep)
    {
        $extra = ' (';
        if (isset($dep['uri'])) {
            return '';
        }
        if (isset($dep['recommended'])) {
            $extra .= 'recommended version ' . $dep['recommended'];
        } else {
            if (isset($dep['min'])) {
                $extra .= 'version >= ' . $dep['min'];
            }
            if (isset($dep['max'])) {
                if ($extra != ' (') {
                    $extra .= ', ';
                }
                $extra .= 'version <= ' . $dep['max'];
            }
            if (isset($dep['exclude'])) {
                if (!is_array($dep['exclude'])) {
                    $dep['exclude'] = array($dep['exclude']);
                }
                if ($extra != ' (') {
                    $extra .= ', ';
                }
                $extra .= 'excluded versions: ';
                foreach ($dep['exclude'] as $i => $exclude) {
                    if ($i) {
                        $extra .= ', ';
                    }
                    $extra .= $exclude;
                }
            }
        }
        $extra .= ')';
        if ($extra == ' ()') {
            $extra = '';
        }
        return $extra;
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function getPHP_OS()
    {
        return PHP_OS;
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function getsysname()
    {
        return $this->_os->getSysname();
    }

    /**
     * Specify a dependency on an OS.  Use arch for detailed os/processor information
     *
     * There are two generic OS dependencies that will be the most common, unix and windows.
     * Other options are linux, freebsd, darwin (OS X), sunos, irix, hpux, aix
     */
    function validateOsDependency($dep)
    {
        if ($this->_state != PEAR2_Pyrus_Validate::INSTALLING &&
              $this->_state != PEAR2_Pyrus_Validate::DOWNLOADING) {
            return true;
        }
        if (isset($dep['conflicts'])) {
            $not = true;
        } else {
            $not = false;
        }
        if ($dep['name'] == '*') {
            return true;
        }
        switch (strtolower($dep['name'])) {
            case 'windows' :
                if ($not) {
                    if (strtolower(substr($this->getPHP_OS(), 0, 3)) == 'win') {
                        if (!isset($this->_options['nodeps']) &&
                              !isset($this->_options['force'])) {
                            return $this->raiseError("Cannot install %s on Windows");
                        } else {
                            return $this->warning("warning: Cannot install %s on Windows");
                        }
                    }
                } else {
                    if (strtolower(substr($this->getPHP_OS(), 0, 3)) != 'win') {
                        if (!isset($this->_options['nodeps']) &&
                              !isset($this->_options['force'])) {
                            return $this->raiseError("Can only install %s on Windows");
                        } else {
                            return $this->warning("warning: Can only install %s on Windows");
                        }
                    }
                }
            break;
            case 'unix' :
                $unices = array('linux', 'freebsd', 'darwin', 'sunos', 'irix', 'hpux', 'aix');
                if ($not) {
                    if (in_array($this->getSysname(), $unices)) {
                        if (!isset($this->_options['nodeps']) &&
                              !isset($this->_options['force'])) {
                            return $this->raiseError("Cannot install %s on any Unix system");
                        } else {
                            return $this->warning(
                                "warning: Cannot install %s on any Unix system");
                        }
                    }
                } else {
                    if (!in_array($this->getSysname(), $unices)) {
                        if (!isset($this->_options['nodeps']) &&
                              !isset($this->_options['force'])) {
                            return $this->raiseError("Can only install %s on a Unix system");
                        } else {
                            return $this->warning(
                                "warning: Can only install %s on a Unix system");
                        }
                    }
                }
            break;
            default :
                if ($not) {
                    if (strtolower($dep['name']) == strtolower($this->getSysname())) {
                        if (!isset($this->_options['nodeps']) &&
                              !isset($this->_options['force'])) {
                            return $this->raiseError('Cannot install %s on ' . $dep['name'] .
                                ' operating system');
                        } else {
                            return $this->warning('warning: Cannot install %s on ' .
                                $dep['name'] . ' operating system');
                        }
                    }
                } else {
                    if (strtolower($dep['name']) != strtolower($this->getSysname())) {
                        if (!isset($this->_options['nodeps']) &&
                              !isset($this->_options['force'])) {
                            return $this->raiseError('Cannot install %s on ' .
                                $this->getSysname() .
                                ' operating system, can only install on ' . $dep['name']);
                        } else {
                            return $this->warning('warning: Cannot install %s on ' .
                                $this->getSysname() .
                                ' operating system, can only install on ' . $dep['name']);
                        }
                    }
                }
        }
        return true;
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function matchSignature($pattern)
    {
        return $this->_os->matchSignature($pattern);
    }

    /**
     * Specify a complex dependency on an OS/processor/kernel version,
     * Use OS for simple operating system dependency.
     *
     * This is the only dependency that accepts an eregable pattern.  The pattern
     * will be matched against the php_uname() output parsed by OS_Guess
     */
    function validateArchDependency($dep)
    {
        if ($this->_state != PEAR2_Pyrus_Validate::INSTALLING) {
            return true;
        }
        if (isset($dep['conflicts'])) {
            $not = true;
        } else {
            $not = false;
        }
        if (!$this->matchSignature($dep['pattern'])) {
            if (!$not) {
                if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                    return $this->raiseError('%s Architecture dependency failed, does not ' .
                        'match "' . $dep['pattern'] . '"');
                } else {
                    return $this->warning('warning: %s Architecture dependency failed, does ' .
                        'not match "' . $dep['pattern'] . '"');
                }
            }
            return true;
        } else {
            if ($not) {
                if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                    return $this->raiseError('%s Architecture dependency failed, required "' .
                        $dep['pattern'] . '"');
                } else {
                    return $this->warning('warning: %s Architecture dependency failed, ' .
                        'required "' . $dep['pattern'] . '"');
                }
            }
            return true;
        }
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function extension_loaded($name)
    {
        return extension_loaded($name);
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function phpversion($name = null)
    {
        if ($name !== null) {
            return phpversion($name);
        } else {
            return phpversion();
        }
    }

    function validateExtensionDependency($dep, $required = true)
    {
        if ($this->_state != PEAR2_Pyrus_Validate::INSTALLING &&
              $this->_state != PEAR2_Pyrus_Validate::DOWNLOADING) {
            return true;
        }
        $loaded = $this->extension_loaded($dep['name']);
        $extra = $this->_getExtraString($dep);
        if (isset($dep['exclude'])) {
            if (!is_array($dep['exclude'])) {
                $dep['exclude'] = array($dep['exclude']);
            }
        }
        if (!isset($dep['min']) && !isset($dep['max']) &&
              !isset($dep['recommended']) && !isset($dep['exclude'])) {
            if ($loaded) {
                if (isset($dep['conflicts'])) {
                    if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                        return $this->raiseError('%s conflicts with PHP extension "' .
                            $dep['name'] . '"' . $extra);
                    } else {
                        return $this->warning('warning: %s conflicts with PHP extension "' .
                            $dep['name'] . '"' . $extra);
                    }
                }
                return true;
            } else {
                if (isset($dep['conflicts'])) {
                    return true;
                }
                if ($required) {
                    if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                        return $this->raiseError('%s requires PHP extension "' .
                            $dep['name'] . '"' . $extra);
                    } else {
                        return $this->warning('warning: %s requires PHP extension "' .
                            $dep['name'] . '"' . $extra);
                    }
                } else {
                    return $this->warning('%s can optionally use PHP extension "' .
                        $dep['name'] . '"' . $extra);
                }
            }
        }
        if (!$loaded) {
            if (isset($dep['conflicts'])) {
                return true;
            }
            if (!$required) {
                return $this->warning('%s can optionally use PHP extension "' .
                    $dep['name'] . '"' . $extra);
            } else {
                if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                    return $this->raiseError('%s requires PHP extension "' . $dep['name'] .
                        '"' . $extra);
                }
                    return $this->warning('warning: %s requires PHP extension "' . $dep['name'] .
                        '"' . $extra);
            }
        }
        $version = (string) $this->phpversion($dep['name']);
        if (empty($version)) {
            $version = '0';
        }
        $fail = false;
        if (isset($dep['min'])) {
            if (!version_compare($version, $dep['min'], '>=')) {
                $fail = true;
            }
        }
        if (isset($dep['max'])) {
            if (!version_compare($version, $dep['max'], '<=')) {
                $fail = true;
            }
        }
        if ($fail && !isset($dep['conflicts'])) {
            if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                return $this->raiseError('%s requires PHP extension "' . $dep['name'] .
                    '"' . $extra . ', installed version is ' . $version);
            } else {
                return $this->warning('warning: %s requires PHP extension "' . $dep['name'] .
                    '"' . $extra . ', installed version is ' . $version);
            }
        } elseif ((isset($dep['min']) || isset($dep['max'])) && !$fail && isset($dep['conflicts'])) {
            if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                return $this->raiseError('%s conflicts with PHP extension "' .
                    $dep['name'] . '"' . $extra . ', installed version is ' . $version);
            } else {
                return $this->warning('warning: %s conflicts with PHP extension "' .
                    $dep['name'] . '"' . $extra . ', installed version is ' . $version);
            }
        }
        if (isset($dep['exclude'])) {
            foreach ($dep['exclude'] as $exclude) {
                if (version_compare($version, $exclude, '==')) {
                    if (isset($dep['conflicts'])) {
                        continue;
                    }
                    if (!isset($this->_options['nodeps']) &&
                          !isset($this->_options['force'])) {
                        return $this->raiseError('%s is not compatible with PHP extension "' .
                            $dep['name'] . '" version ' .
                            $exclude);
                    } else {
                        return $this->warning('warning: %s is not compatible with PHP extension "' .
                            $dep['name'] . '" version ' .
                            $exclude);
                    }
                } elseif (version_compare($version, $exclude, '!=') && isset($dep['conflicts'])) {
                    if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                        return $this->raiseError('%s conflicts with PHP extension "' .
                            $dep['name'] . '"' . $extra . ', installed version is ' . $version);
                    } else {
                        return $this->warning('warning: %s conflicts with PHP extension "' .
                            $dep['name'] . '"' . $extra . ', installed version is ' . $version);
                    }
                }
            }
        }
        if (isset($dep['recommended'])) {
            if (version_compare($version, $dep['recommended'], '==')) {
                return true;
            } else {
                if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                    return $this->raiseError('%s dependency: PHP extension ' . $dep['name'] .
                        ' version "' . $version . '"' .
                        ' is not the recommended version "' . $dep['recommended'] .
                        '", but may be compatible, use --force to install');
                } else {
                    return $this->warning('warning: %s dependency: PHP extension ' .
                        $dep['name'] . ' version "' . $version . '"' .
                        ' is not the recommended version "' . $dep['recommended'].'"');
                }
            }
        }
        return true;
    }

    function validatePhpDependency($dep)
    {
        if ($this->_state != PEAR2_Pyrus_Validate::INSTALLING &&
              $this->_state != PEAR2_Pyrus_Validate::DOWNLOADING) {
            return true;
        }
        $version = $this->phpversion();
        $extra = $this->_getExtraString($dep);
        if (isset($dep['exclude'])) {
            if (!is_array($dep['exclude'])) {
                $dep['exclude'] = array($dep['exclude']);
            }
        }
        if (isset($dep['min'])) {
            if (!version_compare($version, $dep['min'], '>=')) {
                if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                    return $this->raiseError('%s requires PHP' .
                        $extra . ', installed version is ' . $version);
                } else {
                    return $this->warning('warning: %s requires PHP' .
                        $extra . ', installed version is ' . $version);
                }
            }
        }
        if (isset($dep['max'])) {
            if (!version_compare($version, $dep['max'], '<=')) {
                if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                    return $this->raiseError('%s requires PHP' .
                        $extra . ', installed version is ' . $version);
                } else {
                    return $this->warning('warning: %s requires PHP' .
                        $extra . ', installed version is ' . $version);
                }
            }
        }
        if (isset($dep['exclude'])) {
            foreach ($dep['exclude'] as $exclude) {
                if (version_compare($version, $exclude, '==')) {
                    if (!isset($this->_options['nodeps']) &&
                          !isset($this->_options['force'])) {
                        return $this->raiseError('%s is not compatible with PHP version ' .
                            $exclude);
                    } else {
                        return $this->warning(
                            'warning: %s is not compatible with PHP version ' .
                            $exclude);
                    }
                }
            }
        }
        return true;
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function getPEARVersion()
    {
        return '2.0.0a1' === '2.0.0a1' ? '2.0.0' : '2.0.0a1';
    }

    function validatePearinstallerDependency($dep)
    {
        $pearversion = $this->getPEARVersion();
        $extra = $this->_getExtraString($dep);
        if (isset($dep['exclude'])) {
            if (!is_array($dep['exclude'])) {
                $dep['exclude'] = array($dep['exclude']);
            }
        }
        if (version_compare($pearversion, $dep['min'], '<')) {
            if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                return $this->raiseError('%s requires PEAR Installer' . $extra .
                    ', installed version is ' . $pearversion);
            } else {
                return $this->warning('warning: %s requires PEAR Installer' . $extra .
                    ', installed version is ' . $pearversion);
            }
        }
        if (isset($dep['max'])) {
            if (version_compare($pearversion, $dep['max'], '>')) {
                if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                    return $this->raiseError('%s requires PEAR Installer' . $extra .
                        ', installed version is ' . $pearversion);
                } else {
                    return $this->warning('warning: %s requires PEAR Installer' . $extra .
                        ', installed version is ' . $pearversion);
                }
            }
        }
        if (isset($dep['exclude'])) {
            if (!isset($dep['exclude'][0])) {
                $dep['exclude'] = array($dep['exclude']);
            }
            foreach ($dep['exclude'] as $exclude) {
                if (version_compare($exclude, $pearversion, '==')) {
                    if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                        return $this->raiseError('%s is not compatible with PEAR Installer ' .
                            'version ' . $exclude);
                    } else {
                        return $this->warning('warning: %s is not compatible with PEAR ' .
                            'Installer version ' . $exclude);
                    }
                }
            }
        }
        return true;
    }

    function validateSubpackageDependency($dep, $required, $params)
    {
        return $this->validatePackageDependency($dep, $required, $params);
    }

    /**
     * @param array dependency information (2.0 format)
     * @param boolean whether this is a required dependency
     * @param array a list of downloaded packages to be installed, if any
     */
    function validatePackageDependency($dep, $required, $params)
    {
        if ($this->_state != PEAR2_Pyrus_Validate::INSTALLING &&
              $this->_state != PEAR2_Pyrus_Validate::DOWNLOADING) {
            return true;
        }
        if (isset($dep['providesextension'])) {
            if ($this->extension_loaded($dep['providesextension'])) {
                $save = $dep;
                $subdep = $dep;
                $subdep['name'] = $subdep['providesextension'];
                $ret = $this->validateExtensionDependency($subdep, $required);
                if ($ret === true) {
                    return true;
                }
            }
        }
        if ($this->_state == PEAR2_Pyrus_Validate::INSTALLING) {
            return $this->_validatePackageInstall($dep, $required);
        }
        if ($this->_state == PEAR2_Pyrus_Validate::DOWNLOADING) {
            return $this->_validatePackageDownload($dep, $required, $params);
        }
    }

    function _validatePackageDownload($dep, $required, $params)
    {
        $dep['package'] = $dep['name'];
        if (isset($dep['uri'])) {
            $dep['channel'] = '__uri';
        }
        $depname = PEAR2_Pyrus_Config::parsedPackageNameToString($dep, true);
        $found = false;
        foreach ($params as $param) {
            if ($param->name == $dep['name'] && $param->channel == $dep['channel']) {
                $found = true;
                break;
            }
        }
        if (!$found && isset($dep['providesextension'])) {
            foreach ($params as $param) {
                if ($param->isExtension($dep['providesextension'])) {
                    $found = true;
                    break;
                }
            }
        }
        if ($found) {
            $version = $param->version['release'];
            $installed = false;
            $downloaded = true;
        } else {
            if ($this->registry->exists($dep['name'], $dep['channel'])) {
                $installed = true;
                $downloaded = false;
                $version = $this->registry->info($dep['name'],
                    $dep['channel'], 'version');
            } else {
                $version = 'not installed or downloaded';
                $installed = false;
                $downloaded = false;
            }
        }
        $extra = $this->_getExtraString($dep);
        if (isset($dep['exclude'])) {
            if (!is_array($dep['exclude'])) {
                $dep['exclude'] = array($dep['exclude']);
            }
        }
        if (!isset($dep['min']) && !isset($dep['max']) &&
              !isset($dep['recommended']) && !isset($dep['exclude'])) {
            if ($installed || $downloaded) {
                $installed = $installed ? 'installed' : 'downloaded';
                if (isset($dep['conflicts'])) {
                    if ($version) {
                        $rest = ", $installed version is " . $version;
                    } else {
                        $rest = '';
                    }
                    if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                        return $this->raiseError('%s conflicts with package "' . $depname . '"' .
                            $extra . $rest);
                    } else {
                        return $this->warning('warning: %s conflicts with package "' . $depname . '"' .
                            $extra . $rest);
                    }
                }
                return true;
            } else {
                if (isset($dep['conflicts'])) {
                    return true;
                }
                if ($required) {
                    if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                        return $this->raiseError('%s requires package "' . $depname . '"' .
                            $extra);
                    } else {
                        return $this->warning('warning: %s requires package "' . $depname . '"' .
                            $extra);
                    }
                } else {
                    return $this->warning('%s can optionally use package "' . $depname . '"' .
                        $extra);
                }
            }
        }
        if (!$installed && !$downloaded) {
            if (isset($dep['conflicts'])) {
                return true;
            }
            if ($required) {
                if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                    return $this->raiseError('%s requires package "' . $depname . '"' .
                        $extra);
                } else {
                    return $this->warning('warning: %s requires package "' . $depname . '"' .
                        $extra);
                }
            } else {
                return $this->warning('%s can optionally use package "' . $depname . '"' .
                    $extra);
            }
        }
        $fail = false;
        if (isset($dep['min'])) {
            if (version_compare($version, $dep['min'], '<')) {
                $fail = true;
            }
        }
        if (isset($dep['max'])) {
            if (version_compare($version, $dep['max'], '>')) {
                $fail = true;
            }
        }
        if ($fail && !isset($dep['conflicts'])) {
            $installed = $installed ? 'installed' : 'downloaded';
            $dep['package'] = $dep['name'];
            $dep = PEAR2_Pyrus_Config::parsedPackageNameToString($dep, true);
            if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                return $this->raiseError('%s requires package "' . $depname . '"' .
                    $extra . ", $installed version is " . $version);
            } else {
                return $this->warning('warning: %s requires package "' . $depname . '"' .
                    $extra . ", $installed version is " . $version);
            }
        } elseif ((isset($dep['min']) || isset($dep['max'])) && !$fail &&
              isset($dep['conflicts']) && !isset($dep['exclude'])) {
            $installed = $installed ? 'installed' : 'downloaded';
            if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                return $this->raiseError('%s conflicts with package "' . $depname . '"' . $extra .
                    ", $installed version is " . $version);
            } else {
                return $this->warning('warning: %s conflicts with package "' . $depname . '"' .
                    $extra . ", $installed version is " . $version);
            }
        }
        if (isset($dep['exclude'])) {
            $installed = $installed ? 'installed' : 'downloaded';
            foreach ($dep['exclude'] as $exclude) {
                if (version_compare($version, $exclude, '==') && !isset($dep['conflicts'])) {
                    if (!isset($this->_options['nodeps']) &&
                          !isset($this->_options['force'])) {
                        return $this->raiseError('%s is not compatible with ' .
                            $installed . ' package "' .
                            $depname . '" version ' .
                            $exclude);
                    } else {
                        return $this->warning('warning: %s is not compatible with ' .
                            $installed . ' package "' .
                            $depname . '" version ' .
                            $exclude);
                    }
                } elseif (version_compare($version, $exclude, '!=') && isset($dep['conflicts'])) {
                    $installed = $installed ? 'installed' : 'downloaded';
                    if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                        return $this->raiseError('%s conflicts with package "' . $depname . '"' .
                            $extra . ", $installed version is " . $version);
                    } else {
                        return $this->warning('warning: %s conflicts with package "' . $depname . '"' .
                            $extra . ", $installed version is " . $version);
                    }
                }
            }
        }
        if (isset($dep['recommended'])) {
            $installed = $installed ? 'installed' : 'downloaded';
            if (version_compare($version, $dep['recommended'], '==')) {
                return true;
            } else {
                if (!$found && $installed) {
                    $param = $this->registry->package[$dep['channel'] . '/' . $dep['name']];
                }
                if ($param) {
                    $found = false;
                    foreach ($params as $parent) {
                        if ($parent->name == $this->_currentPackage['package'] &&
                              $parent->channel == $this->_currentPackage['channel']) {
                            $found = true;
                            break;
                        }
                    }
                    if ($found) {
                        if ($param->isCompatible($parent)) {
                            return true;
                        }
                    } else { // this is for validPackage() calls
                        $parent = $this->registry->package[
                            $this->_currentPackage['channel'] . '/' .
                            $this->_currentPackage['package']];
                        if ($parent !== null) {
                            if ($param->isCompatible($parent)) {
                                return true;
                            }
                        }
                    }
                }
                if (!isset($this->_options['nodeps']) && !isset($this->_options['force']) &&
                      !isset($this->_options['loose'])) {
                    return $this->raiseError('%s dependency package "' . $depname .
                        '" ' . $installed . ' version ' . $version .
                        ' is not the recommended version ' . $dep['recommended'] .
                        ', but may be compatible, use --force to install');
                } else {
                    return $this->warning('warning: %s dependency package "' . $depname .
                        '" ' . $installed . ' version ' . $version .
                        ' is not the recommended version ' . $dep['recommended']);
                }
            }
        }
        return true;
    }

    function _validatePackageInstall($dep, $required)
    {
        return $this->_validatePackageDownload($dep, $required, array());
    }

    function validatePackageUninstall($dep, $required, $param, $params)
    {
        $dep['package'] = $dep['name'];
        $depname = PEAR2_Pyrus_Config::parsedPackageNameToString($dep, true);
        $version = $package->version;
        $extra = $this->_getExtraString($dep);
        if (isset($dep['exclude'])) {
            if (!is_array($dep['exclude'])) {
                $dep['exclude'] = array($dep['exclude']);
            }
        }
        if (isset($dep['conflicts'])) {
            return true; // uninstall OK - these packages conflict (probably installed with --force)
        }
        if (!isset($dep['min']) && !isset($dep['max'])) {
            if ($required) {
                if (!isset($this->_options['nodeps']) && !isset($this->_options['force'])) {
                    return $this->raiseError('"' . $depname . '" is required by ' .
                        'installed package %s' . $extra);
                } else {
                    return $this->warning('warning: "' . $depname . '" is required by ' .
                        'installed package %s' . $extra);
                }
            } else {
                return $this->warning('"' . $depname . '" can be optionally used by ' .
                        'installed package %s' . $extra);
            }
        }
        $fail = false;
        if (isset($dep['min'])) {
            if (version_compare($version, $dep['min'], '>=')) {
                $fail = true;
            }
        }
        if (isset($dep['max'])) {
            if (version_compare($version, $dep['max'], '<=')) {
                $fail = true;
            }
        }
        if ($fail) {
            if ($required) {
                if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['nodeps']['force'])) {
                    return $this->raiseError($depname . $extra . ' is required by installed package' .
                        ' "%s"');
                } else {
                    return $this->warning('warning: ' . $depname . $extra .
                        ' is required by installed package "%s"');
                }
            } else {
                return $this->warning($depname . $extra . ' can be optionally used by installed package' .
                        ' "%s"');
            }
        }
        return true;
    }

    /**
     * validate a downloaded package against installed packages
     *
     * As of PEAR 1.4.3, this will only validate
     *
     * @param array|PEAR_Downloader_Package|PEAR_PackageFile_v1|PEAR_PackageFile_v2
     *              $pkg package identifier (either
     *                   array('package' => blah, 'channel' => blah) or an array with
     *                   index 'info' referencing an object)
     * @param PEAR_Downloader $dl
     * @param array $params full list of packages to install
     * @return true|PEAR_Error
     */
    function validatePackage($pkg, &$dl, $params = array())
    {
        if (is_array($pkg) && isset($pkg['info'])) {
            $deps = $this->registry->getDependentPackageDependencies($pkg['info']);
        } else {
            $deps = $this->registry->getDependentPackageDependencies($pkg);
        }
        $fail = false;
        if ($deps) {
            $dp = new PEAR_Downloader_Package($dl);
            if (is_object($pkg)) {
                $dp->setPackageFile($pkg);
            } else {
                $dp->setDownloadURL($pkg);
            }
            foreach ($deps as $channel => $info) {
                foreach ($info as $package => $ds) {
                    foreach ($params as $packd) {
                        if (strtolower($packd->getPackage()) == strtolower($package) &&
                              $packd->getChannel() == $channel) {
                            $dl->log(3, 'skipping installed package check of "' .
                                        PEAR2_Pyrus_Config::parsedPackageNameToString(
                                            array('channel' => $channel, 'package' => $package),
                                            true) .
                                        '", version "' . $packd->getVersion() . '" will be ' .
                                        'downloaded and installed');
                            continue 2; // jump to next package
                        }
                    }
                    foreach ($ds as $d) {
                        $checker = new PEAR2_Pyrus_Dependency_Validator($this->_config, $this->_options,
                            array('channel' => $channel, 'package' => $package), $this->_state);
                        $dep = $d['dep'];
                        $required = $d['type'] == 'required';
                        try {
                            $ret = $checker->_validatePackageDownload($dep, $required,
                                 array(&$dp));
                            if (is_array($ret)) {
                                $dl->log(0, $ret[0]);
                            }
                        } catch (Exception $e) {
                            $dl->log(0, $e->getMessage());
                            $fail = true;
                        }
                    }
                }
            }
        }
        if ($fail) {
            return $this->raiseError(
                '%s cannot be installed, conflicts with installed packages');
        }
        return true;
    }

    function raiseError($msg)
    {
        if (isset($this->_options['ignore-errors'])) {
            return $this->warning($msg);
        }
        $this->errs->E_ERROR[] = new PEAR2_Pyrus_Dependency_Exception(sprintf($msg, PEAR2_Pyrus_Config::parsedPackageNameToString(
            $this->_currentPackage, true)));
    }

    function warning($msg)
    {
        $this->errs->E_WARNING[] = new PEAR2_Pyrus_Dependency_Exception(sprintf($msg, PEAR2_Pyrus_Config::parsedPackageNameToString(
            $this->_currentPackage, true)));
    }
}
?>
<?php
/**
 * PEAR2_Pyrus_DirectedGraph
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements a graph data type, used for topological sorting of packages.
 *
 * This structure allows us to sort dependencies into the correct order for installation.
 * Iteration uses a depth-first search to perform a topological sort.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_DirectedGraph implements Iterator
{
    const WHITE = 0;
    const GRAY = 1;
    const BLACK = 2;
    protected $vertices = array();
    /**
     * Map data to abstract vertex
     *
     * @var array
     */
    protected $map = array();
    /**
     * Topologically sorted vertices
     * @var array
     */
    protected $blackVertices = array();

    /**
     * Add a data vertex
     *
     * @param object $data
     * @return PEAR2_Pyrus_DirectedGraph_Vertex
     */
    function add($data)
    {
        $vertex = new PEAR2_Pyrus_DirectedGraph_Vertex($data);
        $this->vertices[spl_object_hash($vertex)] = $vertex;
        $this->map[spl_object_hash($data)] = spl_object_hash($vertex);
        return $vertex;
    }

    /**
     * Connect two vertices in a directed graph
     *
     * This can be used with a fluent interface
     * @param object|PEAR2_Pyrus_DirectedGraph_Vertex $from
     * @param object|PEAR2_Pyrus_DirectedGraph_Vertex $to
     * @return PEAR2_Pyrus_DirectedGraph
     */
    function connect($from, $to)
    {
        if ($from instanceof PEAR2_Pyrus_DirectedGraph_Vertex) {
            $a = spl_object_hash($from);
        } else {
            if (!isset($this->map[spl_object_hash($from)])) {
                $a = $this->add($from);
            } else {
                $a = $this->vertices[$this->map[spl_object_hash($from)]];
            }
        }
        if ($to instanceof PEAR2_Pyrus_DirectedGraph_Vertex) {
            $b = spl_object_hash($to);
        } else {
            if (!isset($this->map[spl_object_hash($to)])) {
                $b = $this->add($to);
            } else {
                $b = $this->vertices[$this->map[spl_object_hash($to)]];
            }
        }
        $this->vertices[spl_object_hash($a)]->connect($b);
        return $this;
    }

    function current()
    {
        return current($this->blackVertices)->data;
    }

    function next()
    {
        return next($this->blackVertices);
    }

    function key()
    {
        return key($this->blackVertices);
    }

    function valid()
    {
        return current($this->blackVertices);
    }

    function rewind()
    {
        $this->topologicalSort();
    }

    /**
     * Sort the vertices by their connections
     */
    function topologicalSort()
    {
        $this->blackVertices = array();
        if (!count($this->vertices)) {
            return;
        }
        foreach ($this->vertices as $vertex) {
            $vertex->color(self::WHITE);
        }
        while (count($this->blackVertices) <  count($this->vertices)) {
            // select a vertex to start
            foreach ($this->vertices as $vertex) {
                if ($vertex->color() == self::BLACK) {
                    // already sorted
                    continue;
                }
                break;
            }
            do {
                // this vertex has been discovered
                $vertex->color(self::GRAY);
                if (!count($vertex)) {
                    // no adjacent edges
                    $this->blackVertices[] = $vertex;
                    $vertex->color(self::BLACK);
                    continue 2;
                }
                $black = true;
                // iterate over adjacent vertices to find a white vertex
                foreach ($vertex as $edge) {
                    if ($edge->color() == self::BLACK) {
                        continue;
                    }
                    if (!count($edge)) {
                        // no adjacent undiscovered vertices, we found a black one
                        $edge->color(self::BLACK);
                        $this->blackVertices[] = $edge;
                        continue;
                    }
                    $black = false;
                    $edge->color(self::GRAY);
                }
                if ($black) {
                    // found a new vertex
                    $this->blackVertices[] = $vertex;
                    $vertex->color(self::BLACK);
                } else {
                    foreach ($vertex as $edge) {
                        if ($edge->color() == self::BLACK) {
                            continue;
                        }
                        $vertex = $edge;
                        break;
                    }
                }
            } while (!$black);
        }
    }
}<?php
/**
 * PEAR2_Pyrus_DirectedGraph_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for directedgraph
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_DirectedGraph_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_DirectedGraph_Vertex
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class to represent vertices within the dependency directed graph.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_DirectedGraph_Vertex implements ArrayAccess, Countable, Iterator
{
    const WHITE = PEAR2_Pyrus_DirectedGraph::WHITE;
    const GRAY = PEAR2_Pyrus_DirectedGraph::GRAY;
    const BLACK = PEAR2_Pyrus_DirectedGraph::BLACK;
    protected $color = self::WHITE;
    public $data;
    protected $connections = array();

    /**
     * Encapsulate data within a directed graph vertex
     *
     * @param object $data
     */
    function __construct($data)
    {
        if (!is_object($data)) {
            throw new PEAR2_Pyrus_DirectedGraph_Exception('data must be an object, was ' .
                gettype($data));
        }
        $this->data = $data;
    }

    /**
     * Connect to another vertex
     *
     * @param PEAR2_Pyrus_DirectedGraph_Vertex $to
     */
    function connect(PEAR2_Pyrus_DirectedGraph_Vertex $to)
    {
        $this->connections[spl_object_hash($to)] = $to;
    }

    /**
     * Set the color of a visited node
     *
     * WHITE = unvisited, GRAY = visited, BLACK = finished
     *
     * @param self::WHITE|self::GRAY|self::BLACK|null $color if null, return the current color
     * @return int
     */
    function color($color = null)
    {
        if ($color === null) {
            return $this->color;
        }
        $this->color = $color;
    }

    function count()
    {
        $count = count($this->connections);
        foreach ($this->connections as $node) {
            if ($node->color() != self::WHITE) {
                --$count;
            }
        }
        return $count;
    }

    function offsetGet($var)
    {
        return $this->connections[$var];
    }

    function offsetSet($var, $value)
    {
        if ($value instanceof PEAR2_Pyrus_DirectedGraph_Vertex) {
            $this->connect($value);
        }
    }

    function offsetExists($var)
    {
        return isset($this->connections[$var]);
    }

    function offsetUnset($var)
    {
        unset($this->connections[$var]);
    }

    function current()
    {
        return current($this->connections);
    }

    function next()
    {
        return next($this->connections);
    }

    function key()
    {
        return key($this->connections);
    }

    function valid()
    {
        return current($this->connections);
    }

    function rewind()
    {
        reset($this->connections);
    }
}<?php
/**
 * PEAR2_Pyrus_Downloader
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Pyrus.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Downloader
{
    /**
     * Download using the cURL extension
     *
     * @param unknown_type $url
     * @param unknown_type $ui
     * @param unknown_type $save_dir
     * @param unknown_type $callback
     * @param unknown_type $lastmodified
     * @param unknown_type $accept
     */
    static function downloadCurlHttp($url, $ui, $save_dir = '.', $callback = null, $lastmodified = null,
                              $accept = false)
    {
        if (!function_exists('curl_init')) {
            throw new PEAR2_Pyrus_Exception('Cannot download with cURL - cURL extension is not enabled');
        }
        $c = curl_init();
        if (is_array($url)) {
            foreach ($url as $u) {
                curl_setopt($c, CURLOPT_URL, $u);
            }
        } else {
            curl_setopt($c, CURLOPT_URL, $url);
        }
        if ($config->http_proxy &&
              $proxy = parse_url($config->http_proxy)) {
            curl_setopt($c, CURLOPT_HTTPPROXYTUNNEL, true);
            curl_setopt($c, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);
            $proxy_host = isset($proxy['host']) ? $proxy['host'] : null;
            $proxy_host = $proxy['scheme'] . '://' . $proxy_host;
            $proxy_port = isset($proxy['port']) ? $proxy['port'] : 8080;
            $proxy_user = isset($proxy['user']) ? urldecode($proxy['user']) : null;
            $proxy_pass = isset($proxy['pass']) ? urldecode($proxy['pass']) : null;
            curl_setopt($c, CURLOPT_PROXY, $proxy_host);
            curl_setopt($c, CURLOPT_PROXYPORT, $proxy_port);
            curl_setopt($c, CURLOPT_PROXYUSERPWD, $proxy_user . ':' . $proxy_pass);
            curl_setopt($c, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
            if ($callback) {
                call_user_func($callback, 'message', "Using HTTP proxy $host:$port");
            }
        } else {

        }
        curl_setopt($c, CURLOPT_MAXREDIRS, 3);
        curl_setopt($c, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($c, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt($c, CURLOPT_ENCODING, '');
        curl_setopt($c, CURLOPT_USERAGENT, 'PEAR/@package_version@/PHP/' . PHP_VERSION);
        $username = $config->username;
        if ($username) {
            $password = $config->password;
            curl_setopt($c, CURLOPT_HTTPAUTH, CURLAUTH_ANY);
            curl_setopt($c, CURLOPT_USERPWD, $username . ':' . $password);
        }
        if ($ui) {
            curl_setopt($c, CURLOPT_WRITEFUNCTION, array(__CLASS__, 'curlCallback'));
            self::$_written = 0;
        }
    }

    static private $_written;
    static private $_savefp;

    static function curlCallback($curl, $string)
    {

    }

    static function headerCallback($curl, $string)
    {
        $length = strlen($string);
        echo "Header: $string<br />\n";
        return $length;
    }

    /**
     * Download a file through HTTP.  Considers suggested file name in
     * Content-disposition: header and can run a callback function for
     * different events.  The callback will be called with two
     * parameters: the callback type, and parameters.  The implemented
     * callback types are:
     *
     *  'setup'       called at the very beginning, parameter is a UI object
     *                that should be used for all output
     *  'message'     the parameter is a string with an informational message
     *  'saveas'      may be used to save with a different file name, the
     *                parameter is the filename that is about to be used.
     *                If a 'saveas' callback returns a non-empty string,
     *                that file name will be used as the filename instead.
     *                Note that $save_dir will not be affected by this, only
     *                the basename of the file.
     *  'start'       download is starting, parameter is number of bytes
     *                that are expected, or -1 if unknown
     *  'bytesread'   parameter is the number of bytes read so far
     *  'done'        download is complete, parameter is the total number
     *                of bytes read
     *  'connfailed'  if the TCP/SSL connection fails, this callback is called
     *                with array(host,port,errno,errmsg)
     *  'writefailed' if writing to disk fails, this callback is called
     *                with array(destfile,errmsg)
     *
     * If an HTTP proxy has been configured (http_proxy PEAR_Config
     * setting), the proxy will be used.
     *
     * @param string  $url       the URL to download
     * @param object  $ui        PEAR_Frontend_* instance
     * @param object  $config    PEAR_Config instance
     * @param string  $save_dir  directory to save file in
     * @param mixed   $callback  function/method to call for status
     *                           updates
     * @param false|string|array $lastmodified header values to check against for caching
     *                           use false to return the header values from this download
     * @param false|array $accept Accept headers to send
     * @return string|array  Returns the full path of the downloaded file or a PEAR
     *                       error on failure.  If the error is caused by
     *                       socket-related errors, the error object will
     *                       have the fsockopen error code available through
     *                       getCode().  If caching is requested, then return the header
     *                       values.
     *
     */
    static function get($url, $ui, $save_dir = '.', $callback = null, $lastmodified = null,
                          $accept = false)
    {
        try {
            return self::downloadCurlHttp($url, $ui, $save_dir, $callback, $lastmodified, $accept);
        } catch (Exception $e) {
            // fall back to fsockopen()
        }
        if (is_array($url)) {
            // download multiple urls
            $ret = array();
            foreach ($url as $u) {
                try {
                    $ret[$u] = $this->get($u, $ui, $save_dir, $callback, $lastmodified, $accept);
                } catch (Exception $e) {
                    $ret[$u] = null;
                }
            }
            return $ret;
        }
        static $redirect = 0;
        // allways reset , so we are clean case of error
        $wasredirect = $redirect;
        $redirect = 0;
        if ($callback) {
            call_user_func($callback, 'setup', array(&$ui));
        }
        $info = parse_url($url);
        if (!isset($info['scheme']) || !in_array($info['scheme'], array('http', 'https'))) {
            throw new PEAR2_Pyrus_Exception('Cannot download non-http URL "' . $url . '"');
        }
        if (!isset($info['host'])) {
            throw new PEAR2_Pyrus_Exception('Cannot download from non-URL "' . $url . '"');
        } else {
            $host = isset($info['host']) ? $info['host'] : null;
            $port = isset($info['port']) ? $info['port'] : null;
            $path = isset($info['path']) ? $info['path'] : null;
        }
        if (isset($this)) {
            $config = &$this->config;
        } else {
            $config = PEAR2_Pyrus_Config::singleton();
        }
        $proxy_host = $proxy_port = $proxy_user = $proxy_pass = '';
        if ($config->http_proxy &&
              $proxy = parse_url($config->http_proxy)) {
            $proxy_host = isset($proxy['host']) ? $proxy['host'] : null;
            if (isset($proxy['scheme']) && $proxy['scheme'] == 'https') {
                $proxy_host = 'ssl://' . $proxy_host;
            }
            $proxy_port = isset($proxy['port']) ? $proxy['port'] : 8080;
            $proxy_user = isset($proxy['user']) ? urldecode($proxy['user']) : null;
            $proxy_pass = isset($proxy['pass']) ? urldecode($proxy['pass']) : null;

            if ($callback) {
                call_user_func($callback, 'message', "Using HTTP proxy $host:$port");
            }
        }
        if (empty($port)) {
            if (isset($info['scheme']) && $info['scheme'] == 'https') {
                $port = 443;
            } else {
                $port = 80;
            }
        }
        if ($proxy_host != '') {
            $fp = @fsockopen($proxy_host, $proxy_port, $errno, $errstr);
            if (!$fp) {
                if ($callback) {
                    call_user_func($callback, 'connfailed', array($proxy_host, $proxy_port,
                                                                  $errno, $errstr));
                }
                throw new PEAR2_Pyrus_Exception("Connection to `$proxy_host:$proxy_port' failed: $errstr", $errno);
            }
            if ($lastmodified === false || $lastmodified) {
                $request = "GET $url HTTP/1.1\r\n";
            } else {
                $request = "GET $url HTTP/1.0\r\n";
            }
        } else {
            if (isset($info['scheme']) && $info['scheme'] == 'https') {
                $host = 'ssl://' . $host;
            }
            $fp = @fsockopen($host, $port, $errno, $errstr);
            if (!$fp) {
                if ($callback) {
                    call_user_func($callback, 'connfailed', array($host, $port,
                                                                  $errno, $errstr));
                }
                throw new PEAR2_Pyrus_Exception("Connection to `$host:$port' failed: $errstr", $errno);
            }
            if ($lastmodified === false || $lastmodified) {
                $request = "GET $path HTTP/1.1\r\n";
                $request .= "Host: $host:$port\r\n";
            } else {
                $request = "GET $path HTTP/1.0\r\n";
                $request .= "Host: $host\r\n";
            }
        }
        $ifmodifiedsince = '';
        if (is_array($lastmodified)) {
            if (isset($lastmodified['Last-Modified'])) {
                $ifmodifiedsince = 'If-Modified-Since: ' . $lastmodified['Last-Modified'] . "\r\n";
            }
            if (isset($lastmodified['ETag'])) {
                $ifmodifiedsince .= "If-None-Match: $lastmodified[ETag]\r\n";
            }
        } else {
            $ifmodifiedsince = ($lastmodified ? "If-Modified-Since: $lastmodified\r\n" : '');
        }
        $request .= $ifmodifiedsince . "User-Agent: PEAR/@package_version@/PHP/" .
            PHP_VERSION . "\r\n";
        if (isset($this)) { // only pass in authentication for non-static calls
            $username = $config->get('username');
            $password = $config->get('password');
            if ($username && $password) {
                $tmp = base64_encode("$username:$password");
                $request .= "Authorization: Basic $tmp\r\n";
            }
        }
        if ($proxy_host != '' && $proxy_user != '') {
            $request .= 'Proxy-Authorization: Basic ' .
                base64_encode($proxy_user . ':' . $proxy_pass) . "\r\n";
        }
        if ($accept) {
            $request .= 'Accept: ' . implode(', ', $accept) . "\r\n";
        }
        $request .= "Connection: close\r\n";
        $request .= "\r\n";
        fwrite($fp, $request);
        $headers = array();
        $reply = 0;
        while (trim($line = fgets($fp, 1024))) {
            if (preg_match('/^([^:]+):\s+(.*)\s*$/', $line, $matches)) {
                $headers[strtolower($matches[1])] = trim($matches[2]);
            } elseif (preg_match('|^HTTP/1.[01] ([0-9]{3}) |', $line, $matches)) {
                $reply = (int) $matches[1];
                if ($reply == 304 && ($lastmodified || ($lastmodified === false))) {
                    return false;
                }
                if (! in_array($reply, array(200, 301, 302, 303, 305, 307))) {
                    throw new PEAR2_Pyrus_Exception("File http://$host:$port$path not valid (received: $line)");
                }
            }
        }
        if ($reply != 200) {
            if (isset($headers['location'])) {
                if ($wasredirect < 5) {
                    $redirect = $wasredirect + 1;
                    return $this->downloadHttp($headers['location'],
                            $ui, $save_dir, $callback, $lastmodified, $accept);
                } else {
                    throw new PEAR2_Pyrus_Exception("File http://$host:$port$path not valid (redirection looped more than 5 times)");
                }
            } else {
                throw new PEAR2_Pyrus_Exception("File http://$host:$port$path not valid (redirected but no location)");
            }
        }
        if (isset($headers['content-disposition']) &&
            preg_match('/\sfilename=\"([^;]*\S)\"\s*(;|$)/', $headers['content-disposition'], $matches)) {
            $save_as = basename($matches[1]);
        } else {
            $save_as = basename($url);
        }
        if ($callback) {
            $tmp = call_user_func($callback, 'saveas', $save_as);
            if ($tmp) {
                $save_as = $tmp;
            }
        }
        $dest_file = $save_dir . DIRECTORY_SEPARATOR . $save_as;
        if (!$wp = @fopen($dest_file, 'wb')) {
            fclose($fp);
            if ($callback) {
                call_user_func($callback, 'writefailed', array($dest_file, $php_errormsg));
            }
            throw new PEAR2_Pyrus_Exception("could not open $dest_file for writing");
        }
        if (isset($headers['content-length'])) {
            $length = $headers['content-length'];
        } else {
            $length = -1;
        }
        $bytes = 0;
        if ($callback) {
            call_user_func($callback, 'start', array(basename($dest_file), $length));
        }
        while ($data = fread($fp, 1024)) {
            $bytes += strlen($data);
            if ($callback) {
                call_user_func($callback, 'bytesread', $bytes);
            }
            if (!@fwrite($wp, $data)) {
                fclose($fp);
                if ($callback) {
                    call_user_func($callback, 'writefailed', array($dest_file, $php_errormsg));
                }
                throw new PEAR2_Pyrus_Exception("$dest_file: write failed ($php_errormsg)");
            }
        }
        fclose($fp);
        fclose($wp);
        if ($callback) {
            call_user_func($callback, 'done', $bytes);
        }
        if ($lastmodified === false || $lastmodified) {
            if (isset($headers['etag'])) {
                $lastmodified = array('ETag' => $headers['etag']);
            }
            if (isset($headers['last-modified'])) {
                if (is_array($lastmodified)) {
                    $lastmodified['Last-Modified'] = $headers['last-modified'];
                } else {
                    $lastmodified = $headers['last-modified'];
                }
            }
            return array($dest_file, $lastmodified, $headers);
        }
        return $dest_file;
    }
}<?php
/**
 * PEAR2_Pyrus_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base Exception class for Pyrus.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_FileTransactions
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Pyrus.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_FileTransactions
{
    private $fileOperations = array();
    static private $_registeredTransactions =
        array(
            'backup' => false,
            'chmod' => false,
            'delete' => false,
            'removebackup' => false,
            'mkdir' => false,
            /* to enable the next three, use registerTransaction() */
//            'rename' => false,
//            'rmdir' => false,
//            'installedas' => false,
        );

    /**
     * Add a file operation to the current file transaction.
     *
     * @see begin()
     * @param string $type This can be one of:
     *    - rename:  rename a file ($data has 3 values)
     *    - backup:  backup an existing file ($data has 1 value)
     *    - removebackup:  clean up backups created during install ($data has 1 value)
     *    - chmod:   change permissions on a file ($data has 2 values)
     *    - delete:  delete a file ($data has 1 value)
     *    - rmdir:   delete a directory if empty ($data has 1 value)
     *    - installedas: mark a file as installed ($data has 4 values).
     * @param array $data For all file operations, this array must contain the
     *    full path to the file or directory that is being operated on.  For
     *    the rename command, the first parameter must be the file to rename,
     *    the second its new name, the third whether this is a PHP extension.
     *
     *    The installedas operation contains 4 elements in this order:
     *    1. Filename as listed in the filelist element from package.xml
     *    2. Full path to the installed file
     *    3. Full path from the php_dir configuration variable used in this
     *       installation
     *    4. Relative path from the php_dir that this file is installed in
     */
    function __call($type, $data)
    {
        if ($type == 'chmod') {
            $octmode = decoct($data[0]);
            PEAR2_Pyrus_Log::log(3, "adding to transaction: $type $octmode $data[1]");
        } else {
            PEAR2_Pyrus_Log::log(3, "adding to transaction: $type " . implode(" ", $data));
        }
        $this->fileOperations[] = array($type, $data);
    }

    function begin($rollback_in_case = false)
    {
        if (count($this->fileOperations) && $rollback_in_case) {
            $this->rollback();
        }
        $this->fileOperations = array();
    }

    function commit()
    {
        $n = count($this->fileOperations);
        PEAR2_Pyrus_Log::log(2, "about to commit $n file operations");
        // {{{ first, check permissions and such manually
        $errors = array();

        foreach ($this->fileOperations as $tr) {
            list($type, $data) = $tr;
            switch ($type) {
                case 'backup' :
                    break;
                case 'chmod' :
                    // check that file is writable
                    if (!is_writable($data[1])) {
                        $errors[] = "permission denied ($type): $data[1] " . decoct($data[0]);
                    }
                    break;
                case 'delete' :
                    if (!file_exists($data[0])) {
                        PEAR2_Pyrus_Log::log(2, "warning: file $data[0] doesn'" .
                            "t exist, can't be deleted");
                    }
                    // check that directory is writable
                    if (file_exists($data[0])) {
                        if (!is_writable(dirname($data[0]))) {
                            $errors[] = "permission denied ($type): $data[0]";
                        } else {
                            // make sure the file to be deleted can be opened for writing
                            $fp = false;
                            if (!is_dir($data[0]) &&
                                  (!is_writable($data[0]) || !($fp = @fopen($data[0], 'a')))) {
                                $errors[] = "permission denied ($type): $data[0]";
                            } elseif ($fp) {
                                fclose($fp);
                            }
                        }
                    }
                    break;
                case 'mkdir' :
                case 'removebackup' :
                    break;
                default :
                    $callback = self::$_registeredTransactions[$type];
                    $callback->check($data, $errors);
            }
        }
        if (count($errors) > 0) {
            foreach ($errors as $error) {
                if (!isset($this->_options['soft'])) {
                    PEAR2_Pyrus_Log::log(1, $error);
                }
            }
            if (!isset($this->_options['ignore-errors'])) {
                return false;
            }
        }
        $this->_dirtree = array();
        foreach ($this->fileOperations as $tr) {
            list($type, $data) = $tr;
            switch ($type) {
                case 'backup' :
                    if (!@copy($data[0], $data[0] . '.bak')) {
                        PEAR2_Pyrus_Log::log(1, 'Could not copy ' . $data[0] . ' to ' . $data[0] .
                            '.bak ' . $php_errormsg);
                        return false;
                    }
                    PEAR2_Pyrus_Log::log(3, "+ backup $data[0] to $data[0].bak");
                    break;
                case 'chmod' :
                    if (!@chmod($data[1], $data[0])) {
                        PEAR2_Pyrus_Log::log(1, 'Could not chmod ' . $data[1] . ' to ' .
                            decoct($data[0]) . ' ' . $php_errormsg);
                        return false;
                    }
                    $octmode = decoct($data[0]);
                    PEAR2_Pyrus_Log::log(3, "+ chmod $octmode $data[1]");
                    break;
                case 'delete' :
                    if (file_exists($data[0])) {
                        if (!@unlink($data[0])) {
                            PEAR2_Pyrus_Log::log(1, 'Could not delete ' . $data[0] . ' ' .
                                $php_errormsg);
                            return false;
                        }
                        PEAR2_Pyrus_Log::log(3, "+ rm $data[0]");
                    }
                    break;
                case 'mkdir' :
                    break;
                case 'removebackup' :
                    if (file_exists($data[0] . '.bak') && is_writable($data[0] . '.bak')) {
                        unlink($data[0] . '.bak');
                        PEAR2_Pyrus_Log::log(3, "+ rm backup of $data[0] ($data[0].bak)");
                    }
                    break;
                default :
                    $callback = self::$_registeredTransactions[$type];
                    $callback->commit($data, $errors);
            }
        }
        PEAR2_Pyrus_Log::log(2, "successfully committed $n file operations");
        $this->fileOperations = array();
        return true;
    }

    function registerTransaction($name, PEAR2_Pyrus_IFileTransaction $callback)
    {
        if (in_array($name, array_keys(self::$_registeredTransactions), true)) {
            throw new PEAR2_Pyrus_FileTransactions_Exception('transaction type ' . $name .
                ' is already registered');
        }
        self::$_registeredTransactions[$name] = $callback;
    }

    function rollback()
    {
        $n = count($this->fileOperations);
        PEAR2_Pyrus_Log::log(2, "rolling back $n file operations");
        foreach ($this->fileOperations as $tr) {
            list($type, $data) = $tr;
            switch ($type) {
                case 'backup' :
                    if (file_exists($data[0] . '.bak')) {
                        @unlink($data[0]);
                        @copy($data[0] . '.bak', $data[0]);
                        PEAR2_Pyrus_Log::log(3, "+ restore $data[0] from $data[0].bak");
                    }
                    break;
                case 'chmod' :
                case 'delete' :
                case 'removebackup' :
                    break;
                case 'mkdir' :
                    @rmdir($data[0]);
                    PEAR2_Pyrus_Log::log(3, "+ rmdir $data[0]");
                    break;
                default :
                    $callback = self::$_registeredTransactions[$type];
                    $callback->rollback($data, $errors);
            }
        }
        foreach (self::$_registeredTransactions as $callback) {
            if (!$callback) {
                continue;
            }
            $callback->cleanup();
        }
        $this->fileOperations = array();
    }
}<?php
/**
 * PEAR2_Pyrus_FileTransactions_Installedas
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Handle files which are installed as a different file. This alters the file
 * transaction to place the file in a different location than normal.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_FileTransactions_Installedas implements PEAR2_Pyrus_IFileTransaction
{
    private $_dirtree = array();
    private $pkginfo;

    public function reset(PEAR2_Pyrus_Package $package)
    {
        $this->pkginfo = $package;
        $this->_dirTree = array();
    }

    public function check($data, &$errors)
    {

    }

    public function commit($data, &$errors)
    {
        //$this->pkginfo->setInstalledAs($data[0], $data[1]);
        if (!isset($this->_dirtree[dirname($data[1])])) {
            $this->_dirtree[dirname($data[1])] = true;
            $this->pkginfo->setDirtree(dirname($data[1]));

            while(!empty($data[3]) && $data[3] != '/' && $data[3] != '\\'
                  && $data[3] != '.') {
                $this->pkginfo->setDirtree($pp =
                    $this->_prependPath($data[3], $data[2]));
                $this->_dirtree[$pp] = true;
                $data[3] = dirname($data[3]);
            }
        }
    }
    function _prependPath($path, $prepend)
    {
        if (strlen($prepend) > 0) {
            if (strpos(PHP_OS, 'WIN') !== false && preg_match('/^[a-z]:/i', $path)) {
                if (preg_match('/^[a-z]:/i', $prepend)) {
                    $prepend = substr($prepend, 2);
                } elseif ($prepend{0} != '\\') {
                    $prepend = "\\$prepend";
                }
                $path = substr($path, 0, 2) . $prepend . substr($path, 2);
            } else {
                $path = $prepend . $path;
            }
        }
        return $path;
    }

    public function rollback($data, &$errors)
    {
        //$this->pkginfo->setInstalledAs($data[0], false);
    }

    public function cleanup()
    {
        //$this->pkginfo->resetDirTree();
    }
}
<?php
/**
 * PEAR2_Pyrus_FileTransactions_Rename
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Handle files which are renamed on installation. This alters the standard file
 * transaction to rename an installed file to a different filename.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_FileTransactions_Rename implements PEAR2_Pyrus_IFileTransaction
{
    public function check($data, &$errors)
    {
        if (!file_exists($data[0])) {
            $errors[] = "cannot rename file $data[0], doesn't exist";
        }
        // check that dest dir. is writable
        if (!is_writable(dirname($data[1]))) {
            $errors[] = "permission denied ($type): $data[1]";
        }
    }

    public function commit($data, &$errors)
    {
        if (file_exists($data[1])) {
            $test = @unlink($data[1]);
        } else {
            $test = null;
        }
        if (!$test && file_exists($data[1])) {
            if ($data[2]) {
                $extra = ', this extension must be installed manually.  Rename to "' .
                    basename($data[1]) . '"';
            } else {
                $extra = '';
            }
            if (!isset($this->_options['soft'])) {
                PEAR2_Pyrus_Log::log(1, 'Could not delete ' . $data[1] . ', cannot rename ' .
                    $data[0] . $extra);
            }
            if (!isset($this->_options['ignore-errors'])) {
                return false;
            }
        }
        // permissions issues with rename - copy() is far superior
        $perms = @fileperms($data[0]);
        if (!@copy($data[0], $data[1])) {
            PEAR2_Pyrus_Log::log(1, 'Could not rename ' . $data[0] . ' to ' . $data[1] .
                ' ' . $php_errormsg);
            return false;
        }
        // copy over permissions, otherwise they are lost
        @chmod($data[1], $perms);
        @unlink($data[0]);
        PEAR2_Pyrus_Log::log(3, "+ mv $data[0] $data[1]");
    }

    public function rollback($data, &$errors)
    {
        @unlink($data[0]);
        PEAR2_Pyrus_Log::log(3, "+ rm $data[0]");
    }

    public function cleanup(){}
}<?php
/**
 * PEAR2_Pyrus_FileTransactions_Rmdir
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Handle directory removal for file transactions.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_FileTransactions_Rmdir implements PEAR2_Pyrus_IFileTransaction
{
    public function check($data, &$errors)
    {

    }

    public function commit($data, &$errors)
    {
        if (file_exists($data[0])) {
            do {
                $testme = opendir($data[0]);
                while (false !== ($entry = readdir($testme))) {
                    if ($entry == '.' || $entry == '..') {
                        continue;
                    }
                    closedir($testme);
                    break 2; // this directory is not empty and can't be
                             // deleted
                }
                closedir($testme);
                if (!@rmdir($data[0])) {
                    PEAR2_Pyrus_Log::log(1, 'Could not rmdir ' . $data[0] . ' ' .
                        $php_errormsg);
                    return false;
                }
                $this->log(3, "+ rmdir $data[0]");
            } while (false);
        }
    }

    public function rollback($data, &$errors)
    {

    }

    public function cleanup(){}
}<?php
/**
 * PEAR2_Pyrus_IChannel
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for channels
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_IChannel
{
    public function getAlias();
    public function getName();
    public function getPort();
    public function getSSL();
    public function getSummary();
    public function getPath($protocol);
    public function getREST();
    public function getFunctions($protocol);
    public function getBaseURL($resourceType);
    public function toChannelObject();
    public function __toString();
    public function __get($var);
    public function __set($var, $value);
    public function supportsREST();
    public function supports($type, $name = null, $version = '1.0');
    public function resetXmlrpc();
    public function resetSOAP();
    public function resetREST();
    public function setName($name);
    public function setPort($port);
    public function setSSL($ssl = true);
    public function setPath($protocol, $path);
    public function addFunction($type, $version, $name);
    public function setBaseUrl($resourceType, $url);
    public function getValidationObject($package = false);
    public function getValidationPackage();
}
<?php
/**
 * PEAR2_Pyrus_IChannelRegistry
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for PEAR2 channel registry.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_IChannelRegistry
{
    public function add(PEAR2_Pyrus_IChannel $channel);
    public function update(PEAR2_Pyrus_IChannel $channel);
    public function delete(PEAR2_Pyrus_IChannel $channel);
    public function get($channel, $strict = true);
    public function exists($channel, $strict = true);
    public function parseName($name);
    public function parsedNameToString($name);
    public function listChannels();
}
<?php
/**
 * PEAR2_Pyrus_IFileTransaction
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for file transactions
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_IFileTransaction
{
    public function check($data, &$errors);
    public function commit($data, &$errors);
    public function rollback($data, &$errors);
    public function cleanup();
}<?php
/**
 * PEAR2_Pyrus_ILog
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for loggin in Pyrus
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_ILog
{
    public function log($level, $message);
}<?php
/**
 * PEAR2_Pyrus_Installer
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Pyrus Installer class
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer
{
    /**
     * Flag that determines the behavior of {@link begin()}
     *
     * If true, begin() will do nothing.  If false, then
     * {@link self::$installPackages} will be reset to an empty array
     * @var bool
     */
    protected static $inTransaction = false;
    /**
     * Packages that will be installed
     *
     * This list is used when {@link commit()} is called to determine
     * the packages to install
     * @var array
     */
    protected static $installPackages = array();

    /**
     * Packages that were installed
     *
     * This list is used when {@link rollback()} is called to determine
     * the packages that should be removed
     * @var array
     */
    protected static $installedPackages = array();

    /**
     * Packages that have been installed and also successfully registered as installed
     *
     * This list is used when {@link rollback()} is called to determine
     * the packages that should be removed from the registry
     * @var array
     */
    protected static $registeredPackages = array();

    /**
     * Packages that were removed during installation
     *
     * This list is used when {@link rollback()} is called to restore state
     * the packages to install
     * @var array
     */
    protected static $removedPackages = array();

    /**
     * Installer options.  Valid indices are:
     *
     * - upgrade (upgrade or install packages)
     * - optionaldeps (also automatically download/install optional deps)
     * @var array
     */
    public static $options = array();
    static protected $transact;
    static protected $installedas;
    /**
     * Prepare installation of packages
     */
    static function begin()
    {
        if (!self::$inTransaction) {
            self::$transact = new PEAR2_Pyrus_FileTransactions;
            self::$installedas = new PEAR2_Pyrus_FileTransactions_Installedas;
            self::$transact->registerTransaction('installedas', self::$installedas);
            self::$transact->registerTransaction('rmdir', new PEAR2_Pyrus_FileTransactions_Rmdir);
            self::$transact->registerTransaction('rename', new PEAR2_Pyrus_FileTransactions_Rename);
            self::$installPackages = array();
            self::$installedPackages = array();
            self::$removedPackages = array();
            self::$inTransaction = true;
        }
    }

    /**
     * Add a package to the list of packages to be downloaded
     *
     * This function checks to see if an identical package is already being downloaded,
     * and manages removing duplicates or erroring out on a conflict
     * @param PEAR2_Pyrus_Package $package
     */
    static function prepare(PEAR2_Pyrus_Package $package)
    {
        if (!isset(self::$installPackages[$package->channel . '/' . $package->name])) {
            if (PEAR2_Pyrus_Config::current()->registry->exists(
                  $package->name, $package->channel)) {
                if (version_compare($package->version['release'],
                      PEAR2_Pyrus_Config::current()->registry->info(
                        $package->name, $package->channel, 'version'), '<=')) {
                    // installed package is the same or newer version than this one
                    if (!isset(self::$options['force'])) {
                        PEAR2_Pyrus_Log::log(1, 'Skipping installed package ' .
                            $package->channel . '/' . $package->name);
                        return;
                    }
                }
            }
            self::$installPackages[$package->channel . '/' . $package->name] = $package;
            self::prepareDependencies(
                self::$installPackages[$package->channel . '/' . $package->name]);
            return;
        }
        $clone = self::$installPackages[$package->channel . '/' . $package->name];
        // compare version
        if ($package->version['release'] === $clone->version['release']) {
            // identical, ignore this package
            return;
        }
        if (version_compare($package->version['release'], $clone->version['release'], '<')) {
            if ($package->couldBeVersion($clone->version['release'])) {
                // packages depending on the cloned version are OK with a newer version
                // already going to install a newer version of this package, all is OK
                return;
            }
            if (!self::$options['force']) {
                //
                self::rollback();
                throw new PEAR2_Pyrus_Installer_Exception('Cannot install ' .
                    $package->channel . '/' . $package->name . ', two conflicting' .
                    ' versions are required by packages that depend on it (' .
                    $package->version['release'] . ' and ' . $clone->version['release']);
            }
            // ignore this version, it is older
            PEAR2_Pyrus_Log::log(0, 'Warning: two conflicting versions of ' .
                $package->channel . '/' . $package->name .
                ' are required by packages that depend on it (' .
                $package->version['release'] . ' and ' . $clone->version['release']);
            return;
        }
        if ($clone->couldBeVersion($package->version['release'])) {
            // packages depending on the cloned version are OK with this version
            self::$installPackages[$package->channel . '/' . $package->name] = $package;
        } else {
            // the version of $package conflicts with packages depending on this package
            if (!self::$options['force']) {
                self::rollback();
                throw new PEAR2_Pyrus_Installer_Exception('Cannot install ' .
                    $package->channel . '/' . $package->name . ', two conflicting' .
                    ' versions are required by packages that depend on it (' .
                    $package->version['release'] . ' and ' . $clone->version['release']);
            }
            PEAR2_Pyrus_Log::log(0, 'Warning: two conflicting versions of ' .
                $package->channel . '/' . $package->name .
                ' are required by packages that depend on it (' .
                $package->version['release'] . ' and ' . $clone->version['release']);
            self::$installPackages[$package->channel . '/' . $package->name] = $package;
        }
        self::prepareDependencies(
            self::$installPackages[$package->channel . '/' . $package->name]);
    }

    /**
     * Download and prepare all dependencies
     *
     * @param PEAR2_Pyrus_Package $package
     */
    static function prepareDependencies(PEAR2_Pyrus_Package $package)
    {
        foreach ($package->dependencies->required->package as $dep) {
            if (isset($dep['conflicts'])) {
                continue;
            }
            self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package, false, true));
        }
        foreach ($package->dependencies->required->subpackage as $dep) {
            if (isset($dep['conflicts'])) {
                continue;
            }
            self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package, true, true));
        }
        if ($package->requestedGroup) {
            foreach ($package->dependencies->group[$package->requestedGroup]->package as $dep) {
                self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package));
            }
            foreach ($package->dependencies->group[$package->requestedGroup]->subpackage as $dep) {
                self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package, true));
            }
        }
        if (!isset(self::$options['optionaldeps'])) {
            return;
        }
        foreach ($package->dependencies->optional->package as $dep) {
            self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package));
        }
        foreach ($package->dependencies->optional->subpackage as $dep) {
            self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package, true));
        }
    }

    /**
     * Cancel installation
     */
    static function rollback()
    {
        if (self::$inTransaction) {
            self::$inTransaction = false;
            self::$transact->rollback();
            $reg = PEAR2_Pyrus_Config::current()->registry;
            $err = new PEAR2_MultiErrors;
            foreach (self::$registeredPackages as $package) {
                try {
                    $reg->uninstall($package[0]->name, $package[0]->channel);
                    if ($package[1]) {
                        $reg->install($package[1]);
                    }
                } catch (Exception $e) {
                    $err->E_ERROR[] = $e;
                }
            }
            foreach (self::$removedPackages as $package) {
                try {
                    $reg->uninstall($package->name, $package->channel);
                } catch (Exception $e) {
                    $err->E_ERROR[] = $e;
                }
                try {
                    $reg->install($package->getPackageFile()->info);
                } catch (Exception $e) {
                    $err->E_ERROR[] = $e;
                }
            }
            self::$installPackages = array();
            self::$installedPackages = array();
            self::$registeredPackages = array();
            self::$removedPackages = array();
            if (count($err)) {
                throw new PEAR2_Pyrus_Installer_Exception('Could not successfully rollback', $err);
            }
        }
    }

    /**
     * Install packages slated for installation during transaction
     */
    static function commit()
    {
        if (!self::$inTransaction) {
            return false;
        }
        try {
            $installer = new PEAR2_Pyrus_Installer;
            // validate dependencies
            $errs = new PEAR2_MultiErrors;
            foreach (self::$installPackages as $package) {
                $package->validateDependencies(self::$installPackages, $errs);
            }
            if (count($errs->E_ERROR)) {
                throw new PEAR2_Pyrus_Installer_Exception('Dependency validation failed ' .
                    'for some installed packages, installation aborted', $errs);
            }
            // download non-local packages
            foreach (self::$installPackages as $package) {
                $package->download();
            }
            // create dependency connections and load them into the directed graph
            $graph = new PEAR2_Pyrus_DirectedGraph;
            foreach (self::$installPackages as $package) {
                $package->makeConnections($graph, self::$installPackages);
            }
            // topologically sort packages and install them via iterating over the graph
            self::$transact->begin();
            foreach ($graph as $package) {
                $installer->install($package);
                self::$installedPackages[] = $package;
            }
            self::$transact->commit();
            $reg = PEAR2_Pyrus_Config::current()->registry;
            foreach (self::$installedPackages as $package) {
                $previous = $reg->toPackageFile($package->name, $package->channel, true);
                self::$registeredPackages[] = array($package, $previous);
                $reg->install($package->getPackageFile()->info);
            }
            self::$installPackages = array();
            PEAR2_Pyrus_Config::current()->saveConfig();
        } catch (Exception $e) {
            self::rollback();
            throw $e;
        }
    }

    /**
     * Install a fully downloaded package
     *
     * Using PEAR2_Pyrus_FileTransactions and the woPEAR2_Pyrus_PEAR2_Installer_Role* to
     * group files in appropriate locations, the install() method then passes
     * on the registration of installation to PEAR2_Pyrus_Registry.  If necessary,
     * PEAR2_Pyrus_Config will update the install-time snapshots of configuration
     * @param PEAR2_Pyrus_Package $package
     */
    function install(PEAR2_Pyrus_Package $package)
    {
        self::$installedas->reset($package);
        $tmp_path = $package->getLocation();
        $this->_options = array();
        try {
            $lastversion = PEAR2_Pyrus_Config::current()->registry->info(
                                    $package->name, $package->channel, 'version');
        } catch (Exception $e) {
            $lastversion = null;
        }
        $globalreplace = array('attribs' =>
                    array('from' => '@' . 'PACKAGE_VERSION@',
                          'to' => 'version',
                          'type' => 'package-info'));

        foreach ($package->installcontents as $file) {
            $channel = $package->channel;
            // {{{ assemble the destination paths
            if (!in_array($file->role,
                  PEAR2_Pyrus_Installer_Role::getValidRoles($package->getPackageType()))) {
                throw new PEAR2_Pyrus_Installer_Exception('Invalid role `' .
                        $file->role .
                        "' for file " . $file->name);
            }
            $role = PEAR2_Pyrus_Installer_Role::factory($package, $file->role,
                PEAR2_Pyrus_Config::current());
            $role->setup($this, $package, $file['attribs'], $file->name);
            if (!$role->isInstallable()) {
                continue;
            }
            $info = $role->processInstallation($package, $file['attribs'],
                $file->name, $tmp_path);
            list($save_destdir, $dest_dir, $dest_file, $orig_file) = $info;
            $final_dest_file = $installed_as = $dest_file;
            if (isset($this->_options['packagingroot'])) {
                $final_dest_file = $this->_prependPath($final_dest_file,
                    $this->_options['packagingroot']);
            }
            $dest_dir = dirname($final_dest_file);
            $dest_file = $dest_dir . DIRECTORY_SEPARATOR . '.tmp' .
                basename($final_dest_file);
            // }}}

            if (empty($this->_options['register-only'])) {
                if (!file_exists($dest_dir) || !is_dir($dest_dir)) {
                    if (!mkdir($dest_dir, 0755, true)) {
                        throw new PEAR2_Pyrus_Installer_Exception("failed to mkdir $dest_dir");
                    }
                    PEAR2_Pyrus_Log::log(3, "+ mkdir $dest_dir");
                }
            }
            // pretty much nothing happens if we are only registering the install
            if (empty($this->_options['register-only'])) {
                if (!file_exists($orig_file)) {
                    throw new PEAR2_Pyrus_Installer_Exception("file $orig_file does not exist");
                }
                $contents = file_get_contents($orig_file);
                if ($contents === false) {
                    $contents = '';
                }
                if (isset($file['md5sum'])) {
                    $md5sum = md5($contents);
                }
                $tasks = $file->tasks;
                if ($package->isNewPackage()) {
                    if (isset($tasks['tasks:replace'])) {
                        if (isset($tasks['tasks:replace'][0])) {
                            $tasks['tasks:replace'][] = $globalreplace;
                        } else {
                            $tasks['tasks:replace'] = array($tasks['tasks:replace'],
                                $globalreplace);
                        }
                    } else {
                        $tasks['tasks:replace'] = $globalreplace;
                    }
                }
                foreach (new PEAR2_Pyrus_Package_Creator_TaskIterator($tasks, $package)
                          as $task) {
                    if (!$task[1]->isScript()) { // scripts are only handled after installation
                        $task[1]->init($task[0], $file['attribs'], null);
                        $newcontents = $task[1]->startSession($package, $contents, $dest_file);
                        if ($newcontents) {
                            $contents = $newcontents; // save changes
                        }
                    }
                }
                $wp = @fopen($dest_file, "wb");
                if (!is_resource($wp)) {
                    throw new PEAR2_Pyrus_Installer_Exception(
                        "failed to create $dest_file: $php_errormsg");
                }
                if (fwrite($wp, $contents) === false) {
                    throw new PEAR2_Pyrus_Installer_Exception(
                        "failed writing to $dest_file: $php_errormsg");
                }
                fclose($wp);
                // {{{ check the md5
                if (isset($md5sum)) {
                    if (strtolower($md5sum) == strtolower($file['md5sum'])) {
                        PEAR2_Pyrus_Log::log(2, "md5sum ok: $final_dest_file");
                    } else {
                        if (empty($options['force'])) {
                            // delete the file
                            if (file_exists($dest_file)) {
                                unlink($dest_file);
                            }
                            if (!isset($options['ignore-errors'])) {
                                throw new PEAR2_Pyrus_Installer_Exception(
                                    "bad md5sum for file $final_dest_file");
                            } else {
                                if (!isset($options['soft'])) {
                                    PEAR2_Pyrus_Log::log(0,
                                        "warning : bad md5sum for file $final_dest_file");
                                }
                            }
                        } else {
                            if (!isset($options['soft'])) {
                                PEAR2_Pyrus_Log::log(0,
                                    "warning : bad md5sum for file $final_dest_file");
                            }
                        }
                    }
                }
                // }}}
                // {{{ set file permissions
                if (strpos(PHP_OS, 'WIN') === false) {
                    if ($role->isExecutable()) {
                        $mode = 0777 & octdec(PEAR2_Pyrus_Config::current()->umask);
                        PEAR2_Pyrus_Log::log(3, "+ chmod +x $dest_file");
                    } else {
                        $mode = 0666 & octdec(PEAR2_Pyrus_Config::current()->umask);
                    }
                    self::$transact->chmod($mode, $dest_file);
                    if (!@chmod($dest_file, $mode)) {
                        if (!isset($options['soft'])) {
                            PEAR2_Pyrus_Log::log(0,
                                "failed to change mode of $dest_file: $php_errormsg");
                        }
                    }
                }
                // }}}
                self::$transact->rename($dest_file, $final_dest_file, $role->isExtension());
            }
            // Store the full path where the file was installed for easy uninstall
            self::$transact->installedas($file->name, $installed_as,
                                $save_destdir, dirname(substr($dest_file,
                                 strlen($save_destdir))));
        }
    }

    /**
     * Return an array containing all of the states that are more stable than
     * or equal to the passed in state
     *
     * @param string Release state
     * @param boolean Determines whether to include $state in the list
     * @return false|array False if $state is not a valid release state
     */
    static function betterStates($state, $include = false)
    {
        static $states = array('snapshot', 'devel', 'alpha', 'beta', 'stable');
        $i = array_search($state, $states);
        if ($i === false) {
            return false;
        }
        if ($include) {
            $i--;
        }
        return array_slice($states, $i + 1);
    }
}
<?php
/**
 * PEAR2_Pyrus_Installer_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus installer
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Installer_Role
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for installation roles for files.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role
{
    static private $_roles;
    /**
     * Set up any additional configuration variables that file roles require
     *
     * Never call this directly, it is called by the PEAR_Config constructor
     * @param PEAR2_Pyrus_Config
     * @access private
     * @static
     */
    public static function initializeConfig(PEAR2_Pyrus_Config $config)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }
        foreach (self::$_roles as $class => $info) {
            if (!$info['config_vars']) {
                continue;
            }
            $config->addConfigValue($info['config_vars']);
        }
    }

    /**
     * @param PEAR2_Pyrus_PackageFile_v2
     * @param string role name
     * @param PEAR2_Pyrus_Config
     * @return PEAR2_Pyrus_Installer_Role_Common
     * @static
     */
    static function factory($pkg, $role)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }
        if (!in_array($role, self::getValidRoles($pkg->getPackageType()))) {
            return $a;
        }
        $a = 'PEAR2_Pyrus_Installer_Role_' . ucfirst($role);
        return new $a(PEAR2_Pyrus_Config::current());
    }

    /**
     * Get a list of file roles that are valid for the particular release type.
     *
     * For instance, src files serve no purpose in regular php releases.
     * @param string
     * @param bool clear cache
     * @return array
     * @static
     */
    static function getValidRoles($release, $clear = false)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }
        static $ret = array();
        if ($clear) {
            $ret = array();
        }
        if (isset($ret[$release])) {
            return $ret[$release];
        }
        $ret[$release] = array();
        foreach (self::$_roles as $role => $okreleases) {
            if (in_array($release, $okreleases['releasetypes'])) {
                $ret[$release][] = strtolower(str_replace('PEAR2_Pyrus_Installer_Role_', '', $role));
            }
        }
        return $ret[$release];
    }

    /**
     * Get a list of roles that require their files to be installed
     *
     * Most roles must be installed, but src and package roles, for instance
     * are pseudo-roles.  src files are compiled into a new extension.  Package
     * roles are actually fully bundled releases of a package
     * @param bool clear cache
     * @return array
     * @static
     */
    static function getInstallableRoles($clear = false)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }
        static $ret;
        if ($clear) {
            unset($ret);
        }
        if (!isset($ret)) {
            $ret = array();
            foreach (self::$_roles as $role => $okreleases) {
                if ($okreleases['installable']) {
                    $ret[] = strtolower(str_replace('PEAR2_Pyrus_Installer_Role_', '', $role));
                }
            }
        }
        return $ret;
    }

    /**
     * Return an array of roles that are affected by the baseinstalldir attribute
     *
     * Most roles ignore this attribute, and instead install directly into:
     * PackageName/filepath
     * so a tests file tests/file.phpt is installed into PackageName/tests/filepath.php
     * @param bool clear cache
     * @return array
     * @static
     */
    static function getBaseinstallRoles($clear = false)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }
        static $ret;
        if ($clear) {
            unset($ret);
        }
        if (!isset($ret)) {
            $ret = array();
            foreach (self::$_roles as $role => $okreleases) {
                if ($okreleases['honorsbaseinstall']) {
                    $ret[] = strtolower(str_replace('PEAR2_Pyrus_Installer_Role_', '', $role));
                }
            }
        }
        return $ret;
    }

    /**
     * Return an array of file roles that should be analyzed for PHP content at package time,
     * like the "php" role.
     * @param bool clear cache
     * @return array
     * @static
     */
    static function getPhpRoles($clear = false)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }
        static $ret;
        if ($clear) {
            unset($ret);
        }
        if (!isset($ret)) {
            $ret = array();
            foreach (self::$_roles as $role => $okreleases) {
                if ($okreleases['phpfile']) {
                    $ret[] = strtolower(str_replace('PEAR2_Pyrus_Installer_Role_', '', $role));
                }
            }
        }
        return $ret;
    }

    /**
     * Scan through the Command directory looking for classes
     * and see what commands they implement.
     * @param string which directory to look for classes, defaults to
     *               the Installer/Roles subdirectory of
     *               the directory from where this file (__FILE__) is
     *               included.
     *
     * @return bool TRUE on success, a PEAR error on failure
     * @access public
     * @static
     */
    static function registerRoles($dir = null)
    {
        self::$_roles = array();
        $parser = new PEAR2_Pyrus_XMLParser;
        if ($dir === null) {
            $dir = dirname(__FILE__) . '/Role';
        }
        if (!file_exists($dir) || !is_dir($dir)) {
            throw new PEAR2_Pyrus_Installer_Role_Exception("registerRoles: opendir($dir) failed");
        }
        $dp = @opendir($dir);
        if (empty($dp)) {
            throw new PEAR2_Pyrus_Installer_Role_Exception("registerRoles: opendir($dir) failed");
        }
        while ($entry = readdir($dp)) {
            if ($entry{0} == '.' || substr($entry, -4) != '.xml') {
                continue;
            }
            $class = "PEAR2_Pyrus_Installer_Role_".substr($entry, 0, -4);
            // List of roles
            if (!isset(self::$_roles[$class])) {
                $file = "$dir/$entry";
                $data = $parser->parse($file);
                $data = $data['role'];
                if (!is_array($data['releasetypes'])) {
                    $data['releasetypes'] = array($data['releasetypes']);
                }
                self::$_roles[$class] = $data;
            }
        }
        closedir($dp);
        $roles = self::$_roles;
        ksort($roles);
        self::$_roles = $roles;
        self::getBaseinstallRoles(true);
        self::getInstallableRoles(true);
        self::getPhpRoles(true);
        self::getValidRoles('****', true);
        return true;
    }

    /**
     * Retrieve configuration information about a file role from its XML info
     *
     * @param string $role Role Classname, as in "PEAR2_Pyrus_Installer_Role_Data"
     * @return array
     */
    static function getInfo($role)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }
        if (empty(self::$_roles[$role])) {
            throw new PEAR2_Pyrus_Installer_Role_Exception('Unknown Role class: "' . $role . '"');
        }
        return self::$_roles[$role];
    }
}
?>
<?php
/**
 * Base class for all installation roles.
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for all installation roles.
 *
 * This class allows extensibility of file roles.  Packages with complex
 * customization can now provide custom file roles along with the possibility of
 * adding configuration values to match.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Common
{
    /**
     * @var PEAR_Config
     * @access protected
     */
    protected $config;

    /**
     * @param PEAR2_Pyrus_Config
     */
    function __construct(PEAR2_Pyrus_Config $config)
    {
        $this->config = $config;
    }

    /**
     * Retrieve configuration information about a file role from its XML info
     *
     * @param string $role Role Classname, as in "PEAR2_Pyrus_Installer_Role_Data"
     * @return array
     */
    static function getInfo($role)
    {
        return PEAR2_Pyrus_Installer_Role::getInfo($role);
    }

    /**
     * Retrieve the location a packaged file should be placed in a package
     *
     * @param PEAR2_Pyrus_Package $pkg
     * @param array $atts
     * @return string
     */
    function getPackagingLocation(PEAR2_Pyrus_PackageFile_v2 $pkg, $atts)
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        $role = str_replace('pear2_pyrus_installer_role_', '',
                strtolower(get_class($this)));
        if ($role === 'php') {
            $role = 'src'; // we use "src" as the directory for role=php
        }
        $file = $atts['name'];
        // strip role from file path
        // so src/Path/To/File.php becomes Path/To/File.php,
        // data/package.xsd becomes package.xsd
        $newpath = $file;
        if (strpos($newpath, $role) === 0) {
            $newpath = substr($newpath, strlen($role) + 1);
            if ($newpath === false) {
                $newpath = $file;
            }
        }
        if ($newpath) {
            $file = $newpath;
        }
        if ($roleInfo['honorsbaseinstall']) {
            $dest_dir = $role;
            if (array_key_exists('baseinstalldir', $atts)) {
                if ($atts['baseinstalldir'] != '/') {
                    $dest_dir .= '/' . $atts['baseinstalldir'];
                }
                if (strlen($atts['baseinstalldir'])) {
                    $dest_dir .= '/';
                }
            } else {
                $dest_dir .= '/';
            }
        } elseif ($roleInfo['unusualbaseinstall']) {
            $dest_dir = $role . '/' . $pkg->channel . '/' . $pkg->name . '/';
            if (array_key_exists('baseinstalldir', $atts)) {
                if (strlen($atts['baseinstalldir']) && $atts['baseinstalldir'] != '/') {
                    $dest_dir .= $atts['baseinstalldir'];
                    if (strlen($atts['baseinstalldir'])) {
                        $dest_dir .= '/';
                    }
                }
            } else {
                if (dirname($file) != '.') {
                    $dest_dir .= dirname($file) . '/';
                }
            }
        } else {
            $dest_dir = $role . '/' . $pkg->channel . '/' . $pkg->name . '/';
        }
        return $dest_dir . $file;
    }

    /**
     * This is called for each file to set up the directories and files
     * @param PEAR2_Pyrus_Package
     * @param array attributes from the <file> tag
     * @param string file name
     * @return array an array consisting of:
     *
     *    1 the original, pre-baseinstalldir installation directory
     *    2 the final installation directory
     *    3 the full path to the final location of the file
     *    4 the location of the pre-installation file
     */
    function processInstallation(PEAR2_Pyrus_Package $pkg, $atts, $file, $tmp_path, $layer = null)
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        if (!$roleInfo['locationconfig']) {
            return false;
        }
        $where = $this->config->{$roleInfo['locationconfig']};
        if ($roleInfo['honorsbaseinstall']) {
            $dest_dir = $save_destdir =
                $where;
            if (!empty($atts['baseinstalldir'])) {
                $dest_dir .= DIRECTORY_SEPARATOR . $atts['baseinstalldir'];
            }
        } elseif ($roleInfo['unusualbaseinstall']) {
            $dest_dir = $save_destdir = $where .
                DIRECTORY_SEPARATOR . $pkg->channel . DIRECTORY_SEPARATOR . $pkg->name;
            if (!empty($atts['baseinstalldir'])) {
                $dest_dir .= DIRECTORY_SEPARATOR . $atts['baseinstalldir'];
            }
        } else {
            $dest_dir = $save_destdir = $where .
                DIRECTORY_SEPARATOR . $pkg->channel . DIRECTORY_SEPARATOR . $pkg->name;
        }
        if (dirname($file) != '.' && empty($atts['install-as'])) {
            $newpath = dirname($file);
            if ($pkg->isNewPackage()) {
                // strip role from file path
                // so php/Path/To/File.php becomes Path/To/File.php,
                // data/package.xsd becomes package.xsd
                if (strpos($newpath, $r = strtolower(str_replace('PEAR2_Pyrus_Installer_Role_', '',
                      get_class($this)))) === 0) {
                    $newpath = substr($newpath, strlen($r) + 1);
                    if ($newpath === false) {
                        $newpath = '';
                    }
                } elseif ($r === 'php' && strpos($newpath, $r = 'src') === 0) {
                    $newpath = substr($newpath, strlen($r) + 1);
                    if ($newpath === false) {
                        $newpath = '';
                    }
                }
            }
            $dest_dir .= DIRECTORY_SEPARATOR . $newpath;
        }
        if (empty($atts['install-as'])) {
            $dest_file = $dest_dir . DIRECTORY_SEPARATOR . basename($file);
        } else {
            $dest_file = $dest_dir . DIRECTORY_SEPARATOR . $atts['install-as'];
        }
        $orig_file = $pkg->getFilePath($file);

        // Clean up the DIRECTORY_SEPARATOR mess
        $ds2 = DIRECTORY_SEPARATOR . DIRECTORY_SEPARATOR;

        list($dest_dir, $dest_file, $orig_file) = preg_replace(array('!\\\\+!', '!/!', "!$ds2+!"),
                                                    array(DIRECTORY_SEPARATOR, DIRECTORY_SEPARATOR,
                                                          DIRECTORY_SEPARATOR),
                                                    array($dest_dir, $dest_file, $orig_file));
        return array($save_destdir, $dest_dir, $dest_file, $orig_file);
    }

    /**
     * Get the name of the configuration variable that specifies the location of this file
     * @return string|false
     */
    function getLocationConfig()
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        return $roleInfo['locationconfig'];
    }

    /**
     * Do any unusual setup here
     * @param PEAR_Installer
     * @param PEAR_PackageFile_v2
     * @param array file attributes
     * @param string file name
     */
    function setup($installer, $pkg, $atts, $file)
    {
    }

    function isExecutable()
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        return $roleInfo['executable'];
    }

    function isInstallable()
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role_Common::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        return $roleInfo['installable'];
    }

    function isExtension()
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        return $roleInfo['phpextension'];
    }
}
?>
<?php
/**
 * PEAR2_Pyrus_Installer_Role_Data
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Data role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Data extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>data_dir</locationconfig>
 <honorsbaseinstall />
 <unusualbaseinstall>1</unusualbaseinstall>
 <phpfile />
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Doc
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Doc role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Doc extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>doc_dir</locationconfig>
 <honorsbaseinstall />
 <unusualbaseinstall>1</unusualbaseinstall>
 <phpfile />
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Exception
 * 
 * PHP version 5
 * 
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for roles
 * 
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Installer_Role_Ext
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Ext role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Ext extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>ext_dir</locationconfig>
 <honorsbaseinstall>1</honorsbaseinstall>
 <unusualbaseinstall />
 <phpfile />
 <executable />
 <phpextension>1</phpextension>
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Php
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * php role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Php extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>php_dir</locationconfig>
 <honorsbaseinstall>1</honorsbaseinstall>
 <unusualbaseinstall />
 <phpfile>1</phpfile>
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Script
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Script role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Script extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>bin_dir</locationconfig>
 <honorsbaseinstall>1</honorsbaseinstall>
 <unusualbaseinstall />
 <phpfile />
 <executable>1</executable>
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Src
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Src role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Src extends PEAR2_Pyrus_Installer_Role_Common
{
    function setup(&$installer, $pkg, $atts, $file)
    {
        $installer->source_files++;
    }
}
?><role version="1.0">
 <releasetypes>extsrc</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <installable />
 <locationconfig />
 <honorsbaseinstall />
 <unusualbaseinstall />
 <phpfile />
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Test
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Test role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Test extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>test_dir</locationconfig>
 <honorsbaseinstall />
 <unusualbaseinstall>1</unusualbaseinstall>
 <phpfile />
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Www
 * 
 * PHP version 5
 * 
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * www role
 * 
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Www extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>www_dir</locationconfig>
 <honorsbaseinstall />
 <unusualbaseinstall>1</unusualbaseinstall>
 <phpfile />
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_IPackage
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_IPackage extends ArrayAccess, Iterator
{
    function getFileContents($file, $asstream = false);
    function getFilePath($file);
    function getLocation();
    function getFrom();
    function __get($var);
    function __toString();
    function __call($func, $args);
}
<?php
/**
 * PEAR2_Pyrus_IRegistry
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for a PEAR2 Pyrus managed installation registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_IRegistry
{
    public function install(PEAR2_Pyrus_PackageFile_v2 $info);
    public function uninstall($name, $channel);
    public function exists($package, $channel);
    public function info($package, $channel, $field);
    public function listPackages($channel);
    public function __get($var);
    /**
     * @return PEAR2_Pyrus_PackageFile_v2
     */
    public function toPackageFile($package, $channel);
    /**
     * Retrieve a list of package objects that depend on this package
     */
    public function getDependentPackages(PEAR2_Pyrus_Registry_Base $package);
}
<?php
/**
 * PEAR2_Pyrus_Log
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Standard logging class for Pyrus
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Log
{
    static public $log = array();
    static public $maxlevel = 7;
    static protected $observers = array();
    static public function log($level, $message)
    {
        if (count(self::$observers)) {
            foreach (self::$observers as $observer) {
                $observer->log($level, $message);
            }
        }
        for ($i = $level; $i <= self::$maxlevel; $i++) {
            self::$log[$i][] = $message;
        }
    }

    static public function attach(PEAR2_Pyrus_ILog $observer)
    {
        self::$observers[spl_object_hash($observer)] = $observer;
    }

    static public function detach(PEAR2_Pyrus_ILog $observer)
    {
        unset(self::$observers[spl_object_hash($observer)]);
    }
}<?php
/**
 * The PEAR2_Pyrus_OSGuess class
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR
 * @author     Stig Bakken <ssb@php.net>
 * @author     Gregory Beaver <cellog@php.net>
 * @copyright  1997-2007 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: Guess.php,v 1.25 2006/12/14 00:24:37 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Pyrus 0.1
 */

// {{{ uname examples

// php_uname() without args returns the same as 'uname -a', or a PHP-custom
// string for Windows.
// PHP versions prior to 4.3 return the uname of the host where PHP was built,
// as of 4.3 it returns the uname of the host running the PHP code.
//
// PC RedHat Linux 7.1:
// Linux host.example.com 2.4.2-2 #1 Sun Apr 8 20:41:30 EDT 2001 i686 unknown
//
// PC Debian Potato:
// Linux host 2.4.17 #2 SMP Tue Feb 12 15:10:04 CET 2002 i686 unknown
//
// PC FreeBSD 3.3:
// FreeBSD host.example.com 3.3-STABLE FreeBSD 3.3-STABLE #0: Mon Feb 21 00:42:31 CET 2000     root@example.com:/usr/src/sys/compile/CONFIG  i386
//
// PC FreeBSD 4.3:
// FreeBSD host.example.com 4.3-RELEASE FreeBSD 4.3-RELEASE #1: Mon Jun 25 11:19:43 EDT 2001     root@example.com:/usr/src/sys/compile/CONFIG  i386
//
// PC FreeBSD 4.5:
// FreeBSD host.example.com 4.5-STABLE FreeBSD 4.5-STABLE #0: Wed Feb  6 23:59:23 CET 2002     root@example.com:/usr/src/sys/compile/CONFIG  i386
//
// PC FreeBSD 4.5 w/uname from GNU shellutils:
// FreeBSD host.example.com 4.5-STABLE FreeBSD 4.5-STABLE #0: Wed Feb  i386 unknown
//
// HP 9000/712 HP-UX 10:
// HP-UX iq B.10.10 A 9000/712 2008429113 two-user license
//
// HP 9000/712 HP-UX 10 w/uname from GNU shellutils:
// HP-UX host B.10.10 A 9000/712 unknown
//
// IBM RS6000/550 AIX 4.3:
// AIX host 3 4 000003531C00
//
// AIX 4.3 w/uname from GNU shellutils:
// AIX host 3 4 000003531C00 unknown
//
// SGI Onyx IRIX 6.5 w/uname from GNU shellutils:
// IRIX64 host 6.5 01091820 IP19 mips
//
// SGI Onyx IRIX 6.5:
// IRIX64 host 6.5 01091820 IP19
//
// SparcStation 20 Solaris 8 w/uname from GNU shellutils:
// SunOS host.example.com 5.8 Generic_108528-12 sun4m sparc
//
// SparcStation 20 Solaris 8:
// SunOS host.example.com 5.8 Generic_108528-12 sun4m sparc SUNW,SPARCstation-20
//
// Mac OS X (Darwin)
// Darwin home-eden.local 7.5.0 Darwin Kernel Version 7.5.0: Thu Aug  5 19:26:16 PDT 2004; root:xnu/xnu-517.7.21.obj~3/RELEASE_PPC  Power Macintosh
//
// Mac OS X early versions
//

// }}}

/* TODO:
 * - define endianness, to allow matchSignature("bigend") etc.
 */

/**
 * Retrieves information about the current operating system
 *
 * This class uses php_uname() to grok information about the current OS
 *
 * @category   pear
 * @package    PEAR
 * @author     Stig Bakken <ssb@php.net>
 * @author     Gregory Beaver <cellog@php.net>
 * @copyright  1997-2005 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 0.1
 */
class PEAR2_Pyrus_OSGuess
{
    var $sysname;
    var $nodename;
    var $cpu;
    var $release;
    var $extra;

    function __construct($uname = null)
    {
        list($this->sysname,
             $this->release,
             $this->cpu,
             $this->extra,
             $this->nodename) = $this->parseSignature($uname);
    }

    function parseSignature($uname = null)
    {
        static $sysmap = array(
            'HP-UX' => 'hpux',
            'IRIX64' => 'irix',
        );
        static $cpumap = array(
            'i586' => 'i386',
            'i686' => 'i386',
            'ppc' => 'powerpc',
        );
        if ($uname === null) {
            $uname = php_uname();
        }
        $parts = preg_split('/\s+/', trim($uname));
        $n = count($parts);

        $release = $machine = $cpu = '';
        $sysname = $parts[0];
        $nodename = $parts[1];
        $cpu = $parts[$n-1];
        $extra = '';
        if ($cpu == 'unknown') {
            $cpu = $parts[$n-2];
        }

        switch ($sysname) {
            case 'AIX' :
                $release = "$parts[3].$parts[2]";
                break;
            case 'Windows' :
                switch ($parts[1]) {
                    case '95/98':
                        $release = '9x';
                        break;
                    default:
                        $release = $parts[1];
                        break;
                }
                $cpu = 'i386';
                break;
            case 'Linux' :
                $extra = $this->_detectGlibcVersion();
                // use only the first two digits from the kernel version
                $release = preg_replace('/^([0-9]+\.[0-9]+).*/', '\1', $parts[2]);
                break;
            case 'Mac' :
                $sysname = 'darwin';
                $nodename = $parts[2];
                $release = $parts[3];
                if ($cpu == 'Macintosh') {
                    if ($parts[$n - 2] == 'Power') {
                        $cpu = 'powerpc';
                    }
                }
                break;
            case 'Darwin' :
                if ($cpu == 'Macintosh') {
                    if ($parts[$n - 2] == 'Power') {
                        $cpu = 'powerpc';
                    }
                }
                $release = ereg_replace('/^([0-9]+\.[0-9]+).*/', '\1', $parts[2]);
                break;
            default:
                $release = ereg_replace('-.*', '', $parts[2]);
                break;
        }


        if (isset($sysmap[$sysname])) {
            $sysname = $sysmap[$sysname];
        } else {
            $sysname = strtolower($sysname);
        }
        if (isset($cpumap[$cpu])) {
            $cpu = $cpumap[$cpu];
        }
        return array($sysname, $release, $cpu, $extra, $nodename);
    }

    private function _detectGlibcVersion()
    {
        static $glibc = false;
        if ($glibc !== false) {
            return $glibc; // no need to run this multiple times
        }
        $major = $minor = 0;
        // Use glibc's <features.h> header file to
        // get major and minor version number:
        if (@file_exists('/usr/include/features.h') &&
              @is_readable('/usr/include/features.h')) {
            if (!@file_exists('/usr/bin/cpp') || !@is_executable('/usr/bin/cpp')) {
                $features_file = fopen('/usr/include/features.h', 'rb');
                while (!feof($features_file)) {
                    $line = fgets($features_file, 8192);
                    if (!$line || (strpos($line, '#define') === false)) {
                        continue;
                    }
                    if (strpos($line, '__GLIBC__')) {
                        // major version number #define __GLIBC__ version
                        $line = preg_split('/\s+/', $line);
                        $glibc_major = trim($line[2]);
                        if (isset($glibc_minor)) {
                            break;
                        }
                        continue;
                    }
                    if (strpos($line, '__GLIBC_MINOR__'))  {
                        // got the minor version number
                        // #define __GLIBC_MINOR__ version
                        $line = preg_split('/\s+/', $line);
                        $glibc_minor = trim($line[2]);
                        if (isset($glibc_major)) {
                            break;
                        }
                        continue;
                    }
                }
                fclose($features_file);
                if (!isset($glibc_major) || !isset($glibc_minor)) {
                    return $glibc = '';
                }
                return $glibc = 'glibc' . trim($glibc_major) . "." . trim($glibc_minor) ;
            } // no cpp
            $tmpfile = tempnam(sys_get_temp_dir(), "glibctest");
            $fp = fopen($tmpfile, "w");
            fwrite($fp, "#include <features.h>\n__GLIBC__ __GLIBC_MINOR__\n");
            fclose($fp);
            $cpp = popen("/usr/bin/cpp $tmpfile", "r");
            while ($line = fgets($cpp, 1024)) {
                if ($line{0} == '#' || trim($line) == '') {
                    continue;
                }
                if (list($major, $minor) = explode(' ', trim($line))) {
                    break;
                }
            }
            pclose($cpp);
            unlink($tmpfile);
        } // features.h
        if (!($major && $minor) && @is_link('/lib/libc.so.6')) {
            // Let's try reading the libc.so.6 symlink
            if (ereg('^libc-(.*)\.so$', basename(readlink('/lib/libc.so.6')), $matches)) {
                list($major, $minor) = explode('.', $matches[1]);
            }
        }
        if (!($major && $minor)) {
            return $glibc = '';
        }
        return $glibc = "glibc{$major}.{$minor}";
    }

    function getSignature()
    {
        if (empty($this->extra)) {
            return "{$this->sysname}-{$this->release}-{$this->cpu}";
        }
        return "{$this->sysname}-{$this->release}-{$this->cpu}-{$this->extra}";
    }

    function getSysname()
    {
        return $this->sysname;
    }

    function getNodename()
    {
        return $this->nodename;
    }

    function getCpu()
    {
        return $this->cpu;
    }

    function getRelease()
    {
        return $this->release;
    }

    function getExtra()
    {
        return $this->extra;
    }

    function matchSignature($match)
    {
        if (is_array($match)) {
            $fragments = $match;
        } else {
            $fragments = explode('-', $match);
        }
        $n = count($fragments);
        $matches = 0;
        if ($n > 0) {
            $matches += $this->_matchFragment($fragments[0], $this->sysname);
        }
        if ($n > 1) {
            $matches += $this->_matchFragment($fragments[1], $this->release);
        }
        if ($n > 2) {
            $matches += $this->_matchFragment($fragments[2], $this->cpu);
        }
        if ($n > 3) {
            $matches += $this->_matchFragment($fragments[3], $this->extra);
        }
        return ($matches == $n);
    }

    function _matchFragment($fragment, $value)
    {
        if (strcspn($fragment, '*?') < strlen($fragment)) {
            $reg = '/^' . str_replace(array('*', '?', '/'), array('.*', '.', '\\/'), $fragment) . '\\z/';
            return preg_match($reg, $value);
        }
        return ($fragment == '*' || !strcasecmp($fragment, $value));
    }

}
/*
 * Local Variables:
 * indent-tabs-mode: nil
 * c-basic-offset: 4
 * End:
 */
?>
<?php
/**
 * PEAR2_Pyrus_Package
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Abstract representation of a package
 *
 * specific package types are:
 *
 * - package.xml
 * - package.tgz/package.tar
 * - package.phar
 * - remote undownloaded package
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package implements IteratorAggregate, ArrayAccess
{
    /**
     * The actual package representation
     *
     * @var PEAR2_Pyrus_Package_Xml|PEAR2_Pyrus_Package_Tar|PEAR2_Pyrus_Package_Phar
     */
    protected $internal;
    protected $from;

    function __construct($packagedescription, $forceremote = false)
    {
        if ($forceremote) {
            $this->internal = new PEAR2_Pyrus_Package_Remote($packagedescription);
        } else {
            $class = $this->_parsePackageDescription($packagedescription);
            $this->internal = new $class($packagedescription, $this);
        }
    }

    function setFrom($from)
    {
        $this->from = $from;
    }

    function __get($var)
    {
        return $this->internal->$var;
    }

    function __call($func, $args)
    {
        // delegate to the internal object
        return call_user_func_array(array($this->internal, $func), $args);
    }

    function getFileContents($file, $asstream = false)
    {
        return $this->internal->getFileContents($file, $asstream);
    }

    function getFilePath($file)
    {
        return $this->internal->getFilePath($file);
    }

    function isNewPackage()
    {
        return $this->internal->isNewPackage();
    }

    function getFrom()
    {
        if ($this->from) {
            return $this->from->getFrom();
        }
        return $this;
    }

    function getLocation()
    {
        return $this->internal->getLocation();
    }

    function getInternalPackage()
    {
        return $this->internal;
    }

    function __toString()
    {
        return $this->internal->__toString();
    }

    function getIterator()
    {
        return $this->internal;
    }

    function offsetExists($offset)
    {
        return isset($this->internal[$offset]);
    }

    function offsetGet($offset)
    {
        return $this->internal[$offset];
    }

    function offsetSet($offset, $value)
    {
        $this->internal[$offset] = $value;
    }

    function offsetUnset($offset)
    {
        unset($this->internal[$offset]);
    }

    function isRemote()
    {
        return $this->internal instanceof PEAR2_Pyrus_Package_Remote;
    }

    function download()
    {
        if ($this->internal instanceof PEAR2_Pyrus_Package_Remote) {
            $this->internal = $this->internal->download();
        }
    }

    function _parsePackageDescription($package)
    {
        if (strpos($package, 'http://') === 0) {
            return 'PEAR2_Pyrus_Package_Remote';
        }
        try {
            if (@file_exists($package) && @is_file($package)) {
                $info = pathinfo($package);
                if (!isset($info['extension']) || !strlen($info['extension'])) {
                    // guess based on first 4 characters
                    $f = @fopen($package, 'r');
                    if ($f) {
                        $first4 = fread($f, 4);
                        fclose($f);
                        if ($first4 == '<?xml') {
                            return 'PEAR2_Pyrus_Package_Xml';
                        }
                        return 'PEAR2_Pyrus_Package_Tar';
                    }
                } else {
                    if (extension_loaded('phar') && strtolower($info['extension']) != 'xml') {
                        return 'PEAR2_Pyrus_Package_Phar';
                    }
                    switch (strtolower($info['extension'])) {
                        case 'xml' :
                            return 'PEAR2_Pyrus_Package_Xml';
                        case 'zip' :
                            return 'PEAR2_Pyrus_Package_Zip';
                        case 'tar' :
                        case 'tgz' :
                            return 'PEAR2_Pyrus_Package_Tar';
                        case 'phar' :
                            return 'PEAR2_Pyrus_Package_Phar';
                    }
                }
            }
            $info = PEAR2_Pyrus_Config::parsePackageName($package);
            return 'PEAR2_Pyrus_Package_Remote';
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Package_Exception('package "' . $package . '" is unknown', $e);
        }
    }
}
<?php
/**
 * PEAR2_Pyrus_Package_Base
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for representing a package in Pyrus
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
abstract class PEAR2_Pyrus_Package_Base implements PEAR2_Pyrus_IPackage
{
    protected $packagefile;
    /**
     * The original source of this package
     *
     * This is a chain documenting the steps it took to get this
     * package instantiated, for instance Tar->Abstract
     * @var PEAR2_Pyrus_IPackage
     */
    protected $from;

    function __construct(PEAR2_Pyrus_PackageFile $packagefile, $parent = null)
    {
        $this->packagefile = $packagefile;
        $this->from = $parent;
    }

    /**
     * Used to determine whether <install as> tags are necessary for
     * PEAR2-style packages
     *
     * @return bool
     */
    function isNewPackage()
    {
        return true;
    }

    function setFrom(PEAR2_Pyrus_IPackage $from)
    {
        $this->from = $from;
    }

    function getFrom()
    {
        if ($this->from) {
            return $this->from->getFrom();
        }
        return $this;
    }

    /**
     * Sort files/directories for removal
     *
     * Files are always removed first, followed by directories in
     * path order
     * @param unknown_type $a
     * @param unknown_type $b
     * @return unknown
     */
    static function sortstuff($a, $b)
    {
        // files can be removed in any order
        if (is_file($a) && is_file($b)) return 0;
        if (is_dir($a) && is_file($b)) return 1;
        if (is_dir($b) && is_file($a)) return -1;
        $countslasha = substr_count($a, DIRECTORY_SEPARATOR);
        $countslashb = substr_count($b, DIRECTORY_SEPARATOR);
        if ($countslasha > $countslashb) return -1;
        if ($countslashb > $countslasha) return 1;
        // if not subdirectories, tehy can be removed in any order
        return 0;
    }

    /**
     * Create vertices/edges of a directed graph for dependencies of this package
     *
     * Iterate over dependencies and create edges from this package to those it
     * depends upon
     * @param PEAR2_Pyrus_DirectedGraph $graph
     * @param array $packages channel/package indexed array of PEAR2_Pyrus_Package objects
     */
    function makeConnections(PEAR2_Pyrus_DirectedGraph $graph, array $packages)
    {
        $graph->add($this->getFrom());
        foreach (array('required', 'optional') as $required) {
            foreach (array('package', 'subpackage') as $package) {
                foreach ($this->dependencies->$required->$package as $d) {
                    if (isset($d['conflicts'])) {
                        continue;
                    }
                    $dchannel = isset($d['channel']) ? $d['channel'] : '__uri';
                    if (isset($packages[$dchannel . '/' . $d['name']])) {
                        $graph->connect($this, $packages[$dchannel . '/' . $d['name']]);
                    }
                }
            }
        }
        foreach ($this->dependencies->group as $group) {
            foreach (array('package', 'subpackage') as $package) {
                foreach ($group->$package as $d) {
                    if (isset($d['conflicts'])) {
                        continue;
                    }
                    $dchannel = isset($d['channel']) ? $d['channel'] : '__uri';
                    if (isset($packages[$dchannel . '/' . $d['name']])) {
                        $graph->connect($this, $packages[$dchannel . '/' . $d['name']]);
                    }
                }
            }
        }
    }

    function offsetExists($offset)
    {
        return $this->packagefile->info->hasFile($offset);
    }

    function offsetGet($offset)
    {
        if (strpos($offset, 'contents://') === 0) {
            return $this->getFileContents(substr($offset, 11));
        }
        return $this->packagefile->info->getFile($offset);
    }

    function offsetSet($offset, $value)
    {
        return;
    }

    function offsetUnset($offset)
    {
        return;
    }

    function current()
    {
        return key($this->packagefile->info->_packageInfo['filelist']);
    }

    function key()
    {
        return 1;
    }

    function next()
    {
        next($this->packagefile->info->_packageInfo['filelist']);
    }

    function rewind()
    {
        reset($this->packagefile->info->_packageInfo['filelist']);
    }

    function getPackageFile()
    {
        return $this->packagefile;
    }

    function __call($func, $args)
    {
        // delegate to the internal object
        return call_user_func_array(array($this->packagefile->info, $func), $args);
    }

    function __get($var)
    {
        return $this->packagefile->info->$var;
    }

    function __toString()
    {
        return $this->packagefile->__toString();
    }

    function valid()
    {
        return key($this->packagefile->info->_packageInfo['filelist']);
    }

    function getFileContents($file, $asstream = false)
    {
        return $asstream ?
            fopen($this->getFilePath($file), 'rb') :
            file_get_contents($this->getFilePath($file));
    }
}
<?php
/**
 * PEAR2_Pyrus_Package_Creator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Create packages using provided renderers.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Creator
{
    const VERSION = '2.0.0a1';
    private $_creators;
    private $_handles = array();
    /**
     * Begin package creation
     *
     * @param array|PEAR2_Pyrus_Package_ICreator $creators
     */
    function __construct($creators, $pear2ExceptionPath = false, $pear2AutoloadPath = false,
                         $pear2MultiErrorsPath = false)
    {
        if (!$pear2ExceptionPath) {
            if (!($pear2Exception = @fopen('PEAR2/Exception.php', 'r', true))) {
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/Exception.php, please' .
                    ' pass in the path to the constructor');
            }
        } else {
            if (!($pear2Exception = @fopen($pear2ExceptionPath, 'r', true))) {
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/Exception.php' .
                    'in ' . $pear2ExceptionPath);
            }
        }
        if (!$pear2AutoloadPath) {
            if (!($pear2Autoload = @fopen('PEAR2/Autoload.php', 'r', true))) {
                fclose($pear2Exception);
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/Autoload.php, please' .
                    ' pass in the path to the constructor');
            }
        } else {
            if (!($pear2Autoload = @fopen($pear2AutoloadPath, 'r', true))) {
                fclose($pear2Exception);
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/Autoload.php' .
                    'in ' . $pear2AutoloadPath);
            }
        }
        if (!$pear2MultiErrorsPath) {
            if (!($pear2MultiErrors = @fopen('PEAR2/MultiErrors.php', 'r', true))) {
                fclose($pear2Exception);
                fclose($pear2Autoload);
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/MultiErrors.php, please' .
                    ' pass in the path to the constructor');
            }
        } else {
            if (!($pear2MultiErrors = @fopen($pear2MultiErrorsPath, 'r', true))) {
                fclose($pear2Exception);
                fclose($pear2Autoload);
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/MultiErrors.php' .
                    'in ' . $pear2MultiErrorsPath);
            }
        }
        $this->_handles['src/PEAR2/Autoload.php'] = $pear2Autoload;
        $this->_handles['src/PEAR2/MultiErrors.php'] = $pear2MultiErrors;
        $this->_handles['src/PEAR2/Exception.php'] = $pear2Exception;
        if ($creators instanceof PEAR2_Pyrus_Package_ICreator) {
            $this->_creators = array($creators);
        } elseif (is_array($creators)) {
            foreach ($creators as $creator) {
                if ($creator instanceof PEAR2_Pyrus_Package_ICreator) {
                    continue;
                }
                throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid ' .
                    'PEAR2 package creator passed into PEAR2_Pyrus_Package_Creator');
            }
            $this->_creators = $creators;
        } else {
            throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid ' .
                'PEAR2 package creator passed into PEAR2_Pyrus_Package_Creator');
        }
    }

    /**
     * Render packages from the creators passed into the constructor.
     *
     * This will take any package source and an array mapping internal
     * path => file name and create new packages in the formats requested.
     *
     * All files in package.xml will have the string 2.0.0a1
     * automatically replaced with the current package's version
     * @param PEAR2_Pyrus_Package $package
     * @param array $extrafiles
     */
    function render(PEAR2_Pyrus_Package $package, array $extrafiles = array())
    {
        foreach ($this->_creators as $creator) {
            $creator->init();
        }
        $packagexml = 'package-' . $package->channel . '-' . $package->name . '-' .
            $package->version['release'] . '.xml';
        if (self::VERSION === '@' . 'PACKAGE_VERSION@') {
            // we're running straight from SVN, so pretend to be 2.0.0
            $package->packagerversion = '2.0.0';
        } else {
            $package->packagerversion = self::VERSION;
        }
        $packageingstr = (string) new PEAR2_Pyrus_XMLWriter(
            $package->toArray(true)); // get packaging package.xml
        foreach ($this->_creators as $creator) {
            $creator->addFile($packagexml, $packageingstr);
        }
        // $packageat is the relative path within the archive
        // $info is an array of format:
        // array('attribs' => array('name' => ...)[, 'tasks:blah' ...])
        $alreadyPackaged = array();
        foreach ($package->packagingcontents as $packageat => $info) {
            $packageat = str_replace('\\', '/', $packageat);
            $packageat = str_replace('//', '/', $packageat);
            if ($packageat[0] === '/' ||
                  (strlen($packageat) > 2 && ($packageat[1] === ':' && $packageat[2] == '/'))) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid path, cannot' .
                    ' save a root path ' . $packageat);
            }
            if (preg_match('@^\.\.?/|/\.\.?\\z|/\.\./@', $packageat)) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid path, cannot' .
                    ' use directory reference . or .. ' . $packageat);
            }
            $alreadyPackaged[$packageat] = true;
            $contents = $package->getFileContents($info['attribs']['name']);
            $globalreplace = array('attribs' =>
                        array('from' => '@' . 'PACKAGE_VERSION@',
                              'to' => 'version',
                              'type' => 'package-info'));
            if (isset($info['tasks:replace'])) {
                if (isset($info['tasks:replace'][0])) {
                    $info['tasks:replace'][] = $globalreplace;
                } else {
                    $info['tasks:replace'] = array($info['tasks:replace'], $globalreplace);
                }
            } else {
                $info['tasks:replace'] = $globalreplace;
            }
            foreach (new PEAR2_Pyrus_Package_Creator_TaskIterator($info, $package) as
                     $task) {
                // do pre-processing of file contents
                try {
                    // TODO: get last installed version into that last "null"
                    $task[1]->init($task[0], $info['attribs'], null);
                    $newcontents = $task[1]->startSession($package, $contents, $packageat);
                    if ($newcontents) {
                        $contents = $newcontents;
                    }
                } catch (Exception $e) {
                    // TODO: handle exceptions
                }
            }
            foreach ($this->_creators as $creator) {
                $creator->mkdir(dirname($packageat));
                $creator->addFile($packageat, $contents);
            }
        }
        $creator->mkdir('src/PEAR2');
        foreach ($this->_handles as $path => $stream) {
            if (isset($alreadyPackaged[$path])) {
                continue; // we're packaging this package
            }
            foreach ($this->_creators as $creator) {
                $creator->addFile($path, $stream);
            }
            fclose($stream);
        }
        foreach ($this->_creators as $creator) {
            if (isset($alreadyPackaged['src/PEAR2/MultiErrors/Exception.php'])) {
                continue; // we're packaging MultiErrors package
            }
            $creator->mkdir('src/PEAR2/MultiErrors');
            $creator->addFile('src/PEAR2/MultiErrors/Exception.php',
                "<?php\nclass PEAR2_MultiErrors_Exception extends PEAR2_Exception {}");
        }
        foreach ($extrafiles as $path => $filename) {
            $path = str_replace('\\', '/', $path);
            $path = str_replace('//', '/', $path);
            if ($path[0] === '/' ||
                  (strlen($path) > 2 && ($path[1] === ':' && $path[2] == '/'))) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid path, cannot' .
                    ' save a root path ' . $path);
            }
            if (preg_match('@^\.\.?/|/\.\.?\\z|/\.\./@', $path)) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid path, cannot' .
                    ' use directory reference . or .. ' . $path);
            }
            if (isset($alreadyPackaged[$path])) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Path ' . $path .
                    'has already been added, and cannot be overwritten');
            }
            $alreadyPackaged[$path] = true;
            if (!@file_exists($filename) || !($fp = @fopen($filename, 'rb'))) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Extra file ' .
                    $filename . ' does not exist or cannot be read');
            }
            foreach ($this->_creators as $creator) {
                $creator->mkdir(dirname($path));
                $creator->addFile($path, $fp);
            }
            fclose($fp);
        }
        foreach ($this->_creators as $creator) {
            $creator->close();
        }
    }
}<?php
/**
 * PEAR2_Pyrus_Package_Creator_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for package creator
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Creator_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Package_Creator_TaskIterator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class which iterates over all the tasks to perform for package creation.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Creator_TaskIterator extends FilterIterator
{
    private $_inner;
    private $_parent;
    private $_tasksNs;
    function __construct(array $arr, PEAR2_Pyrus_Package $parent)
    {
        $this->_parent = $parent;
        $this->_tasksNs = $this->_parent->getTasksNs();
        parent::__construct($this->_inner = new ArrayIterator($arr));
    }

    function accept()
    {
        if (!$this->_inner->valid()) {
            return false;
        }
        if ($this->_inner->key() == 'attribs') {
            return false;
        }
        $key = $this->key();
        if (strpos($key, $this->_tasksNs . ':') !== 0) {
            return false;
        }
        return true;
    }

    function current()
    {
        $xml = parent::current();
        $task = 'PEAR2_Pyrus_Task_' .
            ucfirst(str_replace($this->_tasksNs . ':', '', $this->key()));
        $a = new $task(PEAR2_Pyrus_Config::current(), PEAR2_PYRUS_TASK_PACKAGE);
        return array($xml, $a);
    }
}<?php
/**
 * PEAR2_Pyrus_Package_Dependency
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class represents a package dependency.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Dependency extends PEAR2_Pyrus_Package_Remote
{
    protected $subpackage;
    protected $required;
    function __construct(array $dependency, PEAR2_Pyrus_Package $parent, $subpackage = false,
                         $required = false)
    {
        $this->subpackage = $subpackage;
        $this->required = $required;
        $dependency['package'] = $dependency['name'];
        parent::__construct($dependency, $parent);
    }

    function getPackageDownloadUrl($parr)
    {
        $curchannel = PEAR2_Pyrus_Config::current()->default_channel;
        if (isset($parr['uri'])) {
            try {
                $chan = PEAR2_Pyrus_Config::current()->channelregistry['__uri'];
            } catch (Exception $e) {
                throw new PEAR2_Pyrus_Package_Exception('Cannot retrieve download information ' .
                    'for remote abstract package ' . $parr['channel'] . '/' . $parr['package'], $e);
            }
            PEAR2_Pyrus_Config::current()->default_channel = $parr['channel'];
            try {
                $version = PEAR2_Pyrus_Config::current()->registry->info($parr['name'],
                    '__uri', 'version');
            } catch (Exception $e) {
                $version = null;
            }
        } else {
            $remotechannel = $parr['channel'];
            if (!isset(PEAR2_Pyrus_Config::current()->channelregistry[$remotechannel])) {
                do {
                    if (PEAR2_Pyrus_Config::current()->auto_discover) {
                        if (PEAR2_Pyrus_Config::current()->channelregistry->discover($remotechannel)) {
                            break;
                        }
                    }
                    PEAR2_Pyrus_Config::current()->default_channel = $curchannel;
                    throw new PEAR2_Pyrus_Package_Exception(
                        'Unknown remote channel: ' . $remotechannel);
                } while (false);
            }
            try {
                $chan = PEAR2_Pyrus_Config::current()->channelregistry[$remotechannel];
            } catch (Exception $e) {
                PEAR2_Pyrus_Config::current()->default_channel = $curchannel;
                throw new PEAR2_Pyrus_Package_Exception('Cannot retrieve download information ' .
                    'for remote abstract package ' . $remotechannel . '/' . $parr['name'], $e);
            }
            try {
                $version = PEAR2_Pyrus_Config::current()->registry->info($parr['name'],
                    $remotechannel, 'version');
            } catch (Exception $e) {
                $version = null;
            }
            PEAR2_Pyrus_Config::current()->default_channel = $remotechannel;
        }
        $state = isset($parr['state']) ? $parr['state'] : PEAR2_Pyrus_Config::current()
            ->preferred_state;
        if (isset($parr['state']) && isset($parr['version'])) {
            unset($parr['state']);
        }
        if (isset($parr['uri'])) {
            try {
                $info = new PEAR2_Pyrus_Package_Remote($parr['uri'], $this);
            } catch (Exception $e) {
                PEAR2_Pyrus_Config::current()->default_channel = $curchannel;
                throw new PEAR2_Pyrus_Package_Exception('Cannot process URI dependency ' .
                    $parr['uri'], $e);
            }
            return $info;
        }
        $base2 = false;
        $mirrors = $chan->mirrors;
        if (isset($mirrors[PEAR2_Pyrus_Config::current()->preferred_mirror])) {
            $chan = $mirrors[PEAR2_Pyrus_Config::current()->preferred_mirror];
        }
        if (!$chan->supportsREST() ||
              !(($base2 = $chan->getBaseURL('REST1.3')) ||
              ($base = $chan->getBaseURL('REST1.0')))) {
            PEAR2_Pyrus_Config::current()->default_channel = $curchannel;
            throw new PEAR2_Pyrus_Package_Exception('Cannot process dependency ' .
                'information remotely, ' .
                'channel ' . $chan->getName() . ' does not support REST');
        }
        if ($base2) {
            $rest = new PEAR2_Pyrus_REST_13;
            $base = $base2;
        } else {
            $rest = new PEAR2_Pyrus_REST_10;
        }
        try {
            $url = $rest->getDepDownloadURL($base, $parr, $parr,
                $state, $version);
        } catch (Exception $e) {
            PEAR2_Pyrus_Config::current()->default_channel = $curchannel;
            throw new PEAR2_Pyrus_Package_Exception('Cannot process dependency ' .
                $parr['channel'] . '/' . $parr['name'], $e);
        }
        if ($parr['channel'] != $curchannel) {
            PEAR2_Pyrus_Config::current()->default_channel = $curchannel;
        }
        if (!is_string($url['info'])) {
            throw new PEAR2_Pyrus_Package_Exception('Cannot process dependency ' .
                $parr['channel'] . '/' . $parr['name'] .
                ', invalid remote dependencies retrieved from REST - ' .
                'this should never happen');
        }
        $parser = new PEAR2_Pyrus_PackageFile_Parser_v2;
        $pf = $parser->parse($url['info'], false, 'PEAR2_Pyrus_PackageFile_v2_Remote');
        $url['info'] = $pf;
        return $url;
    }


    /**
     * @param array output of package.getDownloadURL
     * @param string|array|object information for detecting packages to be downloaded, and
     *                            for errors
     * @param array name information of the package
     * @param bool is this an optional dependency?
     * @param bool is this any kind of dependency?
     * @access private
     */
    function analyze($info, $param, $pname)
    {
        if (!$info) {
            // no releases exist
            if (!is_string($param)) {
                $saveparam = ", cannot download \"$param\"";
            } else {
                $saveparam = '';
            }
            throw new PEAR2_Pyrus_Package_Exception('No releases for package "' .
                PEAR2_Pyrus_Config::parsedPackageNameToString($pname, true) . '" exist' . $saveparam);
        }
        if (strtolower($info['info']->channel) != strtolower($pname['channel'])) {
            // downloaded package information claims it is from a different channel
            throw new PEAR2_Pyrus_Package_Exception(
                'SECURITY ERROR: package in channel "' . $pname['channel'] .
                '" retrieved another channel\'s name for download! ("' .
                $info['info']->channel . '")');
        }
        if (isset($info['url'])) {
            $this->checkDeprecated($info);
            return $info;
        }
        // package exists, no releases fit the criteria for downloading
        $reg = PEAR2_Pyrus_Config::current()->registry;
        if (isset($reg->package[$info['info']->channel . '/' . $info['info']->name])) {
            // package is already installed
            $reginfo = $reg->package[$info['info']->channel . '/' . $info['info']->name];
            if (version_compare($info['version'],
                  $reginfo->version, '<=')) {
                // ignore bogus errors of "failed to download dependency"
                // if it is already installed and the one that would be
                // downloaded is older or the same version (PEAR Bug #7219)
                return false;
            }
        }
        $instead =  ', will instead download version ' . $info['version'] .
                    ', stability "' . $info['info']->state . '"';
        // releases exist, but we failed to get any
        if (isset(PEAR2_Pyrus_Installer::$options['force'])) {
            $this->analyzeForced($info, $param, $pname);
        } else {
            if (isset($info['php']) && $info['php']) {
                // package download failed because the package requires a higher PHP
                // version than our own
                throw new PEAR2_Pyrus_Package_Exception('Failed to download ' .
                    $pname['channel'] . '/' . $pname['package'] .
                    ', latest release is version ' . $info['php']['v'] .
                    ', but it requires PHP version "' .
                    $info['php']['m'] . '", use "' .
                    PEAR2_Pyrus_Config::parsedPackageNameToString(
                        array('channel' => $pname['channel'], 'package' => $pname['package'],
                        'version' => $info['php']['v'])) . '" to install');
            }
            // construct helpful error message
            if (!in_array($info['info']->stability['release'],
                  PEAR2_Pyrus_Installer::betterStates(
                  PEAR2_Pyrus_Config::current()->preferred_state, true))) {
                if (!$this->required) {
                    // don't spit out confusing error message, and don't die on
                    // optional dep failure!
                    return $this->getPackageDownloadUrl(
                        array('package' => $pname['package'],
                              'channel' => $pname['channel'],
                              'version' => $info['version']));
                }
                $vs = ' within preferred state "' . PEAR2_Pyrus_Config::current()->preferred_state .
                    '"';
            } else {
                if (!$this->required) {
                    // don't spit out confusing error message, and don't die on
                    // optional dep failure!
                    return $this->getPackageDownloadUrl(
                        array('package' => $pname['package'],
                              'channel' => $pname['channel'],
                              'version' => $info['version']));
                }
                $vs = PEAR2_Pyrus_Dependency_Validator::_getExtraString($pname);
            }
            // this is only set by the "download-all" command
            if (isset(PEAR2_Pyrus_Installer::$options['ignorepreferred_state'])) {
                throw new PEAR2_Pyrus_Package_Exception(
                    'Failed to download ' . $pname['channel'] . '/' . $pname['package'] . '-'
                     . $vs .
                    ', latest release is version ' . $info['version'] .
                    ', stability "' . $info['info']->stability['release'] . '", use "' .
                    $pname['channel'] . '/' . $pname['package'] . '-' .
                    $info['version'] . '" to install');
            }
            throw new PEAR2_Pyrus_Package_Exception(
                'Failed to download ' . $pname['channel'] . '/' . $pname['package']
                 . $vs .
                ', latest release is version ' . $info['version'] .
                ', stability "' . $info['info']->stability['release'] . '", use "' .
                $pname['channel'] . '/' . $pname['package'] . '-' .
                $info['version'] . '" to install');
        }
        $this->checkDeprecated($info);
        return $info;
    }

    function analyzeForced($info, $param, $pname)
    {
        if (!in_array($info['info']->stability['release'],
              PEAR2_Pyrus_Installer::betterStates(
              PEAR2_Pyrus_Config::current()->preferred_state, true))) {
            if (!$this->required) {
                // don't spit out confusing error message
                return $this->getPackageDownloadUrl(
                    array('package' => $pname['package'],
                          'channel' => $pname['channel'],
                          'version' => $info['version']));
            }
            $vs = ' within preferred state "' . PEAR2_Pyrus_Config::current()->preferred_state .
                '"';
        } else {
            if (!$this->required) {
                // don't spit out confusing error message
                return $this->getPackageDownloadUrl(
                    array('package' => $pname['package'],
                          'channel' => $pname['channel'],
                          'version' => $info['version']));
            }
            $vs = PEAR2_Pyrus_Dependency_Validator::_getExtraString($pname);
            $instead = '';
        }
        if (!isset(PEAR2_Pyrus_Installer::$options['soft'])) {
            PEAR2_Pyrus_Log::log(1, 'WARNING: failed to download ' . $pname['channel'] .
                '/' . $pname['package'] . $vs . $instead);
        }
        // download the latest release
        return $this->getPackageDownloadUrl(
            array('package' => $pname['package'],
                  'channel' => $pname['channel'],
                  'version' => $info['version']));
    }
}<?php
/**
 * PEAR2_Pyrus_Package_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Package_ICreator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for a Package creator.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_Package_ICreator
{
    /**
     * save a file inside this package
     * @param string relative path within the package
     * @param string|resource file contents or open file handle
     */
    function addFile($path, $filename);
    /**
     * Initialize the package creator
     */
    function init();
    /**
     * Create an internal directory, creating parent directories as needed
     * @param string $dir
     */
    function mkdir($dir);
    /**
     * Finish saving the package
     */
    function close();
}<?php
/**
 * PEAR2_Pyrus_Package_InstalledException
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for installed packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_InstalledException extends PEAR2_Pyrus_Package_Exception {}<?php
/**
 * PEAR2_Pyrus_Package_Phar
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/PEAR2/Pyrus/
 */

/**
 * Class for phar packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/PEAR2/Pyrus/
 */
class PEAR2_Pyrus_Package_Phar extends PEAR2_Pyrus_Package_Base
{
    private $_packagename;
    static private $_tempfiles = array();
    private $_tmpdir;
    private $_BCpackage = false;

    /**
     * @param string $package path to package file
     */
    function __construct($package, PEAR2_Pyrus_Package $parent)
    {
        $package = realpath($package);
        if (!$package) {
            throw new PEAR2_Pyrus_Package_Phar_Exception(
                'Phar package ' . $package . ' does not exist');
        }
        if (!class_exists('Phar')) {
            throw new PEAR2_Pyrus_Package_Phar_Exception(
                'Phar extension is not available');
        }
        $this->_packagename = $package;
        try {
            if (Phar::isValidPharFilename($package, 1)) {
                $phar = new Phar($package, RecursiveDirectoryIterator::KEY_AS_FILENAME);
            } else {
                $phar = new PharData($package, RecursiveDirectoryIterator::KEY_AS_FILENAME);
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Package_Phar_Exception('Could not open Phar archive ' .
                $package, $e);
        }
        $package = str_replace('\\', '/', $package);
        $where = (string) PEAR2_Pyrus_Config::current()->temp_dir;
        $where = str_replace('\\', '/', $where);
        $where = str_replace('//', '/', $where);
        $where = str_replace('/', DIRECTORY_SEPARATOR, $where);
        if (!file_exists($where)) {
            mkdir($where, 0777, true);
        }
        $where = realpath($where);
        if (dirname($where . 'a') == $where) {
            $where = substr($where, 0, strlen($where) - 1);
        }
        $this->_tmpdir = $where;
        try {
            $pxml = $phar->getMetaData();
            $phar->extractTo($where, null, true);
            if (!$pxml) {
                foreach (new RecursiveIteratorIterator($phar,
                            RecursiveIteratorIterator::LEAVES_ONLY) as $file) {
                    $filename = $file->getFileName();
                    if (preg_match('/^package\-.+\-\\d+(?:\.\d+)*(?:[a-zA-Z]+\d*)?.xml$/',
                          $filename)) {
                        $pxml = str_replace('phar://' . $phar->getPath(), '',
                                            $file->getPathName());
                        break;
                    } elseif ($filename == 'package2.xml') {
                        $this->_BCpackage = true;
                        $pxml = str_replace('phar://' . $phar->getPath(), '',
                                            $file->getPathName());
                        break;
                    } elseif ($filename == 'package.xml') {
                        $this->_BCpackage = true;
                        $pxml = str_replace('phar://' . $phar->getPath(), '',
                                            $file->getPathName());
                    }
                }
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Package_Phar_Exception('Could not extract Phar archive ' .
                $package, $e);
        }
        parent::__construct(new PEAR2_Pyrus_PackageFile($where . DIRECTORY_SEPARATOR . $pxml), $parent);
    }

    function __destruct()
    {
        usort(self::$_tempfiles, array('PEAR2_Pyrus_Package_Base', 'sortstuff'));
        foreach (self::$_tempfiles as $fileOrDir) {
            if (!file_exists($fileOrDir)) continue;
            if (is_file($fileOrDir)) {
                unlink($fileOrDir);
            } elseif (is_dir($fileOrDir)) {
                rmdir($fileOrDir);
            }
        }
    }

    private static function _addTempFile($file)
    {
        self::$_tempfiles[] = $file;
    }

    private static function _addTempDirectory($dir)
    {
        do {
            self::$_tempfiles[] = $dir;
            $dir = dirname($dir);
        } while (!file_exists($dir));
    }

    function getTarballPath()
    {
        return $this->_packagename;
    }

    function getLocation()
    {
        return $this->_tmpdir;
    }

    function isNewPackage()
    {
        return !$this->_BCpackage;
    }

    function __get($var)
    {
        if ($var === 'archivefile') {
            return $this->_packagename;
        }
        return parent::__get($var);
    }

    function getFilePath($file)
    {
        if (!isset($this->packagefile->info->files[$file])) {
            throw new PEAR2_Pyrus_Package_Exception('file ' . $file . ' is not in package.xml');
        }
        $extract = '';
        if ($this->_BCpackage) {
            // old fashioned PEAR 1.x packages put everything in Package-Version/
            // directory
            $extract = DIRECTORY_SEPARATOR . $this->packagefile->info->name . '-' .
                $this->packagefile->info->version['release'];
        }
        $extract = $this->_tmpdir . $extract . DIRECTORY_SEPARATOR . $file;
        $extract = str_replace('\\', '/', $extract);
        $extract = str_replace('//', '/', $extract);
        $extract = str_replace('/', DIRECTORY_SEPARATOR, $extract);
        return $extract;
    }
}
<?php
/**
 * PEAR2_Pyrus_Package_Phar_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Phar packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Phar_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Package_Remote
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class representing a remote package
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Remote extends PEAR2_Pyrus_Package
{
    private $_info;
    protected $downloadInfo;
    /**
     * @param string $package path to package file
     */
    function __construct($package, PEAR2_Pyrus_Package $parent)
    {
        $this->_info = $package;
        if (!is_array($package) &&
              (preg_match('#^(http[s]?|ftp[s]?)://#', $package))) {
            $this->internal = $this->_fromUrl($package);
        } else {
            $this->internal = $this->_fromString($package);
        }
        $this->from = $parent;
    }

    /**
     * Convert this remote packagefile into a local .tar, .tgz or .phar
     *
     * @return PEAR2_Pyrus_Package_Base
     */
    function download()
    {
        if ($this->_type === 'url') {
            return $this->internal;
        }

        $internal = $this->internal;
        // first try to download zip, then tgz, then tar
        $errs = new PEAR2_MultiErrors;
        try {
            $this->internal = new PEAR2_Pyrus_Package_Remote(
                $this->downloadInfo['url'] . '.tgz', $this);
        } catch (Exception $e) {
            $errs->E_ERROR[] = $e;
        }
        if (isset($e)) {
            unset($e);
            try {
                $this->internal = new PEAR2_Pyrus_Package_Remote(
                    $this->downloadInfo['url'] . '.tar', $this);
            } catch (Exception $e) {
                $errs->E_ERROR[] = $e;
            }
        }
        if (isset($e)) {
            unset($e);
            try {
                $this->internal = new PEAR2_Pyrus_Package_Remote(
                    $this->downloadInfo['url'] . '.zip', $this);
            } catch (Exception $e) {
                $errs->E_ERROR[] = $e;
                throw new PEAR2_Pyrus_Package_Exception(
                    'Could not download abstract package ' .
                    $this->downloadInfo['info']->channel . '/' .
                    $this->downloadInfo['info']->name, $errs);
            }
        }
        $this->internal->setFrom($internal);
        return $this->internal;
    }

    private function _fromUrl($param, $saveparam = '')
    {
        $this->_type = 'url';
        // for now, we'll use without callback
//            $callback = $this->_downloader->ui ?
//                array(&$this->_downloader, '_downloadCallback') : null;
        $dir = PEAR2_Pyrus_Config::current()->download_dir;
        try {
            $http = new PEAR2_HTTP_Request($param);
            $response = $http->sendRequest();
            $name = 'unknown.tgz';
            if ($response->code == '200') {
                if (isset($response->headers['content-disposition'])) {
                    if (preg_match('/filename="(.+)"/', $response->headers['content-disposition'], $match)) {
                        $name = $match[1];
                    }
                }
                if (!@file_exists($dir)) {
                    mkdir($dir, 0755, true);
                }
                file_put_contents($dir . DIRECTORY_SEPARATOR . $name, $response->body);
            } else {
                throw new PEAR2_Pyrus_Package_Exception('Download failed, received ' . $response->code);
            }
            // whew, download worked!
            $a = new PEAR2_Pyrus_Package($dir . DIRECTORY_SEPARATOR . $name);
            return $a->getInternalPackage();
        } catch (Exception $e) {
            if (!empty($saveparam)) {
                $saveparam = ", cannot download \"$saveparam\"";
            }
            throw new PEAR2_Pyrus_Package_Exception('Could not download from "' . $param .
                '"' . $saveparam, $e);
        }
    }

    /**
     *
     * @param string|array pass in an array of format
     *                     array(
     *                      'package' => 'pname',
     *                     ['channel' => 'channame',]
     *                     ['version' => 'version',]
     *                     ['state' => 'state',])
     *                     or a string of format [channame/]pname[-version|-state]
     */
    private function _fromString($param)
    {
        try {
            $pname = PEAR2_Pyrus_Config::parsePackageName($param, true);
        } catch (Exception $e) {
            if ($e->why !== 'channel') {
                throw new PEAR2_Pyrus_Package_Exception('Cannot process remote package', $e);
            }
//            if ($this->_downloader->discover($param['channel'])) {
                if (PEAR2_Pyrus_Config::current()->auto_discover) {
                    try {
                        $pname =
                        PEAR2_Pyrus_Config::parsePackageName($param,
                                PEAR2_Pyrus_Config::current()->default_channel);
                    } catch (Exception $e) {
                        if (is_array($param)) {
                            $param =
                              PEAR2_Pyrus_Config::parsedPackageNameToString($param);
                        }
                        throw new PEAR2_Pyrus_Package_Exception(
                            'invalid package name/package file "' . $param . '"', $e);
                    }
                } else {
//                    if (!isset($options['soft'])) {
                        PEAR2_Pyrus_Log::log(0, 'Channel "' . $param['channel'] .
                            '" is not initialized, use ' .
                            '"pyrus channel-discover ' . $param['channel'] . '" to initialize' .
                            'or pyrus config-set auto_discover 1');
//                    }
                }
//            } else {
//                throw new PEAR2_Pyrus_Package_Exception(
//                    'invalid package name/package file "' . $param . '"', $e);
//            }
        }
        $this->_parsedname = $pname;
        if (isset($pname['state'])) {
            $this->_explicitState = $pname['state'];
        } else {
            $this->_explicitState = false;
        }
        if (isset($pname['group'])) {
            $this->_explicitGroup = true;
        } else {
            $this->_explicitGroup = false;
        }
        $info = $this->getPackageDownloadUrl($pname);
        $this->analyze($info, $param, $pname);
        $this->downloadInfo = $info;
        return $info['info'];
    }

    /**
     * @param array output of {@link parsePackageName()}
     * @access private
     */
    function getPackageDownloadUrl($parr)
    {
        $curchannel = PEAR2_Pyrus_Config::current()->default_channel;
        PEAR2_Pyrus_Config::current()->default_channel = $parr['channel'];
        // getDownloadURL returns an array.  On error, it only contains information
        // on the latest release as array(version, info).  On success it contains
        // array(version, info, download url string)
        $state = isset($parr['state']) ? $parr['state'] :  PEAR2_Pyrus_Config::current()->preferred_state;
        if (!isset(PEAR2_Pyrus_Config::current()->channelregistry[$parr['channel']])) {
            do {
                if (PEAR2_Pyrus_Config::current()->auto_discover) {
                    if (PEAR2_Pyrus_Config::current()->channelregistry->discover($parr['channel'])) {
                        break;
                    }
                }
                PEAR2_Pyrus_Config::current()->default_channel = $curchannel;
                throw new PEAR2_Pyrus_Package_Exception(
                    'Unknown remote channel: ' . $remotechannel);
            } while (false);
        }
        try {
            $chan = PEAR2_Pyrus_Config::current()->channelregistry[$parr['channel']];
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Package_Exception('Cannot retrieve download information ' .
                'for remote abstract package ' . $parr['channel'] . '/' . $parr['package'], $e);
        }
        try {
            $version = PEAR2_Pyrus_Config::current()->registry->info($parr['package'],
                $parr['channel'], 'version');
        } catch (Exception $e) {
            $version = null;
        }
        $base2 = false;
        $mirrors = $chan->mirrors;
        if (isset($mirrors[PEAR2_Pyrus_Config::current()->preferred_mirror])) {
            $mirror = $mirrors[PEAR2_Pyrus_Config::current()->preferred_mirror];
        } else {
            $mirror = $chan;
        }
        if (!$mirror->supportsREST() ||
              !(($base2 = $mirror->getBaseURL('REST1.3')) ||
              ($base = $mirror->getBaseURL('REST1.0')))) {
            throw new PEAR2_Pyrus_Package_Exception('Cannot retrieve remote information, ' .
                'channel ' . $chan->getName() . ' does not support REST');
        }
        if ($base2) {
            $rest = new PEAR2_Pyrus_REST_13;
            $base = $base2;
        } else {
            $rest = new PEAR2_Pyrus_REST_10;
        }
        try {
            if (!isset($parr['version']) && !isset($parr['state']) && $version
                  && !isset(PEAR2_Pyrus_Installer::$options['downloadonly'])) {
                $url = $rest->getDownloadURL($base, $parr, $state, $version);
            } else {
                $url = $rest->getDownloadURL($base, $parr, $state, false);
            }
        } catch (Exception $e) {
            PEAR2_Pyrus_Config::current()->default_channel = $curchannel;
            throw new PEAR2_Pyrus_Package_Exception('Cannot retrieve download information ' .
            'for remote abstract package ' . $parr['channel'] . '/' . $parr['package'], $e);
        }
        if ($parr['channel'] != $curchannel) {
            PEAR2_Pyrus_Config::current()->default_channel = $curchannel;
        }
        $url['raw'] = false; // no checking is necessary for REST
        if (!is_string($url['info'])) {
            throw new PEAR2_Pyrus_Package_Exception(
                'Invalid remote dependencies retrieved from REST - ' .
                'this should never happen');
        }
        if (!isset(PEAR2_Pyrus_Installer::$options['force']) &&
              !isset(PEAR2_Pyrus_Installer::$options['downloadonly']) &&
              $version &&
              !isset($parr['group'])) {
            if (version_compare($version, $url['version'], '>=')) {
                throw new PEAR2_Pyrus_Package_InstalledException(
                    PEAR2_Pyrus_Config::parsedPackageNameToString($parr, true) .
                    ' is already installed and is newer than detected ' .
                    'release version ' . $url['version']);
            }
        }
        $parser = new PEAR2_Pyrus_PackageFile_Parser_v2;
        $pf = $parser->parse($url['info'], false, 'PEAR2_Pyrus_PackageFile_v2_Remote');
        $url['info'] = $pf;
        return $url;
    }

    /**
     * @param array output of package.getDownloadURL
     * @param string|array|object information for detecting packages to be downloaded, and
     *                            for errors
     * @param array name information of the package
     * @access private
     */
    function analyze($info, $param, $pname)
    {
        if (!$info) {
            // no releases exist
            if (!is_string($param)) {
                $saveparam = ", cannot download \"$param\"";
            } else {
                $saveparam = '';
            }
            throw new PEAR2_Pyrus_Package_Exception('No releases for package "' .
                PEAR2_Pyrus_Config::parsedPackageNameToString($pname, true) . '" exist' . $saveparam);
        }
        if (strtolower($info['info']->channel) != strtolower($pname['channel'])) {
            // downloaded package information claims it is from a different channel
            throw new PEAR2_Pyrus_Package_Exception(
                'SECURITY ERROR: package in channel "' . $pname['channel'] .
                '" retrieved another channel\'s name for download! ("' .
                $info['info']->channel . '")');
        }
        if (isset($info['url'])) {
            $this->checkDeprecated($info);
            return $info;
        }
        // package exists, no releases fit the criteria for downloading
        $reg = PEAR2_Pyrus_Config::current()->registry;
        if ($reginfo = $reg->exists($info['info']->package, $info['info']->channel)) {
            // package is already installedy
        }
        $instead =  ', will instead download version ' . $info['version'] .
                    ', stability "' . $info['info']->state . '"';
        // releases exist, but we failed to get any
        if (isset(PEAR2_Pyrus_Installer::$options['force'])) {
            $this->analyzeForced($info, $param, $pname);
        } else {
            if (isset($info['php']) && $info['php']) {
                // package download failed because the package requires a higher PHP
                // version than our own
                throw new PEAR2_Pyrus_Package_Exception('Failed to download ' .
                    $pname['channel'] . '/' . $pname['package'] .
                    ', latest release is version ' . $info['php']['v'] .
                    ', but it requires PHP version "' .
                    $info['php']['m'] . '", use "' .
                    PEAR2_Pyrus_Config::parsedPackageNameToString(
                        array('channel' => $pname['channel'], 'package' => $pname['package'],
                        'version' => $info['php']['v'])) . '" to install');
            }
            // construct helpful error message
            if (isset($pname['version'])) {
                $vs = ', version "' . $pname['version'] . '"';
            } elseif (isset($pname['state'])) {
                $vs = ', stability "' . $pname['state'] . '"';
            } else {
                $vs = ' within preferred state "' . PEAR2_Pyrus_Config::current()->preferred_state . '"';
            }
            // this is only set by the "download-all" command
            if (isset(PEAR2_Pyrus_Installer::$options['ignorepreferred_state'])) {
                throw new PEAR2_Pyrus_Package_Exception(
                    'Failed to download ' . $pname['channel'] . '/' . $pname['package'] . '-'
                     . $vs .
                    ', latest release is version ' . $info['version'] .
                    ', stability "' . $info['info']->stability['release'] . '", use "' .
                    $pname['channel'] . '/' . $pname['package'] . '-' .
                    $info['version'] . '" to install');
            }
            throw new PEAR2_Pyrus_Package_Exception(
                'Failed to download ' . $pname['channel'] . '/' . $pname['package']
                 . $vs .
                ', latest release is version ' . $info['version'] .
                ', stability "' . $info['info']->stability['release'] . '", use "' .
                $pname['channel'] . '/' . $pname['package'] . '-' .
                $info['version'] . '" to install');
        }
        $this->checkDeprecated($info);
        return $info;
    }

    function analyzeForced($info, $param, $pname)
    {
        if (isset($pname['version'])) {
            $vs = ', version "' . $pname['version'] . '"';
        } elseif (isset($pname['state'])) {
            $vs = ', stability "' . $pname['state'] . '"';
        } elseif ($param == 'dependency') {
            if (!in_array($info['info']->stability['release'],
                  PEAR2_Pyrus_Installer::betterStates(
                  PEAR2_Pyrus_Config::current()->preferred_state, true))) {
                $vs = ' within preferred state "' . PEAR2_Pyrus_Config::current()->preferred_state .
                    '"';
            } else {
                $vs = PEAR2_Pyrus_Dependency_Validator::_getExtraString($pname);
                $instead = '';
            }
        } else {
            $vs = ' within preferred state "' . $this->_config->get(
                'preferred_state') . '"';
        }
        if (!isset(PEAR2_Pyrus_Installer::$options['soft'])) {
            PEAR2_Pyrus_Log::log(1, 'WARNING: failed to download ' . $pname['channel'] .
                '/' . $pname['package'] . $vs . $instead);
        }
        // download the latest release
        return $this->getPackageDownloadUrl(
            array('package' => $pname['package'],
                  'channel' => $pname['channel'],
                  'version' => $info['version']));
    }

    function checkDeprecated($pname)
    {
        if (isset($pname['deprecated']) && $pname['deprecated']) {
            // package is deprecated in favor of another
            PEAR2_Pyrus_Log::log(0,
                'WARNING: "' .
                $pname['info']->channel . '/' . $pname['package'] . '-' .
                '" is deprecated in favor of "' .
                    PEAR2_Pyrus_Config::parsedPackageNameToString($pname['deprecated'], true) .
                '"');
        }
    }
}
<?php
/**
 * PEAR2_Pyrus_Package_Tar
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class for handling a tar package
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Tar extends PEAR2_Pyrus_Package_Base
{
    private $_fp;
    private $_packagename;
    private $_internalFileLength;
    private $_footerLength;
    private $_tmpdir;
    private $_BCpackage;
    static private $_tempfiles = array();

    /**
     * @param string $package path to package file
     */
    function __construct($package, PEAR2_Pyrus_Package $parent)
    {
        $this->_packagename = $package;
        $info = pathinfo($package);
        $streamfilters = stream_get_filters();
        $this->_fp = fopen($package, 'rb');
        switch ($info['extension']) {
            case 'tgz' :
                if ($this->_fp) {
                    fclose($this->_fp);
                    if (!function_exists('gzopen')) {
                        throw new PEAR2_Pyrus_Package_Tar_Exception('Cannot extract package '.
                            $package . ', PHP must have the zlib extension enabled --with-zlib.');
                    } else {
                        $this->_fp = gzopen($package, 'rb');
                    }
                }
                break;
            case 'tbz' :
                if (!in_array('bzip2.*', $streamfilters)) {
                    throw new PEAR2_Pyrus_Package_Tar_Exception('Cannot open package' .
                        $package . ', bzip2 decompression is not available');
                }
                stream_filter_append($this->_fp, 'bzip2.decompress');
        }
        if (!$this->_fp) {
            throw new PEAR2_Pyrus_Package_Tar_Exception('Cannot open package ' . $package);
        }
        $packagexml = $this->_extract();
        parent::__construct(new PEAR2_Pyrus_PackageFile($packagexml), $parent);
    }

    function __destruct()
    {
        usort(self::$_tempfiles, array('PEAR2_Pyrus_Package_Base', 'sortstuff'));
        foreach (self::$_tempfiles as $fileOrDir) {
            if (!file_exists($fileOrDir)) continue;
            if (is_file($fileOrDir)) {
                unlink($fileOrDir);
            } elseif (is_dir($fileOrDir)) {
                rmdir($fileOrDir);
            }
        }
    }

    function isNewPackage()
    {
        return !$this->_BCpackage;
    }

    private static function _addTempFile($file)
    {
        self::$_tempfiles[] = $file;
    }

    private static function _addTempDirectory($dir)
    {
        do {
            self::$_tempfiles[] = $dir;
            $dir = dirname($dir);
        } while (!file_exists($dir));
    }

    function getTarballPath()
    {
        return $this->_packagename;
    }

    function getLocation()
    {
        $ret = $this->_tmpdir;
        // support old packages
        if (file_exists($a = $ret . DIRECTORY_SEPARATOR .
              $this->packagefile->info->name . '-' .
              $this->packagefile->info->version['release'])) {;
            return $a;
        }
        return $ret;
    }

    function __get($var)
    {
        if ($var === 'archivefile') {
            return $this->_packagename;
        }
        return parent::__get($var);
    }

    function getFilePath($file)
    {
        if (!isset($this->packagefile->info->files[$file])) {
            throw new PEAR2_Pyrus_Package_Exception('file ' . $file . ' is not in package.xml');
        }
        $extract = '';
        if ($this->_BCpackage) {
            // old fashioned PEAR 1.x packages put everything in Package-Version/
            // directory
            $extract = $this->packagefile->info->name . '-' .
                $this->packagefile->info->version['release'];
        }
        $extract = $this->_tmpdir . $extract . DIRECTORY_SEPARATOR . $file;
        $extract = str_replace('\\', '/', $extract);
        $extract = str_replace('//', '/', $extract);
        $extract = str_replace('/', DIRECTORY_SEPARATOR, $extract);
        return $extract;
    }

    private function _processHeader($rawHeader)
    {
        if (strlen($rawHeader) < 512 || $rawHeader == pack("a512", "")) {
            throw new PEAR2_Pyrus_Package_Tar_Exception(
                'Error: "' . $this->_packagename . '" has corrupted tar header');
        }

        $header = unpack(
            "a100filename/a8mode/a8uid/a8gid/a12size/a12mtime/".
            "a8checksum/a1type/a100linkname/a6magic/a2version/".
            "a32uname/a32gname/a8devmajor/a8devminor/a155path",
            $rawHeader);
        $this->_internalFileLength = octdec($header['size']);
        if ($this->_internalFileLength % 512 == 0) {
            $this->_footerLength = 0;
        } else {
            $this->_footerLength = 512 - $this->_internalFileLength % 512;
        }
        return $header;
    }

    private function _readHeader($rawHeader)
    {
        if (!strlen($rawHeader)) {
            $this->_internalFileLength = $this->_footerLength = 0;
            return true;
        }

        if (strlen($rawHeader) != 512) {
            throw new PEAR2_Pyrus_Package_Tar_Exception(
                'Invalid block size : ' . strlen($rawHeader));
        }
        $header = $this->_processHeader($rawHeader);
        if ($header['type'] == 'L') {
            // filenames longer than 100 characters
            // borrowed from Archive_Tar written by Vincent Blavet
            $longFilename = '';
            $n = floor($header['size'] / 512);
            for ($i=0; $i < $n; $i++) {
                $content = fread($this->_fp, 512);
                $longFilename .= $content;
            }
            if (($header['size'] % 512) != 0) {
                $content = fread($this->_fp, 512);
                $longFilename .= $content;
            }
            // ----- Read the next header
            $newHeader = fread($this->_fp, 512);
            $header = $this->_processHeader($newHeader);
            $header['filename'] = trim($longFilename);
            $rawHeader = $newHeader;
        }
        if ($this->_maliciousFilename($header['filename'])) {
            throw new PEAR2_Pyrus_Package_Tar_Exception('Malicious .tar detected, file "' .
                $header['filename'] .
                '" will not install in desired directory tree');
        }

        $checksum = 256; // 8 * ord(' ');
        $c1 = str_split($rawHeader);
        $checkheader = array_merge(array_slice($c1, 0, 148), array_slice($c1, 156));
        if (!function_exists('_pear2tarchecksum')) {
            function _pear2tarchecksum($a, $b) {return $a + ord($b);}
        }
        $checksum += array_reduce($checkheader, '_pear2tarchecksum');

        // ----- Extract the checksum
        $header['checksum'] = octdec(trim($header['checksum']));
        if ($header['checksum'] != $checksum) {
            $header['filename'] = '';

            // ----- Look for last block (empty block)
            if (($checksum == 256) && ($header['checksum'] == 0)) {
                return true;
            }

            throw new PEAR2_Pyrus_Package_Tar_Exception(
                'Invalid checksum for header of file "' . $header['filename'] .
                '" : ' . $checksum . ' calculated, ' .
                $header['checksum'] . ' expected');
        }

        $header['filename'] = trim($header['filename']);
        $header['mode'] = octdec(trim($header['mode']));
        $header['uid'] = octdec(trim($header['uid']));
        $header['gid'] = octdec(trim($header['gid']));
        $header['size'] = octdec(trim($header['size']));
        $header['mtime'] = octdec(trim($header['mtime']));
        if ($header['type'] == '5') {
            $header['size'] = 0;
        }
        $header['linkname'] = trim($header['linkname']);
        return $header;
    }

    /**
     * Detect and report a malicious file name
     *
     * @param string $file
     * @return bool
     * @access private
     */
    private function _maliciousFilename($file)
    {
        if (strpos($file, '/../') !== false) {
            return true;
        }
        if (strpos($file, '../') === 0) {
            return true;
        }
        return false;
    }

    /**
     * Extract the archive so we can work with the contents
     *
     */
    private function _extract()
    {
        $packagexml = false;
        $where = (string) PEAR2_Pyrus_Config::current()->temp_dir;
        $where = str_replace('\\', '/', $where);
        $where = str_replace('//', '/', $where);
        $where = str_replace('/', DIRECTORY_SEPARATOR, $where);
        if (!file_exists($where)) {
            mkdir($where, 0777, true);
        }
        $where = realpath($where);
        if (dirname($where . 'a') != $where) {
            $where .= DIRECTORY_SEPARATOR;
        }
        $this->_tmpdir = $where;
        do {
            $header = fread($this->_fp, 512);
            if ($header == pack('a512', '')) {
                // end of archive
                break;
            }
            $header = $this->_readHeader($header);
            $extract = $where . $header['filename'];
            $extract = str_replace('\\', '/', $extract);
            $extract = str_replace('//', '/', $extract);
            $extract = str_replace('/', DIRECTORY_SEPARATOR, $extract);
            self::_addTempFile($extract);
            if (!file_exists(dirname($extract))) {
                self::_addTempDirectory(dirname($extract));
                mkdir(dirname($extract), 0777, true);
            }
            $fp = fopen($extract, 'wb');
            $amount = stream_copy_to_stream($this->_fp, $fp, $this->_internalFileLength);
            if ($amount != $this->_internalFileLength) {
                throw new PEAR2_Pyrus_Package_Tar_Exception(
                    'Unable to fully extract ' . $header['filename'] . ' from ' .
                    $this->_packagename);
            }
            if ($this->_footerLength) {
                fseek($this->_fp, $this->_footerLength, SEEK_CUR);
            }
            if (!$packagexml) {
                if (preg_match('/^package\-.+\-\\d+(?:\.\d+)*(?:[a-zA-Z]+\d*)?.xml$/',
                      $header['filename'])) {
                    $this->_BCpackage = false;
                    $packagexml = $where . $header['filename'];
                } elseif ($header['filename'] == 'package2.xml') {
                    $this->_BCpackage = true;
                    $packagexml = $where . $header['filename'];
                } elseif ($header['filename'] == 'package.xml') {
                    $this->_BCpackage = true;
                    $packagexml = $where . $header['filename'];
                }
            }
        } while ($this->_internalFileLength);
        fclose($fp);
        fclose($this->_fp);
        if (!$packagexml) {
            throw new PEAR2_Pyrus_Package_Tar_Exception('Archive ' . $this->_packagename .
                ' does not contain a package.xml file');
        }
        return $packagexml;
    }
}
<?php
/**
 * PEAR2_Pyrus_Package_Tar_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Tar packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Tar_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Package_Xml
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Package represented just by the package.xml file
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Xml extends PEAR2_Pyrus_Package_Base
{
    private $_file;
    function __construct($package, PEAR2_Pyrus_Package $parent)
    {
        $this->_file = $package;
        parent::__construct(new PEAR2_Pyrus_PackageFile($package), $parent);
    }

    function getLocation()
    {
        return dirname($this->packagefile->path);
    }

    function getFilePath($file)
    {
        return dirname($this->_file) . DIRECTORY_SEPARATOR . $file;
    }
}
<?php
/**
 * PEAR2_Pyrus_Package_Zip
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class representing a Zip package
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Zip extends PEAR2_Pyrus_Package_Base
{
    private $_packagename;
    static private $_tempfiles = array();
    private $_tmpdir;

    /**
     * @param string $package path to package file
     */
    function __construct($package, PEAR2_Pyrus_Package $parent)
    {
        if (!class_exists('ZIPArchive')) {
            throw new PEAR2_Pyrus_Package_Zip_Exception(
                'Zip extension is not available');
        }
        $this->_packagename = $package;
        $zip = new ZIPArchive;
        if (true !== ($zip->open($package))) {
            throw new PEAR2_Pyrus_Package_Zip_Exception('Could not open ZIP archive ' .
                $package);
        }
        if (false !== ($pxml = $zip->getNameIndex(0))) {
            if (!preg_match('/^package\-.+\-\\d+(?:\.\d+)*(?:[a-zA-Z]+\d*)?.xml$/',
                      $pxml)) {
                throw new PEAR2_Pyrus_Package_Zip_Exception('First file in ZIP archive ' .
                    'is not package.xml, cannot process');
            }
        }
        $where = (string) PEAR2_Pyrus_Config::current()->temp_dir;
        $where = str_replace('\\', '/', $where);
        $where = str_replace('//', '/', $where);
        $where = str_replace('/', DIRECTORY_SEPARATOR, $where);
        if (!file_exists($where)) {
            mkdir($where, 0777, true);
        }
        $where = realpath($where);
        if (dirname($where . 'a') != $where) {
            $where .= DIRECTORY_SEPARATOR;
        }
        $this->_tmpdir = $where;
        $zip->extractTo($where);
        parent::__construct(new PEAR2_Pyrus_PackageFile($where . DIRECTORY_SEPARATOR . $pxml),
            $parent);
    }

    function __destruct()
    {
        usort(self::$_tempfiles, array('PEAR2_Pyrus_Package_Base', 'sortstuff'));
        foreach (self::$_tempfiles as $fileOrDir) {
            if (!file_exists($fileOrDir)) continue;
            if (is_file($fileOrDir)) {
                unlink($fileOrDir);
            } elseif (is_dir($fileOrDir)) {
                rmdir($fileOrDir);
            }
        }
    }

    private static function _addTempFile($file)
    {
        self::$_tempfiles[] = $file;
    }

    private static function _addTempDirectory($dir)
    {
        do {
            self::$_tempfiles[] = $dir;
            $dir = dirname($dir);
        } while (!file_exists($dir));
    }

    function getLocation()
    {
        return $this->_tmpdir;
    }

    function __get($var)
    {
        if ($var === 'archivefile') {
            return $this->_packagename;
        }
        return parent::__get($var);
    }

    function getFilePath($file)
    {
        if (!isset($this->packagefile->info->files[$file])) {
            throw new PEAR2_Pyrus_Package_Exception('file ' . $file . ' is not in package.xml');
        }
        $extract = $this->_tmpdir . DIRECTORY_SEPARATOR . $file;
        $extract = str_replace('\\', '/', $extract);
        $extract = str_replace('//', '/', $extract);
        $extract = str_replace('/', DIRECTORY_SEPARATOR, $extract);
        return $extract;
    }
}
<?php
/**
 * PEAR2_Pyrus_Package_Zip_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Zip packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Zip_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for a PEAR2 package file
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile
{
    public $info;
    public $path;
    function __construct($package, $class = 'PEAR2_Pyrus_PackageFile_v2')
    {
        $this->path = $package;
        $parser = new PEAR2_Pyrus_PackageFile_Parser_v2;
        $data = file_get_contents($package);
        if ($data === false || empty($data)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Unable to open package xml file '
                . $package . ' or file was empty.');
        }
        $this->info = $parser->parse($data, $package, $class);
    }

    function __toString()
    {
        return $this->info->__toString();
    }
}
<?php
/**
 * PEAR2_Pyrus_PackageFile_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for PackageFile
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_IValidator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for package file validators
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_PackageFile_IValidator
{
    public function extendedValidate(array $packageinfo);
}<?php
/**
 * package.xml parsing class, package.xml version 2.0
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Parser for package.xml version 2.0
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_Parser_v2 extends PEAR2_Pyrus_XMLParser
{
    private $_inContents = false;
    private $_path = '';
    private $_files = array();
    /**
     * Mapping of directories within package.xml and their baseinstalldir settings
     * @var array
     */
    private $_baseinstalldirs = array();
    private $_lastDepth = 0;
    private $_lastFileDepth = 0;
    private $_inFile = 0;
    private $_curFile;
    /**
     * Unindent given string
     *
     * @param string $str The string that has to be unindented.
     * @return string
     * @access private
     */
    function _unIndent($str)
    {
        // remove leading newlines
        $str = preg_replace('/^[\r\n]+/', '', $str);
        // find whitespace at the beginning of the first line
        $indent_len = strspn($str, " \t");
        $indent = substr($str, 0, $indent_len);
        $data = '';
        // remove the same amount of whitespace from following lines
        foreach (explode("\n", $str) as $line) {
            if (substr($line, 0, $indent_len) == $indent) {
                $data .= substr($line, $indent_len) . "\n";
            }
        }
        return $data;
    }

    /**
     * post-process data
     *
     * @param string $data
     * @param string $element element name
     */
    function postProcess($data, $element)
    {
        if ($element == 'notes') {
            return trim($this->_unIndent($data));
        }
        return trim($data);
    }

    /**
     * @param string
     * @param string file name of the package.xml
     * @param string|false name of the archive this package.xml came from, if any
     * @param string class name to instantiate and return.  This must be PEAR_PackageFile_v2 or
     *               a subclass
     * @return PEAR2_Pyrus_PackageFile_v2
     */
    function parse($data, $file = false, $class = 'PEAR2_Pyrus_PackageFile_v2')
    {
        $this->_inContents = false;
        $this->_path = '';
        $this->_files = array();
        $this->_lastDepth = $this->_lastFileDepth = 0;
        $this->_inFile = 0;
        $ret = new $class;
        if (!$ret instanceof PEAR2_Pyrus_PackageFile_v2) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Class ' . $class .
                ' passed to parse() must be a child class of PEAR2_Pyrus_PackageFile_v2');
        }

        if (preg_match('/<package[^>]+version="2.1"/', $data)) {
            $schema = PEAR2_Pyrus::getDataPath() . '/package-2.1.xsd';
            // for running out of cvs
            if (!file_exists($schema)) {
                $schema = dirname(dirname(dirname(dirname(dirname(__FILE__))))) . '/data/package-2.1.xsd';
            }
        } elseif (preg_match('/<package[^>]+version="2.0"/', $data)) {
            $schema = PEAR2_Pyrus::getDataPath() . '/package-2.0.xsd';
            // for running out of cvs
            if (!file_exists($schema)) {
                $schema = dirname(dirname(dirname(dirname(dirname(__FILE__))))) . '/data/package-2.0.xsd';
            }
        } else {
            throw new PEAR2_Pyrus_PackageFile_Exception('Cannot process package.xml version 1.0');
        }
        try {
            $ret->fromArray(parent::parseString($data, $schema));
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml', $e);
        }
        $ret->setFileList($this->_files);
        $ret->setBaseInstallDirs($this->_baseinstalldirs);
        $ret->setPackagefile($file);
        return $ret;
    }

    protected function mergeTag($arr, $tag, $attr, $name, $depth)
    {
        $arr = parent::mergeTag($arr, $tag, $attr, $name, $depth);
        if ($this->_inContents) {
            if ($this->_inFile) {
                if ($depth < $this->_inFile) {
                    $this->_inFile = 0;
                }
            }
            if ($name === 'dir') {
                while ($this->_lastDepth >= $depth) {
                    $this->_path = dirname($this->_path);
                    if ($this->_path == '.') {
                        $this->_path = '';
                    } else {
                        $this->_path .= '/';
                    }
                    $this->_lastDepth--;
                }
                $this->_lastDepth = $depth;
                $this->_lastFileDepth = $depth + 1;
                $origpath = $path = $attr['name'];
                if ($path === '/') {
                    $path = '';
                } else {
                    $path .= '/';
                }
                $this->_path .= $path;
                if (isset($attr['baseinstalldir'])) {
                    $this->_baseinstalldirs[$origpath] = $attr['baseinstalldir'];
                } else {
                    if (isset($this->_baseinstalldirs[dirname($path)])) {
                        $this->_baseinstalldirs[$origpath] = $this->_baseinstalldirs[dirname($path)];
                    }
                }
            } elseif ($name === 'file') {
                while ($this->_lastFileDepth > $depth) {
                    $this->_path = dirname($this->_path);
                    if ($this->_path == '.') {
                        $this->_path = '';
                    } else {
                        $this->_path .= '/';
                    }
                    $this->_lastFileDepth--;
                    $this->_lastDepth--;
                }
                $path = $this->_path . $attr['name'];
                if (isset($arr[$name][0])) {
                    $arr['file'][count($arr['file']) - 1]['attribs']['name'] =
                        basename($arr['file'][count($arr['file']) - 1]['attribs']['name']);
                    $this->_files[$path] =
                        $arr['file'][count($arr['file']) - 1];
                } else {
                    $arr['file']['attribs']['name'] = basename($arr['file']['attribs']['name']);
                    $this->_files[$path] = $arr['file'];
                }
                $this->_curFile = $path;
                $this->_inFile = $depth;
            } elseif ($this->_inFile) {
                // add tasks
                $this->_files[$this->_curFile][$name] = $arr[$name];
            }
        } elseif ($name === 'contents') {
            $this->_inContents = true;
        }
        return $arr;
    }
}
?>
<?php
/**
 * PEAR_PackageFile_v2, package.xml version 2.1
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * File representing a package.xml file version 2.1
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2
{
    public $rootAttributes = array(
                                 'version' => '2.1',
                                 'xmlns' => 'http://pear.php.net/dtd/package-2.1',
                                 'xmlns:tasks' => 'http://pear.php.net/dtd/tasks-1.0',
                                 'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
                                 'xsi:schemaLocation' => 'http://pear.php.net/dtd/tasks-1.0
     http://pear.php.net/dtd/tasks-1.0.xsd
     http://pear.php.net/dtd/package-2.1
     http://pear.php.net/dtd/package-2.1.xsd',
                             );
    /**
     * Parsed package information
     *
     * For created-from-scratch packagefiles, set some basic information needed.
     * @var array
     * @access private
     */
    protected $packageInfo = array('attribs' => array(
        'version' => '2.1',
        'xmlns' => 'http://pear.php.net/dtd/package-2.1',
        'xmlns:tasks' => 'http://pear.php.net/dtd/tasks-1.0',
        'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
        'xsi:schemaLocation' => 'http://pear.php.net/dtd/tasks-1.0
     http://pear.php.net/dtd/tasks-1.0.xsd
     http://pear.php.net/dtd/package-2.1
     http://pear.php.net/dtd/package-2.1.xsd',
    ),
        'version' => array(
            'release' => '0.1.0',
            'api' => '0.1.0',
        ),
        'stability' => array(
            'release' => 'devel',
            'api' => 'alpha',
        ),
        'license' => array('attribs' => array('uri' => 'http://www.opensource.org/licenses/bsd-license.php'),
            '_content' => 'New BSD License',
        ),
        'dependencies' => array(
            'required' => array(
                'php' => array('min' => '5.2.0'),
                'pearinstaller' => array('min' => '2.0.0a1'),
            ),
        ),
        'phprelease' => array(),
    );

    /**
     * Set if the XML has been validated against schema
     *
     * @var unknown_type
     */
    private $_schemaValidated = false;

    protected $filelist = array();
    protected $baseinstalldirs = array();
    private $_dirtree = array();

    /**
     * path to package .xml or false if this is an abstract parsed-from-string xml
     * @var string|false
     * @access private
     */
    private $_packageFile = false;

    /**
     * Optional Dependency group requested for installation
     * @var string
     * @access private
     */
    var $_requestedGroup = false;

    /**
     * Namespace prefix used for tasks in this package.xml - use tasks: whenever possible
     */
    var $_tasksNs;

    function setPackagefile($file, $archive = false)
    {
        $this->_packageFile = $file;
        $this->_archiveFile = $archive ? $archive : $file;
    }

    function getPackageFile()
    {
        return $this->_packageFile;
    }

    function getArchiveFile()
    {
        return $this->_archiveFile;
    }

    /**
     * Directly set the array that defines this packagefile
     *
     * WARNING: no validation.  This should only be performed by internal methods
     * inside Pyrus or by inputting an array saved from an existing PEAR_PackageFile_v2
     * @param array
     */
    function fromArray($pinfo)
    {
        $this->_schemaValidated = true;
        $this->packageInfo = $pinfo['package'];
    }

    function hasFile($file)
    {
        return isset($this->filelist[$file]);
    }

    function getFile($file)
    {
        return $this->filelist[$file];
    }

    function setFilelist(array $list)
    {
        $this->filelist = $list;
    }

    function setBaseInstallDirs(array $list)
    {
        $this->baseinstalldirs = $list;
    }

    /**
     * @param string full path to file
     * @param string attribute name
     * @param string attribute value
     * @return bool success of operation
     */
    function setFileAttribute($filename, $attr, $value)
    {
        if (!in_array($attr, array('role', 'name', 'baseinstalldir', 'install-as'), true)) {
            throw new PEAR2_Pyrus_PackageFile_Exception(
                'Cannot set invalid attribute ' . $attr . ' for file ' . $filename);
        }
        if (!isset($this->filelist[$filename])) {
            throw new PEAR2_Pyrus_PackageFile_Exception(
                'Cannot set attribute ' . $attr . ' for non-existent file ' . $filename);
        }
        if ($attr == 'name') {
            throw new PEAR2_Pyrus_PackageFile_Exception('Cannot change name of file ' .
                $filename);
        }
        $this->filelist[$filename]['attribs'][$attr] = $value;
    }

    /**
     * Used by uninstallation to set directory locations to erase
     * @param string $path
     */
    function setDirtree($path)
    {
        $this->_dirtree[$path] = true;
    }

    function getDirtree()
    {
        return $this->_dirtree;
    }

    /**
     * Determines whether this package claims it is compatible with the version of
     * the package that has a recommended version dependency
     * @param PEAR_PackageFile_v2|PEAR_PackageFile_v1|PEAR_Downloader_Package
     * @return boolean
     */
    function isCompatible($pf)
    {
        if (!isset($this->packageInfo['compatible'])) {
            return false;
        }
        if (!isset($this->packageInfo['channel'])) {
            return false;
        }
        $me = $pf->version['release'];
        $compatible = $this->packageInfo['compatible'];
        if (!isset($compatible[0])) {
            $compatible = array($compatible);
        }
        $found = false;
        foreach ($compatible as $info) {
            if (strtolower($info['name']) == strtolower($pf->package)) {
                if (strtolower($info['channel']) == strtolower($pf->channel)) {
                    $found = true;
                    break;
                }
            }
        }
        if (!$found) {
            return false;
        }
        if (isset($info['exclude'])) {
            if (!isset($info['exclude'][0])) {
                $info['exclude'] = array($info['exclude']);
            }
            foreach ($info['exclude'] as $exclude) {
                if (version_compare($me, $exclude, '==')) {
                    return false;
                }
            }
        }
        if (version_compare($me, $info['min'], '>=') && version_compare($me, $info['max'], '<=')) {
            return true;
        }
        return false;
    }

    function isSubpackageOf(PEAR2_Pyrus_PackageFile_v2 $p)
    {
        return $p->isSubpackage($this);
    }

    /**
     * Determines whether the passed in package is a subpackage of this package.
     *
     * No version checking is done, only name verification.
     * @return bool
     */
    function isSubpackage(PEAR2_Pyrus_PackageFile_v2 $p)
    {
        $sub = array();
        if (isset($this->packageInfo['dependencies']['required']['subpackage'])) {
            $sub = $this->packageInfo['dependencies']['required']['subpackage'];
            if (!isset($sub[0])) {
                $sub = array($sub);
            }
        }
        if (isset($this->packageInfo['dependencies']['optional']['subpackage'])) {
            $sub1 = $this->packageInfo['dependencies']['optional']['subpackage'];
            if (!isset($sub1[0])) {
                $sub1 = array($sub1);
            }
            $sub = array_merge($sub, $sub1);
        }
        if (isset($this->packageInfo['dependencies']['group'])) {
            $group = $this->packageInfo['dependencies']['group'];
            if (!isset($group[0])) {
                $group = array($group);
            }
            foreach ($group as $deps) {
                if (isset($deps['subpackage'])) {
                    $sub2 = $deps['subpackage'];
                    if (!isset($sub2[0])) {
                        $sub2 = array($sub2);
                    }
                    $sub = array_merge($sub, $sub2);
                }
            }
        }
        foreach ($sub as $dep) {
            if (strtolower($dep['name']) == strtolower($p->package)) {
                if (isset($dep['channel'])) {
                    if (strtolower($dep['channel']) == strtolower($p->channel)) {
                        return true;
                    }
                } else {
                    if ($dep['uri'] == $p->uri) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function dependsOn($package, $channel)
    {
        if (!($deps = $this->dependencies)) {
            return false;
        }
        foreach (array('package', 'subpackage') as $type) {
            foreach (array('required', 'optional') as $needed) {
                if (isset($deps[$needed][$type])) {
                    if (!isset($deps[$needed][$type][0])) {
                        $deps[$needed][$type] = array($deps[$needed][$type]);
                    }
                    foreach ($deps[$needed][$type] as $dep) {
                        $depchannel = isset($dep['channel']) ? $dep['channel'] : '__uri';
                        if (strtolower($dep['name']) == strtolower($package) &&
                              $depchannel == $channel) {
                            return true;
                        }
                    }
                }
            }
            if (isset($deps['group'])) {
                if (!isset($deps['group'][0])) {
                    $dep['group'] = array($deps['group']);
                }
                foreach ($deps['group'] as $group) {
                    if (isset($group[$type])) {
                        if (!is_array($group[$type])) {
                            $group[$type] = array($group[$type]);
                        }
                        foreach ($group[$type] as $dep) {
                            $depchannel = isset($dep['channel']) ? $dep['channel'] : '__uri';
                            if (strtolower($dep['name']) == strtolower($package) &&
                                  $depchannel == $channel) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    /**
     * Get the contents of a dependency group
     * @param string
     * @return array|false
     */
    function getDependencyGroup($name)
    {
        $name = strtolower($name);
        if (!isset($this->packageInfo['dependencies']['group'])) {
            return false;
        }
        $groups = $this->packageInfo['dependencies']['group'];
        if (!isset($groups[0])) {
            $groups = array($groups);
        }
        foreach ($groups as $group) {
            if (strtolower($group['attribs']['name']) == $name) {
                return $group;
            }
        }
        return false;
    }

    /**
     * @return php|extsrc|extbin|zendextsrc|zendextbin|bundle|false
     */
    function getPackageType()
    {
        if (isset($this->packageInfo['phprelease'])) {
            return 'php';
        }
        if (isset($this->packageInfo['extsrcrelease'])) {
            return 'extsrc';
        }
        if (isset($this->packageInfo['extbinrelease'])) {
            return 'extbin';
        }
        if (isset($this->packageInfo['zendextsrcrelease'])) {
            return 'zendextsrc';
        }
        if (isset($this->packageInfo['zendextbinrelease'])) {
            return 'zendextbin';
        }
        if (isset($this->packageInfo['bundle'])) {
            return 'bundle';
        }
        return false;
    }

    function hasDeps()
    {
        return isset($this->packageInfo['dependencies']);
    }

    function getPackagexmlVersion()
    {
        if (isset($this->packageInfo['zendextsrcrelease'])) {
            return '2.1';
        }
        if (isset($this->packageInfo['zendextbinrelease'])) {
            return '2.1';
        }
        return '2.0';
    }

    /**
     * validate dependencies against the local registry, packages to be installed,
     * and environment (php version, OS, architecture, enabled extensions)
     *
     * @param array $toInstall an array of PEAR2_Pyrus_Package objects
     * @param PEAR2_MultiErrors $errs
     */
    function validateDependencies(array $toInstall, PEAR2_MultiErrors $errs)
    {
        $dep = new PEAR2_Pyrus_Dependency_Validator($this->packageInfo['name'],
            PEAR2_Pyrus_Validate::DOWNLOADING, $errs);
        $dep->validatePhpDependency($this->dependencies->required->php);
        $dep->validatePearinstallerDependency($this->dependencies->required->pearinstaller);
        foreach (array('required', 'optional') as $required) {
            foreach ($this->dependencies->$required->package as $d) {
                $dep->validatePackageDependency($d, $required == 'required', $toInstall);
            }
            foreach ($this->dependencies->$required->subpackage as $d) {
                $dep->validateSubpackageDependency($d, $required == 'required', $toInstall);
            }
            foreach ($this->dependencies->$required->extension as $d) {
                $dep->validateExtensionDependency($d, $required == 'required');
            }
        }
        foreach ($this->dependencies->required->arch as $d) {
            $dep->validateArchDependency($d);
        }
        foreach ($this->dependencies->required->os as $d) {
            $dep->validateOsDependency($d);
        }
    }

    function validate($state = PEAR2_Pyrus_Validate::NORMAL)
    {
        if (!isset($this->packageInfo) || !is_array($this->packageInfo)) {
            return false;
        }
        $validator = new PEAR2_Pyrus_PackageFile_v2_Validator;
        return $validator->validate($this, $state);
    }

    function getTasksNs()
    {
        if (!isset($this->_tasksNs)) {
            if (isset($this->packageInfo['attribs'])) {
                foreach ($this->packageInfo['attribs'] as $name => $value) {
                    if ($value == 'http://pear.php.net/dtd/tasks-1.0') {
                        $this->_tasksNs = str_replace('xmlns:', '', $name);
                        break;
                    }
                }
            }
        }
        return $this->_tasksNs;
    }

    /**
     * Determine whether a task name is a valid task.  Custom tasks may be defined
     * using subdirectories by putting a "-" in the name, as in <tasks:mycustom-task>
     *
     * Note that this method will auto-load the task class file and test for the existence
     * of the name with "-" replaced by "_" as in PEAR/Task/mycustom/task.php makes class
     * PEAR_Task_mycustom_task
     * @param string
     * @return boolean
     */
    function getTask($task)
    {
        $this->getTasksNs();
        // transform all '-' to '/' and 'tasks:' to '' so tasks:replace becomes replace
        $task = str_replace(array($this->_tasksNs . ':', '-'), array('', ' '), $task);
        $task = str_replace(' ', '/', ucwords($task));
        $test = str_replace('/', '_', $task);
        if (class_exists("PEAR2_Pyrus_Task_$test", true)) {
            return "PEAR2_Pyrus_Task_$test";
        }
        return false;
    }

    function getBaseInstallDir($file)
    {
        $file = dirname($file);
        while ($file !== '.' && $file != '/') {
            if (isset($this->baseinstalldirs[$file])) {
                return $this->baseinstalldirs[$file];
            }
            $file = dirname($file);
        }
        if (isset($this->baseinstalldirs[''])) {
            return $this->baseinstalldirs[''];
        }
        return false;
    }

    function __get($var)
    {
        switch ($var) {
            case 'bundledpackage' :
                if ($this->getPackageType() !== 'bundle') {
                    return false;
                }
                if (!isset($this->packageInfo['contents'])) {
                    $this->packageInfo['contents'] = array();
                }
                if (!isset($this->packageInfo['contents']['bundledpackage'])) {
                    $this->packageInfo['contents']['bundledpackage'] = array();
                }
                return new ArrayObject($this->packageInfo['contents']['bundledpackage'],
                    ArrayObject::ARRAY_AS_PROPS);
            case 'packagefile' :
                return $this->_packageFile;
            case 'filepath' :
                return dirname($this->_packageFile);
            case 'contents' :
                // allows stuff like:
                // foreach ($pf->contents as $file) {
                //     echo $file->name;
                //     $file->installed_as = 'hi';
                // }
                return new PEAR2_Pyrus_PackageFile_v2Iterator_File(
                        new PEAR2_Pyrus_PackageFile_v2Iterator_FileAttribsFilter(
                        new PEAR2_Pyrus_PackageFile_v2Iterator_FileContents(
                            $this->packageInfo['contents'], 'contents', $this)),
                            RecursiveIteratorIterator::LEAVES_ONLY);
            case 'installcontents' :
                PEAR2_Pyrus_PackageFile_v2Iterator_FileInstallationFilter::setParent($this);
                return new PEAR2_Pyrus_PackageFile_v2Iterator_FileInstallationFilter(
                        new ArrayIterator(
                            $this->filelist));
            case 'packagingcontents' :
                PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator::setParent($this);
                return new PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator(
                            $this->filelist);
            case 'installGroup' :
                $rel = $this->getPackageType();
                if ($rel != 'bundle') $rel .= 'release';
                $ret = $this->packageInfo[$rel];
                if (!isset($ret[0])) {
                    return array($ret);
                }
                return $ret;
            case 'channel' :
                if (isset($this->packageInfo['uri'])) {
                    return '__uri';
                }
                break;
            case 'state' :
                if (!isset($this->packageInfo['stability']) ||
                      !isset($this->packageInfo['stability']['release'])) {
                    return false;
                }
                return $this->packageInfo['stability']['release'];
            case 'api-version' :
                if (!isset($this->packageInfo['version']) ||
                      !isset($this->packageInfo['version']['api'])) {
                    return false;
                }
                return $this->packageInfo['version']['api'];
            case 'release-version' :
                if (!isset($this->packageInfo['version']) ||
                      !isset($this->packageInfo['version']['release'])) {
                    return false;
                }
                return $this->packageInfo['version']['release'];
            case 'api-state' :
                if (!isset($this->packageInfo['stability']) ||
                      !isset($this->packageInfo['stability']['api'])) {
                    return false;
                }
                return $this->packageInfo['stability']['api'];
            case 'allmaintainers' :
                $leads = $this->tag('lead');
                if ($leads && !isset($leads[0])) {
                    $leads = array($leads);
                }
                $developers = $this->tag('developer');
                if ($developers && !isset($developers[0])) {
                    $developers = array($developers);
                }
                $helpers = $this->tag('helper');
                if ($helpers && !isset($helpers[0])) {
                    $helpers = array($helpers);
                }
                $contributors = $this->tag('contributors');
                if ($contributors && !isset($contributors[0])) {
                    $contributors = array($contributors);
                }
                return array(
                    'lead' => $leads,
                    'developer' => $developers,
                    'helper' => $helpers,
                    'contributor' => $contributors
                );
            case 'releases' :
                $type = $this->getPackageType();
                if ($type != 'bundle') {
                    $type .= 'release';
                }
                if ($type && isset($this->packageInfo[$type])) {
                    return $this->packageInfo[$type];
                }
                return false;
            case 'sourcepackage' :
                if (isset($this->packageInfo['extbinrelease']) ||
                      isset($this->packageInfo['zendextbinrelease'])) {
                    return array('channel' => $this->packageInfo['srcchannel'],
                                 'package' => $this->packageInfo['srcpackage']);
                }
                return false;
            case 'files' :
                return new PEAR2_Pyrus_PackageFile_v2_Files($this->filelist);
            case 'maintainer' :
                return new PEAR2_Pyrus_PackageFile_v2_Developer($this->packageInfo);
            case 'rawdeps' :
                return isset($this->packageInfo['dependencies']) ?
                    $this->packageInfo['dependencies'] : false;
            case 'dependencies' :
                if (!isset($this->packageInfo['dependencies'])) {
                    $this->packageInfo['dependencies'] = array();
                }
                return new PEAR2_Pyrus_PackageFile_v2_Dependencies(
                    $this->packageInfo['dependencies'],
                    $this->packageInfo['dependencies']);
            case 'release' :
                $t = $this->getPackageType();
                if (!$t) {
                    $this->type = 'php';
                    $t = 'phprelease';
                } else {
                    if ($t != 'bundle') {
                        $t .= 'release';
                    }
                }
                if (!$this->packageInfo[$t]) {
                    $this->packageInfo[$t] = array();
                }
                return new PEAR2_Pyrus_PackageFile_v2_Release(
                    $this->packageInfo, $this->packageInfo[$t], $this->filelist);
            case 'compatible' :
                return new PEAR2_Pyrus_PackageFile_v2_Compatible($this->packageInfo);
            case 'schemaOK' :
                return $this->_schemaValidated;
        }
        return $this->tag($var);
    }

    function __set($var, $value)
    {
        if ($var === 'license') {
            if (!is_array($value)) {
                $licensemap =
                    array(
                        'php' => 'http://www.php.net/license',
                        'php license' => 'http://www.php.net/license',
                        'lgpl' => 'http://www.gnu.org/copyleft/lesser.html',
                        'bsd' => 'http://www.opensource.org/licenses/bsd-license.php',
                        'bsd style' => 'http://www.opensource.org/licenses/bsd-license.php',
                        'bsd-style' => 'http://www.opensource.org/licenses/bsd-license.php',
                        'mit' => 'http://www.opensource.org/licenses/mit-license.php',
                        'gpl' => 'http://www.gnu.org/copyleft/gpl.html',
                        'apache' => 'http://www.opensource.org/licenses/apache2.0.php'
                    );
                if (isset($licensemap[strtolower($value)])) {
                    $this->packageInfo['license'] = array(
                        'attribs' => array('uri' =>
                            $licensemap[strtolower($value)]),
                        '_content' => $value
                        );
                } else {
                    // don't use bogus uri
                    $arr['license'] = $value;
                }
            } else {
                $this->packageInfo['license'] = $value;
            }
            return;
        }
        if ($var === 'type') {
            if (!is_string($value)) {
                throw new PEAR2_Pyrus_PackageFile_Exception('package.xml type must be a ' .
                'string, was a ' . gettype($value));
            }
            if ($value != 'bundle') {
                $value .= 'release';
            }
            if (in_array($value, $a = array('phprelease', 'extsrcrelease', 'extbinrelease',
                  'zendextsrcrelease', 'zendextbinrelease', 'bundle'))) {
                foreach ($a as $type) {
                    if ($value == $type) {
                        if (!isset($this->packageInfo[$type])) {
                            $this->packageInfo[$type] = array();
                        }
                        continue;
                    }
                    if (isset($this->packageInfo[$type])) {
                        unset($this->packageInfo[$type]);
                    }
                }
            }
            return;
        }
        if ($var === 'dependencies' && $value === null) {
            $this->packageInfo['dependencies'] = array();
            return;
        }
        if ($var === 'rawdependencies' && is_array($value)) {
            $this->packageInfo['dependencies'] = $value;
            return;
        }
        if ($var === 'rawcompatible' && is_array($value)) {
            $this->packageInfo['compatible'] = $value;
            return;
        }
        if ($var === 'rawstability' && is_string($value)) {
            $this->packageInfo['stability'] = array('release' => $value, 'api' => $value);
            return;
        }
        if ($var === 'packagerversion' && is_string($value)) {
            $this->packageInfo['attribs']['packagerversion'] = $value;
            return;
        }
        if ($var === 'release' && $value === null) {
            $type = $this->getPackageType();
            if ($type != 'bundle') {
                $type .= 'release';
            }
            $this->packageInfo[$type] = array();
            return;
        }
        if ($value instanceof ArrayObject) {
            $value = $value->getArrayCopy();
        }
        if ($var === 'release' && $value === null) {
            $rel = $this->getPackageType();
            if ($rel) {
                if (isset($this->packageInfo[$rel . 'release'])) {
                    $rel .= 'release';
                }
                $this->packageInfo[$rel] = array();
            }
        }
        if (in_array($var, array('attribs', 'lead',
                'developer', 'contributor', 'helper', 'version',
                'stability', 'license', 'contents', 'compatible',
                'dependencies', 'providesextension', 'usesrole', 'usestask', 'srcpackage', 'srcuri',
                'phprelease', 'extsrcrelease', 'zendextsrcrelease', 'zendextbinrelease',
                'extbinrelease', 'bundle', 'changelog'), true)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Cannot set ' . $var . ' directly');
        }
        if (!in_array($var, array('name', 'channel', 'uri', 'extends', 'summary',
                'description', 'date', 'time','notes'), true)) {
            return;
        }
        if ($var === 'uri') {
            if (isset($this->packageInfo['channel'])) {
                unset($this->packageInfo['channel']);
            }
        }
        if ($var == 'api-version') {
            $this->packageInfo['version']['api'] = $value;
            return;
        }
        if ($var == 'release-version') {
            $this->packageInfo['version']['release'] = $value;
        }
        $this->packageInfo[$var] = $value;
    }

    /**
     * Return the contents of a tag
     * @param string $name
     */
    protected function tag($name)
    {
        if (!isset($this->packageInfo[$name]) && in_array($name, array('version',
                'stability', 'license', 'compatible',
                'providesextension', 'usesrole', 'usestask', 'srcpackage', 'srcuri',
                ), true)) {
            $this->packageInfo[$name] = array();
        }
        if (!isset($this->packageInfo[$name])) {
            return false;
        }
        if (is_array($this->packageInfo[$name])) {
            return new ArrayObject($this->packageInfo[$name], ArrayObject::ARRAY_AS_PROPS);
        }
        return $this->packageInfo[$name];
    }

    /**
     * Update the changelog based on the current information
     */
    function updateChangelog()
    {
        $license = $this->license;
        if ($license instanceof ArrayObject) {
            $license = $license->getArrayCopy();
        }
        $info = array(
            'version' => array(
                'release' => $this->version['release'],
                'api' => $this->version['api']
            ),
            'stability' => array(
                'release' => $this->stability['release'],
                'api' => $this->stability['api']
            ),
            'date' => $this->date,
            'license' => $license,
            'notes' => $this->notes,
        );

        if (!is_array($this->packageInfo['changelog'])) {
            $this->packageInfo['changelog'] = $info;
        } elseif (!isset($this->packageInfo['changelog'][0])) {
            $this->packageInfo['changelog'] = array($info, $this->packageInfo['changelog']);
        } else {
            array_unshift($this->packageInfo['changelog'], $info);
        }
    }

    function __toString()
    {
        $this->packageInfo['attribs'] = $this->rootAttributes;
        $this->packageInfo['date'] = date('Y-m-d');
        $this->packageInfo['time'] = date('H:i:s');
        $arr = $this->toArray();
        return (string) new PEAR2_Pyrus_XMLWriter($arr);
    }

    public static function sortInstallAs($a, $b)
    {
        return strnatcasecmp($a['attribs']['name'], $b['attribs']['name']);
    }

    function toArray($forpackaging = false)
    {
        $this->packageInfo['contents'] = array(
            'dir' => array(
                'attribs' => array('name' => '/'),
                'file' => array()
            ));
        uksort($this->filelist, 'strnatcasecmp');
        $a = array_reverse($this->filelist, 1);
        if ($forpackaging) {
            PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator::setParent($this);
            $a = new PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator($a);
        }
        $temp = array();
        foreach ($a as $name => $stuff) {
            if ($forpackaging) {
                // map old to new name
                $temp[$stuff['attribs']['name']] = $name;
            }
            // if we are packaging, $name is the new name
            $stuff['attribs']['name'] = $name;
            $this->packageInfo['contents']['dir']['file'][] = $stuff;
        }
        if (count($this->packageInfo['contents']['dir']['file']) == 1) {
            $this->packageInfo['contents']['dir']['file'] =
                $this->packageInfo['contents']['dir']['file'][0];
        }
        $arr = array();
        foreach (array('attribs', 'name', 'channel', 'uri', 'extends', 'summary',
                'description', 'lead',
                'developer', 'contributor', 'helper', 'date', 'time', 'version',
                'stability', 'license', 'notes', 'contents', 'compatible',
                'dependencies', 'providesextension', 'usesrole', 'usestask', 'srcpackage', 'srcuri',
                'phprelease', 'extsrcrelease', 'zendextsrcrelease', 'zendextbinrelease',
                'extbinrelease', 'bundle', 'changelog') as $index)
        {
            if (!isset($this->packageInfo[$index])) {
                continue;
            }
            $arr[$index] = $this->packageInfo[$index];
        }
        if ($forpackaging) {
            // process releases
            $reltag = $this->getPackageType();
            if ($reltag != 'bundle') {
                $reltag .= 'release';
                if (is_array($arr[$reltag])) {
                    if (!isset($arr[$reltag][0])) {
                        $arr[$reltag] = array($arr[$reltag]);
                    }
                    foreach ($arr[$reltag] as $i => $inf) {
                        if (!isset($inf['filelist'])) {
                            continue;
                        }
                        $inf = $inf['filelist'];
                        if (isset($inf['install'])) {
                            if (!isset($inf['install'][0])) {
                                if (isset($temp[$inf['install']['attribs']['name']])) {
                                    $arr[$reltag][$i]['filelist']['install']['attribs']
                                                       ['name'] =
                                        $temp[$inf['install']['attribs']['name']];
                                }
                            } else {
                                foreach ($inf['install'] as $j => $morinf) {
                                    if (isset($temp[$morinf['attribs']['name']])) {
                                        $arr[$reltag][$i]['filelist']['install'][$j]
                                                           ['attribs']['name'] =
                                            $temp[$morinf['attribs']['name']];
                                    }
                                }
                            }
                        }
                        if (isset($inf['ignore'])) {
                            if (!isset($inf['ignore'][0])) {
                                if (isset($temp[$inf['ignore']['attribs']['name']])) {
                                    $arr[$reltag][$i]['filelist']['ignore']
                                                       ['attribs']['name'] =
                                        $temp[$inf['ignore']['attribs']['name']];
                                }
                            } else {
                                foreach ($inf['ignore'] as $j => $morinf) {
                                    if (isset($temp[$morinf['attribs']['name']])) {
                                        $arr[$reltag][$i]['filelist']['ignore'][$j]
                                                           ['attribs']['name'] =
                                            $temp[$morinf['attribs']['name']];
                                    }
                                }
                            }
                        }
                    }
                    if (count($arr[$reltag]) == 1) {
                        $arr[$reltag] = $arr[$reltag][0];
                    }
                }
            }
        }
        $reltag = $this->getPackageType();
        if ($reltag != 'bundle') {
            $reltag .= 'release';
            if (!is_array($arr[$reltag])) {
                // do nothing
            } elseif (!isset($arr[$reltag][0])) {
                if (isset($arr[$reltag]['install']) && isset($arr[$reltag]['install'][0])) {
                    usort($arr[$reltag]['install'], array('PEAR2_Pyrus_PackageFile_v2',
                        'sortInstallAs'));
                }
                if (isset($arr[$reltag]['ignore']) && isset($arr[$reltag]['ignore'][0])) {
                    usort($arr[$reltag]['ignore'], array('PEAR2_Pyrus_PackageFile_v2',
                        'sortInstallAs'));
                }
            } else {
                foreach ($arr[$reltag] as $i => &$contents) {
                    if (isset($contents['install']) && isset($contents['install'][0])) {
                        usort($contents['install'], array('PEAR2_Pyrus_PackageFile_v2',
                            'sortInstallAs'));
                    }
                    if (isset($contents['ignore']) && isset($contents['ignore'][0])) {
                        usort($contents['ignore'], array('PEAR2_Pyrus_PackageFile_v2',
                            'sortInstallAs'));
                    }
                }
            }
        }
        if (isset($this->packageInfo['dependencies'])) {
            if (isset($this->packageInfo['dependencies']['required'])) {
                $arr['dependencies']['required'] = array();
                foreach (array('php', 'pearinstaller', 'package', 'subpackage',
                            'extension', 'os', 'arch') as $index) {
                    if (!isset($this->packageInfo['dependencies']['required'][$index])) {
                        continue;
                    }
                    $arr['dependencies']['required'][$index] =
                        $this->packageInfo['dependencies']['required'][$index];
                }
            }
            if (isset($this->packageInfo['dependencies']['optional'])) {
                $arr['dependencies']['optional'] = array();
                foreach (array('package', 'subpackage', 'extension') as $index) {
                    if (!isset($this->packageInfo['dependencies']['optional'][$index])) {
                        continue;
                    }
                    $arr['dependencies']['optional'][$index] =
                        $this->packageInfo['dependencies']['optional'][$index];
                }
            }
            if (isset($this->packageInfo['dependencies']['group'])) {
                if (isset($this->packageInfo['dependencies']['group'][0])) {
                    foreach ($this->packageInfo['dependencies']['group'] as $i => $g) {
                        $arr['dependencies']['group'][$i] = array();
                        foreach (array('attribs', 'package', 'subpackage', 'extension') as $index) {
                            if (!isset($g[$index])) {
                                continue;
                            }
                            $arr['dependencies']['group'][$i][$index] = $g[$index];
                        }
                    }
                } else {
                    $a = $this->packageInfo['dependencies']['group'];
                    $arr['dependencies']['group'] = array();
                    foreach (array('attribs', 'package', 'subpackage', 'extension') as $index) {
                        if (!isset($a[$index])) {
                            continue;
                        }
                        $arr['dependencies']['group'][$index] = $a[$index];
                    }
                }
            }
        }
        return array('package' => $arr);
    }
}
<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Release_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Manage compatible packages with this one
 *
 * To be used like:
 * <code>
 * // add a new compatible declaration or replace an existing one
 * $pf->compatible['pear.php.net/Archive_Tar']
 *         ->min('1.2')
 *         ->max('1.3.0')
 *         ->exclude('1.2.1', '1.2.2');
 * // remove a compatibility declaration
 * unset($pf->compatible['pear.php.net/Archive_Tar']);
 * // test for existence of compatible declaration
 * isset($pf->compatible['pear.php.net/Archive_Tar']);
 * // display info:
 * echo $pf->compatible['pear.php.net/Archive_Tar']->min;
 * foreach ($pf->compatible as $package => $info) {
 *     echo $info['min'];
 *     echo $info['max'];
 *     if (isset($info['exclude'])) {
 *         foreach ($info['exclude'] as $version) {
 *             echo $version;
 *         }
 *     }
 * }
 * </code>
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Compatible implements ArrayAccess, Iterator, Countable
{
    private $_packageInfo;
    private $_package = false;
    private $_pos = 0;
    private $_count = 0;
    private $_info = array('name' => '', 'channel' => '', 'min' => '', 'max' => '');
    function __construct(array &$parent, $package = false)
    {
        $this->_packageInfo = &$parent;
        if ($package) {
            $channel = explode('/', $package);
            $package = array_pop($channel);
            $channel = implode('/', $channel);
            $this->_info['name'] = $package;
            $this->_info['channel'] = $channel;
            $this->_package = true;
        } else {
            if (isset($this->_packageInfo['compatible'])) {
                if (isset($this->_packageInfo['compatible'][0])) {
                    $this->_count = count($this->_packageInfo['compatible']);
                } else {
                    $this->_count = 1;
                }
            }
        }
    }

    function count()
    {
        return $this->_count;
    }

    function __get($var)
    {
        if (!$this->_package) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception(
                'Cannnot access compatibility info for unknown package');
        }
        if (isset($this->_info[$var])) {
            return $this->_info[$var];
        }
    }

    function __call($var, $args)
    {
        if (!$this->_package) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception(
                'Cannnot access developer info for unknown developer');
        }
        if ($var == 'min') {
            if (count($args) != 1 || !is_string($args[0])) {
                throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception(
                    'Invalid value for min');
            }
            $this->_info['min'] = $args[0];
        } elseif ($var == 'max') {
            if (count($args) != 1 || !is_string($args[0])) {
                throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception(
                    'Invalid value for max');
            }
            $this->_info['max'] = $args[0];
        } elseif ($var == 'exclude') {
            foreach ($args as $arg) {
                if (!is_string($arg)) {
                    throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception(
                        'Invalid value for exclude');
                }
            }
            $this->_info['exclude'] = (count($args) == 1) ? $args[0] : $args[1];
        } else {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception(
                        'Unknown value to set: ' . $var);
        }
        return $this;
    }

    function offsetGet($var)
    {
        return new PEAR2_Pyrus_PackageFile_v2_Compatible($this->_packageInfo, $var);
    }

    function offsetSet($var, $value)
    {
        if ($this->_package) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception(
                'Use -> to access compatibility information for a package, not []');
        }
        $this->_package = $var;
        $channel = explode('/', $var);
        $this->_info['name'] = array_pop($channel);
        $this->_info['channel'] = implode('/', $channel);
        if ($var instanceof PEAR2_Pyrus_PackageFile_v2_Compatible) {
            $this->_info['min'] = $value->min;
            $this->_info['max'] = $value->max;
            $exclude = $value->exclude;
            if ($exclude) {
                $this->_info['exclude'] = $exclude;
            }
        }
        if (is_array($value) || $value instanceof ArrayObject) {
            if (!isset($value['min']) || !isset($value['max'])) {
                throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception(
                    'Invalid array used to set ' . $var . ' compatibility');
            }
            $this->_info['min'] = $value['min'];
            $this->_info['max'] = $value['max'];
            if (isset($value['exclude'])) {
                $this->_info['exclude'] = $value['exclude'];
            }
        }
        $this->_save();
    }

    /**
     * Remove a compatible package from package.xml (by channel/package)
     * @param string $var
     */
    function offsetUnset($var)
    {
        if (!isset($this->_packageInfo['compatible'])) {
            return;
        }
        $channel = explode('/', $var);
        $package = array_pop($channel);
        $channel = implode('/', $channel);
        if (isset($this->_packageInfo['compatible'][0])) {
            foreach ($this->_packageInfo['compatible'] as $i => $stuff) {
                if ($stuff['name'] == $package && $stuff['channel'] == $channel) {
                    unset($this->_packageInfo['compatible'][$i]);
                    if (!count($this->_packageInfo['compatible'])) {
                        unset($this->_packageInfo['compatible']);
                    }
                    if (count($this->_packageInfo)) {
                        if (isset($this->_packageInfo[0])) {
                            $this->_count = count($this->_packageInfo);
                        } else {
                            $this->_count = 1;
                        }
                    }
                    return;
                }
            }
        } else {
            if ($this->_packageInfo['compatible']['name'] == $package &&
                  $this->_packageInfo['compatible']['channel'] == $channel) {
                unset($this->_packageInfo['compatible']);
                $this->_count = 0;
            }
        }
    }

    /**
     * Test whether compatible package exists in package.xml (by channel/package)
     * @param string $var
     * @return bool
     */
    function offsetExists($var)
    {
        if (!isset($this->_packageInfo['compatible'])) return false;
        $channel = explode('/', $var);
        $package = array_pop($channel);
        $channel = implode('/', $channel);
        $stuff = $this->_packageInfo['compatible'];
        if (!isset($stuff[0])) {
            $stuff = array($stuff);
        }
        foreach ($stuff as $compat) {
            if ($compat['name'] == $package && $compat['channel'] == $channel) {
                return true;
            }
        }
        return false;
    }

    /**
     * Save changes
     */
    private function _save()
    {
        if (!isset($this->_packageInfo['compatible'])) {
            $this->_packageInfo['compatible'] = $this->_info;
            $this->_count = 1;
            return;
        }
        foreach ($this->_packageInfo['compatible'] as $i => $compat) {
            if ($compat['name'] == $package && $compat['channel'] == $channel) {
                // replace declaration
                $this->_packageInfo['compatible'][$i] = $this->_info;
                return;
            }
        }
        $this->_packageInfo['compatible'][] = $this->_info;
        $this->_count = count($this->_packageInfo);
    }

    function current()
    {
        if (!$this->valid()) return null;
        if (!isset($this->_packageInfo['compatible'][0])) {
            return $this->_packageInfo['compatible'];
        }
        return $this->_packageInfo['compatible'][$this->_pos];
    }

    function next()
    {
        $this->_pos++;
    }

    function key()
    {
        if (!$this->valid()) return null;
        if (!isset($this->_packageInfo['compatible'][0])) {
            return $this->_packageInfo['compatible']['channel'] . '/' .
                   $this->_packageInfo['compatible']['package'];
        }
        return $this->_packageInfo['compatible'][$this->_pos]['channel'] . '/' .
               $this->_packageInfo['compatible'][$this->_pos]['package'];
    }

    function valid()
    {
        if (!$this->_count) {
            return false;
        }
        return $this->_pos < $this->_count;
    }

    function rewind()
    {
        $this->_pos = 0;
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Compatible_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for compatiblility exceptions in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Compatible_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Dependencies
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Manage dependencies
 *
 * To be used like:
 * <code>
 * // reset deps
 * $pf->dependencies = null;
 * // for PHP dep
 * // defaults to min
 * $pf->dependencies->required->php = '5.3.0';
 * $pf->dependencies->required->php = array('min' => '5.3.0', 'max' => '7.0.0',
 *      'exclude' => array('6.1.2'));
 * // for PEAR Installer dep
 * // defaults to min
 * $pf->dependencies->required->pearinstaller = '2.0.0';
 * $pf->dependencies->required->pearinstaller = array('min' => '2.0.0');
 * // for required/optional package deps or subpackage deps
 * $pf->dependencies->required->package['channel/PackageName'] =
 *      array('min' => '1.1.0', 'max' => '1.2.0', 'recommended' => '1.1.1',
 *            'exclude' => array('1.1.0a1', '1.1.0a2'));
 * $pf->dependencies->optional->package['channel/PackageName'] =
 *      array('min' => '1.1.0', 'max' => '1.2.0', 'recommended' => '1.1.1',
 *            'exclude' => array('1.1.0a1', '1.1.0a2'));
 * $pf->dependencies->required->subpackage['channel/PackageName'] =
 *      array('min' => '1.1.0', 'max' => '1.2.0', 'recommended' => '1.1.1',
 *            'exclude' => array('1.1.0a1', '1.1.0a2'));
 * // for conflicting package dep
 * $pf->dependencies->required->subpackage['channel/PackageName'] =
 *      array('min' => '1.1.0', 'max' => '1.2.0', 'recommended' => '1.1.1',
 *            'exclude' => array('1.1.0a1', '1.1.0a2'), 'conflicts' => '');
 * // for PECL extension deps (optional or required same as packages)
 * $pf->dependencies->required->package['channel/PackageName'] =
 *      array('min' => '1.1.0', 'max' => '1.2.0', 'recommended' => '1.1.1',
 *            'exclude' => array('1.1.0a1', '1.1.0a2'), 'providesextension' => 'packagename');
 * // for extension deps (required or optional same as packages)
 * $pf->dependencies->required->extension['extension'] =
 *      array('min' => '1.0.0', 'max' => '1.2.0', 'recommended' => '1.1.1');
 * // for regular arch deps
 * $pf->dependencies->required->arch['i386'] = true // only works on i386
 * // for conflicting arch deps
 * $pf->dependencies->required->arch['*(ix|ux)'] = false // doesn't work on unix/linux
 * // for regular OS deps
 * $pf->dependencies->required->os['windows'] = true; // only works on windows
 * // for conflicting OS deps
 * $pf->dependencies->required->os['freebsd'] = false; // doesn't work on FreeBSD
 *
 * // dependency group setup
 * $group = $pf->dependencies->group['name']->hint('Install optional stuff as a group');
 * $group->package['channel/PackageName1'] = array();
 * $group->package['channel/PackageName2'] = array('min' => '1.2.0');
 * $group->subpackage['channel/PackageName3'] = array('recommended' => '1.2.1');
 * $group->extension['extension'] = array();
 * </code>
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Dependencies implements ArrayAccess, Iterator, Countable
{
    private $_parent;
    private $_packageInfo;
    private $_required;
    private $_group = null;
    private $_package;
    private $_type;
    private $_pos = 0;
    private $_count = 0;
    private $_info = array();
    function __construct(array &$parent, array &$packageInfo, $required = null, $type = null,
                         $package = null, $group = null)
    {
        $this->_parent = &$parent;
        $this->_packageInfo = &$packageInfo;
        if (!$required) return;
        if (!in_array($required, array('required', 'optional', 'group'), true)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                'Internal error: $required is not required/optional/group');
        }
        $this->_required = $required;
        if (!isset($parent[$required])) {
            $parent[$required] = array();
            $this->_packageInfo = &$parent;
        }
        if ($this->_required != 'group' && $group) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                'Internal error: $group passed into required dependency');
        } elseif ($group) {
            if (!is_string($group)) {
                throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                    'Internal error: $group must be a string');
            }
            $this->_packageInfo = &$parent['group'];
            $this->_group = $group;
            // locate group in the xml and initialize if not present
            if (!count($this->_packageInfo)) {
                $this->_packageInfo =
                    array('attribs' => array('name' => $group, 'hint' => ''));
            } elseif (!isset($this->_packageInfo[0])) {
                if ($this->_packageInfo['attribs']['name'] != $group) {
                    $this->_packageInfo = array($this->_packageInfo,
                        array('attribs' => array('name' => $group, 'hint' => '')));
                    $this->_packageInfo = &$this->_packageInfo[1];
                }
            } else {
                $found = false;
                foreach ($this->_packageInfo as $i => $g) {
                    if ($g['attribs']['name'] == $group) {
                        $this->_packageInfo = &$this->_packageInfo[$i];
                        $found = true;
                        break;
                    }
                }
                if (!$found) {
                    $this->_packageInfo[$i = count($this->_packageInfo)] =
                        array('attribs' => array('name' => $group, 'hint' => ''));
                }
            }
        } elseif (!$type) {
            $this->_packageInfo = &$this->_packageInfo[$this->_required];
        }
        if (!$type) {
            if (count($this->_packageInfo)) {
                if (isset($this->_packageInfo[0])) {
                    $this->_count = count($this->_packageInfo);
                } else {
                    $this->_count = 1;
                }
            }
            return;
        }
        if (!is_string($type)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                        'Internal error: $type is not a string, but is a ' . gettype($type));
        }
        if ($required == 'required') {
            switch ($type) {
                case 'php' :
                case 'pearinstaller' :
                case 'package' :
                case 'subpackage' :
                case 'extension' :
                case 'arch' :
                case 'os' :
                    $this->_type = $type;
                    if (!isset($this->_packageInfo[$type])) {
                        $this->_packageInfo[$type] = array();
                    }
                    $this->_packageInfo = &$this->_packageInfo[$type];
                    break;
                default :
                    throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                        'Unknown dependency type ' . $type);
            }
        } else {
            switch ($type) {
                case 'package' :
                case 'subpackage' :
                case 'extension' :
                    $this->_type = $type;
                    if (!isset($this->_packageInfo[$type])) {
                        $this->_packageInfo[$type] = array();
                    }
                    $this->_packageInfo = &$this->_packageInfo[$type];
                    break;
                case 'php' :
                case 'pearinstaller' :
                case 'arch' :
                case 'os' :
                default :
                    throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                        $type . ' dependency cannot be optional');
            }
        }
        if (count($this->_packageInfo)) {
            if (isset($this->_packageInfo[0])) {
                $this->_count = count($this->_packageInfo);
            } else {
                $this->_count = 1;
            }
        } else {
            $this->_count = 0;
        }
        if (!$package) return;
        switch ($this->_type) {
            case 'php' :
            case 'pearinstaller' :
                throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                    'Internal error: $package passed into ' . $type . ' dependency');
            case 'package' :
            case 'subpackage' :
                $channel = explode('/', $package);
                $package = array_pop($channel);
                $channel = implode('/', $channel);
                $this->_info['name'] = $package;
                $this->_info['channel'] = $channel;
                $this->_package = true;
                break;
            case 'os' :
            case 'extension' :
                $this->_info['name'] = $package;
                $this->_package = true;
                break;
            case 'arch' :
                $this->_info['pattern'] = $package;
                $this->_package = true;
                break;
        }
        if (!isset($this->_packageInfo[0])) {
            $name = ($this->_type == 'arch') ? 'pattern' : 'name';
            if ($this->_packageInfo[$name] != $package) {
                $this->_packageInfo = array($this->_packageInfo, array($name => $package));
                $this->_packageInfo = &$this->_packageInfo[1];
            }
        } else {
            foreach ($this->_packageInfo as $i => $dep) {
                if ($dep[$name] == $package) {
                    $this->_packageInfo = &$this->_packageInfo[$i];
                    return;
                }
            }
            $this->_packageInfo[$i = count($this->_packageInfo)] = array($name => $package);
            $this->_packageInfo = &$this->_packageInfo[$i];
        }
    }

    function __get($var)
    {
        if (!isset($this->_required)) {
            return new PEAR2_Pyrus_PackageFile_v2_Dependencies($this->_parent,
                $this->_packageInfo, $var);
        }
        if (!isset($this->_type)) {
            if (isset($this->_group)) {
                return new PEAR2_Pyrus_PackageFile_v2_Dependencies(
                    $this->_parent, $this->_packageInfo, $this->_required,
                    $var, null, $this->_group);
            } else {
                return new PEAR2_Pyrus_PackageFile_v2_Dependencies(
                    $this->_parent, $this->_packageInfo, $this->_required,
                    $var);
            }
        }
        if ($this->_type == 'group' && !isset($this->_group)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                'Dependency group must be accessed like $pf->group[\'groupname\']');
        }
        if (!isset($this->_package) && $this->_type != 'php' && $this->_type != 'pearinstaller') {
            return new PEAR2_Pyrus_PackageFile_v2_Dependencies(
                $this->_parent, $this->_packageInfo[$var], $this->_required,
                $this->_type, $var);
        }
        if (!isset($this->_packageInfo[$var])) {
            return null;
        }
        return $this->_packageInfo[$var];
    }

    function __set($var, $value)
    {
        if (isset($this->_required) && $this->_required == 'required'
              && in_array($var, array('php', 'pearinstaller'), true)) {
            if (is_string($value)) {
                $value = array('min' => $value);
            }
            if (!is_array($value)) {
                throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                    $var . ' dependency must be an array, was a ' . gettype($value));
            }
            $info = array();
            foreach (array('min', 'max', 'exclude') as $index) {
                if (isset($value[$index])) {
                    $info[$index] = $value[$index];
                }
            }
            $this->_packageInfo[$var] = $info;
            return;
        }
        throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
            'Cannot set ' . $var . ' directly');
    }

    function current()
    {
        if (!$this->valid()) return null;
        if ($this->_required === 'group' && !isset($this->_group)) {
            if (!isset($this->_type)) {
                if (!isset($this->_packageInfo[0])) {
                    return new PEAR2_Pyrus_PackageFile_v2_Dependencies(
                        $this->_parent, $this->_packageInfo, $this->_required,
                        $this->_type, null, $this->_packageInfo['attribs']['name']);
                } else {
                    return new PEAR2_Pyrus_PackageFile_v2_Dependencies(
                        $this->_parent, $this->_packageInfo, $this->_required,
                        $this->_type, null, $this->_packageInfo[$this->_pos]['attribs']['name']);
                }
            }
        }
        if (!isset($this->_packageInfo[0])) {
            return $this->_packageInfo;
        }
        return $this->_packageInfo[$this->_pos];
    }

    function next()
    {
        $this->_pos++;
    }

    function key()
    {
        if (!$this->valid()) return null;
        return $this->_pos;
    }

    function valid()
    {
        if (!$this->_count) {
            return false;
        }
        return $this->_pos < $this->_count;
    }

    function rewind()
    {
        $this->_pos = 0;
    }

    function count()
    {
        return $this->_count;
    }

    function hint($hint)
    {
        if ($this->_required !== 'group' || !$this->_group) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                'hint can only be set for dependency groups');
        }
        $this->_packageInfo['attribs']['hint'] = $hint;
        return $this;
    }

    function offsetGet($var)
    {
        if ($this->_required == 'group' && !isset($this->_group)) {
            return new PEAR2_Pyrus_PackageFile_v2_Dependencies(
                $this->_parent, $this->_packageInfo, $this->_required,
                $this->_type, null, $var);
        }
        if (isset($this->_type) && in_array($this->_type, array('php', 'pearinstaller', 'arch', 'os'))) {
            return $this->_packageInfo[$var];
        }
        return new PEAR2_Pyrus_PackageFile_v2_Dependencies(
            $this->_parent, $this->_packageInfo, $this->_required,
            $this->_type, $var, $this->_group);
    }

    function offsetSet($var, $value)
    {
        if (!isset($this->_required)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception(
                        'Cannot set ' . $var . ' directly, must specify required, optional, or group dependency first');
        }
        if (isset($this->_type) && in_array($this->_type, array('package', 'subpackage'))) {
            if (!is_array($value)) {
                throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                    $this->_type . ' dependency must be an array, was a ' . gettype($value));
            }
            $channel = explode('/', $var);
            $package = array_pop($channel);
            $channel = implode('/', $channel);
            $info = array('name' => $package, 'channel' => $channel);
            foreach (array('min', 'max', 'recommended', 'exclude', 'nodefault',
                           'conflicts', 'providesextension') as $index) {
                if (isset($value[$index])) {
                    $info[$index] = $value[$index];
                }
            }
            if (isset($this->_packageInfo[0])) {
                foreach ($this->_packageInfo as $i => $dep) {
                    if ($dep['package'] === $package && $dep['channel'] === $channel) {
                        $this->_packageInfo[$i] = $info;
                        return;
                    }
                }
                $this->_packageInfo[] = $info;
            } else {
                if (!count($this->_packageInfo)) {
                    $this->_packageInfo = $info;
                    return;
                }
                if ($this->_packageInfo['name'] === $package
                      && $this->_packageInfo['channel'] === $channel) {
                    $this->_packageInfo = $info;
                } else {
                    $this->_packageInfo = array($this->_packageInfo, $info);
                }
            }
            return;
        }
        if (isset($this->_type) && $this->_type === 'extension') {
            if (!is_array($value)) {
                throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                    $this->_type . ' dependency must be an array, was a ' . gettype($value));
            }
            $info = array('name' => $var);
            foreach (array('min', 'max', 'recommended', 'exclude', 'conflicts') as $index) {
                if (isset($value[$index])) {
                    $info[$index] = $value[$index];
                }
            }
            if (isset($this->_packageInfo[0])) {
                foreach ($this->_packageInfo as $i => $dep) {
                    if ($dep['name'] === $var) {
                        $this->_packageInfo[$i] = $info;
                        return;
                    }
                }
                $this->_packageInfo[] = $info;
            } else {
                if (!count($this->_packageInfo)) {
                    $this->_packageInfo = $info;
                } elseif ($this->_packageInfo['name'] === $var) {
                    $this->_packageInfo = $info;
                } else {
                    $this->_packageInfo = array($this->_packageInfo, $info);
                }
            }
            return;
        }
        if (isset($this->_type) && in_array($this->_type, array('arch', 'os'))) {
            $val = (bool) $value;
            $info = array(($this->_type === 'arch' ? 'pattern' : 'name') => $var);
            if (!$val) {
                $info['conflicts'] = '';
            }
            if (isset($this->_packageInfo[0])) {
                foreach ($this->_packageInfo as $index => $dep) {
                    if ($dep[$name] == $var) {
                        $this->_packageInfo[$index] = $info;
                        return;
                    }
                }
                $this->_packageInfo[] = $info;
            } else {
                if (!count($this->_packageInfo) || $this->_packageInfo[$name] === $var) {
                    $this->_packageInfo = $info;
                } else {
                    $this->_packageInfo = array($this->_packageInfo, $info);
                }
            }
        }
    }

    /**
     * unimplemented
     * @param string $var
     */
    function offsetUnset($var)
    {
    }

    /**
     * unimplemented
     * @param string $var
     * @return bool
     */
    function offsetExists($var)
    {
        return isset($this->_packageInfo[$var]);
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for dependency exceptions in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Developer
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Manage an individual maintainer in package.xml
 *
 * To be used like:
 *
 * <code>
 * // add developer
 * $pf->maintainer['cellog']
 *    ->name('Greg Beaver')
 *    ->role('lead')
 *    ->email('cellog@php.net')
 *    ->active('yes');
 * echo $pf->maintainer['cellog']->name;
 * isset($pf->maintainer['cellog']); // test for maintainer in package.xml
 * unset($pf->maintainer['cellog']); // remove from package.xml
 * </code>
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Developer implements ArrayAccess
{
    private $_packageInfo;
    private $_developer = null;
    private $_role = null;
    private $_info = array('name' => null, 'user' => null, 'email' => null, 'active' => null);
    function __construct(array &$parent, $developer = null)
    {
        $this->_packageInfo = &$parent;
        if ($developer) {
            $this->_developer = $developer;
            $this->_info['user'] = $developer;
        }
    }

    /**
     * Search for a maintainer, find them and return the maintainer role
     *
     * @param string $handle
     * @return string|false the role (lead, developer, contributor, helper)
     */
    function locateMaintainerRole($handle)
    {
        foreach (array('lead', 'developer', 'contributor', 'helper') as $role) {
            if (!isset($this->_packageInfo[$role])) continue;
            $inf = $this->_packageInfo[$role];
            if (!isset($inf[0])) $inf = array($inf);
            foreach ($inf as $i) {
                if ($i['user'] == $handle) return $role;
            }
        }
        return false;
    }

    function __get($var)
    {
        if ($this->_developer === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Cannnot access developer info for unknown developer');
        }
        if (!isset($this->_info[$var])) {
            return null;
        }
        return $this->_info[$var];
    }

    function __call($var, $args)
    {
        if ($this->_developer === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Cannnot set developer info for unknown developer');
        }
        if ($var == 'role') {
            $this->_role = $args[0];
            return $this;
        }
        if (!array_key_exists($var, $this->_info) || $var == 'user') {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Cannot set unknown value ' . $var);
        }
        if (count($args) != 1 || !is_string($args[0])) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Invalid value for ' . $var);
        }
        $this->_info[$var] = $args[0];
        $this->_save();
        return $this;
    }

    function offsetGet($var)
    {
        return new PEAR2_Pyrus_PackageFile_v2_Developer($this->_packageInfo, $var);
    }

    function offsetSet($var, $value)
    {
        $this->_developer = $var;
        $this->_info['user'] = $var;
        if ($var instanceof PEAR2_Pyrus_PackageFile_v2_Developer) {
            $this->_info['name'] = $value->name;
            $this->_info['email'] = $value->email;
            $this->_info['active'] = $value->active;
        }
        if (is_array($value) || $value instanceof ArrayObject) {
            if (!isset($value['name']) || !isset($value['email']) || !isset($value['active'])) {
                throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                    'Invalid array used to set ' . $this->_developer . ' information');
            }
            $this->_info['name'] = $value['name'];
            $this->_info['email'] = $value['email'];
            $this->_info['active'] = $value['active'];
        }
        $this->_save();
    }

    /**
     * Remove a developer from package.xml (by handle)
     * @param string $var
     */
    function offsetUnset($var)
    {
        // remove developer
        $role = $this->locateMaintainerRole($var);
        if (!$role) {
            // already non-existent
            return;
        }
        if (count($this->_packageInfo[$role]) == 1) {
            unset($this->_packageInfo[$role]);
            return;
        }
        foreach ($this->_packageInfo[$role] as $i => $stuff) {
            if ($stuff['user'] == $var) {
                unset($this->_packageInfo[$role][$i]);
                if (count($this->_packageInfo[$role]) == 1) {
                    $this->_packageInfo[$role] = $this->_packageInfo[$role][0];
                }
                return;
            }
        }
    }

    /**
     * Test whether developer exists in package.xml (by handle)
     * @param string $var
     * @return bool
     */
    function offsetExists($var)
    {
        return (bool) $this->locateMaintainerRole($var);
    }

    /**
     * Save changes
     */
    private function _save()
    {
        if (!$this->_role) return;
        if (!$this->_developer) return;
        if (!isset($this->_info['user']) || !isset($this->_info['name']) ||
              !isset($this->_info['email']) || !isset($this->_info['active'])) return;
        $role = $this->locateMaintainerRole($this->_developer);
        if (!$role) {
            // create new
            if (!isset($this->_packageInfo[$this->_role])) {
                $this->_packageInfo[$this->_role] = $this->_info;
                return;
            }
            if (!isset($this->_packageInfo[$this->_role][0])) {
                $this->_packageInfo[$this->_role] = array($this->_packageInfo[$this->_role],
                    $this->_info);
            } else {
                $this->_packageInfo[$this->_role][] = $this->_info;
            }
            return;
        }
        // remove the maintainer from their old role
        if ($role !== $this->_role) {
            if (!isset($this->_packageInfo[$role][0])) {
                unset($this->_packageInfo[$role]);
            } else {
                foreach ($this->_packageInfo[$role] as $i => $dev) {
                    if ($dev['user'] == $this->_developer) {
                        unset($this->_packageInfo[$role][$i]);
                        if (count($this->_packageInfo[$role]) == 1) {
                            $this->_packageInfo[$role] = $this->_packageInfo[$role][0];
                        } else {
                            $this->_packageInfo[$role] =
                                array_values($this->_packageInfo[$role]);
                        }
                    }
                }
            }
        }
        if (!isset($this->_packageInfo[$this->_role])) {
            $this->_packageInfo[$this->_role] = $this->_info;
            return;
        }
        if (!isset($this->_packageInfo[$this->_role][0])) {
            if ($role !== $this->_role) {
                // We are a new entry into this role, and now there are 2 of us
                $this->_packageInfo[$this->_role] =
                    array($this->_packageInfo[$this->_role], $this->_info);
            } else {
                // We are replacing ourself
                $this->_packageInfo[$this->_role] = $this->_info;
            }
        } else {
            if ($role !== $this->_role) {
                // We are a new entry into this role, and now there are several of us
                $this->_packageInfo[$this->_role][] = $this->_info;
            } else {
                foreach ($this->_packageInfo[$role] as $i => $maybeme) {
                    if ($maybeme['user'] == $this->_developer) {
                        // found our entry
                        $this->_packageInfo[$role][$i] = $this->_info;
                        return;
                    }
                }
            }
        }
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Developer_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for developer exceptions in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Developer_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Files
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Represents the files within a package file
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Files implements ArrayAccess
{
    protected $array;
    function __construct(&$array)
    {
        $this->array = &$array;
    }

    function offsetUnset($var)
    {
        unset($this->array[$var]);
    }

    function offsetIsset($var)
    {
        return isset($this->array[$var]);
    }

    function offsetGet($var)
    {
        if (isset($this->array[$var])) {
            return $this->array[$var];
        }
        return null;
    }

    function offsetSet($var, $value)
    {
        if (!is_array($value)) {
            throw new PEAR2_PackageFile_v2_Files_Exception('File must be an array of
                attributes and tasks');
        }
        if (!isset($value['attribs'])) {
            // no tasks is assumed
            $value = array('attribs' => $value);
        }
        $value['attribs']['name'] = $var;
        if (!isset($value['attribs']['role'])) {
            throw new PEAR2_Pyrus_PackageFile_v2_Files_Exception('File role must be set for' .
                ' file ' . $var);
        }
        $this->array[$var] = $value;
    }

    function offsetExists($var)
    {
        return isset($this->array[$var]);
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Files_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for file exceptions in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Files_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Release
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Manage a release in package.xml
 *
 * To be used like:
 *
 * <code>
 * // release is a PHP package
 * $pf->type = 'php';
 * // release is an extension source package
 * $pf->type = 'extsrc';
 * $pf->release[0]->installconditions['php'] = array('min' => '5.2.0');
 * // defaults to "min"
 * $pf->release[0]->installconditions['php'] = '5.2.0';
 * // defaults to "pattern"
 * $pf->release[0]->installconditions['arch'] = 'i386';
 * $pf->release[0]->installconditions['arch'] =
 *      array('pattern' => 'i386', 'conflicts' => 'yes');
 * // defaults to "name"
 * $pf->release[0]->installconditions['os'] = 'windows';
 * // defaults to existing
 * $pf->release[0]->installconditions['extension']['PDO'] = array();
 * $pf->release[0]->installconditions['extension']['PDO'] =
 *      array('min' => '1.0');
 * $pf->release[0]->ignore('path/to/file.ext');
 * $pf->release[0]->installAs('path/to/anotherfile.ext', 'new/name.php');
 * // add another release
 * $i = count($pf->release);
 * $pf->release[$i]->ignore('path/to/anotherfile.ext');
 * $pf->release[$i]->installAs('path/to/file.ext', 'new/name.php');
 * // remove release
 * unset($pf->release[1]);
 * // remove all releases
 * $pf->release = null;
 * </code>
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Release implements ArrayAccess, Countable
{
    private $_parent;
    private $_packageInfo;
    private $_filelist;
    private $_installcondition;
    function __construct(array &$parent, array &$packageInfo, array &$filelist,
                         $installcondition = null)
    {
        $this->_parent = &$parent;
        $this->_packageInfo = &$packageInfo;
        $this->_filelist = &$filelist;
        $this->_installcondition = $installcondition;
    }

    function __get($var)
    {
        if ($var === 'installconditions') {
            return new PEAR2_Pyrus_PackageFile_v2_Release($this->_parent,
                       $this->_packageInfo[$var], $this->_filelist, true);
        }
        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Unknown variable ' . $var .
            ', installconditions is the only supported variable');
    }

    function count()
    {
        if (isset($this->_packageInfo[0])) {
            return count($this->_packageInfo);
        }
        return count($this->_packageInfo) ? 1 : 0;
    }

    function offsetGet($var)
    {
        if (is_int($var) && !$this->_installcondition) {
            if (isset($this->_packageInfo[0])) {
                if (!isset($this->_packageInfo[$var])) {
                    if ($var != count($this)) {
                        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                            'Can only set the ' .
                            'next highest release index ' . count($this) . ', not ' . $var);
                    }
                    $this->_packageInfo[$var] = array();
                }
                return new PEAR2_Pyrus_PackageFile_v2_Release($this->_parent,
                           $this->_packageInfo[$var], $this->_filelist);
            } else {
                if (!$var) {
                    return $this;
                }
                if ($var != count($this)) {
                    throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Can only set the ' .
                        'next highest release index ' . count($this) . ', not ' . $var);
                }
                $this->_packageInfo = array($this->_packageInfo, array());
                return new PEAR2_Pyrus_PackageFile_v2_Release($this->_parent,
                           $this->_packageInfo[$var], $this->_filelist);
            }
        }
        if (is_string($var) && $this->_installcondition == 'extension') {
            if (!isset($this->_packageInfo[$var])) {
                $this->_packageInfo[$var] = array();
            }
            return new PEAR2_Pyrus_PackageFile_v2_Release($this->_parent,
                       $this->_packageInfo[$var], $this->_filelist, 'extension');
        }
        if (!is_int($var) && !$this->_installcondition) {
            if (is_string($this->_installcondition)) {
                if (isset($this->_packageInfo[$var])) {
                    return $this->_packageInfo[$var];
                }
                return null;
            }
            if (in_array($var, array('php', 'os', 'arch', 'extension'), true)) {
                if (!isset($this->_packageInfo['installconditions'])) {
                    $this->_packageInfo['installconditions'] = array();
                }
                if (!isset($this->_packageInfo['installconditions'][$var])) {
                    $this->_packageInfo['installconditions'][$var] = array();
                }
                if ($var !== 'extension') {
                    return $this->_packageInfo['installconditions'][$var];
                }
                return new PEAR2_Pyrus_PackageFile_v2_Release($this->_parent,
                           $this->_packageInfo[$var], $this->_filelist, 'extension');
            }
        }
        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Cannot access numeric index of ' .
            $this->_installcondition . ' install condition');
    }

    private function _setExtension($info)
    {
        if (!isset($this->_packageInfo[0])) {
            if (!count($this->_packageInfo)) {
                $this->_packageInfo = $info;
                return;
            }
            if ($this->_packageInfo['name'] == $info['name']) {
                $this->_packageInfo = $info;
            } else {
                $this->_packageInfo = array($this->_packageInfo, $info);
            }
        } else {
            foreach ($this->_packageInfo as $i => $cond) {
                if ($dep['name'] === $info['name']) {
                    $this->_packageInfo[$i] = $info;
                    return;
                }
            }
            $this->_packageInfo[] = $info;
        }
    }

    function offsetSet($var, $value)
    {
        if (!isset($this->_installcondition)) {
            if ($var === null) {
                $var = 0;
            }
            if (is_int($var)) {
                if (!isset($this->_packageInfo[$var])) {
                    if (count($this->_packageInfo)) {
                        $this->_packageInfo = array($this->_packageInfo);
                    }
                    if (!isset($this->_packageInfo[$var])) {
                        $this->_packageInfo[$var] = array();
                    }
                }
                return new PEAR2_Pyrus_PackageFile_v2_Release($this->_parent,
                    $this->_packageInfo[$var], $this->_filelist);
            }
        }
        if ($this->_installcondition === 'extension') {
            if (!is_string($var)) {
                throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('extension names must be ' .
                    'strings for installconditions');
            }
            $info = array();
            if (is_array($value)) {
                foreach (array('name', 'min', 'max', 'exclude', 'conflicts') as $index) {
                    if (!isset($value[$index])) continue;
                    $info[$index] = $value[$index];
                }
            } elseif (is_string($value)) {
                $info = array('name' => $value);
            } else {
                throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('extension can only be set to' .
                    ' array or string');
            }
            $this->_setExtension($info);
            return;
        }
        switch ($var) {
            case 'php' :
                $info = array();
                if (is_array($value)) {
                    foreach (array('min', 'max', 'exclude') as $index) {
                        if (!isset($value[$index])) continue;
                        $info[$index] = $value[$index];
                    }
                } elseif (is_string($value)) {
                    $info = array('min' => $value);
                }
                $this->_packageInfo = $value;
                break;
            case 'arch' :
                $info = array();
                if (is_array($value)) {
                    foreach (array('pattern', 'conflicts') as $index) {
                        if (!isset($value[$index])) continue;
                        $info[$index] = $value[$index];
                    }
                } elseif (is_string($value)) {
                    $info = array('pattern' => $value);
                }
                $this->_packageInfo = $value;
                break;
            case 'os' :
                $info = array();
                if (is_array($value)) {
                    foreach (array('name', 'conflicts') as $index) {
                        if (!isset($value[$index])) continue;
                        $info[$index] = $value[$index];
                    }
                } elseif (is_string($value)) {
                    $info = array('name' => $value);
                }
                $this->_packageInfo = $value;
                break;
            case 'extension' :
                throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Use [\'extensionname\'] to set' .
                ' an extension\'s installcondition');
            default :
                throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Unknown installcondition ' .
                    $var);
        }
    }

    /**
     * @param string $var
     */
    function offsetUnset($var)
    {
        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('unset not supported');
    }

    /**
     * @param string $var
     * @return bool
     */
    function offsetExists($var)
    {
        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('isset not supported');
    }

    function ignore($file)
    {
        if ($this->_installcondition) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('file ignore is not supported' .
                ' within installconditions');
        }
        if (isset($this->_filelist[$file])) {
            if (!isset($this->_packageInfo['ignore'])) {
                $this->_packageInfo['ignore'] = array('attribs' => array('name' => $file));
                return;
            }
            if (!isset($this->_packageInfo['ignore'][0])) {
                $this->_packageInfo['ignore'] = array($this->_packageInfo['ignore'],
                    array('attribs' => array('name' => $file)));
            }
            $this->_packageInfo['ignore'][] = array('attribs' => array('name' => $file));
        }
        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Unknown file ' . $file .
            ' - add to filelist before ignoring');
    }

    function installAs($file, $newname)
    {
        if (!is_string($file) || !is_string($newname)) {
            throw BadMethodCallException('$file and $newname must be strings');
        }
        if ($this->_installcondition) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('file ignore is not supported' .
                ' within installconditions');
        }
        if (isset($this->_filelist[$file])) {
            if (!isset($this->_packageInfo['install'])) {
                $this->_packageInfo['install'] = array('attribs' =>
                    array('name' => $file, 'as' => $newname));
                return;
            }
            if (!isset($this->_packageInfo['install'][0])) {
                $this->_packageInfo['install'] = array($this->_packageInfo['install'],
                    array('attribs' => array('name' => $file, 'as' => $newname)));
                return;
            }
            $this->_packageInfo['install'][] = array('attribs' =>
                array('name' => $file, 'as' => $newname));
            return;
        }
        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Unknown file ' . $file .
            ' - add to filelist before adding install as tag');
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Release_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for release info in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Release_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Remote
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Represents a remote package file
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Remote extends PEAR2_Pyrus_PackageFile_v2
{

}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Validator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Private validation class used by PEAR2_Pyrus_PackageFile_v2 - do not use directly, its
 * sole purpose is to split up the PEAR/PackageFile/v2.php file to make it smaller
 *
 * @access     private
 * @category   pear
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Validator
{
    /**
     * @var array
     */
    var $_packageInfo;
    /**
     * @var PEAR2_Pyrus_PackageFile_v2
     */
    var $_pf;
    /**
     * @var PEAR2_Pyrus_ErrorStack
     */
    var $_stack;
    /**
     * @var int
     */
    var $_isValid = 0;
    /**
     * @var int
     */
    var $_filesValid = 0;
    /**
     * @var int
     */
    var $_curState = 0;
    private $_contents = array();
    private $_errors;

    /**
     * @param PEAR2_Pyrus_PackageFile_v2
     * @param int
     */
    function validate(PEAR2_Pyrus_PackageFile_v2 $pf, $state = PEAR2_Pyrus_Validate::NORMAL)
    {
        $this->_errors = new PEAR2_MultiErrors;
        if (!$pf->schemaOK) {
            // this package.xml was created from scratch, not loaded from an existing
            // package.xml
            $dom = new DOMDocument;
            libxml_use_internal_errors(true);
            libxml_clear_errors();
            $dom->loadXML($pf);
            $a = $pf->toArray();
            if ($a['package']['attribs']['version'] == '2.1') {
                $schema = PEAR2_Pyrus::getDataPath() . '/package-2.1.xsd';
                // for running out of cvs
                if (!file_exists($schema)) {
                    $schema = dirname(dirname(dirname(dirname(dirname(__FILE__))))) . '/data/package-2.1.xsd';
                }
            } else {
                $schema = PEAR2_Pyrus::getDataPath() . '/package-2.0.xsd';
                // for running out of cvs
                if (!file_exists($schema)) {
                    $schema = dirname(dirname(dirname(dirname(dirname(__FILE__))))) . '/data/package-2.0.xsd';
                }
            }
            $dom->schemaValidate($schema);
            $causes = array();
            foreach (libxml_get_errors() as $error) {
                $this->_errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception("Line " .
                     $error->line . ': ' . $error->message);
            }
            if (count($this->_errors)) {
                throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml, does' .
                    ' not validate against schema', $this->_errors);
            }
        }
        $this->_pf = $pf;
        $this->_curState = $state;
        $this->_packageInfo = $this->_pf->toArray();
        $this->_packageInfo = $this->_packageInfo['package'];
        $this->_isValid = $this->_pf->_isValid;
        $this->_filesValid = $this->_pf->_filesValid;
        if (($this->_isValid & $state) == $state) {
            return true;
        }
        if (!isset($this->_packageInfo) || !is_array($this->_packageInfo)) {
            return false;
        }
        $myversion = self::VERSION;
        if ($myversion === '2.0.0a1') {
            // we're running from CVS, assume we're 2.0.0
            $myversion = '2.0.0';
        }
        $test = $this->_packageInfo;
        if (isset($test['dependencies']) &&
              isset($test['dependencies']['required']) &&
              isset($test['dependencies']['required']['pearinstaller']) &&
              isset($test['dependencies']['required']['pearinstaller']['min']) &&
              version_compare($myversion,
                $test['dependencies']['required']['pearinstaller']['min'], '<')) {
            $this->_errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                'This package.xml requires PEAR version ' .
                $test['dependencies']['required']['pearinstaller']['min'] .
                ' to parse properly, we are version ' . $myversion);
        $this->_errors = new PEAR2_MultiErrors;
        }
        $fail = false;
        if (!count($this->_contents) && isset($this->_packageInfo['contents'])) {
            $contents = array();
            foreach ($pf->contents as $file) {
                // leverage the hidden iterators to do our validation
                $name = $file->dir . $file->name;
                if ($name[0] == '.' && $name[1] == '/') {
                    // name is something like "./doc/whatever.txt"
                    $this->_errors->E_ERROR[] = new PEAR2_Pyrus_Package_Exception(
                        'File "' . $name . '" cannot begin with "."');
                    continue;
                }
                if (!$this->_validateRole($file->role)) {
                    if (isset($this->_packageInfo['usesrole'])) {
                        $roles = $this->_packageInfo['usesrole'];
                        if (!isset($roles[0])) {
                            $roles = array($roles);
                        }
                        foreach ($roles as $role) {
                            if ($role['role'] = $file->role) {
                                if (isset($role['uri'])) {
                                    $package = $role['uri'];
                                } else {
                                    $package = PEAR2_Pyrus_Config::
                                        parsedPackageNameToString(array('package' =>
                                            $role['package'], 'channel' => $role['channel']),
                                            true);
                                }
                                $msg = 'This package contains role "' . $file->role .
                                    '" and requires package "' . $package
                                     . '" to be used';
                                $this->_errors->E_WARNING[] =
                                    new PEAR2_Pyrus_PackageFile_Exception($msg);
                            }
                        }
                    }
                    $this->_errors->E_ERROR[] =
                        new PEAR2_Pyrus_PackageFile_Exception(
                        'File "' . $name . '" has invalid role "' .
                        $file->role . '", should be one of ' . implode(', ',
                        PEAR2_Pyrus_Installer_Role::getValidRoles($this->_pf->getPackageType())));
                }
                if (count($file->tasks) && $this->_curState != PEAR2_Pyrus_Validate::DOWNLOADING) { // has tasks
                    foreach ($file->tasks as $task => $value) {
                        if ($tagClass = $this->_pf->getTask($task)) {
                            if (!is_array($value) || !isset($value[0])) {
                                $value = array($value);
                            }
                            foreach ($value as $v) {
                                $ret = call_user_func(array($tagClass, 'validateXml'),
                                    $this->_pf, $v, $this->_pf->_config, $save);
                                if (is_array($ret)) {
                                    $this->_errors->E_ERROR[] =
                                        new PEAR2_Pyrus_PackageFile_Exception(
                                            $this->_invalidTask($task, $ret, isset($save['name']) ?
                                        $save['name'] : ''));
                                }
                            }
                        } else {
                            if (isset($this->_packageInfo['usestask'])) {
                                $roles = $this->_packageInfo['usestask'];
                                if (!isset($roles[0])) {
                                    $roles = array($roles);
                                }
                                foreach ($roles as $role) {
                                    if ($role['task'] = $task) {
                                        if (isset($role['uri'])) {
                                            $package = $role['uri'];
                                        } else {
                                            $package = PEAR2_Pyrus_Config::
                                                parsedPackageNameToString(array('package' =>
                                                    $role['package'], 'channel' => $role['channel']),
                                                    true);
                                        }
                                        $msg = 'This package contains task "' . $task .
                                            '" and requires package "' . $package
                                             . '" to be used';
                                        $this->_errors->E_WARNING[] =
                                            new PEAR2_Pyrus_PackageFile_Exception($msg);
                                    }
                                }
                            }
                            $this->_errors->E_ERROR[] =
                                new PEAR2_Pyrus_PackageFile_Exception(
                                'Unknown task "' . $task . '" passed in file <file name="' .
                                $name . '">');
                        }
                    }
                }
                $this->_contents[] = $name;
            }
        }
        $this->_validateRelease();
        if (count($this->_errors->E_ERROR)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml', $this->_errors);
        }
        try {
            $validator = PEAR2_Pyrus_Config::current()
                ->registry->channel[$this->_pf->channel]
                ->getValidationObject($this->_pf->name);
            $validator->setPackageFile($this->_pf);
            $validator->validate($state);
            // merge in errors from channel-specific validation
            $this->_errors[] = $validator->getFailures();
        } catch (PEAR2_Pyrus_Config_Exception $e) {
            throw new PEAR2_Pyrus_PackageFile_Exception(
                'Unable to process channel-specific configuration for channel ' .
                $this->_pf->getChannel(), $e);
        } catch (Exception $e) {
            $valpack = PEAR2_Pyrus_Config::current()
                ->registry->channel[$this->_pf->channel]->getValidationPackage();
            $this->_errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                'Unknown channel ' . $this->_pf->channel);
            $this->_errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                'package "' . $chan->getName() . '/' . $this->_pf->name .
                '" cannot be properly validated without validation package "' .
                $chan->getName() . '/' . $valpack['name'] . '-' . $valpack['version'] . '"');
        }
        if (count($this->_errors->E_ERROR)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml',
                $this->_errors);
        }
        if ($state == PEAR2_Pyrus_Validate::PACKAGING && !$this->_filesValid) {
            if ($this->_pf->type == 'bundle') {
                if (!$this->_analyzeBundledPackages()) {
                    throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml',
                        $this->_errors);
                }
            } else {
                if (!$this->_analyzePhpFiles()) {
                    throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml',
                        $this->_errors);
                }
            }
        }
        return $state;
    }

    function _validateFilelist($list)
    {
        $ignored_or_installed = array();
        $filelist = $this->_contents;
        if (isset($list['install'])) {
            if (!isset($list['install'][0])) {
                $list['install'] = array($list['install']);
            }
            foreach ($list['install'] as $file) {
                if (array_key_exists($file['attribs']['name'], $ignored_or_installed)) {
                    $this->_errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                        'Only one <install> tag is allowed for file "' .
                        $file['attribs']['name'] . '"');
                }
                if (!isset($ignored_or_installed[$file['attribs']['name']])) {
                    $ignored_or_installed[$file['attribs']['name']] = array();
                }
                $ignored_or_installed[$file['attribs']['name']][] = 1;
            }
        }
        if (isset($list['ignore'])) {
            if (!isset($list['ignore'][0])) {
                $list['ignore'] = array($list['ignore']);
            }
            foreach ($list['ignore'] as $file) {
                if (array_key_exists($file['attribs']['name'], $ignored_or_installed)) {
                    $this->_errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                        'Cannot have both <ignore> and <install> tags for file "' .
                        $file['attribs']['name'] . '"');
                }
            }
        }
    }

    function _validateRelease()
    {
        if (isset($this->_packageInfo['phprelease'])) {
            $release = 'phprelease';
            $releases = $this->_packageInfo['phprelease'];
            if (!is_array($releases)) {
                return true;
            }
            if (!isset($releases[0])) {
                $releases = array($releases);
            }
        }
        foreach (array('', 'zend') as $prefix) {
            $releasetype = $prefix . 'extsrcrelease';
            if (isset($this->_packageInfo[$releasetype])) {
                $release = $releasetype;
                $releases = $this->_packageInfo[$releasetype];
                if (!is_array($releases)) {
                    return true;
                }
                if (!isset($releases[0])) {
                    $releases = array($releases);
                }
            }
            $releasetype = 'extbinrelease';
            if (isset($this->_packageInfo[$releasetype])) {
                $release = $releasetype;
                $releases = $this->_packageInfo[$releasetype];
                if (!is_array($releases)) {
                    return true;
                }
                if (!isset($releases[0])) {
                    $releases = array($releases);
                }
            }
        }
        if (isset($this->_packageInfo['bundle'])) {
            $release = 'bundle';
            $releases = $this->_packageInfo['bundle'];
            if (!is_array($releases) || !isset($releases[0])) {
                $releases = array($releases);
            }
        }
        foreach ($releases as $rel) {
            if (is_array($rel) && array_key_exists('filelist', $rel)) {
                if ($rel['filelist']) {

                    $this->_validateFilelist($rel['filelist']);
                }
            }
        }
    }

    /**
     * This is here to allow role extension through plugins
     * @param string
     */
    function _validateRole($role)
    {
        return in_array($role, PEAR2_Pyrus_Installer_Role::getValidRoles($this->_pf->getPackageType()));
    }

    function _invalidTask($task, $ret, $file)
    {
        switch ($ret[0]) {
            case PEAR2_PYRUS_TASK_ERROR_MISSING_ATTRIB :
                return 'task <' . $task . '> is missing attribute "' . $ret[1] .
                    '" in file ' . $file;
            case PEAR2_PYRUS_TASK_ERROR_NOATTRIBS :
                return 'task <' . $task . '> has no attributes in file ' . $file;
            case PEAR2_PYRUS_TASK_ERROR_WRONG_ATTRIB_VALUE :
                return 'task <' . $task . '> attribute "' . $ret[1] .
                    '" has the wrong value "' . $ret[2] . '" '.
                    'in file ' . $file . ', expecting one of "' . implode (', ', $ret[3]) . '"';
            case PEAR2_PYRUS_TASK_ERROR_INVALID :
                return 'task <' . $task . '> in file ' . $file .
                    ' is invalid because of "' . $ret[1] . '"';
        }
    }

    function _analyzeBundledPackages()
    {
        if (!$this->_pf->type == 'bundle') {
            return false;
        }
        if (!$this->_pf->packagefile) {
            return false;
        }
        $dir_prefix = $this->_pf->filepath;
        foreach ($this->_pf->bundledpackage as $package) {
            if (!file_exists($dir_prefix . DIRECTORY_SEPARATOR . $package)) {
                $this->_errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                    'File "' . $dir_prefix . DIRECTORY_SEPARATOR . $package .
                    '" in package.xml does not exist');
                continue;
            }
            PEAR2_Pyrus_Log::log(1, "Analyzing bundled package $package");
            try {
                $ret = new PEAR2_Pyrus_Package_Tar($dir_prefix . DIRECTORY_SEPARATOR .
                    $package);
            } catch (Exception $e) {
                $this->_errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                    'File "' . $dir_prefix . DIRECTORY_SEPARATOR . $package .
                    '" in package.xml is not valid', $e);
                continue;
            }
        }
        return true;
    }

    function _analyzePhpFiles()
    {
        if (!$this->_pf->packagefile) {
            throw new PEAR2_Pyrus_PackageFile_Exception(
                'Cannot validate files, no path to package file is set (use setPackageFile())');
        }
        $dir_prefix = $this->_pf->filepath;
        $info = $this->_pf->getContents();
        $info = $info['dir']['file'];
        if (isset($info['attribs'])) {
            $info = array($info);
        }
        $provides = array();
        foreach ($this->_pf->contents as $fa) {
            $file = $fa->name;
            if (!file_exists($dir_prefix . DIRECTORY_SEPARATOR . $file)) {
                $this->_errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                    'File "' . $dir_prefix . DIRECTORY_SEPARATOR . $file .
                    '" in package.xml does not exist');
                continue;
            }
            if (in_array($fa['role'], PEAR2_Pyrus_Installer_Role::getPhpRoles()) && $dir_prefix) {
                PEAR2_Pyrus_Log::log(1, "Analyzing $file");
                $srcinfo = $this->analyzeSourceCode($dir_prefix . DIRECTORY_SEPARATOR .
                    $file);
                if ($srcinfo) {
                    $provides = array_merge($provides, $this->_buildProvidesArray($srcinfo));
                }
            }
        }
        $this->_packageName = $pn = $this->_pf->package;
        $pnl = strlen($pn);
        foreach ($provides as $key => $what) {
            if (isset($what['explicit']) || !$what) {
                // skip conformance checks if the provides entry is
                // specified in the package.xml file
                continue;
            }
            extract($what);
            if ($type == 'class') {
                if (!strncasecmp($name, $pn, $pnl)) {
                    continue;
                }
                $this->_errors->E_WARNING[] = new PEAR2_Pyrus_PackageFile_Exception(
                    'in ' . $file . ': ' . $type . ' "' . $name . '" not prefixed ' .
                    'with package name "' . $package . '"'
                );
            } elseif ($type == 'function') {
                if (strstr($name, '::') || !strncasecmp($name, $pn, $pnl)) {
                    continue;
                }
                $this->_errors->E_WARNING[] = new PEAR2_Pyrus_PackageFile_Exception(
                    'in ' . $file . ': ' . $type . ' "' . $name . '" not prefixed ' .
                    'with package name "' . $package . '"'
                );
            }
        }
        return count($this->_errors->E_ERROR);
    }

    /**
     * Analyze the source code of the given PHP file
     *
     * @param  string Filename of the PHP file
     * @param  boolean whether to analyze $file as the file contents
     * @return mixed
     */
    function analyzeSourceCode($file, $string = false)
    {
        if (!function_exists("token_get_all")) {
            throw new PEAR2_Pyrus_PackageFile_Exception(
                'Parser error: token_get_all() function must exist to analyze source code');
        }
        if ($string) {
            $contents = $file;
        } else {
            if (!$fp = @fopen($file, "r")) {
                return false;
            }
            fclose($fp);
            $contents = file_get_contents($file);
        }
        $tokens = token_get_all($contents);
/*
        for ($i = 0; $i < sizeof($tokens); $i++) {
            @list($token, $data) = $tokens[$i];
            if (is_string($token)) {
                var_dump($token);
            } else {
                print token_name($token) . ' ';
                var_dump(rtrim($data));
            }
        }
*/
        $look_for = 0;
        $paren_level = 0;
        $bracket_level = 0;
        $brace_level = 0;
        $lastphpdoc = '';
        $current_class = '';
        $current_interface = '';
        $current_class_level = -1;
        $current_function = '';
        $current_function_level = -1;
        $declared_classes = array();
        $declared_interfaces = array();
        $declared_functions = array();
        $declared_methods = array();
        $used_classes = array();
        $used_functions = array();
        $extends = array();
        $implements = array();
        $nodeps = array();
        $inquote = false;
        $interface = false;
        for ($i = 0; $i < sizeof($tokens); $i++) {
            if (is_array($tokens[$i])) {
                list($token, $data) = $tokens[$i];
            } else {
                $token = $tokens[$i];
                $data = '';
            }
            if ($inquote) {
                if ($token != '"' && $token != T_END_HEREDOC) {
                    continue;
                } else {
                    $inquote = false;
                    continue;
                }
            }
            switch ($token) {
                case T_WHITESPACE :
                    continue;
                case ';':
                    if ($interface) {
                        $current_function = '';
                        $current_function_level = -1;
                    }
                    break;
                case '"':
                case T_START_HEREDOC:
                    $inquote = true;
                    break;
                case T_CURLY_OPEN:
                case T_DOLLAR_OPEN_CURLY_BRACES:
                case '{': $brace_level++; continue 2;
                case '}':
                    $brace_level--;
                    if ($current_class_level == $brace_level) {
                        $current_class = '';
                        $current_class_level = -1;
                    }
                    if ($current_function_level == $brace_level) {
                        $current_function = '';
                        $current_function_level = -1;
                    }
                    continue 2;
                case '[': $bracket_level++; continue 2;
                case ']': $bracket_level--; continue 2;
                case '(': $paren_level++;   continue 2;
                case ')': $paren_level--;   continue 2;
                case T_INTERFACE:
                    $interface = true;
                case T_CLASS:
                    if (($current_class_level != -1) || ($current_function_level != -1)) {
                        $this->_stack->push(__FUNCTION__, 'error', array('file' => $file),
                        'Parser error: invalid PHP found in file "%file%"');
                        return false;
                    }
                case T_FUNCTION:
                case T_NEW:
                case T_EXTENDS:
                case T_IMPLEMENTS:
                    $look_for = $token;
                    continue 2;
                case T_STRING:
                    if ($look_for == T_CLASS) {
                        $current_class = $data;
                        $current_class_level = $brace_level;
                        $declared_classes[] = $current_class;
                    } elseif ($look_for == T_INTERFACE) {
                        $current_interface = $data;
                        $current_class_level = $brace_level;
                        $declared_interfaces[] = $current_interface;
                    } elseif ($look_for == T_IMPLEMENTS) {
                        $implements[$current_class] = $data;
                    } elseif ($look_for == T_EXTENDS) {
                        $extends[$current_class] = $data;
                    } elseif ($look_for == T_FUNCTION) {
                        if ($current_class) {
                            $current_function = "$current_class::$data";
                            $declared_methods[$current_class][] = $data;
                        } elseif ($current_interface) {
                            $current_function = "$current_interface::$data";
                            $declared_methods[$current_interface][] = $data;
                        } else {
                            $current_function = $data;
                            $declared_functions[] = $current_function;
                        }
                        $current_function_level = $brace_level;
                        $m = array();
                    } elseif ($look_for == T_NEW) {
                        $used_classes[$data] = true;
                    }
                    $look_for = 0;
                    continue 2;
                case T_VARIABLE:
                    $look_for = 0;
                    continue 2;
                case T_DOC_COMMENT:
                case T_COMMENT:
                    if (preg_match('!^/\*\*\s!', $data)) {
                        $lastphpdoc = $data;
                        if (preg_match_all('/@nodep\s+(\S+)/', $lastphpdoc, $m)) {
                            $nodeps = array_merge($nodeps, $m[1]);
                        }
                    }
                    continue 2;
                case T_DOUBLE_COLON:
                    if (!($tokens[$i - 1][0] == T_WHITESPACE || $tokens[$i - 1][0] == T_STRING)) {
                        $this->_errors->E_WARNING[] =
                            new PEAR2_Pyrus_PackageFile_Exception(
                            'Parser error: invalid PHP found in file "' . $file . '"');
                        return false;
                    }
                    $class = $tokens[$i - 1][1];
                    if (strtolower($class) != 'parent') {
                        $used_classes[$class] = true;
                    }
                    continue 2;
            }
        }
        return array(
            "source_file" => $file,
            "declared_classes" => $declared_classes,
            "declared_interfaces" => $declared_interfaces,
            "declared_methods" => $declared_methods,
            "declared_functions" => $declared_functions,
            "used_classes" => array_diff(array_keys($used_classes), $nodeps),
            "inheritance" => $extends,
            "implements" => $implements,
            );
    }

    /**
     * Build a "provides" array from data returned by
     * analyzeSourceCode().  The format of the built array is like
     * this:
     *
     *  array(
     *    'class;MyClass' => 'array('type' => 'class', 'name' => 'MyClass'),
     *    ...
     *  )
     *
     *
     * @param array $srcinfo array with information about a source file
     * as returned by the analyzeSourceCode() method.
     *
     * @return void
     *
     * @access private
     *
     */
    function _buildProvidesArray($srcinfo)
    {
        if (!$this->_isValid) {
            return array();
        }
        $providesret = array();
        $file = basename($srcinfo['source_file']);
        $pn = $this->_pf->package;
        $pnl = strlen($pn);
        foreach ($srcinfo['declared_classes'] as $class) {
            $key = "class;$class";
            if (isset($providesret[$key])) {
                continue;
            }
            $providesret[$key] =
                array('file'=> $file, 'type' => 'class', 'name' => $class);
            if (isset($srcinfo['inheritance'][$class])) {
                $providesret[$key]['extends'] =
                    $srcinfo['inheritance'][$class];
            }
        }
        foreach ($srcinfo['declared_methods'] as $class => $methods) {
            foreach ($methods as $method) {
                $function = "$class::$method";
                $key = "function;$function";
                if ($method{0} == '_' || !strcasecmp($method, $class) ||
                    isset($providesret[$key])) {
                    continue;
                }
                $providesret[$key] =
                    array('file'=> $file, 'type' => 'function', 'name' => $function);
            }
        }

        foreach ($srcinfo['declared_functions'] as $function) {
            $key = "function;$function";
            if ($function{0} == '_' || isset($providesret[$key])) {
                continue;
            }
            if (!strstr($function, '::') && strncasecmp($function, $pn, $pnl)) {
                $warnings[] = "in1 " . $file . ": function \"$function\" not prefixed with package name \"$pn\"";
            }
            $providesret[$key] =
                array('file'=> $file, 'type' => 'function', 'name' => $function);
        }
        return $providesret;
    }
}
?><?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_File
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Traverse the complete <contents> tag, one <dir> at a time
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_File extends RecursiveIteratorIterator
{
    function next()
    {
        parent::next();
        $x = $this->current();
        if (isset($x[0])) {
            parent::next();
            $x = $this->current();
        }
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_FileAttribsFilter
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Filter out the attributes meta-information when traversing the file list
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_FileAttribsFilter extends RecursiveFilterIterator
{
    function accept()
    {
        $it = $this->getInnerIterator();
        if (!$it->valid()) {
            return false;
        }
        $key = $it->key();
        if ($key === 'attribs') {
            return false;
        }
        return true;
    }
}
<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_FileContents
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Traverse the current <dir> in the <contents> tag
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_FileContents extends RecursiveArrayIterator
{
    protected $tag;
    protected $dir = '';
    private $_packagefile;
    function __construct($arr, $tag, PEAR2_Pyrus_PackageFile_v2 $parent, $dir = '')
    {
        $this->tag = $tag;
        $this->dir = $dir;
        $this->_packagefile = $parent;
        if ($arr instanceof PEAR2_Pyrus_PackageFile_v2Iterator_FileTag) {
            $arr = $arr->getArrayCopy();
        }
        parent::__construct($arr);
    }

    function getChildren ()
    {
        $arr = $this->current();
        $now = '';
        if ($this->key() == 'dir' && !isset($arr[0])) {
            $now = $arr['attribs']['name'];
            if (!$this->dir && $now == '/') {
                $now = '';
            }
        }
        $dir = $this->dir;
        if ($now && $dir) {
            if ($dir[strlen($dir) - 1] != '/') {
                $dir .= '/';
            }
        }
        if (isset($arr['attribs'])) unset($arr['attribs']);
        if (isset($arr[0])) {
            return new PEAR2_Pyrus_PackageFile_v2Iterator_FileContentsMulti($arr, $this->key(),
                $this->_packagefile, $dir . $now);
        }
        return new PEAR2_Pyrus_PackageFile_v2Iterator_FileContents($arr, $this->key(),
            $this->_packagefile, $dir . $now);
    }

    function hasChildren()
    {
        $arr = $this->current();
        if (!($arr instanceof PEAR2_Pyrus_PackageFile_v2Iterator_FileTag) && !is_array($arr)) {
            return false;
        }
        if (isset($arr['file']) || isset($arr['dir']) || isset($arr[0])) {
            return true;
        }
        return false;
    }

    function current()
    {
        $x = parent::current();
        return new PEAR2_Pyrus_PackageFile_v2Iterator_FileTag($x, $this->dir, $this->_packagefile);
    }
}
<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_FileContentsMulti
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * iterator for tags with multiple sub-tags
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_FileContentsMulti extends PEAR2_Pyrus_PackageFile_v2Iterator_FileContents
{
    function key()
    {
        return $this->tag;
    }
}
<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_FileInstallationFilter
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * filtered iterator for file installation
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_FileInstallationFilter extends FilterIterator
{
    static private $_parent;
    static private $_installGroup;
    static function setParent(PEAR2_Pyrus_PackageFile_v2 $parent)
    {
        self::$_parent = $parent;
        $errs = new PEAR2_MultiErrors;
        $depchecker = new PEAR2_Pyrus_Dependency_Validator(
            array('channel' => self::$_parent->channel,
                  'package' => self::$_parent->package),
            PEAR2_Pyrus_Validate::INSTALLING, $errs);
        foreach (self::$_parent->installGroup as $instance) {
            try {
                if (isset($instance['installconditions'])) {
                    $installconditions = $instance['installconditions'];
                    if (is_array($installconditions)) {
                        foreach ($installconditions as $type => $conditions) {
                            if (!isset($conditions[0])) {
                                $conditions = array($conditions);
                            }
                            foreach ($conditions as $condition) {
                                $ret = $depchecker->{"validate{$type}Dependency"}($condition);
                            }
                        }
                    }
                }
            } catch (Exception $e) {
                // can't use this release
                continue;
            }
            $release = array('install' => array(), 'ignore' => array());
            // this is the release to use
            if (isset($instance['filelist'])) {
                // ignore files
                if (isset($instance['filelist']['ignore'])) {
                    $ignore = isset($instance['filelist']['ignore'][0]) ?
                        $instance['filelist']['ignore'] :
                        array($instance['filelist']['ignore']);
                    foreach ($ignore as $ig) {
                        $release['ignore'][$ig['attribs']['name']] = true;
                    }
                }
                // install files as this name
                if (isset($instance['filelist']['install'])) {
                    $installas = isset($instance['filelist']['install'][0]) ?
                        $instance['filelist']['install'] :
                        array($instance['filelist']['install']);
                    foreach ($installas as $as) {
                        $release['install'][$as['attribs']['name']] =
                            $as['attribs']['as'];
                    }
                }
            }
            self::$_installGroup = $release;
            return;
        }
    }

    function current()
    {
        $file = $this->key();
        $curfile = parent::current();
        if (isset(self::$_installGroup['install'][$file])) {
            // add the install-as attribute for these files
            $curfile['attribs']['install-as'] =
                self::$_installGroup['install'][$file];
        }
        if ($b = self::$_parent->getBaseInstallDir($file)) {
            $curfile['attribs']['baseinstalldir'] = $b;
        }
        return new PEAR2_Pyrus_PackageFile_v2Iterator_FileTag($curfile,
            dirname($file), self::$_parent);
    }

    function accept()
    {
        $file = $this->getInnerIterator()->key();
        if (isset(self::$_installGroup['ignore'][$file])) {
            // skip ignored files
            return false;
        }
        return true;
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_FileTag
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Store the path to the current file recursively
 *
 * Information can be accessed in three ways:
 *
 * - $file['attribs'] as an array directly
 * - $file->name      as object member, to access attributes
 * - $file->tasks     as pseudo-object, to access each task
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_FileTag extends ArrayObject
{
    public $dir;
    /**
     * @var PEAR2_Pyrus_PackageFile_v2
     */
    private $_packagefile;
    function __construct($a, $t, $parent)
    {
        $this->_packagefile = $parent;
        parent::__construct($a);
        if ($t === '.') $t = '';
        $this->dir = $t;
        if ($this->dir && $this->dir != '/') $this->dir .= '/';
    }

    /**
     * Hide the install-as attribute (it is merged into the "name" attribute)
     *
     * @param string $offset
     * @return mixed
     */
    function offsetGet($offset)
    {
        if ($offset == 'attribs') {
            $ret = parent::offsetGet('attribs');
            if (isset($ret['install-as'])) {
                unset($ret['install-as']);
            }
            return $ret;
        }
        if ($offset == 'install-as') {
            $ret = parent::offsetGet('attribs');
            return $ret['install-as'];
        }
    }

    function __get($var)
    {
        if ($var == 'name') {
            if (isset($this['install-as'])) {
                return $this['install-as'];
            }
            return $this->dir . $this['attribs']['name'];
        }
        if ($var == 'tasks') {
            $ret = $this->getArrayCopy();
            unset($ret['attribs']);
            return $ret;
        }
        return $this['attribs'][$var];
    }

    /**
     * Allow setting of attributes and tasks directly
     *
     * @param string $var
     * @param string|object $value
     */
    function __set($var, $value)
    {
        if (strpos($var, $this->_packagefile->getTasksNs()) === 0) {
            // setting a file task
            if ($value instanceof PEAR2_Pyrus_Task_Common) {
                $this->_packagefile->setFileAttribute($this->_dir .
                    $this['attribs']['name'], $var, $value->getArrayCopy());
                return;
            }
            throw new PEAR2_Pyrus_PackageFile_Exception('Cannot set ' . $var . ' to non-' .
                'PEAR2_Pyrus_Task_Common object in file ' . $this->dir .
                $this['attribs']['name']);
        }
        $this->_packagefile->setFileAttribute($this->dir . $this['attribs']['name'],
            $var, $value);
    }
}
<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * iterator for packaging
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator extends ArrayIterator
{
    static private $_parent;
    static function setParent(PEAR2_Pyrus_PackageFile_v2 $parent)
    {
        self::$_parent = $parent;
    }

    function key()
    {
        $curfile = $this->current();
        $a = 'PEAR2_Pyrus_Installer_Role_' . ucfirst($curfile['attribs']['role']);
        $role = new $a(PEAR2_Pyrus_Config::current());
        // add the install-as attribute to retrieve packaging location
        return $role->getPackagingLocation(self::$_parent, $curfile['attribs']);
    }

    function current()
    {
        $curfile = parent::current();
        $curfile['attribs']['name'] = parent::key();
        if ($base = self::$_parent->getBaseInstallDir($curfile['attribs']['name'])) {
            $curfile['attribs']['baseinstalldir'] = $base;
        } elseif (!isset($curfile['attribs']['baseinstalldir'])) {
            $curfile['attribs']['baseinstalldir'] =
                (dirname($curfile['attribs']['name']) === '.' ?
                    '/' :
                    dirname($curfile['attribs']['name']));
        }
        if (isset($curfile['attribs']['md5sum'])) {
            unset($curfile['attribs']['md5sum']);
        }
        return $curfile;
    }
}<?php
/**
 * PEAR2_Pyrus_Registry
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Registry manager
 *
 * The registry for PEAR2 consists of four related components
 *
 *  - an sqlite database
 *  - saved original package.xml for each installed package
 *  - saved original channel.xml for each discovered channel
 *  - configuration values at package installation time
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry implements PEAR2_Pyrus_IRegistry, IteratorAggregate
{
    static protected $allRegistries = array();
    /**
     * Class to instantiate for singleton.
     *
     * This is useful for unit-testing and for extending the registry
     * @var string
     */
    static public $className = 'PEAR2_Pyrus_Registry';
    /**
     * The parent registry
     *
     * This is used to implement cascading registries
     * @var PEAR2_Pyrus_Registry
     */
    protected $parent;

    /**
     * The base path of this registry
     *
     * @var string
     */
    protected $path;
    /**
     * If true, this registry is a cascaded parent registry, and should be treated
     * as read-only.
     *
     * @var bool
     */
    protected $readonly;

    protected $registries = array();
    /**
     * The channel registry for this path
     *
     * @var PEAR2_PyruschannelRegistry
     */
    protected $channelRegistry;

    public function setChannelRegistry(PEAR2_Pyrus_ChannelRegistry $reg)
    {
        $this->channelRegistry = $reg;
    }

    public function setParent(PEAR2_Pyrus_Registry $parent = null)
    {
        $this->parent = $parent;
    }

    public function __construct($path, $registries = array('Sqlite', 'Xml'), $readonly = false)
    {
        $this->path = $path;
        $this->readonly = $readonly;
        $exceptions = array();
        foreach ($registries as $registry) {
            try {
                $registry = ucfirst($registry);
                $registry = "PEAR2_Pyrus_Registry_$registry";
                if (!class_exists($registry, true)) {
                    $exceptions[] = new PEAR2_Pyrus_Registry_Exception(
                        'Unknown registry type: ' . $registry);
                    continue;
                }
                $this->registries[] = new $registry($path, $readonly);
            } catch (Exception $e) {
                $exceptions[] = $e;
            }
        }
        if (!count($this->registries)) {
            throw new PEAR2_Pyrus_Registry_Exception(
                'Unable to initialize registry for path "' . $path . '"',
                $exceptions);
        }
        $this->channelRegistry = new PEAR2_Pyrus_ChannelRegistry($path,
            $registries, $readonly);
    }

    public function install(PEAR2_Pyrus_PackageFile_v2 $info)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot install packages, registry is read-only');
        }
        foreach ($this->registries as $reg) {
            $reg->install($info);
        }
    }

    public function uninstall($name, $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot uninstall packages, registry is read-only');
        }
        foreach ($this->registries as $reg) {
            $reg->uninstall($name, $channel);
        }
    }

    /**
     * Determines whether a package exists
     *
     * @param string $package
     * @param string $channel
     * @param bool $onlyMain if true, only check the primary registry
     * @return unknown
     */
    public function exists($package, $channel, $onlyMain = false)
    {
        $ret = $this->registries[0]->exists($package, $channel);
        if ($onlyMain) {
            return $ret;
        }
        if (!$ret) {
            if (!$this->parent) {
                return false;
            }
            return $this->parent->exists($package, $channel);
        }
        return true;
    }

    public function info($package, $channel, $field, $onlyMain = false)
    {
        if ($onlyMain) {
            return $this->registries[0]->info($package, $channel, $field);
        }
        if ($this->exists($package, $channel, true)) {
            return $this->registries[0]->info($package, $channel, $field);
        }
        if ($this->exists($package, $channel, false)) {
            if (!$this->parent) {
                return null;
            }
            // installed in parent registry
            return $this->parent->info($package, $channel, $field);
        }

        return null;
    }

    public function listPackages($channel, $onlyMain = false)
    {
        $ret = $this->registries[0]->listPackages($channel);
        if ($onlyMain) {
            return $ret;
        }

        if ($this->parent) {
            return array_merge($ret, $this->parent->listPackages($channel));
        }

        return $ret;
    }

    // TODO: fix to support cascading
    public function getIterator()
    {
        return $this->registries[0];
    }

    public function toPackageFile($package, $channel, $onlyMain = false)
    {
        if ($this->exists($package, $channel, true)) {
            foreach ($this->registries as $reg) {
                if ($reg instanceof PEAR2_Pyrus_Registry_Xml) {
                    // prefer xml for retrieving packagefile object
                    try {
                        return $reg->toPackageFile($package, $channel);
                    } catch (Exception $e) {
                        // failed, cascade to using default registry instead
                    }
                }
            }
            return $this->registries[0]->toPackageFile($package, $channel);
        }
        if ($onlyMain) {
            return null;
        }
        if ($this->exists($package, $channel, false)) {
            if (!$this->parent) {
                return null;
            }
            // installed in parent registry
            return $this->parent->toPackageFile($package, $channel);
        }
    }

    function __get($var)
    {
        // first registry is always the primary registry
        if ($var == 'package') {
            return $this->registries[0]->package;
        }
        if ($var == 'channel') {
            return $this->channelRegistry;
        }
        if ($var == 'registries') {
            return $this->registries;
        }
    }

    public function getParent()
    {
        return $this->parent;
    }

    public function getPath()
    {
        return $this->path;
    }

    public function getDependentPackages(PEAR2_Pyrus_Registry_Base $package)
    {
        return $this->_registries[0]->getDependentPackages($package);
    }
}
<?php
/**
 * PEAR2_Pyrus_Registry_Base
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for a Pyrus Registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
abstract class PEAR2_Pyrus_Registry_Base implements ArrayAccess, PEAR2_Pyrus_IRegistry, Iterator
{
    protected $packagename;
    protected $packageList = array();
    function offsetExists($offset)
    {
        $info = PEAR2_Pyrus_Config::parsePackageName($offset);
        if (is_string($info)) {
            return false;
        }
        return $this->exists($info['package'], $info['channel']);
    }

    function offsetGet($offset)
    {
        $info = PEAR2_Pyrus_Config::parsePackageName($offset, true);
        $this->packagename = $offset;
        $ret = clone $this;
        unset($this->packagename);
        return $ret;
    }

    function offsetSet($offset, $value)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot install or upgrade packages, registry is read-only');
        }
        if ($offset == 'upgrade') {
            $this->upgrade($value);
        }
        if ($offset == 'install') {
            $this->install($value);
        }
    }

    function offsetUnset($offset)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot uninstall packages, registry is read-only');
        }
        $info = PEAR2_Pyrus_Config::parsePackageName($offset);
        if (is_string($info)) {
            return;
        }
        $this->uninstall($info['package'], $info['channel']);
    }

    function __get($var)
    {
        if (!isset($this->packagename)) {
            throw new PEAR2_Pyrus_Registry_Exception('Attempt to retrieve ' . $var .
            ' from unknown package');
        }
        $info = PEAR2_Pyrus_Config::parsePackageName($this->_packagename);
        return $this->info($info['package'], $info['channel'], $var);
    }

    function current()
    {
        $packagename = current($this->packageList);
        return $this->package[PEAR2_Pyrus_Config::current()->default_channel . '/' . $packagename];
    }

    function key()
    {
        return key($this->packageList);
    }

    function valid()
    {
        return current($this->packageList);
    }

    function next()
    {
        return next($this->packageList);
    }

    function rewind()
    {
        $this->packageList = $this->listPackages(PEAR2_Pyrus_Config::current()->default_channel);
    }

    /**
     * Create vertices/edges of a directed graph for dependencies of this package
     *
     * Iterate over dependencies and create edges from this package to those it
     * depends upon
     * @param PEAR2_Pyrus_DirectedGraph $graph
     * @param array $packages channel/package indexed array of PEAR2_Pyrus_Package objects
     */
    function makeUninstallConnections(PEAR2_Pyrus_DirectedGraph $graph, array $packages)
    {
        $graph->add($this);
        $cxml = $this->toPackageFile($this->name, $this->channel);
        foreach (array('required', 'optional') as $required) {
            foreach (array('package', 'subpackage') as $package) {
                foreach ($cxml->dependencies->$required->$package as $d) {
                    if (isset($d['conflicts'])) {
                        continue;
                    }
                    $dchannel = isset($d['channel']) ? $d['channel'] : '__uri';
                    if (isset($packages[$dchannel . '/' . $d['name']])) {
                        $graph->connect($this, $packages[$dchannel . '/' . $d['name']]);
                    }
                }
            }
        }
        foreach ($cxml->dependencies->group as $group) {
            foreach (array('package', 'subpackage') as $package) {
                foreach ($group->$package as $d) {
                    if (isset($d['conflicts'])) {
                        continue;
                    }
                    $dchannel = isset($d['channel']) ? $d['channel'] : '__uri';
                    if (isset($packages[$dchannel . '/' . $d['name']])) {
                        $graph->connect($this, $packages[$dchannel . '/' . $d['name']]);
                    }
                }
            }
        }
    }

    public function validateUninstallDependencies(array $uninstallPackages,
                                                  PEAR2_Multierrors $errs)
    {
        foreach ($uninstallPackages as $package) {
            $dep = new PEAR2_Pyrus_Dependency_Validator($this->name,
                PEAR2_Pyrus_Validate::UNINSTALLING, $errs);
            foreach ($this->getDependentPackages($package) as $deppackage) {
                foreach (array('package', 'subpackage') as $packaged) {
                    foreach ($deppackage->dependencies->required->$packaged as $d) {
                        if ($package->package == '__uri') {
                            if ($d['name'] != $package->name || $d['uri'] != $package->uri) {
                                continue;
                            }
                        } else {
                            if ($d['name'] != $package->name || $d['channel'] != $package->channel) {
                                continue;
                            }
                        }
                        $dep->validatePackageUninstall($d, true, $package, $uninstallPackages);
                    }
                    foreach ($deppackage->dependencies->optional->$packaged as $d) {
                        if ($package->package == '__uri') {
                            if ($d['name'] != $package->name || $d['uri'] != $package->uri) {
                                continue;
                            }
                        } else {
                            if ($d['name'] != $package->name || $d['channel'] != $package->channel) {
                                continue;
                            }
                        }
                        $dep->validatePackageUninstall($d, false, $package, $uninstallPackages);
                    }
                }
            }
        }
    }
}
<?php
/**
 * PEAR2_Pyrus_Registry_Channel
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Channels within the registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Channel extends PEAR2_Pyrus_Registry implements ArrayAccess
{
    private $_channelname;
    function __construct(PEAR2_Pyrus_Registry_Sqlite $cloner)
    {
        parent::__construct($cloner->getDatabase());
    }

    function offsetExists($offset)
    {
        if ($offset[0] == '#') {
            return $this->sqlite->channelExists(substr($offset, 1), false);
        }
        return $this->sqlite->channelExists($offset);
    }

    function offsetGet($offset)
 	{
 	    $this->_channelname = $offset;
 	    $ret = clone $this;
 	    return $ret;
 	}

 	function offsetSet($offset, $value)
 	{
 	    if ($offset == 'update') {
 	        $this->updateChannel($value);
 	    }
 	    if ($offset == 'add') {
 	        $this->addChannel($value);
 	    }
 	}

 	function offsetUnset($offset)
 	{
 	    $this->deleteChannel($offset);
 	}
}<?php
/**
 * PEAR2_Pyrus_Registry_Config
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Configuration information at installation time, per-file
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Config
{

}<?php
/**
 * PEAR2_Pyrus_Registry_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus Registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Exception extends PEAR2_Exception {}
<?php
/**
 * PEAR2_Pyrus_Registry_Package
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Packages within the registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Package implements ArrayAccess
{
    private $_packagename;
    private $_reg;
    function __construct(PEAR2_Pyrus_IRegistry $cloner)
    {
        $this->_reg = $cloner;
    }

    function offsetExists($offset)
    {
 	    $info = $this->_reg->parsePackageName($offset);
        return $this->_reg->packageExists($info['package'], $info['channel']);
    }

    function offsetGet($offset)
 	{
 	    $this->_packagename = $this->_reg->parsePackageName($this->_packagename);
 	    $ret = clone $this;
 	    return $ret;
 	}

 	function offsetSet($offset, $value)
 	{
 	    if ($offset == 'upgrade') {
 	        $this->_reg->upgradePackage($value);
 	    }
 	    if ($offset == 'install') {
 	        $this->_reg->installPackage($value);
 	    }
 	}

 	function offsetUnset($offset)
 	{
 	    $info = $this->parsePackageName($offset);
 	    $this->uninstallPackage($info['package'], $info['channel']);
 	}

 	function __get($var)
 	{
 	    if (!isset($this->_packagename)) {
 	        throw new PEAR2_Pyrus_Registry_Exception('Attempt to retrieve ' . $var .
                ' from unknown package');
 	    }
 	    return $this->_reg->packageInfo($this->_packagename['package'],
 	      $this->_packagename['channel'], $var);
 	}

 	function __call($method, $args)
 	{
 	    return call_user_func_array(array($this->_reg, $method), $args);
 	}
}<?php
/**
 * PEAR2_Pyrus_Registry_Pear1
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Helgi ﬁormar ﬁorbjˆrnsson <dufuz@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/PEAR2/Pyrus
 */

/**
 * This is the central registry, that is used for all installer options,
 * stored in .reg files for PEAR 1 compatibility
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Helgi ﬁormar ﬁorbjˆrnsson <dufuz@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/PEAR2/Pyrus
 */
class PEAR2_Pyrus_Registry_Pear1 implements PEAR2_Pyrus_IRegistry
{
    private $_path;
    function __construct($path)
    {
        $this->_path = $path;
    }

    private function _nameRegistryPath(PEAR2_Pyrus_PackageFile_v2 $info = null,
                                     $channel = null, $package = null, $version = null)
    {
        $channel = $info !== null ? $info->channel : $channel;
        $package = $info !== null ? $info->name    : $package;
        $path = $this->_namePath($channel, $package);
        return $path . '.reg';
    }

    private function _namePath($channel, $package)
    {
        if ($channel == 'pear.php.net') {
            $channel = '';
        } else {
            $channel = '.channel.' . strtolower($channel) . DIRECTORY_SEPARATOR;
        }

        return PEAR2_Pyrus_Config::current()->path . DIRECTORY_SEPARATOR .
            '.registry' . DIRECTORY_SEPARATOR . $channel . strtolower($package);
    }

    /**
     * Create the .registry/package.reg or file
     *
     * @param PEAR2_Pyrus_PackageFile_v2 $pf
     */
    function install(PEAR2_Pyrus_PackageFile_v2 $info)
    {
        // remove previously installed version for upgrade
        $this->uninstall($info->name, $info->channel);
        $packagefile = $this->_nameRegistryPath($info);
        if (!@is_dir(dirname($packagefile))) {
            mkdir(dirname($packagefile), 0777, true);
        }

        $arr = $info->toArray();
        $arr['old']['version'] = $info->version['release'];
        $arr['old']['release_date'] = $info->date;
        $arr['old']['release_state'] = $info->state;
        $license = $info->license;
        if (is_array($license) && isset($license['_content'])) {
            $license = $license['_content'];
        }
        $arr['old']['release_license'] = $license;
        $arr['old']['release_notes'] = $info->notes;
        $deps = array();
        $deps[] = array_merge(array('type' => 'php'), (array) $info->dependencies->php);
        $map = array(
            'php' => 'php',
            'package' => 'pkg',
            'subpackage' => 'pkg',
            'extension' => 'ext',
            'os' => 'os',
            'pearinstaller' => 'pkg',
            );
        foreach (array('package', 'subpackage', 'extension') as $dtype) {
            foreach (array('required', 'optional') as $optorrequired) {
                $optional = ($optorrequired == 'optional');
                foreach ($info->dependencies->required->package as $dep) {
                    $s = array('type' => $map[$dtype]);
                    if (isset($dep['channel'])) {
                        $s['channel'] = $dep['channel'];
                    }
                    if (isset($dep['uri'])) {
                        $s['uri'] = $dep['uri'];
                    }
                    if (isset($dep['name'])) {
                        $s['name'] = $dep['name'];
                    }
                    if (isset($dep['conflicts'])) {
                        $s['rel'] = 'not';
                    } else {
                        if (!isset($dep['min']) &&
                              !isset($dep['max'])) {
                            $s['rel'] = 'has';
                            $s['optional'] = $optional;
                        } elseif (isset($dep['min']) &&
                              isset($dep['max'])) {
                            $s['rel'] = 'ge';
                            $s1 = $s;
                            $s1['rel'] = 'le';
                            $s['version'] = $dep['min'];
                            $s1['version'] = $dep['max'];
                            if (isset($dep['channel'])) {
                                $s1['channel'] = $dep['channel'];
                            }
                            if ($dtype != 'php') {
                                $s['name'] = $dep['name'];
                                $s1['name'] = $dep['name'];
                            }
                            $s['optional'] = $optional;
                            $s1['optional'] = $optional;
                            $deps[] = $s1;
                        } elseif (isset($dep['min'])) {
                            if (isset($dep['exclude']) &&
                                  $dep['exclude'] == $dep['min']) {
                                $s['rel'] = 'gt';
                            } else {
                                $s['rel'] = 'ge';
                            }
                            $s['version'] = $dep['min'];
                            $s['optional'] = $optional;
                            if ($dtype != 'php') {
                                $s['name'] = $dep['name'];
                            }
                        } elseif (isset($dep['max'])) {
                            if (isset($dep['exclude']) &&
                                  $dep['exclude'] == $dep['max']) {
                                $s['rel'] = 'lt';
                            } else {
                                $s['rel'] = 'le';
                            }
                            $s['version'] = $dep['max'];
                            $s['optional'] = $optional;
                            if ($dtype != 'php') {
                                $s['name'] = $dep['name'];
                            }
                        }
                    }
                }
            }
        }
        $arr['old']['release_deps'] = $deps;
        $maintainers = $info->allmaintainers;
        $maint = array();
        foreach (array('lead', 'developer', 'contributor', 'helper') as $role) {
            if ($maintainers[$role]) {
                foreach ($maintainers[$role] as $m) {
                    $m = array_merge(array('role' => $role), $m);
                    $m['handle'] = $m['user'];
                    unset($m['handle']);
                    $maint[] = $m;
                }
            }
        }
        $arr['old']['maintainers'] = $maint;
        $arr['xsdversion'] = '2.0';
        $arr['_lastmodified'] = time();

        file_put_contents($packagefile, serialize($arr));
    }

    function uninstall($package, $channel)
    {
        $packagefile = $this->_nameRegistryPath(null, $channel, $package);
        @unlink($packagefile);
    }

    public function exists($package, $channel)
    {
        $packagefile = $this->_namePath($package, $channel);
        return @file_exists($packagefile) && @is_dir($packagefile);
    }

    public function info($package, $channel, $field)
    {
        if (!$this->exists($package, $channel)) {
            throw new PEAR2_Pyrus_Registry_Exception('Unknown package ' . $channel .
                '/' . $package);
        }

        $pf = $this->toPackageFile($package, $channel);

        if ($field === null) {
            return $pf;
        }

        if ($field == 'version') {
            $field = 'release-version';
        }
        if ($field == 'installedfiles' || $field == 'dirtree') {
            $packagefile = $this->_namePath($package, $channel) . '.reg';
            if (!$packagefile || !isset($packagefile[0])) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot find registry for package ' .
                    $channel . '/' . $package);
            }

            $data = @unserialize($packagefile);
            if ($data === false) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve package file object ' .
                    'for package ' . $package . '/' . $channel . ', PEAR 1.x registry file might be corrupt!');
            }

            $ret = array();
            foreach ($data['filelist'] as $file) {
                if ($field == 'installedfiles') {
                    $ret[] = $file['installed_as'];
                } else {
                    $ret[dirname($file['installed_as'])] = 1;
                }
            }
            return $ret;
        }
        return $pf->$field;
    }

    public function listPackages($channel)
    {
        $dir = $this->_namePath($channel, '');
        if (!@file_exists($dir)) {
            return array();
        }

        $ret = array();
        try {
            foreach (new DirectoryIterator($dir) as $file) {
                if ($file->isDot() && !$file->isFile()) continue;
                $a = @unserialize(file_get_contents($file->getPathName()));
                // $a['name'] is not set on v1 regs
                if ($a !== false && isset($a['name'])) {
                    $ret[] = $a['name'];
                } elseif ($a !== false && isset($a['package'])) {
                    $ret[] = $a['package'];
                } else {
                    PEAR2_Pyrus_Log::log(0, 'Warning: corrupted REG registry entry: ' .
                        $file->getPathName());
                }
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Registry_Exception('Could not open channel directory for ' .
                'channel ' . $channel, $e);
        }
        return $ret;
    }

    public function toPackageFile($package, $channel)
    {
        if (!$this->exists($package, $channel)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve package file object ' .
                'for package ' . $package . '/' . $channel . ', it is not installed');
        }

        $packagefile = $this->_namePath($package, $channel) . '.reg';
        if (!$packagefile || !isset($packagefile[0])) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot find registry for package ' .
                $channel . '/' . $package);
        }

        $data = @unserialize($packagefile);
        if ($data === false) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve package file object ' .
                'for package ' . $package . '/' . $channel . ', PEAR 1.x registry file might be corrupt!');
        }

        if (isset($data['xsdversion']) && $data['xsdversion'] == '1.0'
            || !isset($data['attribs'])
            || isset($data['attribs']) && $data['attribs']['version'] == '1.0') {
            // make scrappy minimal package.xml we can use for dependencies/info
            $pf = new PEAR2_Pyrus_PackageFile_v2;
            $pf->package = $data['name'];
            $pf->channel = 'pear.php.net';
            $pf->version['release'] = $pf->version['api'] = $data['release_version'];
            $pf->stability['release'] = $pf->stability['api'] = $data['release_state'];
            $pf->notes = $data['release_notes'];
            foreach ($data['maintainers'] as $maintainter) {
                $pf->maintainers[$maintainer['handle']]->name($maintainer['name'])
                   ->active('yes')->role($maintainer['role'])->email($maintainer['email']);
            }
            // we don't care what the piece of crap depends on, really, so make it valid
            // and forget about it
            $pf->dependencies->php['min'] = phpversion();
            $pf->dependencies->pearinstaller['min'] = '1.4.0';
            if (!isset($data['filelist'][0])) {
                $data['filelist'] = array($data['filelist']);
            }
            foreach ($data['filelist'] as $file) {
                $pf->files[$file['name']] = array('attribs' => $file);
            }
        } else {
            // create packagefile v2 here
            $pf = new PEAR2_Pyrus_PackageFile_v2;
            $pf->fromArray(array('package' => $data));
        }
        return $pf;
    }

    public function __get($var)
    {
        if ($var == 'package') {
            return new PEAR2_Pyrus_Registry_Pear1_Package($this);
        }
    }

    /**
     * Don't even try - sqlite is the only one that can reliably implement this
     */
    public function getDependentPackages(PEAR2_Pyrus_Registry_Base $package)
    {
        return array();
    }
}
<?php
/**
 * PEAR2_Pyrus_Registry_Pear1_Package
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Helgi ﬁormar ﬁorbjˆrnsson <dufuz@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/PEAR2/Pyrus
 */

/**
 * Package within the PEAR1 registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Helgi ﬁormar ﬁorbjˆrnsson <dufuz@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvnPyrus/
 */
class PEAR2_Pyrus_Registry_Pear1_Package extends PEAR2_Pyrus_Registry_Pear1 implements ArrayAccess
{
    private $_packagename;
    function __construct($path)
    {
        parent::__construct($path);
    }

    function offsetExists($offset)
    {
        $info = PEAR2_Pyrus_Config::current()->channelregistry->parseName($offset);
        return $this->exists($info['package'], $info['channel']);
    }

    function offsetGet($offset)
    {
        $this->_packagename = $offset;
        $ret = clone $this;
        unset($this->_packagename);
        return $ret;
    }

    function offsetSet($offset, $value)
    {
        if ($offset == 'install') {
            $this->install($value);
        }
    }

    function offsetUnset($offset)
    {
        $info = PEAR2_Pyrus_Config::current()->channelregistry->parseName($offset);
        $this->uninstall($info['package'], $info['channel']);
    }

    function __get($var)
    {
        if (!isset($this->_packagename)) {
            throw new PEAR2_Pyrus_Registry_Exception('Attempt to retrieve ' . $var .
                ' from unknown package');
        }
        $info =  PEAR2_Pyrus_Config::current()->channelregistry->parseName($this->_packagename);
        return $this->info($info['package'], $info['channel'], $var);
    }
}<?php
/**
 * PEAR2_Pyrus_Registry_Sqlite
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * This is the central registry, that is used for all installer options,
 * stored as an SQLite database
 *
 * Registry information that must be stored:
 *
 * - A list of installed packages
 * - the files in each package
 * - known channels
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Sqlite extends PEAR2_Pyrus_Registry_Base
{
    /**
     * The database resources, stored by path
     *
     * This allows singleton access to the database by separate objects
     * @var SQLiteDatabase
     */
    static protected $databases = array();
    private $_path;
    protected $readonly;

    /**
     * Initialize the registry
     *
     * @param unknown_type $path
     */
    function __construct($path, $readonly = false)
    {
        $this->readonly = $readonly;
        if ($path && $path != ':memory:') {
            if (dirname($path) . DIRECTORY_SEPARATOR . '.pear2registry' != $path) {
                $path = $path . DIRECTORY_SEPARATOR . '.pear2registry';
            }
        }
        $this->_init($path, $readonly);
        $this->_path = $path;
    }

    private function _init($path, $readonly)
    {
        if (isset(self::$databases[$path]) && self::$databases[$path]) {
            return;
        }

        $error = '';
        if (!$path) {
            $path = ':memory:';
        } elseif (!file_exists(dirname($path))) {
            if ($readonly) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot create SQLite registry, registry is read-only');
            }
            @mkdir(dirname($path), 0755, true);
        }

        if ($readonly && !file_exists($path)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot create SQLite registry, registry is read-only');
        }

        self::$databases[$path] = new SQLiteDatabase($path, 0666, $error);
        if (!self::$databases[$path]) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot open SQLite registry: ' . $error);
        }

        $sql = 'SELECT version FROM pearregistryversion';
        if (@self::$databases[$path]->singleQuery($sql) == '1.0.0') {
            return;
        }

        $a = new PEAR2_Pyrus_Registry_Sqlite_Creator;
        $a->create(self::$databases[$path]);
    }

    function getDatabase()
    {
        return $this->_path;
    }

    /**
     * Add an installed package to the registry
     *
     * @param PEAR2_Pyrus_PackageFile_v2 $info
     */
    function install(PEAR2_Pyrus_PackageFile_v2 $info)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot install package, registry is read-only');
        }

        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite registry for ' . $this->_path);
        }

        try {
            // this ensures upgrade will work
            $this->uninstall($info->name, $info->channel);
        } catch (Exception $e) {
            // ignore errors
        }

        self::$databases[$this->_path]->queryExec('BEGIN');
        $licloc = $info->license;
        $licuri = isset($licloc['attribs']['uri']) ? '"' .
            sqlite_escape_string($licloc['attribs']['uri']) . '"' : 'NULL';
        $licpath = isset($licloc['attribs']['path']) ? '"' .
            sqlite_escape_string($licloc['attribs']['path']) . '"' : 'NULL';

        $sql = '
            INSERT INTO packages
              (name, channel, version, apiversion, summary,
               description, stability, apistability, releasedate,
               releasetime, license, licenseuri, licensepath,
               releasenotes, lastinstalledversion, installedwithpear,
               installtimeconfig)
            VALUES(
              "' . $info->name . '",
              "' . $info->channel . '",
              "' . $info->version['release'] . '",
              "' . $info->version['api'] . '",
              \'' . sqlite_escape_string($info->summary) . '\',
              \'' . sqlite_escape_string($info->description) . '\',
              "' . $info->stability['release'] . '",
              "' . $info->stability['api'] . '",
              "' . $info->date . '",
              ' . ($info->time ? '"' . $info->time . '"' : 'NULL') . ',
              "' . $info->license['_content'] . '",
              ' . $licuri . ',
              ' . $licpath . ',
              \'' . sqlite_escape_string($info->notes) . '\',
              NULL,
              "2.0.0",
              "' . PEAR2_Pyrus_Config::configSnapshot() . '"
            )';
        if (!@self::$databases[$this->_path]->queryExec($sql)) {
            self::$databases[$this->_path]->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                $info->channel . '/' . $info->name . ' could not be installed in registry');
        }

        foreach ($info->allmaintainers as $role => $maintainers) {
            if (!is_array($maintainers)) continue;
            foreach ($maintainers as $maintainer) {
                $sql = '
                    INSERT INTO maintainers
                      (packages_name, packages_channel, role, name, user,
                       email, active)
                    VALUES(
                      "' . $info->name . '",
                      "' . $info->channel . '",
                      "' . $role . '",
                      "' . $maintainer['name'] . '",
                      "' . $maintainer['user'] . '",
                      "' . $maintainer['email'] . '",
                      "' . $maintainer['active'] . '"
                     )';
                if (!@self::$databases[$this->_path]->queryExec($sql)) {
                    self::$databases[$this->_path]->queryExec('ROLLBACK');
                    throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                        $info->channel . '/' . $info->name . ' could not be installed in registry');
                }
            }
        }
        $curconfig = PEAR2_Pyrus_Config::current();
        $roles     = array();
        foreach (PEAR2_Pyrus_Installer_Role::getValidRoles($info->getPackageType()) as $role) {
            // set up a list of file role => configuration variable
            // for storing in the registry
            $roles[$role] =
                PEAR2_Pyrus_Installer_Role::factory($info, $role)->getLocationConfig();
        }

        foreach ($info->installcontents as $file) {
            $sql = '
                INSERT INTO files
                  (packages_name, packages_channel, packagepath, role, rolepath)
                VALUES(
                  "' . $info->name . '",
                  "' . $info->channel . '",
                  "' . $file->name . '",
                  "' . $file->role . '",
                  "' . str_replace($this->_path . DIRECTORY_SEPARATOR,
                       '', $curconfig->{$roles[$file->role]}) . '"
                 )';
            if (!@self::$databases[$this->_path]->queryExec($sql)) {
                self::$databases[$this->_path]->queryExec('ROLLBACK');
                throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                    $info->channel . '/' . $info->name . ' could not be installed in registry');
            }
        }

        foreach (array('required', 'optional') as $required) {
            foreach (array('package', 'subpackage') as $package) {
                foreach ($info->dependencies->$required->$package as $d) {
                    $dchannel = isset($d['channel']) ? $d['channel'] : '__uri';
                    $dmin     = isset($d['min']) ? '"' . $d['min'] . '"' : 'NULL';
                    $dmax     = isset($d['max']) ? '"' . $d['max'] . '"' : 'NULL';

                    $sql = '
                         INSERT INTO package_dependencies
                          (required, packages_name, packages_channel, deppackage,
                           depchannel, conflicts, min, max)
                         VALUES(
                          ' . ($required == 'required' ? 1 : 0) . ',
                          "' . $info->name . '",
                          "' . $info->channel . '",
                          "' . $d['name'] . '",
                          "' . $dchannel . '",
                          "' . isset($d['conflicts']) . '",
                          ' . $dmin . ',
                          ' . $dmax . '
                         )';
                    if (!@self::$databases[$this->_path]->queryExec($sql)) {
                        self::$databases[$this->_path]->queryExec('ROLLBACK');
                        throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                            $info->channel . '/' . $info->getName() . ' could not be installed in registry');
                    }

                    if (isset($d['exclude'])) {
                        if (!is_array($d['exclude'])) {
                            $d['exclude'] = array($d['exclude']);
                        }

                        foreach ($d['exclude'] as $exclude) {
                            $sql = '
                                 INSERT INTO package_dependencies_exclude
                                  (required, packages_name, packages_channel,
                                   deppackage, depchannel, exclude, conflicts)
                                 VALUES(
                                  ' . ($required == 'required' ? 1 : 0) . ',
                                  "' . $info->name . '",
                                  "' . $info->channel . '",
                                  "' . $d['name'] . '",
                                  "' . $dchannel . '",
                                  "' . $exclude . '",
                                  "' . isset($d['conflicts']) . '"
                                 )';
                            if (!@self::$databases[$this->_path]->queryExec($sql)) {
                                self::$databases[$this->_path]->queryExec('ROLLBACK');
                                throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                                    $info->channel . '/' . $info->getName() . ' could not be installed in registry');
                            }
                        }
                    }
                }
            }
        }

        foreach ($info->dependencies->group as $group) {
            foreach (array('package', 'subpackage') as $package) {
                foreach ($group->$package as $d) {
                    $dchannel = isset($d['channel']) ? $d['channel'] :  '__uri';
                    $dmin     = isset($d['min']) ? '"' . $d['min'] . '"' : 'NULL';
                    $dmax     = isset($d['max']) ? '"' . $d['max'] . '"' : 'NULL';

                    $sql = '
                         INSERT INTO package_dependencies
                          (required, packages_name, packages_channel, deppackage,
                           depchannel, conflicts, min, max)
                         VALUES(
                          0,
                          "' . $info->name . '",
                          "' . $info->channel . '",
                          "' . $d['name'] . '",
                          "' . $dchannel . '",
                          "' . isset($d['conflicts']) . '",
                          ' . $dmin . ',
                          ' . $dmax . '
                         )';
                    if (!@self::$databases[$this->_path]->queryExec($sql)) {
                        self::$databases[$this->_path]->queryExec('ROLLBACK');
                        throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                            $info->channel . '/' . $info->name . ' could not be installed in registry');
                    }

                    if (isset($d['exclude'])) {
                        if (!is_array($d['exclude'])) {
                            $d['exclude'] = array($d['exclude']);
                        }

                        foreach ($d['exclude'] as $exclude) {
                            $sql = '
                                 INSERT INTO package_dependencies_exclude
                                  (required, packages_name, packages_channel,
                                   deppackage, depchannel, exclude, conflicts)
                                 VALUES(
                                  0,
                                  "' . $info->name . '",
                                  "' . $info->channel . '",
                                  "' . $d['name'] . '",
                                  "' . $dchannel . '",
                                  "' . $exclude . '",
                                  "' . isset($d['conflicts']) . '",
                                 )';
                            if (!@self::$databases[$this->_path]->queryExec($sql)) {
                                self::$databases[$this->_path]->queryExec('ROLLBACK');
                                throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                                    $info->channel . '/' . $info->name . ' could not be installed in registry');
                            }
                        }
                    }
                }
            }
        }

        self::$databases[$this->_path]->queryExec('COMMIT');
    }

    function uninstall($package, $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot uninstall package, registry is read-only');
        }
        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite registry for ' . $this->_path);
        }
        $channel = PEAR2_Pyrus_Config::current()->channelregistry[$channel]->getName();

        $sql = 'SELECT name FROM packages WHERE name = "' .
              sqlite_escape_string($package) . '" AND channel = "' .
              sqlite_escape_string($channel) . '"';
        if (!self::$databases[$this->_path]->singleQuery($sql)) {
            throw new PEAR2_Pyrus_Registry_Exception('Unknown package ' . $channel . '/' .
                $package);
        }

        $sql = 'DELETE FROM packages WHERE name = "' .
              sqlite_escape_string($package) . '" AND channel = "' .
              sqlite_escape_string($channel) . '"';
        self::$databases[$this->_path]->queryExec($sql);
    }

    function exists($package, $channel)
    {
        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite registry for ' . $this->_path);
        }
        return self::$databases[$this->_path]->singleQuery('SELECT COUNT(*) FROM packages WHERE ' .
            'name=\'' . sqlite_escape_string($package) . '\' AND channel=\'' .
            sqlite_escape_string($channel) . '\'');
    }

    function info($package, $channel, $field)
    {
        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite registry for ' . $this->_path);
        }

        if ($field == 'date') {
            $field = 'releasedate';
        } elseif ($field == 'time') {
            $field = 'releasetime';
        } elseif ($field == 'installedfiles') {
            $ret = array();
            $sql = 'SELECT
                        rolepath, packagepath
                    FROM files
                    WHERE
                        packages_name = \'' . sqlite_escape_string($package) .'\' AND
                        packages_channel = \'' . sqlite_escape_string($channel) . '\'';
            $files = @self::$databases[$this->_path]->arrayQuery($sql, SQLITE_ASSOC);
            if (self::$databases[$this->_path]->lastError()) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve ' . $field .
                    ': ' . sqlite_error_string(self::$databases[$this->_path]->lastError()));
            }
            foreach ($files as $file) {
                $ret[] = $file['rolepath'] . DIRECTORY_SEPARATOR . $file['packagepath'];
            }

            return $ret;
        } elseif ($field == 'dirtree') {
            $ret = array();
            $sql = 'SELECT
                        rolepath, packagepath
                    FROM files
                    WHERE
                        packages_name = \'' . sqlite_escape_string($package) .'\' AND
                        packages_channel = \'' . sqlite_escape_string($channel) . '\'';
            $files = @self::$databases[$this->_path]->arrayQuery($sql, SQLITE_ASSOC);
            if (self::$databases[$this->_path]->lastError()) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve ' . $field .
                    ': ' . sqlite_error_string(self::$databases[$this->_path]->lastError()));
            }

            foreach ($files as $file) {
                $path = dirname($file['rolepath'] . DIRECTORY_SEPARATOR . $file['packagepath']);
                $ret[$path] = 1;
            }

            return $ret;
        }

        $sql = ' SELECT ' . $field . ' FROM packages WHERE
            name = \'' . sqlite_escape_string($package) . '\' AND
            channel = \'' . sqlite_escape_string($channel) . '\'';
        $info = @self::$databases[$this->_path]->singleQuery($sql, true);
        if (self::$databases[$this->_path]->lastError()) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve ' . $field .
                ': ' . sqlite_error_string(self::$databases[$this->_path]->lastError()));
        }
        return $info;
    }

    function listPackages($channel)
    {
        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite registry for ' . $this->_path);
        }

        $ret = array();
        $sql = 'SELECT name FROM packages WHERE
            channel = \'' . sqlite_escape_string($channel) . '\'
            ORDER BY name';
        foreach (self::$databases[$this->_path]->arrayQuery($sql, SQLITE_NUM) as $res) {
            $ret[] = $res[0];
        }

        return $ret;
    }

    function __get($var)
    {
        if ($var === 'package') {
            return new PEAR2_Pyrus_Registry_Sqlite_Package($this);
        }
    }

    /**
     * Extract a packagefile object from the registry
     * @return PEAR2_Pyrus_PackageFile_v2
     */
    function toPackageFile($package, $channel)
    {
        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite registry for ' . $this->_path);
        }
        if (!$this->exists($package, $channel)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve package file object ' .
                'for package ' . $package . '/' . $channel . ', it is not installed');
        }
        $ret = new PEAR2_Pyrus_PackageFile_v2;
        $ret->name        = $package;
        $ret->channel     = $channel;
        $ret->summary     = $this->info($package, $channel, 'summary');
        $ret->description = $this->info($package, $channel, 'description');

        $sql = 'SELECT * FROM maintainers
                WHERE
                    packages_name="' . sqlite_escape_string($package) . '" AND
                    packages_channel="' . sqlite_escape_string($channel) . '"';
        $a = self::$databases[$this->_path]->arrayQuery($sql, SQLITE_ASSOC);
        if (!$a) {
            throw new PEAR2_Pyrus_Registry_Exception('Could not retrieve package file object' .
                ' for package ' . $package . '/' . $channel . ', no maintainers registered');
        }
        foreach ($a as $maintainer) {
            $ret->maintainer[$maintainer['user']]
                ->name($maintainer['name'])
                ->role($maintainer['role'])
                ->email($maintainer['email'])
                ->active($maintainer['active']);
        }
        $ret->date = $this->info($package, $channel, 'date');
        // FIXME why are we querying the same info twice ?
        if ($a = $this->info($package, $channel, 'time')) {
            $ret->time = $this->info($package, $channel, 'time');
        }
        $ret->{'release-version'}  = $this->info($package, $channel, 'version');
        $ret->{'api-version'}      = $this->info($package, $channel, 'apiversion');
        $ret->stability['release'] = $this->info($package, $channel, 'stability');
        $ret->stability['api']     = $this->info($package, $channel, 'apistability');
        $uri     = $this->info($package, $channel, 'licenseuri');
        $path    = $this->info($package, $channel, 'licensepath');
        $license = $this->info($package, $channel, 'license');
        if ($uri) {
            $ret->license = array('attribs' => array('uri' => $uri), '_content' => $license);
        } elseif ($path) {
            $ret->license = array('attribs' => array('path' => $path), '_content' => $license);
        } else {
            $ret->license = $license;
        }
        $ret->notes = $this->info($package, $channel, 'releasenotes');

        $sql = 'SELECT packagepath, role FROM files
                WHERE
                    packages_name = "' . sqlite_escape_string($package) . '" AND
                    packages_channel = "' . sqlite_escape_string($channel) . '"';
        $a = self::$databases[$this->_path]->arrayQuery($sql, SQLITE_ASSOC);
        if (!$a) {
            throw new PEAR2_Pyrus_Registry_Exception('Could not retrieve package file object' .
                ' for package ' . $package . '/' . $channel . ', no files registered');
        }
        foreach ($a as $file) {
            $ret->files[$file['packagepath']] = array('attribs' => array('role' => $file['role']));
        }
        // these two are dummy values not based on anything
        $ret->dependencies->required->php = array('min' => phpversion());
        $ret->dependencies->required->pearinstaller = array('min' => '2.0.0');

        $sql = 'SELECT * FROM package_dependencies
                WHERE
                    packages_name = "' . sqlite_escape_string($package) . '" AND
                    packages_channel = "' . sqlite_escape_string($channel) . '"
                ORDER BY required, deppackage, depchannel, conflicts';
        $a = self::$databases[$this->_path]->arrayQuery($sql, SQLITE_ASSOC);

        $sql = 'SELECT * FROM package_dependencies_exclude
                WHERE
                    packages_name = "' . sqlite_escape_string($package) . '" AND
                    packages_channel = "' . sqlite_escape_string($channel) . '"
                ORDER BY required, deppackage, depchannel, conflicts, exclude';
        $b = self::$databases[$this->_path]->arrayQuery($sql, SQLITE_ASSOC);
        if (!$a) {
            return $ret;
        }

        $odeps = $rdeps = array();
        foreach ($a as $dep) {
            $deps = $dep['required'] ? 'rdeps' : 'odeps';
            if (isset(${$deps}[$dep['depchannel'] . '/' . $dep['deppackage']])) {
                $d = ${$deps}[$dep['depchannel'] . '/' . $dep['deppackage']];
            } else {
                $d = array();
            }
            if ($dep['min']) {
                $d['min'] = $dep['min'];
            }
            if ($dep['max']) {
                $d['max'] = $dep['max'];
            }
            if ($dep['conflicts']) {
                $d['conflicts'] = '';
            }
            if ($dep['exclude']) {
                if (!isset($d['exclude'])) {
                    $d['exclude'] = array();
                }
                $d['exclude'][] = $dep['exclude'];
            }
            ${$deps}[$dep['depchannel'] . '/' . $deps[$dep['deppackage']]] = $d;
        }

        foreach ($b as $dep) {
            $deps = $dep['required'] ? 'rdeps' : 'odeps';
            if (!isset(${$deps}[$dep['depchannel'] . '/' . $dep['deppackage']])) {
                continue;
            }

            $d = ${$deps}[$dep['depchannel'] . '/' . $dep['deppackage']];
            if (isset($d['conflicts']) && !$dep['conflicts']) {
                continue;
            } elseif (!isset($d['conflicts']) && $dep['conflicts']) {
                continue;
            }

            if ($dep['exclude']) {
                if (!isset($d['exclude'])) {
                    $d['exclude'] = array();
                }
                $d['exclude'][] = $dep['exclude'];
            }
            ${$deps}[$dep['depchannel'] . '/' . $deps[$dep['deppackage']]] = $d;
        }

        foreach ($rdeps as $dep => $info) {
            $ret->dependencies->required->package[$dep] = $info;
        }

        foreach ($odeps as $dep => $info) {
            $ret->dependencies->optional->package[$dep] = $info;
        }

        return $ret;
    }

    public function getDependentPackages(PEAR2_Pyrus_Registry_Base $package)
    {
        if (!isset(self::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite channel registry for ' . $this->_path);
        }

        $ret = array();
        $sql = 'SELECT
                    packages_channel, packages_name
                FROM package_dependencies
                WHERE
                    deppackage = \'' . sqlite_escape_string($package->name) . '\' AND
                    depchannel = \'' . sqlite_escape_string($package->name) . '\'
                ORDER BY packages_channel, packages_name';
        foreach (self::$databases[$this->_path]->arrayQuery($sql, SQLITE_ASSOC) as $res) {
            try {
                $ret[] = $this->get($res[0] . '/' . $res[1]);
            } catch (Exception $e) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Could not retrieve ' .
                    'dependent package ' . $res[0] . '/' . $res[1], $e);
            }
        }

        return $ret;
    }
}<?php
/**
 * PEAR2_Pyrus_Registry_Sqlite_Creator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Initialize a sqlite registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Sqlite_Creator
{
    /**
     * Initialize the database for the registry
     *
     * Registry information that must be stored:
     *
     * - A list of installed packages
     * - the files in each package
     * - known channels
     *
     * The SQLite database has this structure:
     *
     * <pre>
     * CREATE TABLE packages (
     *  name TEXT(80) NOT NULL,
     *  channel TEXT(255) NOT NULL,
     *  version TEXT(20) NOT NULL,
     *  apiversion TEXT(20) NOT NULL,
     *  summary TEXT NOT NULL,
     *  description TEXT NOT NULL,
     *  stability TEXT(8) NOT NULL,
     *  apistability TEXT(8) NOT NULL,
     *  releasedate DATE NOT NULL,
     *  releasetime TIME,
     *  license TEXT(50) NOT NULL,
     *  licenseuri TEXT,
     *  licensepath TEXT,
     *  releasenotes TEXT,
     *  lastinstalledversion TEXT(20),
     *  installedwithpear TEXT(20),
     *  installtimeconfig TEXT(50), -- the path to configuration as stored
     *  PRIMARY KEY (name, channel)
     * );
     *
     * CREATE TABLE maintainers (
     *  packages_name TEXT(80) NOT NULL,
     *  packages_channel TEXT(255) NOT NULL,
     *  role TEXT(11) NOT NULL,
     *  user TEXT(20) NOT NULL,
     *  name TEXT(200) NOT NULL,
     *  email TEXT(100) NOT NULL,
     *  active CHAR(3) NOT NULL,
     *  PRIMARY KEY (packages_name, packages_channel, user)
     * );
     *
     * CREATE TABLE files (
     *  packages_name TEXT(80) NOT NULL,
     *  packages_channel TEXT(255) NOT NULL,
     *  packagepath TEXT(255) NOT NULL,
     *  role TEXT(30) NOT NULL,
     *  rolepath TEXT(255) NOT NULL,
     *  PRIMARY KEY (packagepath, role, rolepath),
     *  UNIQUE (packages_name, packages_channel, packagepath)
     * );
     *
     * CREATE TABLE package_dependencies (
     *  required BOOL NOT NULL,
     *  packages_name TEXT(80) NOT NULL,
     *  packages_channel TEXT(255) NOT NULL,
     *  deppackage TEXT(80) NOT NULL,
     *  depchannel TEXT(255) NOT NULL,
     *  conflicts BOOL NOT NULL,
     *  min TEXT(20),
     *  max TEXT(20),
     *  PRIMARY KEY (required, packages_name, packages_channel, deppackage, depchannel)
     * );
     *
     * CREATE TABLE package_dependencies_exclude (
     *  required BOOL NOT NULL,
     *  packages_name TEXT(80) NOT NULL,
     *  packages_channel TEXT(255) NOT NULL,
     *  deppackage TEXT(80) NOT NULL,
     *  depchannel TEXT(255) NOT NULL,
     *  conflicts BOOL NOT NULL,
     *  exclude TEXT(20),
     *  PRIMARY KEY (required, packages_name, packages_channel, deppackage, depchannel)
     * );
     *
     * CREATE TABLE channels (
     *  channel TEXT NOT NULL,
     *  summary TEXT NOT NULL,
     *  suggestedalias TEXT(50) NOT NULL,
     *  alias TEXT(50) NOT NULL,
     *  validatepackageversion TEXT(20) NOT NULL default "default",
     *  validatepackage NOT NULL default "PEAR_Validate",
     *  lastmodified DATETIME,
     *  PRIMARY KEY (channel),
     *  UNIQUE(alias)
     * );
     *
     * CREATE TABLE channel_servers (
     *  channel TEXT NOT NULL,
     *  server TEXT NOT NULL,
     *  ssl integer NOT NULL default 0,
     *  port integer NOT NULL default 80,
     *  xmlrpcpath TEXT NOT NULL,
     *  soappath TEXT NOT NULL,
     *  PRIMARY KEY (channel, server)
     * );
     *
     * CREATE TABLE channel_server_xmlrpc (
     *  channel TEXT NOT NULL,
     *  server TEXT NOT NULL,
     *  function TEXT NOT NULL,
     *  version TEXT(20) NOT NULL,
     *  PRIMARY KEY (channel, server, function, version)
     * );
     *
     * CREATE TABLE channel_server_soap (
     *  channel TEXT NOT NULL,
     *  server TEXT NOT NULL,
     *  function TEXT NOT NULL,
     *  version TEXT(20) NOT NULL,
     *  PRIMARY KEY (channel, server, function, version)
     * );
     *
     * CREATE TABLE channel_server_rest (
     *  channel TEXT NOT NULL,
     *  server TEXT NOT NULL,
     *  type TEXT NOT NULL,
     *  baseurl TEXT NOT NULL,
     *  PRIMARY KEY (channel, server, baseurl, type)
     * );
     *
     * CREATE TABLE pearregistryversion (
     *  version TEXT(20) NOT NULL default "1.0.0"
     * );
     *
     * INSERT INTO pearregistryversion VALUES("1.0.0");
     *
     * CREATE TRIGGER package_delete DELETE ON packages
     *   FOR EACH ROW BEGIN
     *     DELETE FROM maintainers
     *     WHERE
     *       maintainers.packages_name = old.name AND
     *       maintainers.packages_channel = old.channel;
     *     DELETE FROM files
     *     WHERE
     *       files.packages_name = old.name AND
     *       files.packages_channel = old.channel;
     *     DELETE FROM package_dependencies
     *     WHERE
     *       package_dependencies.packages_name = old.name AND
     *       package_dependencies.packages_channel = old.channel;
     *     DELETE FROM package_dependencies_exclude
     *     WHERE
     *       package_dependencies_exclude.packages_name = old.name AND
     *       package_dependencies_exclude.packages_channel = old.channel;
     *   END;
     *
     * CREATE TRIGGER channel_delete DELETE ON channels
     *   FOR EACH ROW BEGIN
     *     DELETE FROM channel_servers
     *     WHERE
     *       channel_servers.channel = old.channel;
     *     DELETE FROM channel_server_xmlrpc
     *     WHERE
     *       channel_server_xmlrpc.channel = old.channel;
     *     DELETE FROM channel_server_soap
     *     WHERE
     *       channel_server_soap.channel = old.channel;
     *     DELETE FROM channel_server_rest
     *     WHERE
     *       channel_server_rest.channel = old.channel;
     *   END;
     * CREATE VIEW deps AS
     *   SELECT
     *       packages_name,
     *       packages_channel
     *       deppackage,
     *       depchannel,
     *       null as exclude,
     *       conflicts,
     *       min,
     *       max
     *   FROM package_dependencies
     *   UNION
     *   SELECT
     *       packages_name,
     *       packages_channel
     *       deppackage,
     *       depchannel,
     *       exclude,
     *       conflicts,
     *       null as min,
     *       null as max
     *   FROM package_dependencies_exclude
     *
     * CREATE VIEW protocols AS
     *  SELECT
     *      channel,
     *      server,
     *      function,
     *      version,
     *      "xmlrpc" as protocol
     *  FROM channel_server_xmlrpc
     *  UNION
     *  SELECT
     *      channel,
     *      server,
     *      function,
     *      version,
     *      "soap" as protocol
     *  FROM channel_server_soap
     *  UNION
     *  SELECT
     *      channel,
     *      server,
     *      baseurl as function,
     *      type as version,
     *      "rest" as protocol
     *  FROM channel_server_rest
     *
     * </pre>
     */
    function create(SQLiteDatabase $database)
    {
        if (!$database->queryExec('BEGIN', $error)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }
        $query = '
          CREATE TABLE packages (
           name TEXT(80) NOT NULL,
           channel TEXT(255) NOT NULL,
           version TEXT(20) NOT NULL,
           apiversion TEXT(20) NOT NULL,
           summary TEXT NOT NULL,
           description TEXT NOT NULL,
           stability TEXT(8) NOT NULL,
           apistability TEXT(8) NOT NULL,
           releasedate DATE NOT NULL,
           releasetime TIME,
           license TEXT(50) NOT NULL,
           licenseuri TEXT,
           licensepath TEXT,
           releasenotes TEXT,
           lastinstalledversion TEXT(20),
           installedwithpear TEXT(20),
           installtimeconfig TEXT(50),
           PRIMARY KEY (name, channel)
          );';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TABLE maintainers (
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           role TEXT(11) NOT NULL,
           name TEXT(200) NOT NULL,
           user TEXT(20) NOT NULL,
           email TEXT(100) NOT NULL,
           active CHAR(3) NOT NULL,
           PRIMARY KEY (packages_name, packages_channel, user)
          );';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TABLE files (
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           packagepath TEXT(255) NOT NULL,
           role TEXT(30) NOT NULL,
           rolepath TEXT(255) NOT NULL,
           PRIMARY KEY (packagepath, role, rolepath),
           UNIQUE (packages_name, packages_channel, packagepath)
          );';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TABLE package_dependencies (
           required BOOL NOT NULL,
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           deppackage TEXT(80) NOT NULL,
           depchannel TEXT(255) NOT NULL,
           conflicts BOOL NOT NULL,
           min TEXT(20),
           max TEXT(20),
           PRIMARY KEY (required, packages_name, packages_channel, deppackage, depchannel)
          );';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TABLE package_dependencies_exclude (
           required BOOL NOT NULL,
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           deppackage TEXT(80) NOT NULL,
           depchannel TEXT(255) NOT NULL,
           exclude TEXT(20),
           conflicts BOOL NOT NULL,
           PRIMARY KEY (required, packages_name, packages_channel, deppackage, depchannel)
          );';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TABLE channels (
           channel TEXT NOT NULL,
           summary TEXT NOT NULL,
           suggestedalias TEXT(50) NOT NULL,
           alias TEXT(50) NOT NULL,
           validatepackageversion TEXT(20) NOT NULL default "default",
           validatepackage NOT NULL default "PEAR_Validate",
           lastmodified TEXT,
           PRIMARY KEY (channel),
           UNIQUE(alias)
          );';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TABLE channel_servers (
           channel TEXT NOT NULL,
           server TEXT NOT NULL,
           ssl integer NOT NULL default 0,
           port integer NOT NULL default 80,
           xmlrpcpath TEXT NOT NULL,
           soappath TEXT NOT NULL,
           PRIMARY KEY (channel, server)
          );';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TABLE channel_server_xmlrpc (
           channel TEXT NOT NULL,
           server TEXT NOT NULL,
           function TEXT NOT NULL,
           version TEXT(20) NOT NULL,
           PRIMARY KEY (channel, server, function, version)
          );';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TABLE channel_server_soap (
           channel TEXT NOT NULL,
           server TEXT NOT NULL,
           function TEXT NOT NULL,
           version TEXT(20) NOT NULL,
           PRIMARY KEY (channel, server, function, version)
          );';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TABLE channel_server_rest (
           channel TEXT NOT NULL,
           server TEXT NOT NULL,
           type TEXT NOT NULL,
           baseurl TEXT NOT NULL,
           PRIMARY KEY (channel, server, baseurl, type)
          );';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TABLE pearregistryversion (
           version TEXT(20) NOT NULL
          );

          INSERT INTO pearregistryversion VALUES("1.0.0");
        ';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TRIGGER package_delete DELETE ON packages
            FOR EACH ROW BEGIN
              DELETE FROM maintainers
              WHERE
                maintainers.packages_name = old.name AND
                maintainers.packages_channel = old.channel;
              DELETE FROM files
              WHERE
                files.packages_name = old.name AND
                files.packages_channel = old.channel;
              DELETE FROM package_dependencies
              WHERE
                package_dependencies.packages_name = old.name AND
                package_dependencies.packages_channel = old.channel;
              DELETE FROM package_dependencies_exclude
              WHERE
                package_dependencies_exclude.packages_name = old.name AND
                package_dependencies_exclude.packages_channel = old.channel;
            END;
        ';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
CREATE TRIGGER channel_check BEFORE DELETE ON channels
            BEGIN
             SELECT RAISE(ROLLBACK, \'Cannot delete channel, installed packages use it\')
             WHERE old.channel IN (SELECT channel FROM packages);
            END;';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE TRIGGER channel_delete DELETE ON channels
            FOR EACH ROW BEGIN
              DELETE FROM channel_servers
              WHERE
                channel_servers.channel = old.channel;
              DELETE FROM channel_server_xmlrpc
              WHERE
                channel_server_xmlrpc.channel = old.channel;
              DELETE FROM channel_server_soap
              WHERE
                channel_server_soap.channel = old.channel;
              DELETE FROM channel_server_rest
              WHERE
                channel_server_rest.channel = old.channel;
            END;
        ';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE VIEW deps AS
            SELECT
                packages_name,
                packages_channel
                deppackage,
                depchannel,
                null as exclude,
                conflicts,
                min,
                max
            FROM package_dependencies
            UNION
            SELECT
                packages_name,
                packages_channel
                deppackage,
                depchannel,
                exclude,
                conflicts,
                null as min,
                null as max
            FROM package_dependencies_exclude
        ';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }

        $query = '
          CREATE VIEW protocols AS
            SELECT
                channel,
                server,
                function,
                version,
                "xmlrpc" as protocol
            FROM channel_server_xmlrpc
            UNION
            SELECT
                channel,
                server,
                function,
                version,
                "soap" as protocol
            FROM channel_server_soap
            UNION
            SELECT
                channel,
                server,
                baseurl as function,
                type as version,
                "rest" as protocol
            FROM channel_server_rest
        ';
        $worked = @$database->queryExec($query, $error);
        if (!$worked) {
            @$database->queryExec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite registry: ' . $error);
        }
        @$database->queryExec('COMMIT');
    }
}
<?php
/**
 * PEAR2_Pyrus_Registry_Sqlite_Package
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Package within the sqlite registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Sqlite_Package extends PEAR2_Pyrus_Registry_Sqlite implements ArrayAccess
{
    private $_packagename;
    function __construct(PEAR2_Pyrus_Registry_Sqlite $cloner)
    {
        parent::__construct($cloner->getDatabase());
    }

    function offsetExists($offset)
    {
        $info = PEAR2_Pyrus_Config::current()->channelregistry->parseName($offset);
        return $this->exists($info['package'], $info['channel']);
    }

    function offsetGet($offset)
    {
        $this->_packagename = $offset;
        $ret = clone $this;
        unset($this->_packagename);
        return $ret;
    }

    function offsetSet($offset, $value)
    {
        if ($offset == 'install') {
            $this->install($value);
        }
    }

    function offsetUnset($offset)
    {
        $info = PEAR2_Pyrus_Config::current()->channelregistry->parseName($offset);
        $this->uninstall($info['package'], $info['channel']);
    }

    function __get($var)
    {
        if (!isset($this->_packagename)) {
            throw new PEAR2_Pyrus_Registry_Exception('Attempt to retrieve ' . $var .
                ' from unknown package');
        }
        $info =  PEAR2_Pyrus_Config::current()->channelregistry->parseName($this->_packagename);
        return $this->info($info['package'], $info['channel'], $var);
    }
}<?php
/**
 * PEAR2_Pyrus_Registry_Xml
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * This is the central registry, that is used for all installer options,
 * stored in xml files
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Xml implements PEAR2_Pyrus_IRegistry
{
    protected $readonly;
    private $_path;

    function __construct($path, $readonly = false)
    {
        $this->_path = $path;
        $this->readonly = $readonly;
    }

    private function _nameRegistryPath(PEAR2_Pyrus_PackageFile_v2 $info = null,
                                     $channel = null, $package = null, $version = null)
    {
        $channel = $info !== null ? $info->channel : $channel;
        $package = $info !== null ? $info->name : $package;
        $path = $this->_namePath($channel, $package);
        $version = $info !== null ? $info->version['release'] : $version;
        return $path . DIRECTORY_SEPARATOR . $version . '-package.xml';
    }

    private function _namePath($channel, $package)
    {
        return PEAR2_Pyrus_Config::current()->path . DIRECTORY_SEPARATOR .
            '.registry' . DIRECTORY_SEPARATOR .
            str_replace('/', '!', $channel) .
            DIRECTORY_SEPARATOR . $package;
    }

    /**
     * Create the Channel!PackageName-Version-package.xml file
     *
     * @param PEAR2_Pyrus_PackageFile_v2 $pf
     */
    function install(PEAR2_Pyrus_PackageFile_v2 $info)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot install package, registry is read-only');
        }
        // remove previously installed version for upgrade
        $this->uninstall($info->name, $info->channel);
        $packagefile = $this->_nameRegistryPath($info);
        if (!@is_dir(dirname($packagefile))) {
            mkdir(dirname($packagefile), 0777, true);
        }
        file_put_contents($packagefile, (string) $info);
    }

    function uninstall($package, $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot install package, registry is read-only');
        }
        $packagefile = $this->_nameRegistryPath(null, $channel, $package);
        @unlink($packagefile);
        @rmdir(dirname($packagefile));
    }

    public function exists($package, $channel)
    {
        $packagefile = $this->_namePath($package, $channel);
        return @file_exists($packagefile) && @is_dir($packagefile);
    }

    public function info($package, $channel, $field)
    {
        if (!$this->exists($package, $channel)) {
            throw new PEAR2_Pyrus_Registry_Exception('Unknown package ' . $channel .
                '/' . $package);
        }
        $packagefile = glob($this->_namePath($package, $channel) .
            DIRECTORY_SEPARATOR . '*.xml');
        if (!$packagefile || !isset($packagefile[0])) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot find registry for package ' .
                $channel . '/' . $package);
        }
        // create packagefile v2 here
        if ($field === null) {
            return $pf;
        }

        if ($field == 'version') {
            $field = 'release-version';
        } elseif ($field == 'installedfiles') {
            $ret = array();
            try {
                $config = new PEAR2_Pyrus_Config_Snapshot($pf->date . ' ' . $pf->time);
            } catch (Exception $e) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve files, config ' .
                                        'snapshot could not be processed', $e);
            }
            $roles = array();
            foreach (PEAR2_Pyrus_Installer_Role::getValidRoles($info->getPackageType()) as $role) {
                // set up a list of file role => configuration variable
                // for storing in the registry
                $roles[$role] =
                    PEAR2_Pyrus_Installer_Role::factory($info, $role)->getLocationConfig();
            }
            $ret = array();
            foreach ($pf->files as $path => $info) {
                $ret[] = $config->{$roles[$info['role']]} . DIRECTORY_SEPARATOR . $path;
            }
            return $ret;
        } elseif ($field == 'dirtree') {
            $files = $this->installedfiles;
            $ret = array();
            foreach ($files as $file) {
                $ret[dirname($file)] = true;
            }
            return $ret;
        }

        return $pf->$field;
    }

    public function listPackages($channel)
    {
        $dir = $this->_namePath($channel, '');
        if (!@file_exists($dir)) {
            return array();
        }
        $ret = array();
        try {
            $parser = new PEAR2_Pyrus_XMLParser;
            foreach (new DirectoryIterator($dir) as $file) {
                if ($file->isDot()) continue;
                try {
                    $a = $parser->parse($file->getPathName());
                    $ret[] = $a['package']['name'];
                } catch (Exception $e) {
                    PEAR2_Pyrus_Log::log(0, 'Warning: corrupted XML registry entry: ' .
                        $file->getPathName() . ': ' . $e);
                }
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Registry_Exception('Could not open channel directory for ' .
                'channel ' . $channel, $e);
        }
        return $ret;
    }

    public function toPackageFile($package, $channel)
    {
        if (!$this->exists($package, $channel)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve package file object ' .
                'for package ' . $package . '/' . $channel . ', it is not installed');
        }
        $packagefile = $this->_nameRegistryPath(null, $channel, $package);
        $x = new PEAR2_Pyrus_PackageFile($packagefile);
        return $x->info;
    }

    public function __get($var)
    {
        if ($var == 'package') {
            return new PEAR2_Pyrus_Registry_Xml_Package($this);
        }
        if ($var == 'channel') {
            return new PEAR2_Pyrus_Registry_Xml_Channel($this);
        }
    }

    /**
     * Don't even try - sqlite is the only one that can reliably implement this
     */
    public function getDependentPackages(PEAR2_Pyrus_Registry_Base $package)
    {
        return array();
    }
}
<?php
/**
 * PEAR_REST
 *
 * PHP versions 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Intelligently retrieve data, following hyperlinks if necessary, and re-directing
 * as well
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_REST
{
    protected $config;
    protected $_options;
    function __construct($options = array())
    {
        $this->config = PEAR2_Pyrus_Config::current();
        $this->_options = $options;
    }

    /**
     * Retrieve REST data, but always retrieve the local cache if it is available.
     *
     * This is useful for elements that should never change, such as information on a particular
     * release
     * @param string full URL to this resource
     * @param array|false contents of the accept-encoding header
     * @param boolean     if true, xml will be returned as a string, otherwise, xml will be
     *                    parsed using PEAR_XMLParser
     * @return string|array
     */
    function retrieveCacheFirst($url, $accept = false, $forcestring = false)
    {
        $cachefile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
            md5($url) . 'rest.cachefile';
        if (file_exists($cachefile)) {
            return unserialize(implode('', file($cachefile)));
        }
        return $this->retrieveData($url, $accept, $forcestring);
    }

    /**
     * Retrieve a remote REST resource
     * @param string full URL to this resource
     * @param array|false contents of the accept-encoding header
     * @param boolean     if true, xml will be returned as a string, otherwise, xml will be
     *                    parsed using PEAR_XMLParser
     * @return string|array
     */
    function retrieveData($url, $accept = false, $forcestring = false)
    {
        $cacheId = $this->getCacheId($url);
        if ($ret = $this->useLocalCache($url, $cacheId)) {
            return $ret;
        }

        if (!isset($this->_options['offline'])) {
            $trieddownload = true;
            try {
                $file = $this->downloadHttp($url, $cacheId ? $cacheId['lastChange'] : false, $accept);
            } catch (PEAR2_HTTP_Request_Exception $e) {
                $trieddownload = false;
                $file = false;
            }
        } else {
            $trieddownload = false;
            $file = false;
        }
        if (!$file) {
            $ret = $this->getCache($url);
            if ($trieddownload) {
                // reset the age of the cache if the server says it was unmodified
                $this->saveCache($url, $ret, null, true, $cacheId);
            }
            return $ret;
        }
        if (is_array($file)) {
            $headers = $file[2];
            $lastmodified = $file[1];
            $content = $file[0];
        } else {
            $content = $file;
            $lastmodified = false;
            $headers = array();
        }
        if ($forcestring) {
            $this->saveCache($url, $content, $lastmodified, false, $cacheId);
            return $content;
        }
        if (isset($headers['content-type'])) {
            switch ($headers['content-type']) {
                case 'text/xml' :
                case 'application/xml' :
                    $parser = new PEAR2_Pyrus_XMLParser;
                    try {
                        $content = $parser->parseString($content);
                        $content = current($content);
                    } catch (Exception $e) {
                        throw new PEAR2_Pyrus_REST_Exception(
                            'Invalid xml downloaded from "' . $url . '"', $e);
                    }
                case 'text/html' :
                default :
                    // use it as a string
            }
        } else {
            // assume XML
            $parser = new PEAR2_Pyrus_XMLParser;
            try {
                $content = $parser->parseString($content);
                $content = current($content);
            } catch (Exception $e) {
                throw new PEAR2_Pyrus_REST_Exception(
                    'Invalid xml downloaded from "' . $url . '"', $e);
            }
        }
        $this->saveCache($url, $content, $lastmodified, false, $cacheId);
        return $content;
    }

    function useLocalCache($url, $cacheid = null)
    {
        if ($cacheid === null) {
            $cacheidfile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
                md5($url) . 'rest.cacheid';
            if (!file_exists($cacheidfile)) {
                return false;
            }

            $cacheid = unserialize(implode('', file($cacheidfile)));
        }
        $cachettl = $this->config->cache_ttl;
        // If cache is newer than $cachettl seconds, we use the cache!
        if (time() - $cacheid['age'] < $cachettl) {
            return $this->getCache($url);
        }
        return false;
    }

    function getCacheId($url)
    {
        $cacheidfile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
            md5($url) . 'rest.cacheid';
        if (file_exists($cacheidfile)) {
            $ret = unserialize(implode('', file($cacheidfile)));
            return $ret;
        }

        return false;
    }

    function getCache($url)
    {
        $cachefile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
            md5($url) . 'rest.cachefile';
        if (file_exists($cachefile)) {
            return unserialize(implode('', file($cachefile)));
        }

        throw new PEAR2_Pyrus_REST_Exception(
                'No cached content available for "' . $url . '"');
    }

    /**
     * @param string full URL to REST resource
     * @param string original contents of the REST resource
     * @param array  HTTP Last-Modified and ETag headers
     * @param bool   if true, then the cache id file should be regenerated to
     *               trigger a new time-to-live value
     */
    function saveCache($url, $contents, $lastmodified, $nochange = false, $cacheid = null)
    {
        $cacheidfile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
            md5($url) . 'rest.cacheid';
        $cachefile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
            md5($url) . 'rest.cachefile';
        if ($cacheid === null && $nochange) {
            $cacheid = unserialize(implode('', file($cacheidfile)));
        }

        $fp = @fopen($cacheidfile, 'wb');
        if (!$fp) {
            $cache_dir = $this->config->cache_dir;
            if (is_dir($cache_dir)) {
                return false;
            }

            if (!@mkdir($cache_dir, 0755, true)) {
                throw new PEAR2_Pyrus_REST_Exception(
                    'Cannot create REST cache directory ' . $cache_dir);
            }

            $fp = @fopen($cacheidfile, 'wb');
            if (!$fp) {
                return false;
            }
        }

        if ($nochange) {
            fwrite($fp, serialize(array(
                'age'        => time(),
                'lastChange' => $cacheid['lastChange'],
                )));
            fclose($fp);
            return true;
        } else {
            fwrite($fp, serialize(array(
                'age'        => time(),
                'lastChange' => $lastmodified,
                )));
        }
        fclose($fp);

        $fp = @fopen($cachefile, 'wb');
        if (!$fp) {
            if (file_exists($cacheidfile)) {
                @unlink($cacheidfile);
            }
            return false;
        }
        fwrite($fp, serialize($contents));
        fclose($fp);
        return true;
    }

    /**
     * Efficiently Download a file through HTTP.  Returns downloaded file as a string in-memory
     * This is best used for small files
     *
     * If an HTTP proxy has been configured (http_proxy PEAR_Config
     * setting), the proxy will be used.
     *
     * @param string  $url       the URL to download
     * @param string  $save_dir  directory to save file in
     * @param false|string|array $lastmodified header values to check against for caching
     *                           use false to return the header values from this download
     * @param false|array $accept Accept headers to send
     * @return string|array  Returns the contents of the downloaded file or a PEAR
     *                       error on failure.  If the error is caused by
     *                       socket-related errors, the error object will
     *                       have the fsockopen error code available through
     *                       getCode().  If caching is requested, then return the header
     *                       values.
     *
     * @access public
     */
    function downloadHttp($url, $lastmodified = null, $accept = false)
    {
        $info = parse_url($url);
        if (!isset($info['scheme']) || !in_array($info['scheme'], array('http', 'https'))) {
            throw new PEAR2_Pyrus_REST_Exception('Cannot download non-http URL "' . $url . '"');
        }
        if (!isset($info['host'])) {
            throw new PEAR2_Pyrus_REST_Exception('Cannot download from non-URL "' . $url . '"');
        }
        $request = new PEAR2_HTTP_Request($url);
        $host = $info['host'];
        if (!array_key_exists('port', $info)) {
            $info['port'] = null;
        }
        if (!array_key_exists('path', $info)) {
            $info['path'] = null;
        }
        $port = $info['port'];
        $path = $info['path'];
        $proxy_host = $proxy_port = $proxy_user = $proxy_pass = '';
        if ($this->config->http_proxy &&
              $proxy = parse_url($this->config->http_proxy)) {
            $proxy_host = isset($proxy['host']) ? $proxy['host'] : null;
            if (isset($proxy['scheme']) && $proxy['scheme'] == 'https') {
                $proxy_host = 'ssl://' . $proxy_host;
            }
            $proxy_port = isset($proxy['port']) ? $proxy['port'] : 8080;
            $proxy_user = isset($proxy['user']) ? urldecode($proxy['user']) : null;
            $proxy_pass = isset($proxy['pass']) ? urldecode($proxy['pass']) : null;
            // TODO: implement this when HTTP_Request supports it
        }
        if (empty($port)) {
            if (isset($info['scheme']) && $info['scheme'] == 'https') {
                $port = 443;
            } else {
                $port = 80;
            }
        }

        if (is_array($lastmodified)) {
            if (isset($lastmodified['Last-Modified'])) {
                $request->setHeader('If-Modified-Since', $lastmodified['Last-Modified']);
            }
            if (isset($lastmodified['ETag'])) {
                $request->setHeader('If-None-Match', $lastmodified['ETag']);
            }
        } elseif ($lastmodified) {
            $request->setHeader('If-Modified-Since', $lastmodified);
        }
        $request->setHeader('User-Agent', 'PEAR2_Pyrus/2.0.0a1/PHP/' . PHP_VERSION);
        $username = $this->config->username;
        $password = $this->config->password;
        if ($username && $password) {
            $tmp = base64_encode("$username:$password");
            $request->setHeader('Authorization', 'Basic ' . $tmp);
        }
        if ($proxy_host != '' && $proxy_user != '') {
            $request->setHeader('Proxy-Authorization', 'Basic ' .
                base64_encode($proxy_user . ':' . $proxy_pass));
        }
        if ($accept) {
            $request->setHeader('Accept', implode(', ', $accept));
        } else {
            $request->setHeader('Accept', '');
        }
        $request->setHeader('Connection', 'close');
        $response = $request->sendRequest();
        if ($response->code == 304 && ($lastmodified || ($lastmodified === false))) {
            return false;
        }
        if ($response->code != 200) {
            throw new PEAR2_Pyrus_REST_HTTPException(
                "File http://$host:$port$path not valid (received: $line)", $response->code);
        }
        if (isset($response->headers['content-length'])) {
            $length = $response->headers['content-length'];
        } else {
            $length = -1;
        }
        $data = $response->body;
        if ($lastmodified === false || $lastmodified) {
            if (isset($response->headers['etag'])) {
                $lastmodified = array('ETag' => $response->headers['etag']);
            }
            if (isset($response->headers['last-modified'])) {
                if (is_array($lastmodified)) {
                    $lastmodified['Last-Modified'] = $response->headers['last-modified'];
                } else {
                    $lastmodified = $response->headers['last-modified'];
                }
            }
            return array($data, $lastmodified, $response->headers);
        }
        return $data;
    }
}<?php
/**
 * PEAR_REST_10
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implement REST 1.0
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_REST_10
{
    /**
     * @var PEAR2_Pyrus_REST
     */
    protected $rest;
    function __construct($options = array())
    {
        $this->rest = new PEAR2_Pyrus_REST($options);
    }

    /**
     * Retrieve information about a remote package to be downloaded from a REST server
     *
     * @param string $base The uri to prepend to all REST calls
     * @param array $packageinfo an array of format:
     * <pre>
     *  array(
     *   'package' => 'packagename',
     *   'channel' => 'channelname',
     *  ['state' => 'alpha' (or valid state),]
     *  -or-
     *  ['version' => '1.whatever']
     * </pre>
     * @param string $prefstate Current preferred_state config variable value
     * @param bool $installed the installed version of this package to compare against
     * @return array|false|PEAR_Error see {@link returnDownloadURL()}
     */
    function getDownloadURL($base, $packageinfo, $prefstate, $installed)
    {
        $channel = $packageinfo['channel'];
        $package = $packageinfo['package'];
        $states = PEAR2_Pyrus_Installer::betterStates($prefstate, true);
        if (!$states) {
            throw new PEAR2_Pyrus_REST_Exception('"' . $prefstate . '" is not a valid state');
        }
        $state   = isset($packageinfo['state'])   ? $packageinfo['state']   : null;
        $version = isset($packageinfo['version']) ? $packageinfo['version'] : null;
        try {
            $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) . '/allreleases.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('No releases available for package "' .
                $channel . '/' . $package . '"', $e);
        }
        if (!isset($info['r'])) {
            return false;
        }
        $release = $found = false;
        if (!is_array($info['r']) || !isset($info['r'][0])) {
            $info['r'] = array($info['r']);
        }
        foreach ($info['r'] as $release) {
            if (!isset($this->rest->_options['force']) && ($installed &&
                  version_compare($release['v'], $installed, '<'))) {
                continue;
            }
            if (isset($state)) {
                // try our preferred state first
                if ($release['s'] == $state) {
                    $found = true;
                    break;
                }
                // see if there is something newer and more stable
                // bug #7221
                if (in_array($release['s'], PEAR2_Pyrus_Installer::betterStates($state), true)) {
                    $found = true;
                    break;
                }
            } elseif (isset($version)) {
                if ($release['v'] == $version) {
                    $found = true;
                    break;
                }
            } else {
                if (in_array($release['s'], $states)) {
                    $found = true;
                    break;
                }
            }
        }
        return $this->returnDownloadURL($base, $package, $release, $info, $found);
    }

    function getDepDownloadURL($base, $dependency, $deppackage,
                               $prefstate = 'stable', $installed = false)
    {
        $channel = $dependency['channel'];
        $package = $dependency['name'];
        $states = PEAR2_Pyrus_Installer::betterStates($prefstate, true);
        if (!$states) {
            throw new PEAR2_Pyrus_REST_Exception('"' . $prefstate . '" is not a valid state');
        }
        $state   = isset($dependency['state'])   ? $dependency['state']   : null;
        $version = isset($dependency['version']) ? $dependency['version'] : null;
        try {
            $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) . '/allreleases.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Package "' . $deppackage['channel'] . '/' . $deppackage['package']
                . '" dependency "' . $channel . '/' . $package . '" has no releases', $e);
        }
        if (!is_array($info) || !isset($info['r'])) {
            return false;
        }
        $exclude = array();
        $min = $max = $recommended = false;
        $min = isset($dependency['min']) ? $dependency['min'] : false;
        $max = isset($dependency['max']) ? $dependency['max'] : false;
        $recommended = isset($dependency['recommended']) ?
            $dependency['recommended'] : false;
        if (isset($dependency['exclude'])) {
            if (!isset($dependency['exclude'][0])) {
                $exclude = array($dependency['exclude']);
            }
        }
        $release = $found = false;
        if (!is_array($info['r']) || !isset($info['r'][0])) {
            $info['r'] = array($info['r']);
        }
        foreach ($info['r'] as $release) {
            if (!isset($this->rest->_options['force']) && ($installed &&
                  version_compare($release['v'], $installed, '<'))) {
                continue;
            }
            if (in_array($release['v'], $exclude)) { // skip excluded versions
                continue;
            }
            // allow newer releases to say "I'm OK with the dependent package"
            if (isset($release['co'])) {
                if (!is_array($release['co']) || !isset($release['co'][0])) {
                    $release['co'] = array($release['co']);
                }
                foreach ($release['co'] as $entry) {
                    if (isset($entry['x']) && !is_array($entry['x'])) {
                        $entry['x'] = array($entry['x']);
                    } elseif (!isset($entry['x'])) {
                        $entry['x'] = array();
                    }
                    if ($entry['c'] == $deppackage['channel'] &&
                          strtolower($entry['p']) == strtolower($deppackage['package']) &&
                          version_compare($deppackage['version'], $entry['min'], '>=') &&
                          version_compare($deppackage['version'], $entry['max'], '<=') &&
                          !in_array($release['v'], $entry['x'])) {
                        $recommended = $release['v'];
                        break;
                    }
                }
            }
            if ($recommended) {
                if ($release['v'] != $recommended) { // if we want a specific
                    // version, then skip all others
                    continue;
                } else {
                    if (!in_array($release['s'], $states)) {
                        // the stability is too low, but we must return the
                        // recommended version if possible
                        return $this->returnDownloadURL($base, $package, $release, $info, true);
                    }
                }
            }
            if ($min && version_compare($release['v'], $min, 'lt')) { // skip too old versions
                continue;
            }
            if ($max && version_compare($release['v'], $max, 'gt')) { // skip too new versions
                continue;
            }
            if ($installed && version_compare($release['v'], $installed, '<')) {
                continue;
            }
            if (in_array($release['s'], $states)) { // if in the preferred state...
                $found = true; // ... then use it
                break;
            }
        }
        return $this->returnDownloadURL($base, $package, $release, $info, $found);
    }

    /**
     * Take raw data and return the array needed for processing a download URL
     *
     * @param string $base REST base uri
     * @param string $package Package name
     * @param array $release an array of format array('v' => version, 's' => state)
     *                       describing the release to download
     * @param array $info list of all releases as defined by allreleases.xml
     * @param bool|null $found determines whether the release was found or this is the next
     *                    best alternative.  If null, then versions were skipped because
     *                    of PHP dependency
     * @return array|PEAR_Error
     * @access private
     */
    protected function returnDownloadURL($base, $package, $release, $info, $found, $phpversion = false)
    {
        if (!$found) {
            $release = $info['r'][0];
        }
        try {
            $pinfo = $this->rest->retrieveCacheFirst($base . 'p/' . strtolower($package) . '/' .
            'info.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Package "' . $package .
                '" does not have REST info xml available', $e);
        }
        try {
            $releaseinfo = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package) . '/' .
            $release['v'] . '.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Package "' . $package . '" Version "' . $release['v'] .
                '" does not have REST xml available', $e);
        }
        try {
            $packagexml = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package) . '/' .
            'package.' . $release['v'] . '.xml', false, true);
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Package "' . $package . '" Version "' . $release['v'] .
                '" does not have REST dependency information available', $e);
        }
        $allinfo = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
            '/allreleases.xml');
        if (!is_array($allinfo['r']) || !isset($allinfo['r'][0])) {
            $allinfo['r'] = array($allinfo['r']);
        }
        $compatible = false;
        foreach ($allinfo['r'] as $release) {
            if ($release['v'] != $releaseinfo['v']) {
                continue;
            }
            if (!isset($release['co'])) {
                break;
            }
            $compatible = array();
            if (!is_array($release['co']) || !isset($release['co'][0])) {
                $release['co'] = array($release['co']);
            }
            foreach ($release['co'] as $entry) {
                $comp = array();
                $comp['name'] = $entry['p'];
                $comp['channel'] = $entry['c'];
                $comp['min'] = $entry['min'];
                $comp['max'] = $entry['max'];
                if (isset($entry['x']) && !is_array($entry['x'])) {
                    $comp['exclude'] = $entry['x'];
                }
                $compatible[] = $comp;
            }
            if (count($compatible) == 1) {
                $compatible = $compatible[0];
            }
            break;
        }
        if (isset($pinfo['dc']) && isset($pinfo['dp'])) {
            if (is_array($pinfo['dp'])) {
                $deprecated = array('channel' => (string) $pinfo['dc'],
                                    'package' => trim($pinfo['dp']['_content']));
            } else {
                $deprecated = array('channel' => (string) $pinfo['dc'],
                                    'package' => trim($pinfo['dp']));
            }
        } else {
            $deprecated = false;
        }
        if ($found) {
            return
                array('version' => $releaseinfo['v'],
                      'info' => $packagexml,
                      'package' => $releaseinfo['p']['_content'],
                      'stability' => $releaseinfo['st'],
                      'url' => $releaseinfo['g'],
                      'compatible' => $compatible,
                      'deprecated' => $deprecated,
                );
        } else {
            return
                array('version' => $releaseinfo['v'],
                      'package' => $releaseinfo['p']['_content'],
                      'stability' => $releaseinfo['st'],
                      'info' => $packagexml,
                      'compatible' => $compatible,
                      'deprecated' => $deprecated,
                      'php' => $phpversion
                );
        }
    }

    function listPackages($base)
    {
        try {
            $packagelist = $this->rest->retrieveData($base . 'p/packages.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Cannot list packages', $e);
        }
        if (!is_array($packagelist) || !isset($packagelist['p'])) {
            return array();
        }
        if (!is_array($packagelist['p'])) {
            $packagelist['p'] = array($packagelist['p']);
        }
        return $packagelist['p'];
    }

    /**
     * List all categories of a REST server
     *
     * @param string $base base URL of the server
     * @return array of categorynames
     */
    function listCategories($base)
    {
        $categories = array();

        // c/categories.xml does not exist;
        // check for every package its category manually
        // This is SLOOOWWWW : ///
        try {
            $packagelist = $this->rest->retrieveData($base . 'p/packages.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Could not list categories', $e);
        }
        if (!is_array($packagelist) || !isset($packagelist['p'])) {
            $ret = array();
            return $ret;
        }
        if (!is_array($packagelist['p'])) {
            $packagelist['p'] = array($packagelist['p']);
        }

        try {
            foreach ($packagelist['p'] as $package) {
                $inf = $this->rest->retrieveData($base . 'p/' . strtolower($package) . '/info.xml');
                $cat = $inf['ca']['_content'];
                if (!isset($categories[$cat])) {
                    $categories[$cat] = $inf['ca'];
                }
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Could not list categories', $e);
        }
        return array_values($categories);
    }

    /**
     * List a category of a REST server
     *
     * @param string $base base URL of the server
     * @param string $category name of the category
     * @param boolean $info also download full package info
     * @return array of packagenames
     */
    function listCategory($base, $category, $info=false)
    {
        // gives '404 Not Found' error when category doesn't exist
        try {
            $packagelist = $this->rest->retrieveData($base.'c/'.urlencode($category).'/packages.xml');
        } catch (PEAR2_Pyrus_REST_HTTPException $e) {
            throw new PEAR2_Pyrus_REST_Exception('Unknown category ' . $category, $e);
        }
        if (!is_array($packagelist) || !isset($packagelist['p'])) {
            return array();
        }
        if (!is_array($packagelist['p']) ||
            !isset($packagelist['p'][0])) { // only 1 pkg
            $packagelist = array($packagelist['p']);
        } else {
            $packagelist = $packagelist['p'];
        }

        if ($info == true) {
            // get individual package info
            foreach ($packagelist as $i => $packageitem) {
                $url = sprintf('%s'.'r/%s/latest.txt',
                        $base,
                        strtolower($packageitem['_content']));
                try {
                    $version = $this->rest->retrieveData($url);
                } catch (Exception $e) {
                    break; // skipit
                }
                $url = sprintf('%s'.'r/%s/%s.xml',
                        $base,
                        strtolower($packageitem['_content']),
                        $version);
                try {
                    $info = $this->rest->retrieveData($url);
                } catch (Exception $e) {
                    break; // skipit
                }
                $packagelist[$i]['info'] = $info;
            }
        }

        return $packagelist;
    }


    function listAll($base, $dostable, $basic = true, $searchpackage = false, $searchsummary = false)
    {
        try {
            $packagelist = $this->rest->retrieveData($base . 'p/packages.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Could not retrieve package list to list all',
                $e);
        }
        $ret = array();
        if (!is_array($packagelist) || !isset($packagelist['p'])) {
            return $ret;
        }
        if (!is_array($packagelist['p'])) {
            $packagelist['p'] = array($packagelist['p']);
        }

        // only search-packagename = quicksearch !
        if ($searchpackage && (!$searchsummary || empty($searchpackage))) {
            $newpackagelist = array();
            foreach ($packagelist['p'] as $package) {
                if (!empty($searchpackage) && stristr($package, $searchpackage) !== false) {
                    $newpackagelist[] = $package;
                }
            }
            $packagelist['p'] = $newpackagelist;
        }
        foreach ($packagelist['p'] as $progress => $package) {
            if ($basic) { // remote-list command
                try {
                    if ($dostable) {
                        $latest = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
                            '/stable.txt');
                    } else {
                        $latest = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
                            '/latest.txt');
                    }
                } catch (Exception $e) {
                    $latest = false;
                }
                $info = array('stable' => $latest);
            } else { // list-all command
                try {
                    $inf = $this->rest->retrieveData($base . 'p/' . strtolower($package) . '/info.xml');
                } catch (Exception $e) {
                    throw new PEAR2_Pyrus_REST_Exception(
                        'Cannot list all, can\'t get package info for ' . $package, $e);
                }
                if ($searchpackage) {
                    $found = (!empty($searchpackage) && stristr($package, $searchpackage) !== false);
                    if (!$found && !(isset($searchsummary) && !empty($searchsummary)
                        && (stristr($inf['s'], $searchsummary) !== false
                            || stristr($inf['d'], $searchsummary) !== false)))
                    {
                        continue;
                    };
                }
                try {
                    $releases = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
                        '/allreleases.xml');
                } catch (Exception $e) {
                    continue;
                }
                if (!isset($releases['r'][0])) {
                    $releases['r'] = array($releases['r']);
                }
                unset($latest);
                unset($unstable);
                unset($stable);
                unset($state);
                foreach ($releases['r'] as $release) {
                    if (!isset($latest)) {
                        if ($dostable && $release['s'] == 'stable') {
                            $latest = $release['v'];
                            $state = 'stable';
                        }
                        if (!$dostable) {
                            $latest = $release['v'];
                            $state = $release['s'];
                        }
                    }
                    if (!isset($stable) && $release['s'] == 'stable') {
                        $stable = $release['v'];
                        if (!isset($unstable)) {
                            $unstable = $stable;
                        }
                    }
                    if (!isset($unstable) && $release['s'] != 'stable') {
                        $latest = $unstable = $release['v'];
                        $state = $release['s'];
                    }
                    if (isset($latest) && !isset($state)) {
                        $state = $release['s'];
                    }
                    if (isset($latest) && isset($stable) && isset($unstable)) {
                        break;
                    }
                }
                $deps = array();
                if (!isset($unstable)) {
                    $unstable = false;
                    $state = 'stable';
                    if (isset($stable)) {
                        $latest = $unstable = $stable;
                    }
                } else {
                    $latest = $unstable;
                }
                if (!isset($latest)) {
                    $latest = false;
                }
                if ($latest) {
                    try {
                        $d = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package) . '/deps.' .
                           $latest . '.txt');
                        $d = unserialize($d);
                        if ($d) {
                            $pf = new PEAR2_Pyrus_PackageFile_v2;
                            $deps = $pf->dependencies;
                        }
                    } catch (Exception $e) {
                        $deps = false;
                    }
                }
                if (!isset($stable)) {
                    $stable = '-n/a-';
                }
                if (!$searchpackage) {
                    $info = array('stable' => $latest, 'summary' => $inf['s'], 'description' =>
                        $inf['d'], 'deps' => $deps, 'category' => $inf['ca']['_content'],
                        'unstable' => $unstable, 'state' => $state);
                } else {
                    $info = array('stable' => $stable, 'summary' => $inf['s'], 'description' =>
                        $inf['d'], 'deps' => $deps, 'category' => $inf['ca']['_content'],
                        'unstable' => $unstable, 'state' => $state);
                }
            }
            $ret[$package] = $info;
        }
        return $ret;
    }

    function listLatestUpgrades($base, $pref_state, $installed, $channel, &$reg)
    {
        try {
            $packagelist = $this->rest->retrieveData($base . 'p/packages.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Could not retrieve latest upgrades', $e);
        }
        $ret = array();
        if (!is_array($packagelist) || !isset($packagelist['p'])) {
            return $ret;
        }
        if (!is_array($packagelist['p'])) {
            $packagelist['p'] = array($packagelist['p']);
        }
        foreach ($packagelist['p'] as $package) {
            if (!isset($installed[strtolower($package)])) {
                continue;
            }
            $inst_version = $reg->packageInfo($package, 'version', $channel);
            $inst_state = $reg->packageInfo($package, 'release_state', $channel);
            try {
                $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
                    '/allreleases.xml');
            } catch (Exception $e) {
                continue; // no remote releases
            }
            if (!isset($info['r'])) {
                continue;
            }
            $found = false;
            $release = false;
            if (!is_array($info['r']) || !isset($info['r'][0])) {
                $info['r'] = array($info['r']);
            }
            // $info['r'] is sorted by version number
            foreach ($info['r'] as $release) {
                if ($inst_version && version_compare($release['v'], $inst_version, '<=')) {
                    // not newer than the one installed
                    break;
                }

                // new version > installed version
                if (!$pref_state) {
                    // every state is a good state
                    $found = true;
                    break;
                } else {
                    $new_state = $release['s'];
                    // if new state >= installed state: go
                    if (in_array($new_state, PEAR2_Pyrus_Installer::betterStates($inst_state, true))) {
                        $found = true;
                        break;
                    } else {
                        // only allow to lower the state of package,
                        // if new state >= preferred state: go
                        if (in_array($new_state, PEAR2_Pyrus_Installer::betterStates($pref_state, true))) {
                            $found = true;
                            break;
                        }
                    }
                }
            }
            if (!$found) {
                continue;
            }
            try {
                $relinfo = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package) . '/' .
                $release['v'] . '.xml');
            } catch (Exception $e) {
                throw new PEAR2_Pyrus_REST_Exception('Cannot retrieve latest upgrade release' .
                    ' information for package ' . $package, $e);
            }
            $ret[$package] = array(
                    'version' => $release['v'],
                    'state' => $release['s'],
                    'filesize' => $relinfo['f'],
                );
        }
        return $ret;
    }

    function packageInfo($base, $package)
    {
        try {
            $pinfo = $this->rest->retrieveData($base . 'p/' . strtolower($package) . '/info.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Unknown package: "' . $package . '"', $e);
        }
        $releases = array();
        try {
            $allreleases = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
                '/allreleases.xml');
            if (!is_array($allreleases['r']) || !isset($allreleases['r'][0])) {
                $allreleases['r'] = array($allreleases['r']);
            }
            $pf = new PEAR2_Pyrus_PackageFile_v2;
            foreach ($allreleases['r'] as $release) {
                try {
                    $ds = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package) . '/deps.' .
                        $release['v'] . '.txt');
                } catch (Exception $e) {
                    continue;
                }
                if (!isset($latest)) {
                    $latest = $release['v'];
                }
                $pf->dependencies = unserialize($ds);
                $ds = $pf->dependencies;
                try {
                    $info = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package)
                        . '/' . $release['v'] . '.xml');
                } catch (Exception $e) {
                    continue;
                }
                $releases[$release['v']] = array(
                    'doneby' => $info['m'],
                    'license' => $info['l'],
                    'summary' => $info['s'],
                    'description' => $info['d'],
                    'releasedate' => $info['da'],
                    'releasenotes' => $info['n'],
                    'state' => $release['s'],
                    'deps' => $ds ? $ds : array(),
                );
            }
        } catch (Exception $e) {
            $latest = '';
        }
        if (isset($pinfo['dc']) && isset($pinfo['dp'])) {
            if (is_array($pinfo['dp'])) {
                $deprecated = array('channel' => (string) $pinfo['dc'],
                                    'package' => trim($pinfo['dp']['_content']));
            } else {
                $deprecated = array('channel' => (string) $pinfo['dc'],
                                    'package' => trim($pinfo['dp']));
            }
        } else {
            $deprecated = false;
        }
        return array(
            'name' => $pinfo['n'],
            'channel' => $pinfo['c'],
            'category' => $pinfo['ca']['_content'],
            'stable' => $latest,
            'license' => $pinfo['l'],
            'summary' => $pinfo['s'],
            'description' => $pinfo['d'],
            'releases' => $releases,
            'deprecated' => $deprecated,
            );
    }
}
?><?php
/**
 * PEAR_REST_11 - implement faster list-all/remote-list command
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implement REST 1.1
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR_REST_11
{
    /**
     * @var PEAR_REST
     */
    var $_rest;

    function PEAR_REST_11($config, $options = array())
    {
        $this->_rest = &new PEAR_REST($config, $options);
    }

    function listAll($base, $dostable, $basic = true)
    {
        $categorylist = $this->_rest->retrieveData($base . 'c/categories.xml');
        if (PEAR::isError($categorylist)) {
            return $categorylist;
        }
        $ret = array();
        if (!is_array($categorylist['c']) || !isset($categorylist['c'][0])) {
            $categorylist['c'] = array($categorylist['c']);
        }
        PEAR::pushErrorHandling(PEAR_ERROR_RETURN);

        foreach ($categorylist['c'] as $progress => $category) {
            $category = $category['_content'];
            $packagesinfo = $this->_rest->retrieveData($base .
                'c/' . urlencode($category) . '/packagesinfo.xml');

            if (PEAR::isError($packagesinfo)) {
                continue;
            }

            if (!is_array($packagesinfo) || !isset($packagesinfo['pi'])) {
                continue;
            }

            if (!is_array($packagesinfo['pi']) || !isset($packagesinfo['pi'][0])) {
                $packagesinfo['pi'] = array($packagesinfo['pi']);
            }

            foreach ($packagesinfo['pi'] as $packageinfo) {
                $info = $packageinfo['p'];
                $package = $info['n'];
                $releases = isset($packageinfo['a']) ? $packageinfo['a'] : false;
                unset($latest);
                unset($unstable);
                unset($stable);
                unset($state);

                if ($releases) {
                    if (!isset($releases['r'][0])) {
                        $releases['r'] = array($releases['r']);
                    }
                    foreach ($releases['r'] as $release) {
                        if (!isset($latest)) {
                            if ($dostable && $release['s'] == 'stable') {
                                $latest = $release['v'];
                                $state = 'stable';
                            }
                            if (!$dostable) {
                                $latest = $release['v'];
                                $state = $release['s'];
                            }
                        }
                        if (!isset($stable) && $release['s'] == 'stable') {
                            $stable = $release['v'];
                            if (!isset($unstable)) {
                                $unstable = $stable;
                            }
                        }
                        if (!isset($unstable) && $release['s'] != 'stable') {
                            $unstable = $release['v'];
                            $state = $release['s'];
                        }
                        if (isset($latest) && !isset($state)) {
                            $state = $release['s'];
                        }
                        if (isset($latest) && isset($stable) && isset($unstable)) {
                            break;
                        }
                    }
                }

                if ($basic) { // remote-list command
                    if (!isset($latest)) {
                        $latest = false;
                    }
                    if ($dostable) {
                        // $state is not set if there are no releases
                        if (isset($state) && $state == 'stable') {
                            $ret[$package] = array('stable' => $latest);
                        } else {
                            $ret[$package] = array('stable' => '-n/a-');
                        }
                    } else {
                        $ret[$package] = array('stable' => $latest);
                    }
                    continue;
                }

                // list-all command
                $deps = array();
                if (!isset($unstable)) {
                    $unstable = false;
                    $state = 'stable';
                    if (isset($stable)) {
                        $latest = $unstable = $stable;
                    }
                } else {
                    $latest = $unstable;
                }

                if (!isset($latest)) {
                    $latest = false;
                }

                if ($latest && isset($packageinfo['deps'])) {
                    if (!is_array($packageinfo['deps']) ||
                          !isset($packageinfo['deps'][0])) {
                        $packageinfo['deps'] = array($packageinfo['deps']);
                    }
                    $d = false;
                    foreach ($packageinfo['deps'] as $dep) {
                        if ($dep['v'] == $latest) {
                            $d = unserialize($dep['d']);
                        }
                    }
                    if ($d) {
                        if (isset($d['required'])) {
                            if (!class_exists('PEAR_PackageFile_v2')) {
                                require_once 'PEAR/PackageFile/v2.php';
                            }
                            if (!isset($pf)) {
                                $pf = new PEAR_PackageFile_v2;
                            }
                            $pf->setDeps($d);
                            $tdeps = $pf->getDeps();
                        } else {
                            $tdeps = $d;
                        }
                        foreach ($tdeps as $dep) {
                            if ($dep['type'] !== 'pkg') {
                                continue;
                            }
                            $deps[] = $dep;
                        }
                    }
                }

                $info = array('stable' => $latest, 'summary' => $info['s'],
                    'description' =>
                    $info['d'], 'deps' => $deps, 'category' => $info['ca']['_content'],
                    'unstable' => $unstable, 'state' => $state);
                $ret[$package] = $info;
            }
        }
        PEAR::popErrorHandling();
        return $ret;
    }

    /**
     * List all categories of a REST server
     *
     * @param string $base base URL of the server
     * @return array of categorynames
     */
    function listCategories($base)
    {
        $categorylist = $this->_rest->retrieveData($base . 'c/categories.xml');
        if (PEAR::isError($categorylist)) {
            return $categorylist;
        }
        if (!is_array($categorylist) || !isset($categorylist['c'])) {
            return array();
        }
        if (isset($categorylist['c']['_content'])) {
            // only 1 category
            $categorylist['c'] = array($categorylist['c']);
        }
        return $categorylist['c'];
    }

    /**
     * List packages in a category of a REST server
     *
     * @param string $base base URL of the server
     * @param string $category name of the category
     * @param boolean $info also download full package info
     * @return array of packagenames
     */
    function listCategory($base, $category, $info=false)
    {
        if ($info == false) {
            $url = '%s'.'c/%s/packages.xml';
        } else {
            $url = '%s'.'c/%s/packagesinfo.xml';
        }
        $url = sprintf($url,
                    $base,
                    urlencode($category));

        // gives '404 Not Found' error when category doesn't exist
        $packagelist = $this->_rest->retrieveData($url);
        if (PEAR::isError($packagelist)) {
            return $packagelist;
        }
        if (!is_array($packagelist)) {
            return array();
        }

        if ($info == false) {
            if (!isset($packagelist['p'])) {
                return array();
            }
            if (!is_array($packagelist['p']) ||
                !isset($packagelist['p'][0])) { // only 1 pkg
                $packagelist = array($packagelist['p']);
            } else {
                $packagelist = $packagelist['p'];
            }
            return $packagelist;
        } else {
            // info == true
            if (!isset($packagelist['pi'])) {
                return array();
            }
            if (!is_array($packagelist['pi']) ||
                !isset($packagelist['pi'][0])) { // only 1 pkg
                $packagelist_pre = array($packagelist['pi']);
            } else {
                $packagelist_pre = $packagelist['pi'];
            }

            $packagelist = array();
            foreach ($packagelist_pre as $i => $item) {
                // compatibility with r/<latest.txt>.xml
                if (isset($item['a']['r'][0])) {
                    // multiple releases
                    $item['p']['v'] = $item['a']['r'][0]['v'];
                    $item['p']['st'] = $item['a']['r'][0]['s'];
                } elseif (isset($item['a'])) {
                    // first and only release
                    $item['p']['v'] = $item['a']['r']['v'];
                    $item['p']['st'] = $item['a']['r']['s'];
                }

                $packagelist[$i] = array('attribs' => $item['p']['r'],
                                         '_content' => $item['p']['n'],
                                         'info' => $item['p']);
            }
        }

        return $packagelist;
    }
}
?><?php
/**
 * PEAR_REST_13
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */


/**
 * Implement REST 1.3
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_REST_13 extends PEAR2_Pyrus_REST_10
{
    /**
     * Retrieve information about a remote package to be downloaded from a REST server
     *
     * This is smart enough to resolve the minimum PHP version dependency prior to download
     * @param string $base The uri to prepend to all REST calls
     * @param array $packageinfo an array of format:
     * <pre>
     *  array(
     *   'package' => 'packagename',
     *   'channel' => 'channelname',
     *  ['state' => 'alpha' (or valid state),]
     *  -or-
     *  ['version' => '1.whatever']
     * </pre>
     * @param string $prefstate Current preferred_state config variable value
     * @param bool $installed the installed version of this package to compare against
     * @return array|false|PEAR_Error see {@link returnDownloadURL(()}
     */
    function getDownloadURL($base, $packageinfo, $prefstate, $installed)
    {
        $channel = $packageinfo['channel'];
        $package = $packageinfo['package'];
        $states = PEAR2_Pyrus_Installer::betterStates($prefstate, true);
        if (!$states) {
            throw new PEAR2_Pyrus_REST_Exception('"' . $prefstate . '" is not a valid state');
        }
        $state   = isset($packageinfo['state'])   ? $packageinfo['state']   : null;
        $version = isset($packageinfo['version']) ? $packageinfo['version'] : null;
        try {
            $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) . '/allreleases2.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('No releases available for package "' .
                $channel . '/' . $package . '"', $e);
        }
        if (!isset($info['r'])) {
            return false;
        }
        $release = $found = false;
        if (!is_array($info['r']) || !isset($info['r'][0])) {
            $info['r'] = array($info['r']);
        }
        $skippedphp = false;
        foreach ($info['r'] as $release) {
            if (!isset($this->_rest->_options['force']) && ($installed &&
                  version_compare($release['v'], $installed, '<'))) {
                continue;
            }
            if (isset($state)) {
                // try our preferred state first
                if ($release['s'] == $state) {
                    if (!isset($version) && version_compare($release['m'], phpversion(), '>')) {
                        // skip releases that require a PHP version newer than our PHP version
                        $skippedphp = $release;
                        continue;
                    }
                    $found = true;
                    break;
                }
                // see if there is something newer and more stable
                // bug #7221
                if (in_array($release['s'], PEAR2_Pyrus_Installer::betterStates($state), true)) {
                    if (!isset($version) && version_compare($release['m'], phpversion(), '>')) {
                        // skip releases that require a PHP version newer than our PHP version
                        $skippedphp = $release;
                        continue;
                    }
                    $found = true;
                    break;
                }
            } elseif (isset($version)) {
                if ($release['v'] == $version) {
                    if (!isset($this->_rest->_options['force']) &&
                          !isset($version) &&
                          version_compare($release['m'], phpversion(), '>')) {
                        // skip releases that require a PHP version newer than our PHP version
                        $skippedphp = $release;
                        continue;
                    }
                    $found = true;
                    break;
                }
            } else {
                if (in_array($release['s'], $states)) {
                    if (version_compare($release['m'], phpversion(), '>')) {
                        // skip releases that require a PHP version newer than our PHP version
                        $skippedphp = $release;
                        continue;
                    }
                    $found = true;
                    break;
                }
            }
        }
        if (!$found && $skippedphp) {
            $found = null;
        }
        return $this->returnDownloadURL($base, $package, $release, $info, $found, $skippedphp);
    }

    function getDepDownloadURL($base, $dependency, $deppackage,
                               $prefstate = 'stable', $installed = false)
    {
        $channel = $dependency['channel'];
        $package = $dependency['name'];
        $states = PEAR2_Pyrus_Installer::betterStates($prefstate, true);
        if (!$states) {
            throw new PEAR2_Pyrus_REST_Exception('"' . $prefstate . '" is not a valid state');
        }
        $state   = isset($dependency['state'])   ? $dependency['state']   : null;
        $version = isset($dependency['version']) ? $dependency['version'] : null;
        $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
            '/allreleases2.xml');
        try {
            $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) . '/allreleases2.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Package "' . $deppackage['channel'] . '/' . $deppackage['package']
                . '" dependency "' . $channel . '/' . $package . '" has no releases', $e);
        }
        if (!is_array($info) || !isset($info['r'])) {
            return false;
        }
        $exclude = array();
        $min = $max = $recommended = false;
        $pinfo['package'] = $dependency['name'];
        $min = isset($dependency['min']) ? $dependency['min'] : false;
        $max = isset($dependency['max']) ? $dependency['max'] : false;
        $recommended = isset($dependency['recommended']) ?
            $dependency['recommended'] : false;
        if (isset($dependency['exclude'])) {
            if (!isset($dependency['exclude'][0])) {
                $exclude = array($dependency['exclude']);
            }
        }
        $found = false;
        $release = false;
        $skippedphp = false;
        if (!is_array($info['r']) || !isset($info['r'][0])) {
            $info['r'] = array($info['r']);
        }
        foreach ($info['r'] as $release) {
            if (!isset($this->rest->_options['force']) && ($installed &&
                  version_compare($release['v'], $installed, '<'))) {
                continue;
            }
            if (in_array($release['v'], $exclude)) { // skip excluded versions
                continue;
            }
            // allow newer releases to say "I'm OK with the dependent package"
            if (isset($release['co'])) {
                if (!is_array($release['co']) || !isset($release['co'][0])) {
                    $release['co'] = array($release['co']);
                }
                foreach ($release['co'] as $entry) {
                    if (isset($entry['x']) && !is_array($entry['x'])) {
                        $entry['x'] = array($entry['x']);
                    } elseif (!isset($entry['x'])) {
                        $entry['x'] = array();
                    }
                    if ($entry['c'] == $deppackage['channel'] &&
                          strtolower($entry['p']) == strtolower($deppackage['package']) &&
                          version_compare($deppackage['version'], $entry['min'], '>=') &&
                          version_compare($deppackage['version'], $entry['max'], '<=') &&
                          !in_array($release['v'], $entry['x'])) {
                        if (version_compare($release['m'], phpversion(), '>')) {
                            // skip dependency releases that require a PHP version
                            // newer than our PHP version
                            $skippedphp = $release;
                            continue;
                        }
                        $recommended = $release['v'];
                        break;
                    }
                }
            }
            if ($recommended) {
                if ($release['v'] != $recommended) { // if we want a specific
                    // version, then skip all others
                    continue;
                } else {
                    if (!in_array($release['s'], $states)) {
                        // the stability is too low, but we must return the
                        // recommended version if possible
                        return $this->returnDownloadURL($base, $package, $release, $info, true);
                    }
                }
            }
            if ($min && version_compare($release['v'], $min, 'lt')) { // skip too old versions
                continue;
            }
            if ($max && version_compare($release['v'], $max, 'gt')) { // skip too new versions
                continue;
            }
            if ($installed && version_compare($release['v'], $installed, '<')) {
                continue;
            }
            if (in_array($release['s'], $states)) { // if in the preferred state...
                if (version_compare($release['m'], phpversion(), '>')) {
                    // skip dependency releases that require a PHP version
                    // newer than our PHP version
                    $skippedphp = $release;
                    continue;
                }
                $found = true; // ... then use it
                break;
            }
        }
        if (!$found && $skippedphp) {
            $found = null;
        }
        return $this->returnDownloadURL($base, $package, $release, $info, $found, $skippedphp);
    }
}
?><?php
/**
 * PEAR2_Pyrus_REST_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for REST
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_REST_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_REST_HTTPException
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for REST HTTP
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_REST_HTTPException extends PEAR2_Pyrus_REST_Exception {}<?php
/**
 * This script handles the command line interface commands to Pyrus
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * This script handles the command line interface commands to Pyrus
 * 
 * Each command is a separate method, and will be called with the arguments
 * entered by the end user.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ScriptFrontend_Commands
{
    public $commands = array();

    function __construct()
    {
        $a = new ReflectionClass($this);
        foreach ($a->getMethods() as $method) {
            $name = $method->getName();
            if ($name[0] == '_' || $name === 'run') {
                continue;
            }
            $this->commands[preg_replace_callback('/[A-Z]/',
                    create_function('$m', 'return "-" . strtolower($m[0]);'), $name)] = $name;
        }
    }

    /**
     * This method acts as a controller which dispatches the request to the 
     * correct command/method.
     * 
     * <code>
     * $cli = PEAR2_Pyrus_ScriptFrontend_Commands();
     * $cli->run($args = array (0 => 'install',
     *                          1 => 'PEAR2/Pyrus_Developer/package.xml'));
     * </code>
     *
     * The above code will dispatch to the install command
     * 
     * @param array $args An array of command line arguments.
     * 
     * @return void
     */
    function run($args)
    {
        try {
            if (!count($args)) {
                $args[0] = 'help';
            }
            $this->_findPEAR($args);
            if (isset($this->commands[$args[0]])) {
                $command = array_shift($args);
                $command = $this->commands[$command];
                $this->$command($args);
            } else {
                $this->help($args);
            }
        } catch (Exception $e) {
            echo "Operation failed:\n$e";
        }
    }

    function _findPEAR(&$arr)
    {
        if (isset($arr[0]) && @file_exists($arr[0]) && @is_dir($arr[0])) {
            $maybe = array_shift($arr);
            $maybe = realpath($maybe);
            echo "Using PEAR installation found at $maybe\n";
            $config = PEAR2_Pyrus_Config::singleton($maybe);
            return;
        }
        $mypath = PEAR2_Pyrus_Config::singleton()->my_pear_path;
        if ($mypath) {
            foreach (explode(PATH_SEPARATOR, $mypath) as $path) {
                echo "Using PEAR installation found at $path\n";
                $config = PEAR2_Pyrus_Config::singleton($path);
                return;
            }
        }
        $include_path = explode(PATH_SEPARATOR, get_include_path());
        foreach ($include_path as $path) {
            if ($path == '.') continue;
            echo "Using PEAR installation found at $path\n";
            $config = PEAR2_Pyrus_Config::singleton($path);
            return;
        }
        echo "Using PEAR installation in current directory\n";
    }

    /**
     * Display the help dialog and list all commands supported.
     *
     * @param array $args Array of command line arguments
     */
    function help($args)
    {
        if (isset($args[0]) && $args[0] == 'help') {
            echo "Commands supported:\n";
            foreach ($this->commands as $command => $true) {
                echo "$command\n";
            }
        } else {
            if (isset($args[0])) {
                echo "Unknown command: $args[0]\n";
            }
            echo "Commands supported:\n";
            foreach ($this->commands as $command => $true) {
                echo "$command [PEARPath]\n";
            }
        }
    }

    /**
     * install a local or remote package
     *
     * @param array $args
     */
    function install($args)
    {
        PEAR2_Pyrus_Installer::begin();
        try {
            $packages = array();
            foreach ($args as $arg) {
                PEAR2_Pyrus_Installer::prepare($packages[] = new PEAR2_Pyrus_Package($arg));
            }
            PEAR2_Pyrus_Installer::commit();
            foreach ($packages as $package) {
                echo 'Installed ' . $package->channel . '\\' . $package->name . '-' . $package->version['release'] . "\n";
            }
        } catch (Exception $e) {
            echo $e;
            exit -1;
        }
    }

    /**
     * uninstall an installed package
     *
     * @param array $args
     */
    function uninstall($args)
    {
        PEAR2_Pyrus_Uninstaller::begin();
        try {
            $packages = $non = $failed = array();
            foreach ($args as $arg) {
                try {
                    if (!isset(PEAR2_Pyrus_Config::current()->registry->package[$arg])) {
                        $non[] = $arg;
                        continue;
                    }
                    $packages[] = PEAR2_Pyrus_Uninstaller::prepare($arg);
                } catch (Exception $e) {
                    $failed[] = $arg;
                }
            }
            PEAR2_Pyrus_Uninstaller::commit();
            foreach ($non as $package) {
                echo "Package $package not installed, cannot uninstall\n";
            }
            foreach ($packages as $package) {
                echo 'Uninstalled ', $package->channel, '/', $package->name, "\n";
            }
            foreach ($failed as $package) {
                echo "Package $package could not be uninstalled\n";
            }
        } catch (Exception $e) {
            echo $e;
            exit -1;
        }
    }

    /**
     * download a remote package
     *
     * @param array $args
     */
    function download($args)
    {
        PEAR2_Pyrus_Config::current()->download_dir = getcwd();
        $packages = array();
        foreach ($args as $arg) {
            try {
                $packages[] = array(new PEAR2_Pyrus_Package($arg), $arg);
            } catch (Exception $e) {
                echo "failed to init $arg for download (", $e->getMessage(), ")\n";
            }
        }
        foreach ($packages as $package) {
            $arg = $package[1];
            $package = $package[0];
            echo "Downloading ", $arg, '...';
            try {
                $package->download();
                $path = $package->getInternalPackage()->getTarballPath();
                echo "done ($path)\n";
            } catch (Exception $e) {
                echo 'failed! (', $e->getMessage(), ")\n";
            }
        }
    }

    /**
     * Upgrade a package
     *
     * @param array $args
     */
    function upgrade($args)
    {
        PEAR2_Pyrus_Installer::$options['upgrade'] = true;
        $this->install($args);
    }

    /**
     * list all the installed packages
     *
     * @param array $args
     */
    function listPackages($args)
    {
        $reg = PEAR2_Pyrus_Config::current()->registry;
        $creg = PEAR2_Pyrus_Config::current()->channelregistry;
        $cascade = array(array($reg, $creg));
        while ($p = $reg->getParent() && $c = $creg->getParent()) {
            $cascade[] = array($p, $c);
        }
        array_reverse($cascade);
        foreach ($cascade as $p) {
            $c = $p[1];
            $p = $p[0];
            echo "Listing installed packages [", $p->getPath(), "]:\n";
            $packages = array();
            foreach ($c as $channel) {
                PEAR2_Pyrus_Config::current()->default_channel = $channel->name;
                foreach ($p as $package) {
                    $packages[$channel->name][] = $package->name;
                }
            }
            asort($packages);
            foreach ($packages as $channel => $stuff) {
                echo "[channel $channel]:\n";
                foreach ($stuff as $package) {
                    echo " $package\n";
                }
            }
        }
    }

    /**
     * List all the known channels
     *
     * @param array $args
     */
    function listChannels($args)
    {
        $creg = PEAR2_Pyrus_Config::current()->channelregistry;
        $cascade = array($creg);
        while ($c = $creg->getParent()) {
            $cascade[] = $c;
        }
        array_reverse($cascade);
        foreach ($cascade as $c) {
            echo "Listing channels [", $c->getPath(), "]:\n";
            foreach ($c as $channel) {
                echo $channel->getName() . ' (' . $channel->getAlias() . ")\n";
            }
        }
    }

    /**
     * remotely connect to a channel server and grab the channel information,
     * then add it to the current pyrus managed repo
     *
     * @param array $args $args[0] should be the channel name, eg:pear.unl.edu
     */
    function channelDiscover($args)
    {
        $chan = 'http://' . $args[0] . '/channel.xml';
        $http = new PEAR2_HTTP_Request($chan);
        try {
            $response = $http->sendRequest();
        } catch (Exception $e) {
            // try secure
            try {
                $chan = 'https://' . $args[0] . '/channel.xml';
                $http = new PEAR2_HTTP_Request($chan);
                $response = $http->sendRequest();
            } catch (Exception $u) {
                // failed, re-throw original error
                throw $e;
            }
        }

        $chan = new PEAR2_Pyrus_Channel($response->body);
        PEAR2_Pyrus_Config::current()->channelregistry->add($chan);
        echo "Discovery of channel ", $chan->name, " successful\n";
    }

    /**
     * add a channel to the current pyrus managed path using the raw channel.xml
     *
     * @param array $args $args[0] should be the channel.xml filename
     */
    function channelAdd($args)
    {
        echo "Adding channel from channel.xml:\n";
        $chan = file_get_contents($args[0]);
        if (!$chan) {
            echo "Retrieving channel.xml contents failed\n";
            exit -1;
        }
        $chan = new PEAR2_Pyrus_Channel($chan);
        PEAR2_Pyrus_Config::current()->channelregistry->add($chan);
        echo "Adding channel ", $chan->name, " successful\n";
    }

    function channelDel($args)
    {
        echo "Adding channel from channel.xml:\n";
        $chan = PEAR2_Pyrus_Config::current()->channelregistry->get($args[0], false);
        if (count($chan)) {
            echo "Cannot remove channel ", $chan->name, "packages are installed\n";
            exit -1;
        }
        PEAR2_Pyrus_Config::current()->channelregistry->delete($chan);
        echo "Deleting channel ", $chan->name, " successful\n";
    }

    /**
     * Display pyrus configuration vars
     *
     * @param array $args
     */
    function configShow($args)
    {
        $conf = PEAR2_Pyrus_Config::current();
        echo "System paths:\n";
        foreach ($conf->mainsystemvars as $var) {
            echo "  $var => " . $conf->$var . "\n";
        }
        echo "Custom System paths:\n";
        foreach ($conf->customsystemvars as $var) {
            echo "  $var => " . $conf->$var . "\n";
        }
        echo "User config (from " . $conf->userfile . "):\n";
        foreach ($conf->mainuservars as $var) {
            echo "  $var => " . $conf->$var . "\n";
        }
        echo "Custom User config (from " . $conf->userfile . "):\n";
        foreach ($conf->customuservars as $var) {
            echo "  $var => " . $conf->$var . "\n";
        }
    }

    /**
     * Set a configuration option.
     *
     * @param array $args
     */
    function set($args)
    {
        $conf = PEAR2_Pyrus_Config::current();
        if (in_array($args[0], $conf->uservars)) {
            echo "Setting $args[0] in " . $conf->userfile . "\n";
            $conf->{$args[0]} = $args[1];
        } elseif (in_array($args[0], $conf->systemvars)) {
            echo "Setting $args[0] in system paths\n";
            $conf->{$args[0]} = $args[1];
        } else {
            echo "Unknown config variable: $args[0]\n";
            exit -1;
        }
        $conf->saveConfig();
    }

    /**
     * Set up a pear path managed by pyrus.
     *
     * @param array $args Arguments
     */
    function mypear($args)
    {
        echo "Setting my pear repositories to:\n";
        echo implode("\n", $args) . "\n";
        $args = implode(PATH_SEPARATOR, $args);
        PEAR2_Pyrus_Config::current()->my_pear_path = $args;
        PEAR2_Pyrus_Config::current()->saveConfig();
    }
}
<?php
/**
 * PEAR_Task_Common, base class for installer tasks
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
/**#@+
 * Error codes for task validation routines
 */
define('PEAR2_PYRUS_TASK_ERROR_NOATTRIBS', 1);
define('PEAR2_PYRUS_TASK_ERROR_MISSING_ATTRIB', 2);
define('PEAR2_PYRUS_TASK_ERROR_WRONG_ATTRIB_VALUE', 3);
define('PEAR2_PYRUS_TASK_ERROR_INVALID', 4);
/**#@-*/
define('PEAR2_PYRUS_TASK_PACKAGE', 1);
define('PEAR2_PYRUS_TASK_INSTALL', 2);
define('PEAR2_PYRUS_TASK_PACKAGEANDINSTALL', 3);
/**
 * A task is an operation that manipulates the contents of a file.
 *
 * Simple tasks operate on 1 file.  Multiple tasks are executed after all files have been
 * processed and installed, and are designed to operate on all files containing the task.
 * The Post-install script task simply takes advantage of the fact that it will be run
 * after installation, replace is a simple task.
 *
 * Combining tasks is possible, but ordering is significant.
 *
 * <file name="test.php" role="php">
 *  <tasks:replace from="@data-dir@" to="data_dir" type="pear-config"/>
 *  <tasks:postinstallscript/>
 * </file>
 *
 * This will first replace any instance of @data-dir@ in the test.php file
 * with the path to the current data directory.  Then, it will include the
 * test.php file and run the script it contains to configure the package post-installation.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Common
{
    /**
     * Valid types for this version are 'simple' and 'multiple'
     *
     * - simple tasks operate on the contents of a file and write out changes to disk
     * - multiple tasks operate on the contents of many files and write out the
     *   changes directly to disk
     *
     * Child task classes must override this property.
     * @access protected
     */
    var $type = 'simple';
    /**
     * Determines which install phase this task is executed under
     */
    var $phase = PEAR2_PYRUS_TASK_INSTALL;
    /**
     * @access protected
     */
    var $config;
    /**
     * @access protected
     */
    var $registry;
    /**
     * @access protected
     */
    var $logger;
    /**
     * @access protected
     */
    var $installphase;
    /**
     * @param PEAR_Config
     * @param PEAR_Common
     */

    static $multiple = array();

    function __construct($config, $phase)
    {
        $this->config = $config;
        $this->registry = $config->registry;
        $this->installphase = $phase;
        if ($this->type == 'multiple') {
            self::$multiple[get_class($this)][] = $this;
        }
    }

    /**
     * Validate the basic contents of a task tag.
     * @param PEAR_PackageFile_v2
     * @param array
     * @param PEAR_Config
     * @param array the entire parsed <file> tag
     * @return true|array On error, return an array in format:
     *    array(PEAR_TASK_ERROR_???[, param1][, param2][, ...])
     *
     *    For PEAR_TASK_ERROR_MISSING_ATTRIB, pass the attribute name in
     *    For PEAR_TASK_ERROR_WRONG_ATTRIB_VALUE, pass the attribute name and an array
     *    of legal values in
     * @static
     * @abstract
     */
    static function validateXml($pkg, $xml, $config, $fileXml)
    {
    }

    /**
     * Initialize a task instance with the parameters
     * @param array raw, parsed xml
     * @param array attributes from the <file> tag containing this task
     * @param string|null last installed version of this package
     * @abstract
     */
    function init($xml, $fileAttributes, $lastVersion)
    {
    }

    /**
     * Begin a task processing session.  All multiple tasks will be processed after each file
     * has been successfully installed, all simple tasks should perform their task here and
     * return any errors using the custom throwError() method to allow forward compatibility
     *
     * This method MUST NOT write out any changes to disk
     * @param PEAR_PackageFile_v2
     * @param string file contents
     * @param string the eventual final file location (informational only)
     * @return string|false|PEAR_Error false to skip this file, PEAR_Error to fail
     *         (use $this->throwError), otherwise return the new contents
     * @abstract
     */
    function startSession($pkg, $contents, $dest)
    {
    }

    /**
     * This method is used to process each of the tasks for a particular multiple class
     * type.  Simple tasks need not implement this method.
     * @param array an array of tasks
     * @access protected
     * @static
     * @abstract
     */
    function run($tasks)
    {
    }

    /**
     * @static
     * @final
     */
    function hasPostinstallTasks()
    {
        return count(self::$multiple);
    }

    /**
     * @static
     * @final
     */
     function runPostinstallTasks()
     {
         foreach (self::$multiple as $class => $tasks) {
             call_user_func(array($class, 'run'),
                  self::$multiple[$class]);
         }
         self::$multiple = array();
    }

    /**
     * Determines whether a role is a script
     * @return bool
     */
    function isScript()
    {
        return $this->type == 'script';
    }
}
?><?php
/**
 * PEAR2_Pyrus_Task_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus Tasks
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Exception extends PEAR2_Exception {}<?php
/**
 * <tasks:postinstallscript>
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements the postinstallscript file task.
 *
 * Note that post-install scripts are handled separately from installation, by the
 * "pear run-scripts" command
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Postinstallscript extends PEAR2_Pyrus_Task_Common
{
    var $type = 'script';
    var $_class;
    var $_params;
    var $_obj;
    /**
     *
     * @var PEAR_PackageFile_v2
     */
    var $_pkg;
    var $_contents;
    var $phase = PEAR2_PYRUS_TASK_INSTALL;

    /**
     * Validate the raw xml at parsing-time.
     *
     * This also attempts to validate the script to make sure it meets the criteria
     * for a post-install script
     * @param PEAR_PackageFile_v2
     * @param array The XML contents of the <postinstallscript> tag
     * @param PEAR_Config
     * @param array the entire parsed <file> tag
     * @static
     */
    function validateXml($pkg, $xml, $config, $fileXml)
    {
        if ($fileXml['role'] != 'php') {
            return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
            $fileXml['name'] . '" must be role="php"');
        }
        try {
            $file = $pkg->getFileContents($fileXml['name']);
        } catch (Exception $e) {
            return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                $fileXml['name'] . '" is not valid: ' .
                $e->getMessage());
        }
        if ($file === null) {
            return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                $fileXml['name'] . '" could not be retrieved for processing!');
        } else {
            $analysis = $pkg->analyzeSourceCode($file, true);
            if (!$analysis) {
                $warnings = '';
                foreach ($pkg->getValidationWarnings() as $warn) {
                    $warnings .= $warn['message'] . "\n";
                }
                return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Analysis of post-install script "' .
                    $fileXml['name'] . '" failed: ' . $warnings);
            }
            if (count($analysis['declared_classes']) != 1) {
                return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                    $fileXml['name'] . '" must declare exactly 1 class');
            }
            $class = $analysis['declared_classes'][0];
            if ($class != str_replace(array('/', '.php'), array('_', ''),
                  $fileXml['name']) . '_postinstall') {
                return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                    $fileXml['name'] . '" class "' . $class . '" must be named "' .
                    str_replace(array('/', '.php'), array('_', ''),
                    $fileXml['name']) . '_postinstall"');
            }
            if (!isset($analysis['declared_methods'][$class])) {
                return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                    $fileXml['name'] . '" must declare methods init() and run()');
            }
            $methods = array('init' => 0, 'run' => 1);
            foreach ($analysis['declared_methods'][$class] as $method) {
                if (isset($methods[$method])) {
                    unset($methods[$method]);
                }
            }
            if (count($methods)) {
                return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                    $fileXml['name'] . '" must declare methods init() and run()');
            }
        }
        $definedparams = array();
        $tasksNamespace = $pkg->getTasksNs() . ':';
        if (!isset($xml[$tasksNamespace . 'paramgroup']) && isset($xml['paramgroup'])) {
            // in order to support the older betas, which did not expect internal tags
            // to also use the namespace
            $tasksNamespace = '';
        }
        if (isset($xml[$tasksNamespace . 'paramgroup'])) {
            $params = $xml[$tasksNamespace . 'paramgroup'];
            if (!is_array($params) || !isset($params[0])) {
                $params = array($params);
            }
            foreach ($params as $param) {
                if (!isset($param[$tasksNamespace . 'id'])) {
                    return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                        $fileXml['name'] . '" <paramgroup> must have ' .
                        'an ' . $tasksNamespace . 'id> tag');
                }
                if (isset($param[$tasksNamespace . 'name'])) {
                    if (!in_array($param[$tasksNamespace . 'name'], $definedparams)) {
                        return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                            $fileXml['name'] . '" ' . $tasksNamespace .
                            'paramgroup> id "' . $param[$tasksNamespace . 'id'] .
                            '" parameter "' . $param[$tasksNamespace . 'name'] .
                            '" has not been previously defined');
                    }
                    if (!isset($param[$tasksNamespace . 'conditiontype'])) {
                        return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                            $fileXml['name'] . '" ' . $tasksNamespace .
                            'paramgroup> id "' . $param[$tasksNamespace . 'id'] .
                            '" must have a ' . $tasksNamespace .
                            'conditiontype> tag containing either "=", ' .
                            '"!=", or "preg_match"');
                    }
                    if (!in_array($param[$tasksNamespace . 'conditiontype'],
                          array('=', '!=', 'preg_match'))) {
                        return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                            $fileXml['name'] . '" ' . $tasksNamespace .
                            'paramgroup> id "' . $param[$tasksNamespace . 'id'] .
                            '" must have a ' . $tasksNamespace .
                            'conditiontype> tag containing either "=", ' .
                            '"!=", or "preg_match"');
                    }
                    if (!isset($param[$tasksNamespace . 'value'])) {
                        return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                            $fileXml['name'] . '" ' . $tasksNamespace .
                            'paramgroup> id "' . $param[$tasksNamespace . 'id'] .
                            '" must have a ' . $tasksNamespace .
                            'value> tag containing expected parameter value');
                    }
                }
                if (isset($param[$tasksNamespace . 'instructions'])) {
                    if (!is_string($param[$tasksNamespace . 'instructions'])) {
                        return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                            $fileXml['name'] . '" ' . $tasksNamespace .
                            'paramgroup> id "' . $param[$tasksNamespace . 'id'] .
                            '" ' . $tasksNamespace . 'instructions> must be simple text');
                    }
                }
                if (!isset($param[$tasksNamespace . 'param'])) {
                    continue; // <param> is no longer required
                }
                $subparams = $param[$tasksNamespace . 'param'];
                if (!is_array($subparams) || !isset($subparams[0])) {
                    $subparams = array($subparams);
                }
                foreach ($subparams as $subparam) {
                    if (!isset($subparam[$tasksNamespace . 'name'])) {
                        return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                            $fileXml['name'] . '" parameter for ' .
                            $tasksNamespace . 'paramgroup> id "' .
                            $param[$tasksNamespace . 'id'] . '" must have ' .
                            'a ' . $tasksNamespace . 'name> tag');
                    }
                    if (!preg_match('/[a-zA-Z0-9]+/',
                          $subparam[$tasksNamespace . 'name'])) {
                        return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                            $fileXml['name'] . '" parameter "' .
                            $subparam[$tasksNamespace . 'name'] .
                            '" for ' . $tasksNamespace . 'paramgroup> id "' .
                            $param[$tasksNamespace . 'id'] .
                            '" is not a valid name.  Must contain only alphanumeric characters');
                    }
                    if (!isset($subparam[$tasksNamespace . 'prompt'])) {
                        return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                            $fileXml['name'] . '" parameter "' .
                            $subparam[$tasksNamespace . 'name'] .
                            '" for ' . $tasksNamespace . 'paramgroup> id "' .
                            $param[$tasksNamespace . 'id'] .
                            '" must have a ' . $tasksNamespace . 'prompt> tag');
                    }
                    if (!isset($subparam[$tasksNamespace . 'type'])) {
                        return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'Post-install script "' .
                            $fileXml['name'] . '" parameter "' .
                            $subparam[$tasksNamespace . 'name'] .
                            '" for ' . $tasksNamespace . 'paramgroup> id "' .
                            $param[$tasksNamespace . 'id'] .
                            '" must have a ' . $tasksNamespace . 'type> tag');
                    }
                    $definedparams[] = $param[$tasksNamespace . 'id'] . '::' .
                    $subparam[$tasksNamespace . 'name'];
                }
            }
        }
        return true;
    }

    /**
     * Initialize a task instance with the parameters
     * @param array raw, parsed xml
     * @param array attributes from the <file> tag containing this task
     * @param string|null last installed version of this package, if any (useful for upgrades)
     */
    function init($xml, $fileattribs, $lastversion)
    {
        $this->_class = str_replace('/', '_', $fileattribs['name']);
        $this->_filename = $fileattribs['name'];
        $this->_class = str_replace ('.php', '', $this->_class) . '_postinstall';
        $this->_params = $xml;
        $this->_lastversion = $lastversion;
    }

    /**
     * Strip the tasks: namespace from internal params
     *
     * @access private
     */
    function _stripNamespace($params = null)
    {
        if ($params === null) {
            $params = array();
            if (!is_array($this->_params)) {
                return;
            }
            foreach ($this->_params as $i => $param) {
                if (is_array($param)) {
                    $param = $this->_stripNamespace($param);
                }
                $params[str_replace($this->_pkg->getTasksNs() . ':', '', $i)] = $param;
            }
            $this->_params = $params;
        } else {
            $newparams = array();
            foreach ($params as $i => $param) {
                if (is_array($param)) {
                    $param = $this->_stripNamespace($param);
                }
                $newparams[str_replace($this->_pkg->getTasksNs() . ':', '', $i)] = $param;
            }
            return $newparams;
        }
    }

    /**
     * Unlike other tasks, the installed file name is passed in instead of the file contents,
     * because this task is handled post-installation
     * @param PEAR_PackageFile_v1|PEAR_PackageFile_v2
     * @param string file name
     * @return bool|PEAR_Error false to skip this file, PEAR_Error to fail
     *         (use $this->throwError)
     */
    function startSession($pkg, $contents)
    {
        if ($this->installphase != PEAR2_PYRUS_TASK_INSTALL) {
            return false;
        }
        // remove the tasks: namespace if present
        $this->_pkg = $pkg;
        $this->_stripNamespace();
        PEAR2_Pyrus_Log::log(0, 'Including external post-installation script "' .
            $contents . '" - any errors are in this script');
        include $contents;
        if (class_exists($this->_class)) {
            PEAR2_Pyrus_Log::log(0, 'Inclusion succeeded');
        } else {
            throw new PEAR2_Pyrus_Task_Exception('init of post-install script class "' . $this->_class
                . '" failed');
        }
        $this->_obj = new $this->_class;
        PEAR2_Pyrus_Log::log(1, 'running post-install script "' . $this->_class . '->init()"');
        try {
            $res = $this->_obj->init($this->config, $pkg, $this->_lastversion);
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Task_Exception('init of post-install script "' . $this->_class .
                '->init()" failed');
        }
        PEAR2_Pyrus_Log::log(0, 'init succeeded');
        $this->_contents = $contents;
        return true;
    }

    /**
     * No longer used
     * @see PEAR_PackageFile_v2::runPostinstallScripts()
     * @param array an array of tasks
     * @param string install or upgrade
     * @access protected
     * @static
     */
    function run()
    {
    }
}
?><?php
/**
 * <tasks:postinstallscript> - read/write version
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: rw.php,v 1.1 2006/12/28 20:42:32 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Release 1.4.0a10
 */
/**
 * Base class
 */
require_once 'PEAR/Task/Postinstallscript.php';
/**
 * Abstracts the postinstallscript file task xml.
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 1.4.0a10
 */
class PEAR_Task_Postinstallscript_rw extends PEAR_Task_Postinstallscript
{
    /**
     * parent package file object
     *
     * @var PEAR_PackageFile_v2_rw
     */
    var $_pkg;
    /**
     * Enter description here...
     *
     * @param PEAR_PackageFile_v2_rw $pkg
     * @param PEAR_Config $config
     * @param PEAR_Frontend $logger
     * @param array $fileXml
     * @return PEAR_Task_Postinstallscript_rw
     */
    function PEAR_Task_Postinstallscript_rw(&$pkg, &$config, &$logger, $fileXml)
    {
        parent::PEAR_Task_Common($config, $logger, PEAR_TASK_PACKAGE);
        $this->_contents = $fileXml;
        $this->_pkg = &$pkg;
        $this->_params = array();
    }

    function validate()
    {
        return $this->validateXml($this->_pkg, $this->_params, $this->config, $this->_contents);
    }

    function getName()
    {
        return 'postinstallscript';
    }

    /**
     * add a simple <paramgroup> to the post-install script
     *
     * Order is significant, so call this method in the same
     * sequence the users should see the paramgroups.  The $params
     * parameter should either be the result of a call to {@link getParam()}
     * or an array of calls to getParam().
     *
     * Use {@link addConditionTypeGroup()} to add a <paramgroup> containing
     * a <conditiontype> tag
     * @param string $id <paramgroup> id as seen by the script
     * @param array|false $params array of getParam() calls, or false for no params
     * @param string|false $instructions
     */
    function addParamGroup($id, $params = false, $instructions = false)
    {
        if ($params && isset($params[0]) && !isset($params[1])) {
            $params = $params[0];
        }
        $stuff =
            array(
                $this->_pkg->getTasksNs() . ':id' => $id,
            );
        if ($instructions) {
            $stuff[$this->_pkg->getTasksNs() . ':instructions'] = $instructions;
        }
        if ($params) {
            $stuff[$this->_pkg->getTasksNs() . ':param'] = $params;
        }
        $this->_params[$this->_pkg->getTasksNs() . ':paramgroup'][] = $stuff;
    }

    /**
     * add a complex <paramgroup> to the post-install script with conditions
     *
     * This inserts a <paramgroup> with
     *
     * Order is significant, so call this method in the same
     * sequence the users should see the paramgroups.  The $params
     * parameter should either be the result of a call to {@link getParam()}
     * or an array of calls to getParam().
     *
     * Use {@link addParamGroup()} to add a simple <paramgroup>
     *
     * @param string $id <paramgroup> id as seen by the script
     * @param string $oldgroup <paramgroup> id of the section referenced by
     *                         <conditiontype>
     * @param string $param name of the <param> from the older section referenced
     *                      by <contitiontype>
     * @param string $value value to match of the parameter
     * @param string $conditiontype one of '=', '!=', 'preg_match'
     * @param array|false $params array of getParam() calls, or false for no params
     * @param string|false $instructions
     */
    function addConditionTypeGroup($id, $oldgroup, $param, $value, $conditiontype = '=',
                                   $params = false, $instructions = false)
    {
        if ($params && isset($params[0]) && !isset($params[1])) {
            $params = $params[0];
        }
        $stuff =
            array(
                $this->_pkg->getTasksNs() . ':id' => $id,
            );
        if ($instructions) {
            $stuff[$this->_pkg->getTasksNs() . ':instructions'] = $instructions;
        }
        $stuff[$this->_pkg->getTasksNs() . ':name'] = $oldgroup . '::' . $param;
        $stuff[$this->_pkg->getTasksNs() . ':conditiontype'] = $conditiontype;
        $stuff[$this->_pkg->getTasksNs() . ':value'] = $value;
        if ($params) {
            $stuff[$this->_pkg->getTasksNs() . ':param'] = $params;
        }
        $this->_params[$this->_pkg->getTasksNs() . ':paramgroup'][] = $stuff;
    }

    function getXml()
    {
        return $this->_params;
    }

    /**
     * Use to set up a param tag for use in creating a paramgroup
     * @static
     */
    function getParam($name, $prompt, $type = 'string', $default = null)
    {
        if ($default !== null) {
            return
            array(
                $this->_pkg->getTasksNs() . ':name' => $name,
                $this->_pkg->getTasksNs() . ':prompt' => $prompt,
                $this->_pkg->getTasksNs() . ':type' => $type,
                $this->_pkg->getTasksNs() . ':default' => $default
            );
        }
        return
            array(
                $this->_pkg->getTasksNs() . ':name' => $name,
                $this->_pkg->getTasksNs() . ':prompt' => $prompt,
                $this->_pkg->getTasksNs() . ':type' => $type,
            );
    }
}
?><?php
/**
 * <tasks:replace>
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements the replace file task.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Replace extends PEAR2_Pyrus_Task_Common
{
    var $type = 'simple';
    var $phase = PEAR2_PYRUS_TASK_PACKAGEANDINSTALL;
    var $_replacements;

    /**
     * Validate the raw xml at parsing-time.
     * @param PEAR_PackageFile_v2
     * @param array raw, parsed xml
     * @param PEAR_Config
     * @static
     */
    static function validateXml($pkg, $xml, $config, $fileXml)
    {
        if (!isset($xml['attribs'])) {
            return array(PEAR2_PYRUS_TASK_ERROR_NOATTRIBS);
        }
        if (!isset($xml['attribs']['type'])) {
            return array(PEAR2_PYRUS_TASK_ERROR_MISSING_ATTRIB, 'type');
        }
        if (!isset($xml['attribs']['to'])) {
            return array(PEAR2_PYRUS_TASK_ERROR_MISSING_ATTRIB, 'to');
        }
        if (!isset($xml['attribs']['from'])) {
            return array(PEAR2_PYRUS_TASK_ERROR_MISSING_ATTRIB, 'from');
        }
        if ($xml['attribs']['type'] == 'pear-config') {
            if (!in_array($xml['attribs']['to'], $config->systemvars)) {
                return array(PEAR2_PYRUS_TASK_ERROR_WRONG_ATTRIB_VALUE, 'to', $xml['attribs']['to'],
                    $config->systemvars);
            }
        } elseif ($xml['attribs']['type'] == 'php-const') {
            if (defined($xml['attribs']['to'])) {
                return true;
            } else {
                return array(PEAR2_PYRUS_TASK_ERROR_WRONG_ATTRIB_VALUE, 'to', $xml['attribs']['to'],
                    array('valid PHP constant'));
            }
        } elseif ($xml['attribs']['type'] == 'package-info') {
            if (in_array($xml['attribs']['to'],
                array('name', 'summary', 'channel', 'notes', 'extends', 'description',
                    'release_notes', 'license', 'release-license', 'license-uri',
                    'version', 'api-version', 'state', 'api-state', 'release_date',
                    'date', 'time'))) {
                return true;
            } else {
                return array(PEAR2_PYRUS_TASK_ERROR_WRONG_ATTRIB_VALUE, 'to', $xml['attribs']['to'],
                    array('name', 'summary', 'channel', 'notes', 'extends', 'description',
                    'release_notes', 'license', 'release-license', 'license-uri',
                    'version', 'api-version', 'state', 'api-state', 'release_date',
                    'date', 'time'));
            }
        } else {
            return array(PEAR2_PYRUS_TASK_ERROR_WRONG_ATTRIB_VALUE, 'type', $xml['attribs']['type'],
                array('pear-config', 'package-info', 'php-const'));
        }
        return true;
    }

    /**
     * Initialize a task instance with the parameters
     * @param array raw, parsed xml
     * @param unused
     */
    function init($xml, $attribs)
    {
        $this->_replacements = isset($xml['attribs']) ? array($xml) : $xml;
    }

    /**
     * Do a package.xml 1.0 replacement, with additional package-info fields available
     *
     * See validateXml() source for the complete list of allowed fields
     * @param PEAR_PackageFile_v1|PEAR_PackageFile_v2
     * @param string file contents
     * @param string the eventual final file location (informational only)
     * @return string|false|PEAR_Error false to skip this file, PEAR_Error to fail
     *         (use $this->throwError), otherwise return the new contents
     */
    function startSession($pkg, $contents, $dest)
    {
        $subst_from = $subst_to = array();
        foreach ($this->_replacements as $a) {
            $a = $a['attribs'];
            $to = '';
            if ($a['type'] == 'pear-config') {
                if ($this->installphase == PEAR2_PYRUS_TASK_PACKAGE) {
                    return false;
                }
                if (false) {// $this->config->isDefinedLayer('ftp')) {
                    // try the remote config file first
                    $to = $this->config->{$a['to']};
                    if (is_null($to)) {
                        // then default to local
                        $to = $this->config->{$a['to']};
                    }
                } else {
                    $to = $this->config->{$a['to']};
                }
                if (is_null($to)) {
                    PEAR2_Pyrus_Log::log(0, "$dest: invalid pear-config replacement: $a[to]");
                    return false;
                }
            } elseif ($a['type'] == 'php-const') {
                if ($this->installphase == PEAR2_PYRUS_TASK_PACKAGE) {
                    return false;
                }
                if (defined($a['to'])) {
                    $to = constant($a['to']);
                } else {
                    PEAR2_Pyrus_Log::log(0, "$dest: invalid php-const replacement: $a[to]");
                    return false;
                }
            } else {
                if ($t = $pkg->{$a['to']}) {
                    if ($a['to'] == 'version') {
                        $t = $t['release'];
                    }
                    $to = $t;
                } else {
                    PEAR2_Pyrus_Log::log(0, "$dest: invalid package-info replacement: $a[to]");
                    return false;
                }
            }
            if (!is_null($to)) {
                $subst_from[] = $a['from'];
                $subst_to[] = $to;
            }
        }
        PEAR2_Pyrus_Log::log(3, "doing " . sizeof($subst_from) .
            " substitution(s) for $dest");
        if (sizeof($subst_from)) {
            $contents = str_replace($subst_from, $subst_to, $contents);
        }
        return $contents;
    }
}
?><?php
/**
 * <tasks:replace> - read/write version
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: rw.php,v 1.1 2006/12/28 20:42:32 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Release 1.4.0a10
 */
/**
 * Base class
 */
require_once 'PEAR/Task/Replace.php';
/**
 * Abstracts the replace task xml.
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 1.4.0a10
 */
class PEAR_Task_Replace_rw extends PEAR_Task_Replace
{
    function PEAR_Task_Replace_rw(&$pkg, &$config, &$logger, $fileXml)
    {
        parent::PEAR_Task_Common($config, $logger, PEAR_TASK_PACKAGE);
        $this->_contents = $fileXml;
        $this->_pkg = &$pkg;
        $this->_params = array();
    }

    function validate()
    {
        return $this->validateXml($this->_pkg, $this->_params, $this->config, $this->_contents);
    }

    function setInfo($from, $to, $type)
    {
        $this->_params = array('attribs' => array('from' => $from, 'to' => $to, 'type' => $type));
    }

    function getName()
    {
        return 'replace';
    }

    function getXml()
    {
        return $this->_params;
    }
}
?><?php
/**
 * <tasks:unixeol>
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements the unix line endings file task.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Unixeol extends PEAR2_Pyrus_Task_Common
{
    var $type = 'simple';
    var $phase = PEAR2_PYRUS_TASK_PACKAGE;
    var $_replacements;

    /**
     * Validate the raw xml at parsing-time.
     * @param PEAR_PackageFile_v2
     * @param array raw, parsed xml
     * @param PEAR_Config
     * @static
     */
    static function validateXml($pkg, $xml, &$config, $fileXml)
    {
        if ($xml != '') {
            return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'no attributes allowed');
        }
        return true;
    }

    /**
     * Initialize a task instance with the parameters
     * @param array raw, parsed xml
     * @param unused
     */
    function init($xml, $attribs)
    {
    }

    /**
     * Replace all line endings with line endings customized for the current OS
     *
     * See validateXml() source for the complete list of allowed fields
     * @param PEAR_PackageFile_v1|PEAR_PackageFile_v2
     * @param string file contents
     * @param string the eventual final file location (informational only)
     * @return string|false|PEAR_Error false to skip this file, PEAR_Error to fail
     *         (use $this->throwError), otherwise return the new contents
     */
    function startSession($pkg, $contents, $dest)
    {
        PEAR2_Pyrus_Log::log(3, "replacing all line endings with \\n in $dest");
        return preg_replace("/\r\n|\n\r|\r|\n/", "\n", $contents);
    }
}
?><?php
/**
 * <tasks:unixeol> - read/write version
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: rw.php,v 1.1 2006/12/28 20:42:32 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Release 1.4.0a10
 */
/**
 * Base class
 */
require_once 'PEAR/Task/Unixeol.php';
/**
 * Abstracts the unixeol task xml.
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 1.4.0a10
 */
class PEAR_Task_Unixeol_rw extends PEAR_Task_Unixeol
{
    function PEAR_Task_Unixeol_rw(&$pkg, &$config, &$logger, $fileXml)
    {
        parent::PEAR_Task_Common($config, $logger, PEAR_TASK_PACKAGE);
        $this->_contents = $fileXml;
        $this->_pkg = &$pkg;
        $this->_params = array();
    }

    function validate()
    {
        return true;
    }

    function getName()
    {
        return 'unixeol';
    }

    function getXml()
    {
        return '';
    }
}
?><?php
/**
 * <tasks:windowseol>
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements the windows line endsings file task.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Windowseol extends PEAR2_Pyrus_Task_Common
{
    var $type = 'simple';
    var $phase = PEAR2_PYRUS_TASK_PACKAGE;
    var $_replacements;

    /**
     * Validate the raw xml at parsing-time.
     * @param PEAR_PackageFile_v2
     * @param array raw, parsed xml
     * @param PEAR_Config
     * @static
     */
    static function validateXml($pkg, $xml, &$config, $fileXml)
    {
        if ($xml != '') {
            return array(PEAR2_PYRUS_TASK_ERROR_INVALID, 'no attributes allowed');
        }
        return true;
    }

    /**
     * Initialize a task instance with the parameters
     * @param array raw, parsed xml
     * @param unused
     */
    function init($xml, $attribs)
    {
    }

    /**
     * Replace all line endings with windows line endings
     *
     * See validateXml() source for the complete list of allowed fields
     * @param PEAR_PackageFile_v1|PEAR_PackageFile_v2
     * @param string file contents
     * @param string the eventual final file location (informational only)
     * @return string|false|PEAR_Error false to skip this file, PEAR_Error to fail
     *         (use $this->throwError), otherwise return the new contents
     */
    function startSession($pkg, $contents, $dest)
    {
        PEAR2_Pyrus_Log::log(3, "replacing all line endings with \\r\\n in $dest");
        return preg_replace("/\r\n|\n\r|\r|\n/", "\r\n", $contents);
    }
}
?><?php
/**
 * <tasks:windowseol> - read/write version
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: rw.php,v 1.1 2006/12/28 20:42:32 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Release 1.4.0a10
 */
/**
 * Base class
 */
require_once 'PEAR/Task/Windowseol.php';
/**
 * Abstracts the windowseol task xml.
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 1.4.0a10
 */
class PEAR_Task_Windowseol_rw extends PEAR_Task_Windowseol
{
    function PEAR_Task_Windowseol_rw(&$pkg, &$config, &$logger, $fileXml)
    {
        parent::PEAR_Task_Common($config, $logger, PEAR_TASK_PACKAGE);
        $this->_contents = $fileXml;
        $this->_pkg = &$pkg;
        $this->_params = array();
    }

    function validate()
    {
        return true;
    }

    function getName()
    {
        return 'windowseol';
    }

    function getXml()
    {
        return '';
    }
}
?><?php
require __DIR__ .  '/../../../sandbox/Loader/src/PEAR2/Loader/PEAR2Svn.php';
$dev_directory = dirname(dirname(__DIR__));
PEAR2_Pyrus_Config::singleton('/home/cellog/testpear');
$a = new PEAR2_Pyrus_Package_Creator(array(
        //new PEAR2_Pyrus_Developer_Creator_Xml($dev_directory . 'newpyrus.xml'),
        //new PEAR2_Pyrus_Developer_Creator_Tar($dev_directory . 'newpyrus.tar'),
        //new PEAR2_Pyrus_Developer_Creator_Zip($dev_directory . 'PEAR2_Pyrus-0.1.0.zip'),
        new PEAR2_Pyrus_Developer_Creator_Phar_PHPArchive($dev_directory . '/pyrus.phar', '<?php
function __autoload($class)
{
    include \'phar://\' . PYRUS_PHAR_FILE . \'/src/\' . implode(\'/\', explode(\'_\', $class)) . \'.php\';
}
$frontend = new PEAR2_Pyrus_ScriptFrontend_Commands;
@array_shift($_SERVER[\'argv\']);
$frontend->run($_SERVER[\'argv\']);
'),
    ));
$b = new PEAR2_Pyrus_Package(__DIR__ . '/../../package.xml');
$rp = __DIR__ . '/../../../HTTP_Request/src/HTTP';
$a->render($b, array(
    'src/PEAR2/HTTP/Request.php' => $rp . '/Request.php',
    'src/PEAR2/HTTP/Request/Adapter.php' => $rp . '/Request/Adapter.php',
    'src/PEAR2/HTTP/Request/Adapter/Phpsocket.php' => $rp . '/Request/Adapter/Phpsocket.php',
    'src/PEAR2/HTTP/Request/Adapter/Phpstream.php' => $rp . '/Request/Adapter/Phpstream.php',
    'src/PEAR2/HTTP/Request/Exception.php' => $rp . '/Request/Exception.php',
    'src/PEAR2/HTTP/Request/Headers.php' => $rp . '/Request/Headers.php',
    'src/PEAR2/HTTP/Request/Response.php' => $rp . '/Request/Response.php',
    'src/PEAR2/HTTP/Request/Uri.php' => $rp . '/Request/Uri.php',
    'src/Net/URL2.php' => '/usr/local/lib/php/Net/URL2.php',
));
exit;
// this shows how it works
function __autoload($class)
{
    if (substr($class, 0, 5) != 'PEAR2') return false;
    $path = explode('_', substr($class, 11)); // strip PEAR2_Pyrus for CVS
    $path = dirname(__FILE__) . implode('/', $path) . '.php';
    include $path;
}
include $a = '/home/cellog/workspace/PEAR2/Exception/trunk/src/Exception.php';
include $b = '/home/cellog/workspace/PEAR2/MultiErrors/trunk/src/MultiErrors.php';
include '/home/cellog/workspace/PEAR2/MultiErrors/trunk/src/MultiErrors/Exception.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/v2.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN/Filter.php';
//new PEAR2_Pyrus_Developer_PackageFile_PEAR2SVN(
//    '/home/cellog/workspace/PEAR2/Pyrus_Developer', 'PEAR2_Pyrus_Developer', 'pear2.php.net', false, false);
//exit;
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/Creator/Zip.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/Creator/Phar.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/Creator/Xml.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/Creator/Exception.php';
//$a = new PEAR2_Pyrus_Package_Creator(array(
//        new PEAR2_Pyrus_Developer_Creator_Phar('/home/cellog/workspace/Pyrus/blah.phar',
//            '<?php echo "hi";__HALT_COMPILER();'),
//        new PEAR2_Pyrus_Developer_Creator_Tar('/tmp/blah.tgz'),
//        new PEAR2_Pyrus_Developer_Creator_Xml('/tmp/blah.xml'),
//    ), $a, '/home/cellog/workspace/PEAR2/Autoload/trunk/src/Autoload.php', $b);
//$b = new PEAR2_Pyrus_Package('/home/cellog/workspace/pear-core/PEAR-1.6.2.tgz');
//$a->render($b);
//exit;
define('OS_WINDOWS', false);
define('OS_UNIX', true);
include '/home/cellog/workspace/PEAR2/HTTP_Request/trunk/src/HTTP/Request/allfiles.php';
$g = new PEAR2_Pyrus_Config('/home/cellog/testpear');
try {
    PEAR2_Pyrus_Installer::begin();
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Autoload/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Exception/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/MultiErrors/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Pyrus_Developer/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/Pyrus/package.xml'));
    PEAR2_Pyrus_Installer::commit();
} catch (Exception $e) {
    PEAR2_Pyrus_Installer::rollback();
    echo $e;
}
exit;
//$g = new PEAR2_Pyrus_Config('C:/development/pear-core/testpear');
$g = new PEAR2_Pyrus_Config('/home/cellog/testpear');
$g->saveConfig();
$g->bin_dir = 'home/cellog/testpear';
//$a = new PEAR2_Pyrus_Package('C:/development/pear-core/PEAR-1.5.0a1.tgz');
$a = new PEAR2_Pyrus_Package('/tmp/blah.tgz');
$b = new PEAR2_Pyrus_Installer;
$b->install($a);<?php
// this shows how it works
function __autoload($class)
{
    if (substr($class, 0, 5) != 'PEAR2') return false;
    $path = explode('_', substr($class, 11)); // strip PEAR2_Pyrus for CVS
    $path = dirname(__FILE__) . implode('/', $path) . '.php';
    include $path;
}
include $a = '/home/cellog/workspace/PEAR2/Exception/trunk/src/Exception.php';
include $b = '/home/cellog/workspace/PEAR2/MultiErrors/trunk/src/MultiErrors.php';
include '/home/cellog/workspace/PEAR2/MultiErrors/trunk/src/MultiErrors/Exception.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/v2.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN/Filter.php';
//new PEAR2_Pyrus_Developer_PackageFile_PEAR2SVN(
//    '/home/cellog/workspace/PEAR2/Pyrus_Developer', 'PEAR2_Pyrus_Developer', 'pear2.php.net', false, false);
//exit;
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/Creator/Zip.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/Creator/Phar.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/Creator/Xml.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/Creator/Exception.php';
//$a = new PEAR2_Pyrus_Package_Creator(array(
//        new PEAR2_Pyrus_Developer_Creator_Phar('/home/cellog/workspace/Pyrus/blah.phar',
//            '<?php echo "hi";__HALT_COMPILER();'),
//        new PEAR2_Pyrus_Developer_Creator_Tar('/tmp/blah.tgz'),
//        new PEAR2_Pyrus_Developer_Creator_Xml('/tmp/blah.xml'),
//    ), $a, '/home/cellog/workspace/PEAR2/Autoload/trunk/src/Autoload.php', $b);
//$b = new PEAR2_Pyrus_Package('/home/cellog/workspace/pear-core/PEAR-1.6.2.tgz');
//$a->render($b);
//exit;
define('OS_WINDOWS', false);
define('OS_UNIX', true);
include '/home/cellog/workspace/PEAR2/HTTP_Request/trunk/src/HTTP/Request/allfiles.php';
$g = new PEAR2_Pyrus_Config('/home/cellog/testpear');
try {
    PEAR2_Pyrus_Installer::begin();
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Autoload/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Exception/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/MultiErrors/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Pyrus_Developer/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/Pyrus/package.xml'));
//    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('pear.php.net/Console_Getopt'));
    PEAR2_Pyrus_Installer::commit();
} catch (Exception $e) {
    PEAR2_Pyrus_Installer::rollback();
    echo $e;
}
exit;
//$g = new PEAR2_Pyrus_Config('C:/development/pear-core/testpear');
$g = new PEAR2_Pyrus_Config('/home/cellog/testpear');
$g->saveConfig();
$g->bin_dir = 'home/cellog/testpear';
//$a = new PEAR2_Pyrus_Package('C:/development/pear-core/PEAR-1.5.0a1.tgz');
$a = new PEAR2_Pyrus_Package('/tmp/blah.tgz');
$b = new PEAR2_Pyrus_Installer;
$b->install($a);<?php
function __autoload($class)
{
    if (substr($class, 0, 4) != 'PEAR') return false;
    $path = explode('_', substr($class, 11)); // strip PEAR2_Pyrus for CVS
    $path = dirname(__FILE__) . implode('\\', $path) . '.php';
    include $path;
}
include $a = 'C:/development/PEAR2/Exception/trunk/src/Exception.php';
include $b = 'C:/development/PEAR2/MultiErrors/trunk/src/MultiErrors.php';
include 'C:/development/PEAR2/MultiErrors/trunk/src/MultiErrors/Exception.php';
//include 'C:/development/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN.php';
//include 'C:/development/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN/Filter.php';
//include 'C:/development/PEAR2/Pyrus_Developer/src/Developer/PackageFile/v2.php';
//new PEAR2_Pyrus_Developer_PackageFile_PEAR2SVN(
//    'C:/development/PEAR2/Autoload', 'PEAR2_Autoload', 'pear2.php.net',
//        false, false);
////    'C:/development/PEAR2/Pyrus', 'PEAR2_Pyrus', 'pear2.php.net');
//new PEAR2_Pyrus_Package('C:/development/PEAR2/Pyrus_Developer/package.xml');
//exit;
//include 'C:/development/PEAR2/HTTP/Request/src/HTTP/Request/allfiles.php';
//include 'C:/development/PEAR2/Pyrus_Developer/Creator/Zip.php';
//include 'C:/development/PEAR2/Pyrus_Developer/Creator/Tar.php';
//include 'C:/development/PEAR2/Pyrus_Developer/Creator/Xml.php';
//include 'C:/development/PEAR2/Pyrus_Developer/Creator/Exception.php';
//$a = new PEAR2_Pyrus_Package_Creator(array(
//        new PEAR2_Pyrus_Developer_Creator_Zip('C:/development/PEAR2/blah.zip'),
//        new PEAR2_Pyrus_Developer_Creator_Tar('C:/development/PEAR2/blah.tgz'),
//        new PEAR2_Pyrus_Developer_Creator_Xml('C:/development/PEAR2/blah.xml'),
//    ), $a, 'C:/development/PEAR2/Autoload/Autoload.php', $b);
//$b = new PEAR2_Pyrus_Package('C:/development/pear-core/PEAR-1.6.0.tgz');
//$a->render($b);
//exit;
//$pf = new PEAR2_Pyrus_PackageFile_v2;
//$pf->name = 'test';
//$pf->channel = 'pear.php.net';
//$pf->summary = 'test';
//$pf->description = 'testing';
//$pf->maintainer['cellog']->name('Greg Beaver')->role('lead')->email('cellog@php.net')
//    ->active('yes');
//$a = new DateTime();
//$pf->date = $a->format('Y-m-d');
//$pf->version['release'] = '1.0.0';
//$pf->version['api'] = '1.0.0';
//$pf->stability['release'] = 'stable';
//$pf->stability['api'] = 'stable';
//$pf->license = 'PHP License';
//$pf->notes = 'test';
//$pf->dependencies->required->php = array('min' => '5.2.0');
//$pf->dependencies->required->pearinstaller = array('min' => '5.2.0', 'exclude' => '1.2.3');
//$pf->files['test/me.php'] = array('attribs' => array('role' => 'php'));
//$pf = new PEAR2_Pyrus_package(dirname(__FILE__) . '/test.xml');
//foreach ($pf->packagingcontents as $name => $file) {
//    var_dump($name, $file);
//}
//exit;
define('OS_WINDOWS', true);
define('OS_UNIX', false);
$g = PEAR2_Pyrus_Config::singleton('C:/development/pear-core/testpear');
//$g = new PEAR2_Pyrus_Config('/home/cellog/testpear');
try {
    PEAR2_Pyrus_Installer::$options['force'] = true;
    PEAR2_Pyrus_Installer::begin();
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/Autoload/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/Exception/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/MultiErrors/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/Pyrus_Developer/package.xml'));
//    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/Pyrus/trunk/pyrus.phar'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/Pyrus/trunk/package.xml'));
    PEAR2_Pyrus_Installer::commit();
} catch (Exception $e) {
    PEAR2_Pyrus_Installer::rollback();
    echo $e;
}
exit;
<?php
/**
 * PEAR2_Pyrus_Uninstaller
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Pyrus Uninstaller class
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Uninstaller
{
    /**
     * Flag that determines the behavior of {@link begin()}
     *
     * If true, begin() will do nothing.  If false, then
     * {@link self::$installPackages} will be reset to an empty array
     * @var bool
     */
    protected static $inTransaction = false;
    /**
     * Packages that will be uninstalled
     *
     * This list is used when {@link commit()} is called to determine
     * the packages to install
     * @var array
     */
    protected static $uninstallPackages = array();

    /**
     * Packages that were uninstalled
     *
     * This list is used when {@link rollback()} is called to determine
     * the packages that should be restored
     * @var array
     */
    protected static $uninstalledPackages = array();

    /**
     * Packages that have been installed and also successfully registered as uninstalled
     *
     * This list is used when {@link rollback()} is called to determine
     * the packages that should be removed from the registry
     * @var array
     */
    protected static $registeredPackages = array();

    /**
     * Packages that were restored during uninstallation
     *
     * This list is used when {@link rollback()} is called to restore state
     * the packages to install
     * @var array
     */
    protected static $restoredPackages = array();

    /**
     * Installer options.  Valid indices are:
     *
     * - ignore_errors
     * @var array
     */
    public static $options = array();
    static protected $transact;
    /**
     * Prepare uninstallation of packages
     */
    static function begin()
    {
        if (!self::$inTransaction) {
            self::$transact = new PEAR2_Pyrus_FileTransactions;
            self::$transact->registerTransaction('rmdir', new PEAR2_Pyrus_FileTransactions_Rmdir);
            self::$transact->registerTransaction('rename', new PEAR2_Pyrus_FileTransactions_Rename);
            self::$uninstallPackages = array();
            self::$uninstalledPackages = array();
            self::$restoredPackages = array();
            self::$inTransaction = true;
        }
    }

    /**
     * Add a package to the list of packages to be removed
     *
     * This function checks to see if an identical package is already being downloaded,
     * and manages removing duplicates or erroring out on a conflict
     * @param PEAR2_Pyrus_Package $package
     */
    static function prepare($packageName)
    {
        try {
            $package = PEAR2_Pyrus_Config::current()->registry->package[$packageName];
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Uninstaller_Exception('Invalid package name ' .
                                                        $packageName, $e);
        }
        if (isset(self::$uninstallPackages[$package->channel . '/' . $package->name])) {
            return;
        }
        self::$uninstallPackages[$package->channel . '/' . $package->name] = $package;
        return $package->toPackageFile($package->name, $package->channel);
    }

    /**
     * Download and prepare all dependencies
     *
     * @param PEAR2_Pyrus_Package $package
     */
    static function prepareDependencies(PEAR2_Pyrus_Package $package)
    {
        foreach ($package->dependencies->required->package as $dep) {
            if (isset($dep['conflicts'])) {
                continue;
            }
            self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package, false, true));
        }
        foreach ($package->dependencies->required->subpackage as $dep) {
            if (isset($dep['conflicts'])) {
                continue;
            }
            self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package, true, true));
        }
        if ($package->requestedGroup) {
            foreach ($package->dependencies->group[$package->requestedGroup]->package as $dep) {
                self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package));
            }
            foreach ($package->dependencies->group[$package->requestedGroup]->subpackage as $dep) {
                self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package, true));
            }
        }
        if (!isset(self::$options['optionaldeps'])) {
            return;
        }
        foreach ($package->dependencies->optional->package as $dep) {
            self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package));
        }
        foreach ($package->dependencies->optional->subpackage as $dep) {
            self::prepare(new PEAR2_Pyrus_Package_Dependency($dep, $package, true));
        }
    }

    /**
     * Cancel installation
     */
    static function rollback()
    {
        if (self::$inTransaction) {
            self::$inTransaction = false;
            self::$transact->rollback();
            $reg = PEAR2_Pyrus_Config::current()->registry;
            $err = new PEAR2_MultiErrors;
            foreach (self::$registeredPackages as $package) {
                try {
                    $reg->uninstall($package[0]->name, $package[0]->channel);
                    if ($package[1]) {
                        $reg->install($package[1]);
                    }
                } catch (Exception $e) {
                    $err->E_ERROR[] = $e;
                }
            }
            foreach (self::$restoredPackages as $package) {
                try {
                    $reg->uninstall($package->name, $package->channel);
                } catch (Exception $e) {
                    $err->E_ERROR[] = $e;
                }
                try {
                    $reg->install($package->getPackageFile()->info);
                } catch (Exception $e) {
                    $err->E_ERROR[] = $e;
                }
            }
            self::$uninstallPackages = array();
            self::$uninstalledPackages = array();
            self::$registeredPackages = array();
            self::$restoredPackages = array();
            if (count($err)) {
                throw new PEAR2_Pyrus_Installer_Exception('Could not successfully rollback', $err);
            }
        }
    }

    /**
     * Install packages slated for installation during transaction
     */
    static function commit()
    {
        if (!self::$inTransaction) {
            return false;
        }
        try {
            $installer = new PEAR2_Pyrus_Uninstaller;
            // validate dependencies
            $errs = new PEAR2_MultiErrors;
            foreach (self::$uninstallPackages as $package) {
                $package->validateUninstallDependencies(self::$uninstallPackages, $errs);
            }
            if (count($errs->E_ERROR)) {
                throw new PEAR2_Pyrus_Installer_Exception('Dependency validation failed ' .
                    'for some installed packages, installation aborted', $errs);
            }
            // create dependency connections and load them into the directed graph
            $graph = new PEAR2_Pyrus_DirectedGraph;
            foreach (self::$uninstallPackages as $package) {
                $package->makeUninstallConnections($graph, self::$uninstallPackages);
            }
            // topologically sort packages and install them via iterating over the graph
            self::$transact->begin();
            $actual = array();
            foreach ($graph as $package) {
                $actual[] = $package;
            }
            // easy reverse topological sort
            array_reverse($actual);
            foreach ($actual as $package) {
                $installer->uninstall($package);
                self::$uninstalledPackages[] = $package;
            }
            self::$transact->commit();
            self::$transact->begin();
            foreach ($actual as $package) {
                // remove empty directories
                $installer->cleanup($package);
            }
            self::$transact->commit();
            $reg = PEAR2_Pyrus_Config::current()->registry;
            foreach (self::$uninstalledPackages as $package) {
                $previous = $reg->toPackageFile($package->name, $package->channel, true);
                self::$registeredPackages[] = array($package, $previous);
                $reg->uninstall($package->name, $package->channel);
            }
            self::$uninstallPackages = array();
            PEAR2_Pyrus_Config::current()->saveConfig();
        } catch (Exception $e) {
            self::rollback();
            throw $e;
        }
    }

    /**
     * Uninstall a package
     *
     * Using PEAR2_Pyrus_FileTransactions and the woPEAR2_Pyrus_PEAR2_Installer_Role* to
     * group files in appropriate locations, the install() method then passes
     * on the registration of installation to PEAR2_Pyrus_Registry.  If necessary,
     * PEAR2_Pyrus_Config will update the install-time snapshots of configuration
     * @param PEAR2_Pyrus_Package $package
     */
    function uninstall(PEAR2_Pyrus_IRegistry $package)
    {
        if (!empty($this->_options['register-only'])) {
            // pretty much nothing happens if we are only registering the install
            return;
        }
        foreach ($package->installedfiles as $file) {
            self::$transact->backup($file);
            self::$transact->delete($file);
        }
    }

    function cleanup(PEAR2_Pyrus_IRegistry $package)
    {
        if ($dirtree = $package->dirtree) {
            // attempt to delete empty directories
            uksort($dirtree, 'strnatcmp');
            array_reverse($dirtree);
            foreach($dirtree as $dir => $notused) {
                self::$transact->rmdir($dir);
            }
        }
    }
}
<?php
/**
 * PEAR2_Pyrus_Validate
 *
 * PHP version 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Validation class for package.xml - channel-level advanced validation
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Validate
{
/**#@+
 * Constants for install stage
 */
    const INSTALLING = 1;
    const UNINSTALLING = 2; // this is not bit-mapped like the others
    const NORMAL = 3;
    const DOWNLOADING = 4; // this is not bit-mapped like the others
    const PACKAGING = 7;
/**#@-*/
    var $packageregex = '[A-Za-z][a-zA-Z0-9_]+';
    /**
     * @var PEAR_PackageFile_v1|PEAR_PackageFile_v2
     */
    var $_packagexml;
    /**
     * @var int one of the PEAR2_Pyrus_Validate::* constants
     */
    var $_state = PEAR2_Pyrus_Validate::NORMAL;
    /**
     * Format: ('error' => array('field' => name, 'reason' => reason), 'warning' => same)
     * @var array
     * @access private
     */
    var $_failures = array('error' => array(), 'warning' => array());

    /**
     * Override this method to handle validation of normal package names
     * @param string
     * @return bool
     * @access protected
     */
    protected function _validPackageName($name)
    {
        return (bool) preg_match('/^' . $this->packageregex . '$/', $name);
    }

    /**
     * @param string package name to validate
     * @param string name of channel-specific validation package
     * @final
     */
    final function validPackageName($name, $validatepackagename = false)
    {
        if ($validatepackagename) {
            if (strtolower($name) == strtolower($validatepackagename)) {
                return (bool) preg_match('/^[a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)*$/', $name);
            }
        }
        return $this->_validPackageName($name);
    }

    /**
     * This validates a bundle name, and bundle names must conform
     * to the PEAR naming convention, so the method is final and static.
     * @param string
     * @final
     * @static
     */
    static final function validGroupName($name)
    {
        return (bool) preg_match('/^[A-Za-z][a-zA-Z0-9_]+$/', $name);
    }

    /**
     * Determine whether $state represents a valid stability level
     * @param string
     * @return bool
     * @static
     * @final
     */
    static final function validState($state)
    {
        return in_array($state, array('snapshot', 'devel', 'alpha', 'beta', 'stable'));
    }

    /**
     * Get a list of valid stability levels
     * @return array
     * @static
     * @final
     */
    static final function getValidStates()
    {
        return array('snapshot', 'devel', 'alpha', 'beta', 'stable');
    }

    /**
     * Determine whether a version is a properly formatted version number that can be used
     * by version_compare
     * @param string
     * @return bool
     * @static
     * @final
     */
    static final function validVersion($ver)
    {
        return (bool) preg_match('/^\d+(?:\.\d+)*(?:[a-zA-Z]+\d*)?$/', $ver);
    }

    /**
     * @param PEAR_PackageFile_v1|PEAR_PackageFile_v2
     */
    function setPackageFile($pf)
    {
        $this->_packagexml = $pf;
    }

    /**
     * @access private
     */
    function _addFailure($field, $reason)
    {
        $this->_failures->E_ERROR[] =
            new PEAR2_Pyrus_Validate_Exception($reason, $field);
    }

    /**
     * @access private
     */
    private function _addWarning($field, $reason)
    {
        $this->_failures->E_WARNING[] =
            new PEAR2_Pyrus_Validate_Exception($reason, $field);
    }

    function getFailures()
    {
        return $this->_failures;
    }

    /**
     * @param int one of the PEAR2_Pyrus_Validate::* constants
     */
    function validate($state = null)
    {
        if (!isset($this->_packagexml)) {
            return false;
        }
        if ($state !== null) {
            $this->_state = $state;
        }
        $this->_failures = new PEAR2_MultiErrors;
        $this->validatePackageName();
        $this->validateVersion();
        $this->validateMaintainers();
        $this->validateDate();
        $this->validateSummary();
        $this->validateDescription();
        $this->validateLicense();
        $this->validateNotes();
        $this->validateTime();
        $this->validateStability();
        $this->validateDependencies();
        $this->validateMainFilelist();
        $this->validateReleaseFilelist();
        //$this->validateGlobalTasks();
        $this->validateChangelog();
        return !((bool) count($this->_failures->E_ERROR));
    }

    /**
     * @access protected
     */
    function validatePackageName()
    {
        if ($this->_state == PEAR2_Pyrus_Validate::PACKAGING ||
              $this->_state == PEAR2_Pyrus_Validate::NORMAL) {
            if ($this->_packagexml->extends) {
                $version = $this->_packagexml->version['release'] . '';
                $name = $this->_packagexml->name;
                $test = array_shift($a = explode('.', $version));
                if ($test == '0') {
                    return true;
                }
                $vlen = strlen($test);
                $majver = substr($name, strlen($name) - $vlen);
                while ($majver && !is_numeric($majver{0})) {
                    $majver = substr($majver, 1);
                }
                if ($majver != $test) {
                    $this->_addWarning('package', "package $name extends package " .
                        $this->_packagexml->extends . ' and so the name should ' .
                        'have a postfix equal to the major version like "' .
                        $this->_packagexml->extends . $test . '"');
                    return true;
                } elseif (substr($name, 0, strlen($name) - $vlen) !=
                            $this->_packagexml->extends) {
                    $this->_addWarning('package', "package $name extends package " .
                        $this->_packagexml->extends . ' and so the name must ' .
                        'be an extension like "' . $this->_packagexml->extends .
                        $test . '"');
                    return true;
                }
            }
        }
        if (!$this->validPackageName($this->_packagexml->name)) {
            $this->_addFailure('name', 'package name "' .
                $this->_packagexml->name . '" is invalid');
            return false;
        }
    }

    /**
     * @access protected
     */
    function validateVersion()
    {
        if ($this->_state != PEAR2_Pyrus_Validate::PACKAGING) {
            if (!$this->validVersion($this->_packagexml->version['release'])) {
                $this->_addFailure('version',
                    'Invalid version number "' . $this->_packagexml->version['release'] . '"');
            }
            return false;
        }
        $version = $this->_packagexml->version['release'];
        $versioncomponents = explode('.', $version);
        if (count($versioncomponents) != 3) {
            $this->_addWarning('version',
                'A version number should have 3 decimals (x.y.z)');
            return true;
        }
        $name = $this->_packagexml->name;
        // version must be based upon state
        switch ($this->_packagexml->stability['release']) {
            case 'snapshot' :
                return true;
            case 'devel' :
                if ($versioncomponents[0] . 'a' == '0a') {
                    return true;
                }
                if ($versioncomponents[0] == 0) {
                    $versioncomponents[0] = '0';
                    $this->_addWarning('version',
                        'version "' . $version . '" should be "' .
                        implode('.' ,$versioncomponents) . '"');
                } else {
                    $this->_addWarning('version',
                        'packages with devel stability must be < version 1.0.0');
                }
                return true;
            break;
            case 'alpha' :
            case 'beta' :
                // check for a package that extends a package,
                // like Foo and Foo2
                if ($this->_state == PEAR2_Pyrus_Validate::PACKAGING) {
                    if (substr($versioncomponents[2], 1, 2) == 'rc') {
                        $this->_addFailure('version', 'Release Candidate versions ' .
                            'must have capital RC, not lower-case rc');
                        return false;
                    }
                }
                if (!$this->_packagexml->extends) {
                    if ($versioncomponents[0] == '1') {
                        if ($versioncomponents[2]{0} == '0') {
                            if ($versioncomponents[2] == '0') {
                                // version 1.*.0000
                                $this->_addWarning('version',
                                    'version 1.' . $versioncomponents[1] .
                                        '.0 probably should not be alpha or beta');
                                return true;
                            } elseif (strlen($versioncomponents[2]) > 1) {
                                // version 1.*.0RC1 or 1.*.0beta24 etc.
                                return true;
                            } else {
                                // version 1.*.0
                                $this->_addWarning('version',
                                    'version 1.' . $versioncomponents[1] .
                                        '.0 probably should not be alpha or beta');
                                return true;
                            }
                        } else {
                            $this->_addWarning('version',
                                'bugfix versions (1.3.x where x > 0) probably should ' .
                                'not be alpha or beta');
                            return true;
                        }
                    } elseif ($versioncomponents[0] != '0') {
                        $this->_addWarning('version',
                            'major versions greater than 1 are not allowed for packages ' .
                            'without an <extends> tag or an identical postfix (foo2 v2.0.0)');
                        return true;
                    }
                    if ($versioncomponents[0] . 'a' == '0a') {
                        return true;
                    }
                    if ($versioncomponents[0] == 0) {
                        $versioncomponents[0] = '0';
                        $this->_addWarning('version',
                            'version "' . $version . '" should be "' .
                            implode('.' ,$versioncomponents) . '"');
                    }
                } else {
                    $vlen = strlen($versioncomponents[0] . '');
                    $majver = substr($name, strlen($name) - $vlen);
                    while ($majver && !is_numeric($majver{0})) {
                        $majver = substr($majver, 1);
                    }
                    if (($versioncomponents[0] != 0) && $majver != $versioncomponents[0]) {
                        $this->_addWarning('version', 'first version number "' .
                            $versioncomponents[0] . '" must match the postfix of ' .
                            'package name "' . $name . '" (' .
                            $majver . ')');
                        return true;
                    }
                    if ($versioncomponents[0] == $majver) {
                        if ($versioncomponents[2]{0} == '0') {
                            if ($versioncomponents[2] == '0') {
                                // version 2.*.0000
                                $this->_addWarning('version',
                                    "version $majver." . $versioncomponents[1] .
                                        '.0 probably should not be alpha or beta');
                                return false;
                            } elseif (strlen($versioncomponents[2]) > 1) {
                                // version 2.*.0RC1 or 2.*.0beta24 etc.
                                return true;
                            } else {
                                // version 2.*.0
                                $this->_addWarning('version',
                                    "version $majver." . $versioncomponents[1] .
                                        '.0 cannot be alpha or beta');
                                return true;
                            }
                        } else {
                            $this->_addWarning('version',
                                "bugfix versions ($majver.x.y where y > 0) should " .
                                'not be alpha or beta');
                            return true;
                        }
                    } elseif ($versioncomponents[0] != '0') {
                        $this->_addWarning('version',
                            "only versions 0.x.y and $majver.x.y are allowed for alpha/beta releases");
                        return true;
                    }
                    if ($versioncomponents[0] . 'a' == '0a') {
                        return true;
                    }
                    if ($versioncomponents[0] == 0) {
                        $versioncomponents[0] = '0';
                        $this->_addWarning('version',
                            'version "' . $version . '" should be "' .
                            implode('.' ,$versioncomponents) . '"');
                    }
                }
                return true;
            break;
            case 'stable' :
                if ($versioncomponents[0] == '0') {
                    $this->_addWarning('version', 'versions less than 1.0.0 cannot ' .
                    'be stable');
                    return true;
                }
                if (!is_numeric($versioncomponents[2])) {
                    if (preg_match('/\d+(rc|a|alpha|b|beta)\d*/i',
                          $versioncomponents[2])) {
                        $this->_addWarning('version', 'version "' . $version . '" or any ' .
                            'RC/beta/alpha version cannot be stable');
                        return true;
                    }
                }
                // check for a package that extends a package,
                // like Foo and Foo2
                if ($this->_packagexml->extends) {
                    $vlen = strlen($versioncomponents[0] . '');
                    $majver = substr($name, strlen($name) - $vlen);
                    while ($majver && !is_numeric($majver{0})) {
                        $majver = substr($majver, 1);
                    }
                    if (($versioncomponents[0] != 0) && $majver != $versioncomponents[0]) {
                        $this->_addWarning('version', 'first version number "' .
                            $versioncomponents[0] . '" must match the postfix of ' .
                            'package name "' . $name . '" (' .
                            $majver . ')');
                        return true;
                    }
                } elseif ($versioncomponents[0] > 1) {
                    $this->_addWarning('version', 'major version x in x.y.z may not be greater than ' .
                        '1 for any package that does not have an <extends> tag');
                }
                return true;
            break;
            default :
                return false;
            break;
        }
    }

    /**
     * @access protected
     */
    function validateMaintainers()
    {
        // maintainers can only be truly validated server-side for most channels
        // but allow this customization for those who wish it
        return true;
    }

    /**
     * @access protected
     */
    function validateDate()
    {
        if ($this->_state == PEAR2_Pyrus_Validate::NORMAL ||
              $this->_state == PEAR2_Pyrus_Validate::PACKAGING) {

            if (!preg_match('/(\d\d\d\d)\-(\d\d)\-(\d\d)/',
                  $this->_packagexml->date, $res) ||
                  count($res) < 4
                  || !checkdate($res[2], $res[3], $res[1])
                ) {
                $this->_addFailure('date', 'invalid release date "' .
                    $this->_packagexml->date . '"');
                return false;
            }


            if ($this->_state == PEAR2_Pyrus_Validate::PACKAGING &&
                  $this->_packagexml->date != date('Y-m-d')) {
                $this->_addWarning('date', 'Release Date "' .
                    $this->_packagexml->date . '" is not today');
            }
        }
        return true;
    }

    /**
     * @access protected
     */
    function validateTime()
    {
        if (!$this->_packagexml->time) {
            // default of no time value set
            return true;
        }
        // packager automatically sets time, so only validate if
        // pear validate is called
        if ($this->_state = PEAR2_Pyrus_Validate::NORMAL) {
            if (!preg_match('/\d\d:\d\d:\d\d/',
                  $this->_packagexml->time)) {
                $this->_addFailure('time', 'invalid release time "' .
                    $this->_packagexml->time . '"');
                return false;
            }
            if (strtotime($this->_packagexml->time) == -1) {
                $this->_addFailure('time', 'invalid release time "' .
                    $this->_packagexml->time . '"');
                return false;
            }
        }
        return true;
    }

    /**
     * @access protected
     */
    function validateStability()
    {
        $ret = true;
        $packagestability = $this->_packagexml->stability['release'];
        $apistability = $this->_packagexml->stability['api'];
        if (!self::validState($packagestability)) {
            $this->_addFailure('state', 'invalid release stability "' .
                $this->_packagexml->stability['release'] . '", must be one of: ' .
                implode(', ', self::getValidStates()));
            $ret = false;
        }
        $apistates = self::getValidStates();
        array_shift($apistates); // snapshot is not allowed
        if (!in_array($apistability, $apistates)) {
            $this->_addFailure('state', 'invalid API stability "' .
                $this->_packagexml->stability['api'] . '", must be one of: ' .
                implode(', ', $apistates));
            $ret = false;
        }
        return $ret;
    }

    /**
     * @access protected
     */
    function validateSummary()
    {
        return true;
    }

    /**
     * @access protected
     */
    function validateDescription()
    {
        return true;
    }

    /**
     * @access protected
     */
    function validateLicense()
    {
        return true;
    }

    /**
     * @access protected
     */
    function validateNotes()
    {
        return true;
    }

    /**
     * for package.xml 2.0 only - channels can't use package.xml 1.0
     * @access protected
     */
    function validateDependencies()
    {
        return true;
    }

    /**
     * for package.xml 2.0 only
     * @access protected
     */
    function validateMainFilelist()
    {
        return true; // placeholder for now
    }

    /**
     * for package.xml 2.0 only
     * @access protected
     */
    function validateReleaseFilelist()
    {
        return true; // placeholder for now
    }

    /**
     * @access protected
     */
    function validateChangelog()
    {
        return true;
    }
}
?>
<?php
/**
 * PEAR2_Pyrus_Validate_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Validate
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Validate_Exception extends PEAR2_Exception
{
    /**
     * package.xml field that failed channel-specific validation
     *
     * @var string
     */
    public $field;
    /**
     * The reason that validation failed
     *
     * @var string
     */
    public $reason;
    /**
     * Set up message/field combination for package.xml validation
     *
     * @param string $msg
     * @param string $field
     */
    public function __construct($msg, $field)
    {
        $this->reason = $msg;
        $msg = 'Channel validator error: field "' . $field . '" - "' .
                    $msg;
        parent::__construct($msg);
        $this->field = $field;
    }
}<?php
/**
 * Channel Validator for the pecl.php.net channel
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Channel Validator for the pecl.php.net channel
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Validator_PECL extends PEAR2_Pyrus_Validate
{
    function validateVersion()
    {
        if ($this->_state == PEAR2_Pyrus_Validate::PACKAGING) {
            $version = $this->_packagexml->getVersion();
            $versioncomponents = explode('.', $version);
            $last = array_pop($versioncomponents);
            if (substr($last, 1, 2) == 'rc') {
                $this->_addFailure('version', 'Release Candidate versions must have ' .
                'upper-case RC, not lower-case rc');
                return false;
            }
        }
        return true;
    }

    function validatePackageName()
    {
        $ret = parent::validatePackageName();
        if ($this->_packagexml->getPackageType() == 'extsrc' ||
              $this->_packagexml->getPackageType() == 'zendextsrc') {
            if (strtolower($this->_packagexml->getPackage()) !=
                  strtolower($this->_packagexml->getProvidesExtension())) {
                $this->_addWarning('providesextension', 'package name "' .
                    $this->_packagexml->getPackage() . '" is different from extension name "' .
                    $this->_packagexml->getProvidesExtension() . '"');
            }
        }
        return $ret;
    }
}
?><?php
/**
 * Process an XML file, convert it to an array
 * @package PEAR2
 * @subpackage XML
 */
class PEAR2_Pyrus_XMLParser
{
    protected $reader;
    function __construct()
    {
        $this->reader = new XMLReader;
    }

    function parseString($string, $schema = false)
    {
        $this->reader->XML($string);
        return $this->_parse($string, $schema, false);
    }

    /**
     * Using XMLReader, unserialize XML into an array
     *
     * This unserializer has limitations on the XML it can parse, for simplicity:
     *
     *  - Only a single text node (the last one) will be processed, so this code:
     *    <pre>
     *     <?xml version="1.0" ?><test>hi<tag/>there</test>
     *    </pre>
     *    results in <code>array('test' => array('tag' => '', '_content' => 'there'))</code>
     *  - tag ordering is not preserved in all cases:
     *    <pre>
     *     <?xml version="1.0" ?><test><tag /><another /> <tag /></test>
     *    </pre>
     *    results in
     *    <code>array('test' => array('tag' => array('', ''), 'another' => ''))</code>
     * @param string $file file URI to process
     * @return array
     */
    function parse($file, $schema = false)
    {
        if (!$this->reader->open($file)) {
            throw new PEAR2_Pyrus_XMLParser_Exception('Cannot open ' . $file .
                ' for parsing');
        }
        return $this->_parse($file, $schema, true);
    }

    protected function mergeTag($arr, $tag, $attr, $name, $depth)
    {
        if ($attr) {
            // tag has attributes
            if (is_string($tag) && $tag !== '') {
                $tag = array('attribs' => $attr, '_content' => $tag);
            } else {
                if (!is_array($tag)) {
                    $tag = array();
                }
                $tag['attribs'] = $attr;
            }
        }
        if (is_array($arr) && isset($arr[$name]) && is_array($arr[$name]) &&
              isset($arr[$name][0])) {
            // tag exists as a sibling
            $where = count($arr[$name]);
            if (!isset($arr[$name][$where])) {
                $arr[$name][$where] = $tag;
                return $arr;
            }
            if (!is_array($arr[$name][$where])) {
                if (strlen($arr[$name][$where])) {
                    $arr[$name][$where] = array('_content' => $arr[$name][$where]);
                } else {
                    $arr[$name][$where] = array();
                }
            }
            $arr[$name][$where] = $tag;
        } else {
            if (!is_array($arr)) {
                $arr = array();
            }
            if (isset($arr[$name])) {
                // new sibling
                $arr[$name] = array($arr[$name], $tag);
                return $arr;
            }
            $arr[$name] = $tag;
        }
        return $arr;
    }

    protected function mergeValue($arr, $value)
    {
        if (is_array($arr) && isset($arr[0])) {
            // multiple siblings
            $arr[count($arr) - 1] = $this->mergeActualValue(
                $arr[count($arr) - 1], $value);
        } elseif (is_array($arr)) {
            $arr = $this->mergeActualValue($arr, $value);
        } else {
            $arr = $value;
        }
        return $arr;
    }

    protected function mergeActualValue($me, $value)
    {
        if (count($me)) {
            $me['_content'] = $value;
        } else {
            $me = $value;
        }
        return $me;
    }

    private function _parse($file, $schema, $isfile)
    {
        $arr = $this->_recursiveParse();
        $this->reader->close();
        if ($schema) {
            $a = new DOMDocument();
            if ($isfile) {
                $a->load($file);
            } else {
                $a->loadXML($file);
            }
            /*
             from Rob Richards talk, use
             $a->setSchema($schema);
             and then check $a->isValid() in the _recursiveParse() and
             log errors - much more efficient
            */
            libxml_use_internal_errors(true);
            libxml_clear_errors();
            $a->schemaValidate($schema);
            $causes = array();
            foreach (libxml_get_errors() as $error) {
                $causes[] = new PEAR2_Pyrus_XMLParser_Exception("Line " .
                     $error->line . ': ' . $error->message);
            }
            libxml_clear_errors();
            if (count($causes)) {
                throw new PEAR2_Pyrus_XMLParser_Exception('Invalid XML document', $causes);
            }
        }

        return $arr;
    }

    private function _recursiveParse($arr = array())
    {
        while ($this->reader->read()) {
            $depth = $this->reader->depth;
            if ($this->reader->nodeType == XMLReader::ELEMENT) {
                $tag = $this->reader->name;

                $attrs = array();
                if ($this->reader->isEmptyElement) {
                    if ($this->reader->hasAttributes) {
                        $attr = $this->reader->moveToFirstAttribute();
                        while ($attr) {
                            $attrs[$this->reader->name] = $this->reader->value;
                            $attr = $this->reader->moveToNextAttribute();
                        }
                        $depth = $this->reader->depth;
                        $arr = $this->mergeTag($arr, '', $attrs, $tag, $depth);
                        continue;
                    }
                    $depth = $this->reader->depth;
                    $arr = $this->mergeTag($arr, '', array(), $tag, $depth);
                    continue;
                }
                if ($this->reader->hasAttributes) {
                    $attr = $this->reader->moveToFirstAttribute();
                    while ($attr) {
                        $attrs[$this->reader->name] = $this->reader->value;
                        $attr = $this->reader->moveToNextAttribute();
                    }
                }
                $depth = $this->reader->depth;
                $arr = $this->mergeTag($arr, '', $attrs, $tag, $depth);
                if (is_array($arr[$tag]) && isset($arr[$tag][0])) {
                    // seek to last sibling
                    $arr[$tag][count($arr[$tag]) - 1] =
                        $this->_recursiveParse($arr[$tag][count($arr[$tag]) - 1]);
                } else {
                    $arr[$tag] = $this->_recursiveParse($arr[$tag]);
                }
                continue;
            }
            if ($this->reader->nodeType == XMLReader::END_ELEMENT) {
                return $arr;
            }
            if ($this->reader->nodeType == XMLReader::TEXT ||
                  $this->reader->nodeType == XMLReader::CDATA) {
                $arr = $this->mergeValue($arr, $this->reader->value);
            }
        }
        return $arr;
    }
}
<?php
/**
 * PEAR2_Pyrus_XMLParser_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for the XMLParser
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_XMLParser_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_XMLWriter
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Process an array, and serialize it into XML
 *
 * @category   PEAR2
 * @package    PEAR2_Pyrus
 * @subpackage XML
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  2008 The PEAR Group
 * @license    http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link       http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_XMLWriter
{
    private $_array;
    private $_state;
    /**
     * @var XMLWriter
     */
    private $_writer;
    private $_iter;
    private $_tagStack;
    private $_namespaces;
    private $_tag;
    private $_expectedDepth;
    private $_type;
    private $_lastkey;
    
    /**
     * Construct a new xml writer object.
     * <code>
     * $xmlarray = array('channel'=>array('name'=>'pear2.php.net'));
     * $channel = new PEAR2_Pyrus_XMLWriter($xmlarray);
     * </code>
     * 
     * @param array $array Array representing the XML data.
     */
    function __construct(array $array)
    {
        if (count($array) != 1) {
            throw new PEAR2_Pyrus_XMLWriter_Exception('Cannot serialize array to' .
                'XML, array must have exactly 1 element');
        }
        $this->_array  = $array;
        $this->_writer = new XMLWriter;
    }

    /**
     * Return the raw xml string representation.
     * 
     * @return string
     */
    function __toString()
    {
        $this->_writer->openMemory();
        return $this->_serialize();
    }

    function toFile($file)
    {
        $this->_writer->openUri($file);
        return $this->_serialize();
    }

    private function _pushState()
    {
        $this->_state[] = array($this->_type, $this->_tag, $this->_expectedDepth,
            $this->_namespaces);
    }

    private function _popState()
    {
        $save = $this->_namespaces;
        
        list($this->_type, $this->_tag, $this->_expectedDepth, $this->_namespaces) =
            array_pop($this->_state);
        foreach ($save as $ns) {
            if (!isset($this->_namespaces[$ns])) {
                // all namespaces must exist - only overriding is allowed
                $this->_namespaces = $save;
                return;
            }
        }
    }

    private function _finish($key, $values)
    {
        switch ($this->_type) {
        case 'Attribs' :
                $this->_popState();
                return false;
        case 'Tag' :
                $this->_popState();
                $this->_writer->endElement();
                return false;
        case 'Sibling' :
                $this->_popState();
                return false;
        }
    }

    private function _startElement($key, $values)
    {
        // new element
        if (strpos($key, ':')) {
            // namespaced element
            list($ns, $element) = explode(':', $key);
        }
        if (isset($element) && !isset($this->_namespaces[$ns])) {
            if (is_string($values)) {
                if (strlen($values)) {
                    $this->_writer->writeElementNs($ns, $element, $this->_namespaces[$ns], $values);
                } else {
                    $this->_writer->writeElementNs($ns, $element, $this->_namespaces[$ns]);
                }
            } else {
                $this->_writer->startElementNs($ns, $element, $this->_namespaces[$ns]);
            }
        } else {
            if (is_string($values) || is_int($values)) {
                if (strlen($values)) {
                    $this->_writer->writeElement($key, $values);
                } else {
                    $this->_writer->writeElement($key);
                }
            } else {
                $this->_writer->startElement($key);
            }
        }
    }

    /**
     * Handle an individual tag/element in the XML
     * 
     * @param mixed $key    The key for this element.
     * @param mixed $values The contents of this tag/element.
     */
    private function _handleTag($key, $values)
    {
        if (is_int($key)) {
            $this->_type          = 'Sibling';
            $this->_expectedDepth = $this->_iter->getDepth();
            $this->_pushState();
            // handle sibling tags
            return '_handleSibling';
        }
        $this->_startElement($key, $values);
        if (!is_string($values)) {
            $this->_expectedDepth = $this->_iter->getDepth();
            $this->_pushState();
            $this->_tag = $key;
        }
        // cycle to next key
        return false;
    }

    private function _handleSibling($key, $values)
    {
        if (is_int($key) && $this->_iter->getDepth() == $this->_expectedDepth) {
            if ($key) {
                $this->_startElement($this->_tag, $values);
                if (!is_string($values)) {
                    $this->_pushState();
                }
            } else {
                if (is_string($values)) {
                    $this->_writer->text($values);
                    $this->_writer->endElement();
                }
            }
        }
        if (!is_string($values)) {
            $this->_type          = 'Tag';
            $this->_expectedDepth = $this->_iter->getDepth() + 1;
            // handle internal tags
        }
        // cycle to next key
        return false;
    }

    private function _handleAttribs($key, $values)
    {
        // xmlwriter converts these to &#10; and &#13;.  Bad.
        $values = str_replace(array("\n","\r"), array('', ''), $values);
        if (strpos($key, ':')) {
            // namespaced
            list($ns, $attr) = explode(':', $key);
            if ($ns == 'xmlns' || isset($this->_namespaces[$ns])) {
                if ($ns == 'xmlns') {
                    // new namespace declaration
                    $this->_namespaces[$attr] = $values;
                }
                $this->_writer->writeAttribute($key, $values);
            } else {
                $this->_writer->writeAttributeNS($ns, $attr, $values, $values);
            }
        } else { // default namespace
            $this->_writer->writeAttribute($key, $values);
        }
        // cycle to next key
        return false;
    }

    /**
     * @access private
     * 
     * @return bool
     */
    public static function _filter($a)
    {
        if ($a === false) {
            return false;
        }
        return true;
    }

    /**
     * Utilize custom serialization for XMLWriter object, to convert object
     * to SQL.
     * 
     * @return string
     */
    private function _serialize()
    {
        $this->_writer->setIndent(true);
        $this->_writer->setIndentString(' ');
        $this->_writer->startDocument('1.0', 'UTF-8');
        $this->_namespaces    = array();
        $this->_tagStack      = array();
        $this->_state         = array();
        $this->_type          = 'Tag';
        $this->_expectedDepth = 0;
        $this->_lastkey       = array();
        $lastdepth            = 0;
        foreach ($this->_iter = new RecursiveIteratorIterator(
                        new RecursiveArrayIterator($this->_array),
                        RecursiveIteratorIterator::SELF_FIRST) as $key => $values) {
            $depth = $this->_iter->getDepth();
            while ($depth < $this->_expectedDepth) {
                // finished with this tag
                $this->_finish($key, $values);
                $lastdepth--;
            }
            if (isset($this->_lastkey[$depth]) && $key != $this->_lastkey[$depth]) {
                while ($lastdepth > $depth) {
                    $this->_finish($key, $values);
                    $lastdepth--;
                }
            }
            $this->_lastkey[$depth] = $key;
            foreach ($this->_lastkey as $d => &$k) {
                if ($d > $depth) {
                    $k = false;
                }
            }
            $this->_lastkey = array_filter($this->_lastkey,
                array('PEAR2_Pyrus_XMLWriter', '_filter'));
            $lastdepth = $depth;
            if ($this->_type !== 'Attribs') {
                if ($key === '_content') {
                    $this->_writer->text($values);
                    continue;
                }
                if ($key === 'attribs') {
                    // attributes are 1 depth higher
                    $this->_pushState();
                    $this->_expectedDepth = $this->_iter->getDepth() + 1;
                    $this->_type          = 'Attribs';
                    // cycle to first attribute
                    continue;
                }
            }
            $next = '_handle' . $this->_type;
            while ($next = $this->{$next}($key, $values));
        }
        while ($lastdepth) {
            $this->_finish($key, $values);
            $lastdepth--;
        }
        $this->_writer->endDocument();
        return $this->_writer->flush();
    }
}<?php
/**
 * PEAR2_Pyrus_XMLWriter_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for the XMLWriter
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_XMLWriter_Exception extends PEAR2_Exception {}<?php
// set $dir and include
if (!($dir = realpath($dir))) return;
foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir), RecursiveIteratorIterator::CHILD_FIRST) as $name => $file) {
    if ($file->isDir()) {
        rmdir($file->getPathName());
        continue;
    }
    unlink($file->getPathname());
}
rmdir($dir);
?>
TOTAL TIME: 00:00
0 PASSED TESTS
0 SKIPPED TESTS
1 FAILED TESTS:
/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/test.phpt
<?php
require __DIR__ . '/../setup.php.inc';
$testpath = __DIR__ . '/testit';
mkdir($testpath);
$cdir = $testpath . '/.configsnapshots/';
001- ===DONE===
001+ Test Failure: "1"
002+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/test.php line 14
003+ Diff of expecting/received:
004+ @@ -1 +1 @@
005+ -'configsnapshot-20080529.xml'
006+ +'configsnapshot-20080529.1.xml'
007+ Expecting:
008+ 'configsnapshot-20080529.xml'
009+ Received:
010+ 'configsnapshot-20080529.1.xml'
011+ 
012+ Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/testit/.configsnapshots//configsnapshot-20080529.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/test.php on line 29
013+ Test Failure: "contents 1"
014+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/test.php line 29
015+ Diff of expecting/received:
016+ @@ -1,3 +1 @@
017+ -'<?xml version="1.0"?>
018+ -<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini><foo>hi</foo></pearconfig>
019+ -'
020+ +false
021+ Expecting:
022+ '<?xml version="1.0"?>
023+ <pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini><foo>hi</foo></pearconfig>
024+ '
025+ Received:
026+ false
027+ ===DONE======DONE===
---- EXPECTED OUTPUT
===DONE===
---- ACTUAL OUTPUT
Test Failure: "1"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/test.php line 14
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.xml'
+'configsnapshot-20080529.1.xml'
Expecting:
'configsnapshot-20080529.xml'
Received:
'configsnapshot-20080529.1.xml'

Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/testit/.configsnapshots//configsnapshot-20080529.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/test.php on line 29
Test Failure: "contents 1"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/test.php line 29
Diff of expecting/received:
@@ -1,3 +1 @@
-'<?xml version="1.0"?>
-<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini><foo>hi</foo></pearconfig>
-'
+false
Expecting:
'<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini><foo>hi</foo></pearconfig>
'
Received:
false
===DONE===
---- FAILED
Test Failure: "1"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/test.php line 14
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.xml'
+'configsnapshot-20080529.1.xml'
Expecting:
'configsnapshot-20080529.xml'
Received:
'configsnapshot-20080529.1.xml'

Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/testit/.configsnapshots//configsnapshot-20080529.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/test.php on line 29
Test Failure: "contents 1"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/test.php line 29
Diff of expecting/received:
@@ -1,3 +1 @@
-'<?xml version="1.0"?>
-<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini><foo>hi</foo></pearconfig>
-'
+false
Expecting:
'<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini><foo>hi</foo></pearconfig>
'
Received:
false
===DONE===<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
$a = $configclass::singleton($testpath, $testpath . '/blah');
$a->addConfigValue('foo', 'booya');
$a->addConfigValue('foo2', 'booya2', false);
$test->assertEquals('booya', $a->foo, 'foo');
$test->assertEquals('booya2', $a->foo2, 'foo');
$a->foo = 'hi';
$a->foo2 = 'hi2';
$test->assertEquals('hi', $a->foo, 'foo');
$test->assertEquals('hi2', $a->foo2, 'foo2');
$d = DIRECTORY_SEPARATOR;
$test->assertEquals('configsnapshot-' . date('Ymd') . '.xml', $a->configSnapshot(), 1);

$test->assertEquals('<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>' .
    $a->php_dir . '</php_dir><ext_dir>' .
    $a->ext_dir . '</ext_dir><cfg_dir>' .
    $a->cfg_dir . '</cfg_dir><doc_dir>' .
    $a->doc_dir . '</doc_dir><bin_dir>' .
    $a->bin_dir . '</bin_dir><data_dir>' .
    $a->data_dir . '</data_dir><www_dir>' .
    $a->www_dir . '</www_dir><test_dir>' .
    $a->test_dir . '</test_dir><php_bin>' .
    $a->php_bin . '</php_bin><php_ini>' .
    $a->php_ini . '</php_ini><foo>' .
    $a->foo . '</foo></pearconfig>
', file_get_contents($cdir . '/configsnapshot-' . date('Ymd') . '.xml'), 'contents 1');
?>
===DONE===
--TEST--
PEAR2_Pyrus_Config::addConfigValue()
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
$a = $configclass::singleton($testpath, $testpath . '/blah');
$a->addConfigValue('foo', 'booya');
$a->addConfigValue('foo2', 'booya2', false);
$test->assertEquals('booya', $a->foo, 'foo');
$test->assertEquals('booya2', $a->foo2, 'foo');
$a->foo = 'hi';
$a->foo2 = 'hi2';
$test->assertEquals('hi', $a->foo, 'foo');
$test->assertEquals('hi2', $a->foo2, 'foo2');
$d = DIRECTORY_SEPARATOR;
$test->assertEquals('configsnapshot-' . date('Ymd') . '.xml', $a->configSnapshot(), 1);

$test->assertEquals('<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>' .
    $a->php_dir . '</php_dir><ext_dir>' .
    $a->ext_dir . '</ext_dir><cfg_dir>' .
    $a->cfg_dir . '</cfg_dir><doc_dir>' .
    $a->doc_dir . '</doc_dir><bin_dir>' .
    $a->bin_dir . '</bin_dir><data_dir>' .
    $a->data_dir . '</data_dir><www_dir>' .
    $a->www_dir . '</www_dir><test_dir>' .
    $a->test_dir . '</test_dir><php_bin>' .
    $a->php_bin . '</php_bin><php_ini>' .
    $a->php_ini . '</php_ini><foo>' .
    $a->foo . '</foo></pearconfig>
', file_get_contents($cdir . '/configsnapshot-' . date('Ymd') . '.xml'), 'contents 1');
?>
===DONE===
--CLEAN--
<?php
$dir = __DIR__ . '/testit';
include __DIR__ . '/../../clean.php.inc';
?>
--EXPECT--
===DONE===
<?php
require __DIR__ . '/../setup.php.inc';
$testpath = __DIR__ . '/testit';
mkdir($testpath);
$cdir = $testpath . '/.configsnapshots/';
001- ===DONE===
001+ Test Failure: "1"
002+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 6
003+ Diff of expecting/received:
004+ @@ -1 +1 @@
005+ -'configsnapshot-20080529.xml'
006+ +'configsnapshot-20080528.1.1.1.xml'
007+ Expecting:
008+ 'configsnapshot-20080529.xml'
009+ Received:
010+ 'configsnapshot-20080528.1.1.1.xml'
011+ Test Failure: "2"
012+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 7
013+ Diff of expecting/received:
014+ @@ -1 +1 @@
015+ -'configsnapshot-20080529.xml'
016+ +'configsnapshot-20080528.1.1.1.xml'
017+ Expecting:
018+ 'configsnapshot-20080529.xml'
019+ Received:
020+ 'configsnapshot-20080528.1.1.1.xml'
021+ Test Failure: "3"
022+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 8
023+ Diff of expecting/received:
024+ @@ -1 +1 @@
025+ -'configsnapshot-20080529.xml'
026+ +'configsnapshot-20080528.1.1.1.xml'
027+ Expecting:
028+ 'configsnapshot-20080529.xml'
029+ Received:
030+ 'configsnapshot-20080528.1.1.1.xml'
031+ Test Failure: "4"
032+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 11
033+ Diff of expecting/received:
034+ @@ -1 +1 @@
035+ -'configsnapshot-20080529.1.xml'
036+ +'configsnapshot-20080528.1.xml'
037+ Expecting:
038+ 'configsnapshot-20080529.1.xml'
039+ Received:
040+ 'configsnapshot-20080528.1.xml'
041+ Test Failure: "5"
042+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 12
043+ Diff of expecting/received:
044+ @@ -1 +1 @@
045+ -'configsnapshot-20080529.1.xml'
046+ +'configsnapshot-20080528.1.xml'
047+ Expecting:
048+ 'configsnapshot-20080529.1.xml'
049+ Received:
050+ 'configsnapshot-20080528.1.xml'
051+ Test Failure: "6"
052+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 14
053+ Diff of expecting/received:
054+ @@ -1 +1 @@
055+ -'configsnapshot-20080529.xml'
056+ +'configsnapshot-20080528.1.1.1.xml'
057+ Expecting:
058+ 'configsnapshot-20080529.xml'
059+ Received:
060+ 'configsnapshot-20080528.1.1.1.xml'
061+ Test Failure: "7"
062+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 16
063+ Diff of expecting/received:
064+ @@ -1 +1 @@
065+ -'configsnapshot-20080529.1.1.xml'
066+ +'configsnapshot-20080528.1.1.xml'
067+ Expecting:
068+ 'configsnapshot-20080529.1.1.xml'
069+ Received:
070+ 'configsnapshot-20080528.1.1.xml'
071+ 
072+ Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/testit/.configsnapshots//configsnapshot-20080529.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php on line 30
073+ Test Failure: "contents 1"
074+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 30
075+ Diff of expecting/received:
076+ @@ -1,3 +1 @@
077+ -'<?xml version="1.0"?>
078+ -<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
079+ -'
080+ +false
081+ Expecting:
082+ '<?xml version="1.0"?>
083+ <pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
084+ '
085+ Received:
086+ false
087+ 
088+ Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/testit/.configsnapshots//configsnapshot-20080529.1.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php on line 43
089+ Test Failure: "contents 2"
090+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 43
091+ Diff of expecting/received:
092+ @@ -1,3 +1 @@
093+ -'<?xml version="1.0"?>
094+ -<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>hi</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
095+ -'
096+ +false
097+ Expecting:
098+ '<?xml version="1.0"?>
099+ <pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>hi</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
100+ '
101+ Received:
102+ false
103+ 
104+ Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/testit/.configsnapshots//configsnapshot-20080529.1.1.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php on line 56
105+ Test Failure: "contents 3"
106+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 56
107+ Diff of expecting/received:
108+ @@ -1,3 +1 @@
109+ -'<?xml version="1.0"?>
110+ -<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>another</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
111+ -'
112+ +false
113+ Expecting:
114+ '<?xml version="1.0"?>
115+ <pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>another</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
116+ '
117+ Received:
118+ false
119+ ===DONE======DONE===
---- EXPECTED OUTPUT
===DONE===
---- ACTUAL OUTPUT
Test Failure: "1"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 6
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.xml'
+'configsnapshot-20080528.1.1.1.xml'
Expecting:
'configsnapshot-20080529.xml'
Received:
'configsnapshot-20080528.1.1.1.xml'
Test Failure: "2"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 7
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.xml'
+'configsnapshot-20080528.1.1.1.xml'
Expecting:
'configsnapshot-20080529.xml'
Received:
'configsnapshot-20080528.1.1.1.xml'
Test Failure: "3"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 8
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.xml'
+'configsnapshot-20080528.1.1.1.xml'
Expecting:
'configsnapshot-20080529.xml'
Received:
'configsnapshot-20080528.1.1.1.xml'
Test Failure: "4"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 11
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.1.xml'
+'configsnapshot-20080528.1.xml'
Expecting:
'configsnapshot-20080529.1.xml'
Received:
'configsnapshot-20080528.1.xml'
Test Failure: "5"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 12
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.1.xml'
+'configsnapshot-20080528.1.xml'
Expecting:
'configsnapshot-20080529.1.xml'
Received:
'configsnapshot-20080528.1.xml'
Test Failure: "6"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 14
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.xml'
+'configsnapshot-20080528.1.1.1.xml'
Expecting:
'configsnapshot-20080529.xml'
Received:
'configsnapshot-20080528.1.1.1.xml'
Test Failure: "7"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 16
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.1.1.xml'
+'configsnapshot-20080528.1.1.xml'
Expecting:
'configsnapshot-20080529.1.1.xml'
Received:
'configsnapshot-20080528.1.1.xml'

Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/testit/.configsnapshots//configsnapshot-20080529.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php on line 30
Test Failure: "contents 1"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 30
Diff of expecting/received:
@@ -1,3 +1 @@
-'<?xml version="1.0"?>
-<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
-'
+false
Expecting:
'<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
'
Received:
false

Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/testit/.configsnapshots//configsnapshot-20080529.1.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php on line 43
Test Failure: "contents 2"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 43
Diff of expecting/received:
@@ -1,3 +1 @@
-'<?xml version="1.0"?>
-<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>hi</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
-'
+false
Expecting:
'<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>hi</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
'
Received:
false

Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/testit/.configsnapshots//configsnapshot-20080529.1.1.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php on line 56
Test Failure: "contents 3"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 56
Diff of expecting/received:
@@ -1,3 +1 @@
-'<?xml version="1.0"?>
-<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>another</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
-'
+false
Expecting:
'<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>another</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
'
Received:
false
===DONE===
---- FAILED
Test Failure: "1"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 6
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.xml'
+'configsnapshot-20080528.1.1.1.xml'
Expecting:
'configsnapshot-20080529.xml'
Received:
'configsnapshot-20080528.1.1.1.xml'
Test Failure: "2"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 7
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.xml'
+'configsnapshot-20080528.1.1.1.xml'
Expecting:
'configsnapshot-20080529.xml'
Received:
'configsnapshot-20080528.1.1.1.xml'
Test Failure: "3"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 8
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.xml'
+'configsnapshot-20080528.1.1.1.xml'
Expecting:
'configsnapshot-20080529.xml'
Received:
'configsnapshot-20080528.1.1.1.xml'
Test Failure: "4"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 11
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.1.xml'
+'configsnapshot-20080528.1.xml'
Expecting:
'configsnapshot-20080529.1.xml'
Received:
'configsnapshot-20080528.1.xml'
Test Failure: "5"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 12
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.1.xml'
+'configsnapshot-20080528.1.xml'
Expecting:
'configsnapshot-20080529.1.xml'
Received:
'configsnapshot-20080528.1.xml'
Test Failure: "6"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 14
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.xml'
+'configsnapshot-20080528.1.1.1.xml'
Expecting:
'configsnapshot-20080529.xml'
Received:
'configsnapshot-20080528.1.1.1.xml'
Test Failure: "7"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 16
Diff of expecting/received:
@@ -1 +1 @@
-'configsnapshot-20080529.1.1.xml'
+'configsnapshot-20080528.1.1.xml'
Expecting:
'configsnapshot-20080529.1.1.xml'
Received:
'configsnapshot-20080528.1.1.xml'

Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/testit/.configsnapshots//configsnapshot-20080529.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php on line 30
Test Failure: "contents 1"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 30
Diff of expecting/received:
@@ -1,3 +1 @@
-'<?xml version="1.0"?>
-<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
-'
+false
Expecting:
'<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>/tests</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
'
Received:
false

Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/testit/.configsnapshots//configsnapshot-20080529.1.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php on line 43
Test Failure: "contents 2"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 43
Diff of expecting/received:
@@ -1,3 +1 @@
-'<?xml version="1.0"?>
-<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>hi</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
-'
+false
Expecting:
'<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>hi</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
'
Received:
false

Warning: file_get_contents(/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/testit/.configsnapshots//configsnapshot-20080529.1.1.xml): failed to open stream: No such file or directory in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php on line 56
Test Failure: "contents 3"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.php line 56
Diff of expecting/received:
@@ -1,3 +1 @@
-'<?xml version="1.0"?>
-<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>another</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
-'
+false
Expecting:
'<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>/src</php_dir><ext_dir>/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613</ext_dir><cfg_dir>/cfg</cfg_dir><doc_dir>/docs</doc_dir><bin_dir>/usr/local/php5/bin</bin_dir><data_dir>/data</data_dir><www_dir>/www</www_dir><test_dir>another</test_dir><php_bin></php_bin><php_ini>/usr/local/php5/lib/php.ini</php_ini></pearconfig>
'
Received:
false
===DONE===<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
$a = $configclass::singleton($testpath, $testpath . '/blah');
$d = DIRECTORY_SEPARATOR;
$test->assertEquals('configsnapshot-' . date('Ymd') . '.xml', $a->configSnapshot(), 1);
$test->assertEquals('configsnapshot-' . date('Ymd') . '.xml', $a->configSnapshot(), 2);
$test->assertEquals('configsnapshot-' . date('Ymd') . '.xml', $a->configSnapshot(), 3);
$t = $a->test_dir;
$a->test_dir = 'hi';
$test->assertEquals('configsnapshot-' . date('Ymd') . '.1.xml', $a->configSnapshot(), 4);
$test->assertEquals('configsnapshot-' . date('Ymd') . '.1.xml', $a->configSnapshot(), 5);
$a->test_dir = $t;
$test->assertEquals('configsnapshot-' . date('Ymd') . '.xml', $a->configSnapshot(), 6);
$a->test_dir = 'another';
$test->assertEquals('configsnapshot-' . date('Ymd') . '.1.1.xml', $a->configSnapshot(), 7);

$test->assertEquals('<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>' .
    $a->php_dir . '</php_dir><ext_dir>' .
    $a->ext_dir . '</ext_dir><cfg_dir>' .
    $a->cfg_dir . '</cfg_dir><doc_dir>' .
    $a->doc_dir . '</doc_dir><bin_dir>' .
    $a->bin_dir . '</bin_dir><data_dir>' .
    $a->data_dir . '</data_dir><www_dir>' .
    $a->www_dir . '</www_dir><test_dir>' .
    $t . '</test_dir><php_bin>' .
    $a->php_bin . '</php_bin><php_ini>' .
    $a->php_ini . '</php_ini></pearconfig>
', file_get_contents($cdir . '/configsnapshot-' . date('Ymd') . '.xml'), 'contents 1');
$test->assertEquals('<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>' .
    $a->php_dir . '</php_dir><ext_dir>' .
    $a->ext_dir . '</ext_dir><cfg_dir>' .
    $a->cfg_dir . '</cfg_dir><doc_dir>' .
    $a->doc_dir . '</doc_dir><bin_dir>' .
    $a->bin_dir . '</bin_dir><data_dir>' .
    $a->data_dir . '</data_dir><www_dir>' .
    $a->www_dir . '</www_dir><test_dir>' .
    'hi</test_dir><php_bin>' .
    $a->php_bin . '</php_bin><php_ini>' .
    $a->php_ini . '</php_ini></pearconfig>
', file_get_contents($cdir . '/configsnapshot-' . date('Ymd') . '.1.xml'), 'contents 2');
$test->assertEquals('<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>' .
    $a->php_dir . '</php_dir><ext_dir>' .
    $a->ext_dir . '</ext_dir><cfg_dir>' .
    $a->cfg_dir . '</cfg_dir><doc_dir>' .
    $a->doc_dir . '</doc_dir><bin_dir>' .
    $a->bin_dir . '</bin_dir><data_dir>' .
    $a->data_dir . '</data_dir><www_dir>' .
    $a->www_dir . '</www_dir><test_dir>' .
    'another</test_dir><php_bin>' .
    $a->php_bin . '</php_bin><php_ini>' .
    $a->php_ini . '</php_ini></pearconfig>
', file_get_contents($cdir . '/configsnapshot-' . date('Ymd') . '.1.1.xml'), 'contents 3');
?>
===DONE===
--TEST--
PEAR2_Pyrus_Config::configSnapshot()
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
$a = $configclass::singleton($testpath, $testpath . '/blah');
$d = DIRECTORY_SEPARATOR;
$test->assertEquals('configsnapshot-' . date('Ymd') . '.xml', $a->configSnapshot(), 1);
$test->assertEquals('configsnapshot-' . date('Ymd') . '.xml', $a->configSnapshot(), 2);
$test->assertEquals('configsnapshot-' . date('Ymd') . '.xml', $a->configSnapshot(), 3);
$t = $a->test_dir;
$a->test_dir = 'hi';
$test->assertEquals('configsnapshot-' . date('Ymd') . '.1.xml', $a->configSnapshot(), 4);
$test->assertEquals('configsnapshot-' . date('Ymd') . '.1.xml', $a->configSnapshot(), 5);
$a->test_dir = $t;
$test->assertEquals('configsnapshot-' . date('Ymd') . '.xml', $a->configSnapshot(), 6);
$a->test_dir = 'another';
$test->assertEquals('configsnapshot-' . date('Ymd') . '.1.1.xml', $a->configSnapshot(), 7);

$test->assertEquals('<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>' .
    $a->php_dir . '</php_dir><ext_dir>' .
    $a->ext_dir . '</ext_dir><cfg_dir>' .
    $a->cfg_dir . '</cfg_dir><doc_dir>' .
    $a->doc_dir . '</doc_dir><bin_dir>' .
    $a->bin_dir . '</bin_dir><data_dir>' .
    $a->data_dir . '</data_dir><www_dir>' .
    $a->www_dir . '</www_dir><test_dir>' .
    $t . '</test_dir><php_bin>' .
    $a->php_bin . '</php_bin><php_ini>' .
    $a->php_ini . '</php_ini></pearconfig>
', file_get_contents($cdir . '/configsnapshot-' . date('Ymd') . '.xml'), 'contents 1');
$test->assertEquals('<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>' .
    $a->php_dir . '</php_dir><ext_dir>' .
    $a->ext_dir . '</ext_dir><cfg_dir>' .
    $a->cfg_dir . '</cfg_dir><doc_dir>' .
    $a->doc_dir . '</doc_dir><bin_dir>' .
    $a->bin_dir . '</bin_dir><data_dir>' .
    $a->data_dir . '</data_dir><www_dir>' .
    $a->www_dir . '</www_dir><test_dir>' .
    'hi</test_dir><php_bin>' .
    $a->php_bin . '</php_bin><php_ini>' .
    $a->php_ini . '</php_ini></pearconfig>
', file_get_contents($cdir . '/configsnapshot-' . date('Ymd') . '.1.xml'), 'contents 2');
$test->assertEquals('<?xml version="1.0"?>
<pearconfig version="1.0"><php_dir>' .
    $a->php_dir . '</php_dir><ext_dir>' .
    $a->ext_dir . '</ext_dir><cfg_dir>' .
    $a->cfg_dir . '</cfg_dir><doc_dir>' .
    $a->doc_dir . '</doc_dir><bin_dir>' .
    $a->bin_dir . '</bin_dir><data_dir>' .
    $a->data_dir . '</data_dir><www_dir>' .
    $a->www_dir . '</www_dir><test_dir>' .
    'another</test_dir><php_bin>' .
    $a->php_bin . '</php_bin><php_ini>' .
    $a->php_ini . '</php_ini></pearconfig>
', file_get_contents($cdir . '/configsnapshot-' . date('Ymd') . '.1.1.xml'), 'contents 3');
?>
===DONE===
--CLEAN--
<?php
$dir = __DIR__ . '/testit';
include __DIR__ . '/../../clean.php.inc';
?>
--EXPECT--
===DONE===
--TEST--
PEAR2_Pyrus_Config::constructDefaults() basic test
--INI--
extension_dir=
--ENV--
PATH=.
PHP_PEAR_BIN_DIR=
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$test->assertEquals(array(
            'php_dir' => '@php_dir@/src', // pseudo-value in this implementation
            'ext_dir' => '@php_dir@/ext_dir',
            'doc_dir' => '@php_dir@/docs',
            'bin_dir' => PHP_BINDIR,
            'data_dir' => '@php_dir@/data', // pseudo-value in this implementation
            'cfg_dir' => '@php_dir@/cfg',
            'www_dir' => '@php_dir@/www',
            'test_dir' => '@php_dir@/tests',
            'php_bin' => '',
            'php_ini' => '',
            'default_channel' => 'pear2.php.net',
            'preferred_mirror' => 'pear2.php.net',
            'auto_discover' => 0,
            'http_proxy' => '',
            'cache_dir' => '@php_dir@/cache',
            'temp_dir' => '@php_dir@/temp',
            'download_dir' => '@php_dir@/downloads',
            'username' => '',
            'password' => '',
            'verbose' => 1,
            'preferred_state' => 'stable',
            'umask' => '0644',
            'cache_ttl' => 3600,
            'sig_type' => '',
            'sig_bin' => '',
            'sig_keyid' => '',
            'sig_keydir' => '',
            'my_pear_path' => '@php_dir@',
        ), tc::getTestDefaults(), 'before init');
tc::constructDefaults();
$test->assertEquals(array(
            'php_dir' => '@php_dir@' . DIRECTORY_SEPARATOR . 'src',
            'ext_dir' => PEAR_EXTENSION_DIR,
            'doc_dir' => '@php_dir@' . DIRECTORY_SEPARATOR . 'docs',
            'bin_dir' => PHP_BINDIR,
            'data_dir' => '@php_dir@' . DIRECTORY_SEPARATOR . 'data', // pseudo-value in this implementation
            'cfg_dir' => '@php_dir@/cfg',
            'www_dir' => '@php_dir@' . DIRECTORY_SEPARATOR . 'www',
            'test_dir' => '@php_dir@' . DIRECTORY_SEPARATOR . 'tests',
            'php_bin' => '',
            'default_channel' => 'pear2.php.net',
            'preferred_mirror' => 'pear2.php.net',
            'auto_discover' => '0',
            'http_proxy' => '',
            'cache_dir' => '@php_dir@' . DIRECTORY_SEPARATOR . 'cache',
            'temp_dir' => '@php_dir@' . DIRECTORY_SEPARATOR . 'temp',
            'download_dir' => '@php_dir@' . DIRECTORY_SEPARATOR . 'downloads',
            'username' => '',
            'password' => '',
            'verbose' => '1',
            'preferred_state' => 'stable',
            'umask' => '0644',
            'cache_ttl' => '3600',
            'sig_type' => '',
            'sig_bin' => '',
            'sig_keyid' => '',
            'sig_keydir' => '',
            'my_pear_path' => '@php_dir@',
        ), tc::getTestDefaults(true), 'after');
$phpini = tc::getTestDefaults();
$test->assertRegex('/\.ini/', $phpini['php_ini'], 'php_ini');
?>
===DONE===
--EXPECT--
===DONE===
--TEST--
PEAR2_Pyrus_Config::constructDefaults() bin_dir from PHP_PEAR_BIN_DIR
--ENV--
PATH=.;{PWD}
PHP_PEAR_BIN_DIR=somethingelse
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
tc::constructDefaults();
$defaults = tc::getTestDefaults();
$test->assertEquals('somethingelse', $defaults['bin_dir'], 'after');
?>
===DONE===
--EXPECT--
===DONE===
--TEST--
PEAR2_Pyrus_Config::constructDefaults() bin_dir from PHP_BINDIR
--SKIPIF--
<?php
if (PATH_SEPARATOR == ';') echo 'skip requires non-MS Windows';
?>
--ENV--
PHP_PEAR_BIN_DIR=
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
tc::constructDefaults();
$defaults = tc::getTestDefaults();
$test->assertEquals(PHP_BINDIR, $defaults['bin_dir'], 'after');
?>
===DONE===
--EXPECT--
===DONE===
--TEST--
PEAR2_Pyrus_Config::constructDefaults() bin_dir from PATH on Windows
--SKIPIF--
<?php
if (PATH_SEPARATOR !== ';') echo 'skip requires MS Windows';
?>
--ENV--
PATH=.;{PWD}
PHP_PEAR_BIN_DIR=
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
tc::constructDefaults();
$defaults = tc::getTestDefaults();
$test->assertEquals(dirname(__FILE__), $defaults['bin_dir'], 'after');
?>
===DONE===
--EXPECT--
===DONE===
--TEST--
PEAR2_Pyrus_Config::constructDefaults() extension_dir from PHP_PEAR_EXTENSION_DIR
--ENV--
PATH=.
PHP_PEAR_EXTENSION_DIR=somethingelse
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
tc::constructDefaults();
$defaults = tc::getTestDefaults();
$test->assertEquals('somethingelse', $defaults['ext_dir'], 'after');
?>
===DONE===
--EXPECT--
===DONE===
--TEST--
PEAR2_Pyrus_Config::constructDefaults() extension_dir from PEAR_EXTENSION_DIR
--SKIPIF--
<?php
if (ini_get('extension_dir')) die("skip extension_dir must be unset to test this");
?>
--ENV--
PATH=.
PHP_PEAR_EXTENSION_DIR=
PEAR_EXTENSION_DIR=somethingelse2
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
tc::constructDefaults();
$defaults = tc::getTestDefaults();
$test->assertEquals('somethingelse2', $defaults['ext_dir'], 'after');
?>
===DONE===
--EXPECT--
===DONE===
--TEST--
PEAR2_Pyrus_Config::constructDefaults() extension_dir from php.ini
--SKIPIF--
<?php if (!ini_get('extension_dir')) die("skip extension_dir not set"); ?>
--ENV--
PHP_PEAR_EXTENSION_DIR=
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
tc::constructDefaults();
$defaults = tc::getTestDefaults();
$test->assertEquals(ini_get('extension_dir'), $defaults['ext_dir'], 'after');
?>
===DONE===
--EXPECT--
===DONE===
<?php
require dirname(dirname(__FILE__)) . '/setup.php.inc';
class tc extends PEAR2_Pyrus_Config
{
    public static function getTestDefaults($nophpini = false)
    {
        if ($nophpini) {
            $a = self::$defaults;
            unset($a['php_ini']);
            return $a;
        }
        return self::$defaults;
    }

    public static function constructDefaults()
    {
        return parent::constructDefaults();
    }
}
001- ===DONE===
001+ Test Failure: "peardir"
002+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/badsystemfile.php line 8
003+ Diff of expecting/received:
004+ @@ -1 +1 @@
005+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
006+ +NULL
007+ Expecting:
008+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
009+ Received:
010+ NULL
011+ ===DONE======DONE===
---- EXPECTED OUTPUT
===DONE===
---- ACTUAL OUTPUT
Test Failure: "peardir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/badsystemfile.php line 8
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
Received:
NULL
===DONE===
---- FAILED
Test Failure: "peardir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/badsystemfile.php line 8
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
Received:
NULL
===DONE===<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
file_put_contents($testpath . '/.config', '<?xml version="1.0" ?>oops> <cra&p>; ?>');
try {
    tc::$test = $test;
    $a = new tc($testpath, $testpath . '/blah');
    $test->assertEquals($testpath, $a->pearDir, 'peardir');
    $test->assertEquals($testpath . '/blah', $a->userFile, 'userfile');
} catch (Exception $e) {
    $test->assertException($e, 'PEAR2_Pyrus_Config_Exception', 'Unable to parse invalid PEAR configuration at "' . $testpath . '"', 'exception');
}
?>
===DONE===
--TEST--
PEAR2_Pyrus_Config::loadConfigFile() corrupt systemfile
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
file_put_contents($testpath . '/.config', '<?xml version="1.0" ?>oops> <cra&p>; ?>');
try {
    tc::$test = $test;
    $a = new tc($testpath, $testpath . '/blah');
    $test->assertEquals($testpath, $a->pearDir, 'peardir');
    $test->assertEquals($testpath . '/blah', $a->userFile, 'userfile');
} catch (Exception $e) {
    $test->assertException($e, 'PEAR2_Pyrus_Config_Exception', 'Unable to parse invalid PEAR configuration at "' . $testpath . '"', 'exception');
}
?>
===DONE===
--CLEAN--
<?php
$dir = __DIR__ . '/testit';
include __DIR__ . '/../../clean.php.inc';
?>
--EXPECT--
===DONE===
--TEST--
PEAR2_Pyrus_Config::loadConfigFile() corrupt userfile
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
file_put_contents($testpath . '/blah', '<?xml version="1.0" ?>oops> <cra&p>; ?>');
try {
    tc::$test = $test;
    $a = new tc($testpath, $testpath . '/blah');
    $test->assertEquals($testpath, $a->pearDir, 'peardir');
    $test->assertEquals($testpath . '/blah', $a->userFile, 'userfile');
} catch (Exception $e) {
    $test->assertException($e, 'PEAR2_Pyrus_Config_Exception', 'Unable to parse invalid user PEAR configuration at "' . $testpath . '/blah"', 'exception');
}
?>
===DONE===
--CLEAN--
<?php
$dir = __DIR__ . '/testit';
include __DIR__ . '/../../clean.php.inc';
?>
--EXPECT--
===DONE===
001- ===DONE===
001+ Test Failure: "peardir"
002+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/defaults.php line 6
003+ Diff of expecting/received:
004+ @@ -1 +1 @@
005+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
006+ +NULL
007+ Expecting:
008+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
009+ Received:
010+ NULL
011+ ===DONE======DONE===
---- EXPECTED OUTPUT
===DONE===
---- ACTUAL OUTPUT
Test Failure: "peardir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/defaults.php line 6
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
Received:
NULL
===DONE===
---- FAILED
Test Failure: "peardir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/defaults.php line 6
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
Received:
NULL
===DONE===<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
tc::$test = $test;
$a = new tc($testpath, $testpath . '/notfound');
$test->assertEquals($testpath, $a->pearDir, 'peardir');
$test->assertEquals($testpath . '/notfound', $a->userFile, 'userfile');
?>
===DONE===
--TEST--
PEAR2_Pyrus_Config::loadConfigFile() no configuration found, use defaults
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
tc::$test = $test;
$a = new tc($testpath, $testpath . '/notfound');
$test->assertEquals($testpath, $a->pearDir, 'peardir');
$test->assertEquals($testpath . '/notfound', $a->userFile, 'userfile');
?>
===DONE===
--CLEAN--
<?php
$dir = __DIR__ . '/testit';
include __DIR__ . '/../../clean.php.inc';
?>
--EXPECT--
===DONE===
001- here
001+ Test Failure: "peardir"
002- ===DONE===
002+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 19
003+ Diff of expecting/received:
004+ @@ -1 +1 @@
005+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
006+ +NULL
007+ Expecting:
008+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
009+ Received:
010+ NULL
011+ Test Failure: "php_dir"
012+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 21
013+ Diff of expecting/received:
014+ @@ -1 +1 @@
015+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/src'
016+ +'/src'
017+ Expecting:
018+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/src'
019+ Received:
020+ '/src'
021+ Test Failure: "data_dir"
022+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 22
023+ Diff of expecting/received:
024+ @@ -1 +1 @@
025+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/data'
026+ +'/data'
027+ Expecting:
028+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/data'
029+ Received:
030+ '/data'
031+ Test Failure: "ext_dir"
032+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 23
033+ Diff of expecting/received:
034+ @@ -1 +1 @@
035+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/foo'
036+ +'/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613'
037+ Expecting:
038+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/foo'
039+ Received:
040+ '/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613'
041+ Test Failure: "doc_dir"
042+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 24
043+ Diff of expecting/received:
044+ @@ -1 +1 @@
045+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bah'
046+ +'/docs'
047+ Expecting:
048+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bah'
049+ Received:
050+ '/docs'
051+ Test Failure: "bin_dir"
052+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 25
053+ Diff of expecting/received:
054+ @@ -1 +1 @@
055+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bar'
056+ +'/usr/local/php5/bin'
057+ Expecting:
058+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bar'
059+ Received:
060+ '/usr/local/php5/bin'
061+ Test Failure: "www_dir"
062+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 26
063+ Diff of expecting/received:
064+ @@ -1 +1 @@
065+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/boo'
066+ +'/www'
067+ Expecting:
068+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/boo'
069+ Received:
070+ '/www'
071+ Test Failure: "test_dir"
072+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 27
073+ Diff of expecting/received:
074+ @@ -1 +1 @@
075+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/blah'
076+ +'/tests'
077+ Expecting:
078+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/blah'
079+ Received:
080+ '/tests'
081+ Test Failure: "php_bin"
082+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 28
083+ Diff of expecting/received:
084+ @@ -1 +1 @@
085+ -'/path/to/php'
086+ +''
087+ Expecting:
088+ '/path/to/php'
089+ Received:
090+ ''
091+ Test Failure: "php_ini"
092+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 29
093+ Diff of expecting/received:
094+ @@ -1 +1 @@
095+ -'/path/to/php.ini'
096+ +'/usr/local/php5/lib/php.ini'
097+ Expecting:
098+ '/path/to/php.ini'
099+ Received:
100+ '/usr/local/php5/lib/php.ini'
101+ here
102+ ===DONE===here
===DONE===
---- EXPECTED OUTPUT
here
===DONE===
---- ACTUAL OUTPUT
Test Failure: "peardir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 19
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
Received:
NULL
Test Failure: "php_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 21
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/src'
+'/src'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/src'
Received:
'/src'
Test Failure: "data_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 22
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/data'
+'/data'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/data'
Received:
'/data'
Test Failure: "ext_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 23
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/foo'
+'/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/foo'
Received:
'/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613'
Test Failure: "doc_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 24
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bah'
+'/docs'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bah'
Received:
'/docs'
Test Failure: "bin_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 25
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bar'
+'/usr/local/php5/bin'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bar'
Received:
'/usr/local/php5/bin'
Test Failure: "www_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 26
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/boo'
+'/www'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/boo'
Received:
'/www'
Test Failure: "test_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 27
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/blah'
+'/tests'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/blah'
Received:
'/tests'
Test Failure: "php_bin"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 28
Diff of expecting/received:
@@ -1 +1 @@
-'/path/to/php'
+''
Expecting:
'/path/to/php'
Received:
''
Test Failure: "php_ini"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 29
Diff of expecting/received:
@@ -1 +1 @@
-'/path/to/php.ini'
+'/usr/local/php5/lib/php.ini'
Expecting:
'/path/to/php.ini'
Received:
'/usr/local/php5/lib/php.ini'
here
===DONE===
---- FAILED
Test Failure: "peardir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 19
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
Received:
NULL
Test Failure: "php_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 21
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/src'
+'/src'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/src'
Received:
'/src'
Test Failure: "data_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 22
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/data'
+'/data'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/data'
Received:
'/data'
Test Failure: "ext_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 23
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/foo'
+'/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/foo'
Received:
'/usr/local/php5/lib/php/extensions/no-debug-non-zts-20060613'
Test Failure: "doc_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 24
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bah'
+'/docs'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bah'
Received:
'/docs'
Test Failure: "bin_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 25
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bar'
+'/usr/local/php5/bin'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/bar'
Received:
'/usr/local/php5/bin'
Test Failure: "www_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 26
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/boo'
+'/www'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/boo'
Received:
'/www'
Test Failure: "test_dir"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 27
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/blah'
+'/tests'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/blah'
Received:
'/tests'
Test Failure: "php_bin"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 28
Diff of expecting/received:
@@ -1 +1 @@
-'/path/to/php'
+''
Expecting:
'/path/to/php'
Received:
''
Test Failure: "php_ini"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.php line 29
Diff of expecting/received:
@@ -1 +1 @@
-'/path/to/php.ini'
+'/usr/local/php5/lib/php.ini'
Expecting:
'/path/to/php.ini'
Received:
'/usr/local/php5/lib/php.ini'
here
===DONE===<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
file_put_contents($testpath . '/.config', '<?xml version="1.0" ?>
<c>
 <!-- make sure php_dir and data_dir are not processed -->
 <php_dir>oops</php_dir>
 <data_dir>I did it again</data_dir>
 <ext_dir>@php_dir@/foo</ext_dir>
 <doc_dir>@php_dir@/bah</doc_dir>
 <bin_dir>@php_dir@/bar</bin_dir>
 <www_dir>@php_dir@/boo</www_dir>
 <test_dir>@php_dir@/blah</test_dir>
 <php_bin>/path/to/php</php_bin>
 <php_ini>/path/to/php.ini</php_ini>
 <unknown>ha!</unknown>
</c>');
$a = $configclass::singleton($testpath, $testpath . '/blah');
$test->assertEquals($testpath, $a->path, 'peardir');
$test->assertEquals($testpath . '/blah', $a->userfile, 'userfile');
$test->assertEquals($testpath . '/src', $a->php_dir, 'php_dir');
$test->assertEquals($testpath . '/data', $a->data_dir, 'data_dir');
$test->assertEquals($testpath . '/foo', $a->ext_dir, 'ext_dir');
$test->assertEquals($testpath . '/bah', $a->doc_dir, 'doc_dir');
$test->assertEquals($testpath . '/bar', $a->bin_dir, 'bin_dir');
$test->assertEquals($testpath . '/boo', $a->www_dir, 'www_dir');
$test->assertEquals($testpath . '/blah', $a->test_dir, 'test_dir');
$test->assertEquals('/path/to/php', $a->php_bin, 'php_bin');
$test->assertEquals('/path/to/php.ini', $a->php_ini, 'php_ini');
try {
    $test->assertEquals('this should NOT execute, should go to exception', $a->unknown, 'unknown');
} catch (PEAR2_Pyrus_Config_Exception $e) {
    echo "here\n";
    $test->assertEquals('Unknown configuration variable "unknown" in location ' .
            $a->path, $e->getMessage(), 'exception message');
}
?>
===DONE===
--TEST--
PEAR2_Pyrus_Config::loadConfigFile() good systemfile
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
file_put_contents($testpath . '/.config', '<?xml version="1.0" ?>
<c>
 <!-- make sure php_dir and data_dir are not processed -->
 <php_dir>oops</php_dir>
 <data_dir>I did it again</data_dir>
 <ext_dir>@php_dir@/foo</ext_dir>
 <doc_dir>@php_dir@/bah</doc_dir>
 <bin_dir>@php_dir@/bar</bin_dir>
 <www_dir>@php_dir@/boo</www_dir>
 <test_dir>@php_dir@/blah</test_dir>
 <php_bin>/path/to/php</php_bin>
 <php_ini>/path/to/php.ini</php_ini>
 <unknown>ha!</unknown>
</c>');
$a = $configclass::singleton($testpath, $testpath . '/blah');
$test->assertEquals($testpath, $a->path, 'peardir');
$test->assertEquals($testpath . '/blah', $a->userfile, 'userfile');
$test->assertEquals($testpath . '/src', $a->php_dir, 'php_dir');
$test->assertEquals($testpath . '/data', $a->data_dir, 'data_dir');
$test->assertEquals($testpath . '/foo', $a->ext_dir, 'ext_dir');
$test->assertEquals($testpath . '/bah', $a->doc_dir, 'doc_dir');
$test->assertEquals($testpath . '/bar', $a->bin_dir, 'bin_dir');
$test->assertEquals($testpath . '/boo', $a->www_dir, 'www_dir');
$test->assertEquals($testpath . '/blah', $a->test_dir, 'test_dir');
$test->assertEquals('/path/to/php', $a->php_bin, 'php_bin');
$test->assertEquals('/path/to/php.ini', $a->php_ini, 'php_ini');
try {
    $test->assertEquals('this should NOT execute, should go to exception', $a->unknown, 'unknown');
} catch (PEAR2_Pyrus_Config_Exception $e) {
    echo "here\n";
    $test->assertEquals('Unknown configuration variable "unknown" in location ' .
            $a->path, $e->getMessage(), 'exception message');
}
?>
===DONE===
--CLEAN--
<?php
$dir = __DIR__ . '/testit';
include __DIR__ . '/../../clean.php.inc';
?>
--EXPECT--
here
===DONE===
001- ===DONE===
001+ Test Failure: "called 0"
002+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/setup.php.inc line 35
003+ Diff of expecting/received:
004+ @@ -1 +1 @@
005+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
006+ +'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit:/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/hi/there'
007+ Expecting:
008+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
009+ Received:
010+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit:/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/hi/there'
011+ Test Failure: "called times"
012+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/gooduser.mypath.php line 11
013+ Diff of expecting/received:
014+ @@ -1 +1 @@
015+ -1
016+ +2
017+ Expecting:
018+ 1
019+ Received:
020+ 2
021+ ===DONE======DONE===
---- EXPECTED OUTPUT
===DONE===
---- ACTUAL OUTPUT
Test Failure: "called 0"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/setup.php.inc line 35
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
+'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit:/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/hi/there'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
Received:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit:/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/hi/there'
Test Failure: "called times"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/gooduser.mypath.php line 11
Diff of expecting/received:
@@ -1 +1 @@
-1
+2
Expecting:
1
Received:
2
===DONE===
---- FAILED
Test Failure: "called 0"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/setup.php.inc line 35
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
+'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit:/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/hi/there'
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit'
Received:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit:/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/testit/hi/there'
Test Failure: "called times"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/gooduser.mypath.php line 11
Diff of expecting/received:
@@ -1 +1 @@
-1
+2
Expecting:
1
Received:
2
===DONE===<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
file_put_contents($testpath . '/blah', '<?xml version="1.0" ?>
<c>
 <my_pear_path>' . $testpath . '/hi/there</my_pear_path>
</c>');
try {
    tc::$test = $test;
    $a = new tc($testpath, $testpath . '/blah');
    $test->assertEquals(tc::$called, 2, 'called times');
    $test->assertEquals($testpath, $a->pearDir, 'peardir');
    $test->assertEquals($testpath . '/blah', $a->userFile, 'userfile');
} catch (Exception $e) {
    echo "failed with $e";
}
?>
===DONE===
--TEST--
PEAR2_Pyrus_Config::loadConfigFile() good userfile with my_pear_path set
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
file_put_contents($testpath . '/blah', '<?xml version="1.0" ?>
<c>
 <my_pear_path>' . $testpath . '/hi/there</my_pear_path>
</c>');
try {
    tc::$test = $test;
    $a = new tc($testpath, $testpath . '/blah');
    $test->assertEquals(tc::$called, 2, 'called times');
    $test->assertEquals($testpath, $a->pearDir, 'peardir');
    $test->assertEquals($testpath . '/blah', $a->userFile, 'userfile');
} catch (Exception $e) {
    echo "failed with $e";
}
?>
===DONE===
--CLEAN--
<?php
$dir = __DIR__ . '/testit';
include __DIR__ . '/../../clean.php.inc';
?>
--EXPECT--
===DONE===
--TEST--
PEAR2_Pyrus_Config::loadConfigFile() good userfile
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
set_include_path(''); // disable include_path cascading for simplicity
file_put_contents($testpath . '/.config', '<?xml version="1.0" ?>
<c>
 <!-- make sure php_dir and data_dir are not processed -->
 <php_dir>oops</php_dir>
 <data_dir>I did it again</data_dir>
 <ext_dir>@php_dir@/foo</ext_dir>
 <doc_dir>@php_dir@/bah</doc_dir>
 <bin_dir>@php_dir@/bar</bin_dir>
 <www_dir>@php_dir@/boo</www_dir>
 <test_dir>@php_dir@/blah</test_dir>
 <php_bin>/path/to/php</php_bin>
 <php_ini>/path/to/php.ini</php_ini>
 <unknown>ha!</unknown>
</c>');
file_put_contents($testpath . '/blah', '<?xml version="1.0" ?>
<c>
 <default_channel>pear.poo.net</default_channel>
 <preferred_mirror>pear.poo.de</preferred_mirror>
 <auto_discover>2</auto_discover>
 <http_proxy>hi</http_proxy>
 <cache_dir>/path/tomy/dir</cache_dir>
 <temp_dir>/path/to/temp</temp_dir>
 <download_dir>/download</download_dir>
 <username>boo</username>
 <password>ya</password>
 <verbose>5</verbose>
 <preferred_state>beta</preferred_state>
 <umask>' . 0642 . '</umask>
 <cache_ttl>1</cache_ttl>
 <sig_type>buh</sig_type>
 <sig_bin>/path/to/buh</sig_bin>
 <sig_keyid>999999random</sig_keyid>
 <sig_keydir>/path/to/buh/dir</sig_keydir>
 <my_pear_path>' . $testpath . '</my_pear_path>
 <unknown>ha!</unknown>
</c>');
$a = $configclass::singleton($testpath, $testpath . '/blah');
$test->assertEquals($testpath, $a->path, 'peardir');
$test->assertEquals('pear.poo.net', $a->default_channel, 'default_channel');
$test->assertEquals('pear.poo.de', $a->preferred_mirror, 'preferred_mirror');
$test->assertEquals('2', $a->auto_discover, 'auto_discover');
$test->assertEquals('hi', $a->http_proxy, 'http_proxy');
$test->assertEquals('/path/tomy/dir', $a->cache_dir, 'cache_dir');
$test->assertEquals('/path/to/temp', $a->temp_dir, 'temp_dir');
$test->assertEquals('/download', $a->download_dir, 'download_dir');
$test->assertEquals('boo', $a->username, 'username');
$test->assertEquals('ya', $a->password, 'password');
$test->assertEquals('5', $a->verbose, 'verbose');
$test->assertEquals('beta', $a->preferred_state, 'preferred_state');
$test->assertEquals((string) 0642, $a->umask, 'umask');
$test->assertEquals('1', $a->cache_ttl, 'cache_ttl');
$test->assertEquals('buh', $a->sig_type, 'sig_type');
$test->assertEquals('/path/to/buh', $a->sig_bin, 'sig_bin');
$test->assertEquals('999999random', $a->sig_keyid, 'sig_keyid');
$test->assertEquals('/path/to/buh/dir', $a->sig_keydir, 'sig_keydir');
$test->assertEquals($testpath, $a->my_pear_path, 'my_pear_path');
try {
    $test->assertEquals('this should NOT execute, should go to exception', $a->unknown, 'unknown');
} catch (PEAR2_Pyrus_Config_Exception $e) {
    echo "here\n";
    $test->assertEquals('Unknown configuration variable "unknown" in location ' .
            $a->path, $e->getMessage(), 'exception message');
}
?>
===DONE===
--CLEAN--
<?php
$dir = __DIR__ . '/testit';
include __DIR__ . '/../../clean.php.inc';
?>
--EXPECT--
here
===DONE===
<?php
require __DIR__ . '/../setup.php.inc';
$testpath = __DIR__ . '/testit';
mkdir($testpath);
class tc extends PEAR2_Pyrus_Config
{
    /**
     * location of PEAR2 installation
     *
     * @var string
     */
    public $pearDir;
    /**
     * location of user-specific configuration file
     *
     * @var string
     */
    public $userFile;

    public static $test;

    public static $called = 0;

    private static $paths;

    public function __construct($pearDirectory, $userfile = false)
    {
        self::$paths = array($GLOBALS['testpath'], $GLOBALS['testpath'] . PATH_SEPARATOR .
                             $GLOBALS['testpath'] . DIRECTORY_SEPARATOR . 'hi/there');
        return parent::__construct($pearDirectory, $userfile);
    }

    public function setCascadingRegistries($path)
    {
        self::$test->assertEquals(self::$paths[self::$called++], $path, "called " . (self::$called - 1));
        return parent::setCascadingRegistries($path);
    }
}
001- ===DONE===
001+ Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 7
002+ Test Failure: "registry path"
003+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 7
004+ Diff of expecting/received:
005+ @@ -1 +1 @@
006+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
007+ +NULL
008+ Expecting:
009+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
010+ Received:
011+ NULL
012+ 
013+ Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 8
014+ 
015+ Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 8
016+ Test Failure: "registry->parent path"
017+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 8
018+ Diff of expecting/received:
019+ @@ -1 +1 @@
020+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
021+ +NULL
022+ Expecting:
023+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
024+ Received:
025+ NULL
026+ 
027+ Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 9
028+ 
029+ Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 9
030+ 
031+ Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 10
032+ Test Failure: "channelregistry path"
033+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 10
034+ Diff of expecting/received:
035+ @@ -1 +1 @@
036+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
037+ +NULL
038+ Expecting:
039+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
040+ Received:
041+ NULL
042+ 
043+ Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 11
044+ 
045+ Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 11
046+ Test Failure: "channelregistry->parent path"
047+  in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 11
048+ Diff of expecting/received:
049+ @@ -1 +1 @@
050+ -'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
051+ +NULL
052+ Expecting:
053+ '/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
054+ Received:
055+ NULL
056+ 
057+ Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 12
058+ 
059+ Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 12
060+ ===DONE======DONE===
---- EXPECTED OUTPUT
===DONE===
---- ACTUAL OUTPUT
Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 7
Test Failure: "registry path"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 7
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
Received:
NULL

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 8

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 8
Test Failure: "registry->parent path"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 8
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
Received:
NULL

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 9

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 9

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 10
Test Failure: "channelregistry path"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 10
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
Received:
NULL

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 11

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 11
Test Failure: "channelregistry->parent path"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 11
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
Received:
NULL

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 12

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 12
===DONE===
---- FAILED
Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 7
Test Failure: "registry path"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 7
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
Received:
NULL

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 8

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 8
Test Failure: "registry->parent path"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 8
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
Received:
NULL

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 9

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 9

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 10
Test Failure: "channelregistry path"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 10
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/something'
Received:
NULL

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 11

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 11
Test Failure: "channelregistry->parent path"
 in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php line 11
Diff of expecting/received:
@@ -1 +1 @@
-'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
+NULL
Expecting:
'/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/foo'
Received:
NULL

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 12

Notice: Trying to get property of non-object in /Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.php on line 12
===DONE===<?php
require dirname(__FILE__) . '/setup.php.inc';
@mkdir(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'foo');
set_include_path(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'foo');
$c = $configclass::singleton(dirname(__FILE__) . '/something' . PATH_SEPARATOR . dirname(__FILE__) . '/foo', dirname(__FILE__) . '/something/blah');
restore_include_path();
$test->assertEquals(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'something', $c->registry->path, 'registry path');
$test->assertEquals(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'foo', $c->registry->parent->path, 'registry->parent path');
$test->assertNull($c->registry->parent->parent, 'registry parent parent');
$test->assertEquals(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'something', $c->channelregistry->path, 'channelregistry path');
$test->assertEquals(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'foo', $c->channelregistry->parent->path, 'channelregistry->parent path');
$test->assertNull($c->channelregistry->parent->parent, 'channelregistry parent parent');
?>
===DONE===
--TEST--
PEAR2_Pyrus_Config::setCascading Registries() basic test
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
@mkdir(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'foo');
set_include_path(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'foo');
$c = $configclass::singleton(dirname(__FILE__) . '/something' . PATH_SEPARATOR . dirname(__FILE__) . '/foo', dirname(__FILE__) . '/something/blah');
restore_include_path();
$test->assertEquals(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'something', $c->registry->path, 'registry path');
$test->assertEquals(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'foo', $c->registry->parent->path, 'registry->parent path');
$test->assertNull($c->registry->parent->parent, 'registry parent parent');
$test->assertEquals(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'something', $c->channelregistry->path, 'channelregistry path');
$test->assertEquals(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'foo', $c->channelregistry->parent->path, 'channelregistry->parent path');
$test->assertNull($c->channelregistry->parent->parent, 'channelregistry parent parent');
?>
===DONE===
--CLEAN--
<?php
$dir = __DIR__ . '/foo';
include __DIR__ . '/../../clean.php.inc';
?>
<?php
$dir = __DIR__ . '/something';
include __DIR__ . '/../../clean.php.inc';
?>
--EXPECT--
===DONE===
<?php
require dirname(dirname(__FILE__)) . '/setup.php.inc';
class r extends PEAR2_Pyrus_Registry
{
    public $parent;
    public $path;
}
class c extends PEAR2_Pyrus_ChannelRegistry
{
    public $parent;
    public $path;
}
PEAR2_Pyrus_Registry::$className = 'r';
PEAR2_Pyrus_ChannelRegistry::$className = 'c';
<?php
include dirname(__FILE__) . '/../test_framework.php.inc';
$configclass = 'PEAR2_Pyrus_Config';
--TEST--
Pyrus DirectedGraph: basic topological sort
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$a1 = new stdClass;
$a2 = new stdClass;
$a3 = new stdClass;
$a4 = new stdClass;
$a5 = new stdClass;
$digraph->add($a1);
$digraph->add($a2);
$digraph->add($a3);
$digraph->add($a4);
$digraph->add($a5);

$digraph->connect($a1, $a2);
$digraph->connect($a1, $a3);
$digraph->connect($a2, $a3);
$digraph->connect($a2, $a5);
$digraph->connect($a4, $a2);
$digraph->connect($a4, $a1);
$digraph->connect($a4, $a5);
$digraph->connect($a5, $a3);

$res = array();
foreach ($digraph as $val) {
    $res[] = $val;
}
$test->assertEquals(array($a3, $a5, $a2, $a1, $a4), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus DirectedGraph: topological sort with cycles
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$a1 = new stdClass;
$a2 = new stdClass;
$a3 = new stdClass;
$a4 = new stdClass;
$a5 = new stdClass;
$digraph->add($a1);
$digraph->add($a2);
$digraph->add($a3);
$digraph->add($a4);
$digraph->add($a5);

$digraph->connect($a1, $a2);
$digraph->connect($a2, $a1);
$digraph->connect($a3, $a4);
$digraph->connect($a4, $a5);
$digraph->connect($a5, $a1);
$digraph->connect($a1, $a3);

$res = array();
foreach ($digraph as $val) {
    $res[] = $val;
}
$test->assertEquals(array($a2, $a1, $a3, $a4, $a5), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===<?php
include dirname(__FILE__) . '/../test_framework.php.inc';
$digraph = new PEAR2_Pyrus_DirectedGraph;
<?xml version="1.0" encoding="UTF-8"?>
<package version="2.1" xmlns="http://pear.php.net/dtd/package-2.1" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0     http://pear.php.net/dtd/tasks-1.0.xsd     http://pear.php.net/dtd/package-2.1     http://pear.php.net/dtd/package-2.1.xsd">
 <name>PEAR2_Pyrus</name>
 <channel>pear2.php.net</channel>
 <summary>Pyrus is the package manager and installer for PHP 5.2 or newer
</summary>
 <description>
Pyrus provides the means to install and manage installations for
packages built using package.xml version 2.0 or newer.  Pyrus is
redesigned from the ground up for PHP 5.2 or newer, and provides
significant improvements over the older PEAR Installer.

To use Pyrus, in this development series of releases, you need to
instantiate a simple script that creates a package and installs it:

&lt;?php
// use full path if include_path is not set up
include 'PEAR2/Autoload.php';
require_once 'Net/URL2.php'; // PEAR package needed for PEAR2_HTTP_Request dep
$config = PEAR2_Pyrus_Config::singleton('/where/to/install');
// this can be a url to a remote package, a local .tgz, .zip or package.xml
$p = new PEAR2_Pyrus_Package('thingtoinstall');
try {
    PEAR2_Pyrus_Installer::begin();
    PEAR2_Pyrus_Installer::prepare($p);
    PEAR2_Pyrus_Installer::commit();
} catch (Exception $e) {
    PEAR2_Pyrus_Installer::rollback();
    echo $e;
}
?&gt;</description>
 <lead>
  <name>Gregory Beaver</name>
  <user>cellog</user>
  <email>cellog@php.net</email>
  <active>yes</active>
 </lead>
 <date>2007-10-06</date>
 <version>
  <release>2.0.0a1</release>
  <api>0.1.0</api>
 </version>
 <stability>
  <release>alpha</release>
  <api>alpha</api>
 </stability>
 <license uri="http://www.opensource.org/licenses/bsd-license.php">New BSD License</license>
 <notes>Initial development release, no frontend is included</notes>
 <contents>
  <dir name="/">
   <dir name="data" baseinstalldir="/">
    <file role="data" name="channel-1.0.xsd"/>
    <file role="data" name="package-2.0.xsd"/>
    <file role="data" name="package-2.1.xsd"/>
   </dir>
   <dir name="src" baseinstalldir="PEAR2">
    <dir name="Pyrus">
     <dir name="Channel">
      <file role="php" name="Base.php"/>
      <file role="php" name="Exception.php"/>
      <file role="php" name="IMirror.php"/>
      <file role="php" name="Mirror.php"/>
     </dir>
     <dir name="ChannelRegistry">
      <dir name="Channel">
       <file role="php" name="Sqlite.php"/>
       <file role="php" name="Xml.php"/>
      </dir>
      <dir name="Mirror">
       <file role="php" name="Sqlite.php"/>
       <file role="php" name="Xml.php"/>
      </dir>
      <file role="php" name="Base.php"/>
      <file role="php" name="Exception.php"/>
      <file role="php" name="Sqlite.php"/>
      <file role="php" name="Xml.php"/>
     </dir>
     <dir name="Config">
      <file role="php" name="Exception.php"/>
     </dir>
     <dir name="Dependency">
      <file role="php" name="Exception.php"/>
      <file role="php" name="Validator.php"/>
     </dir>
     <dir name="DirectedGraph">
      <file role="php" name="Exception.php"/>
      <file role="php" name="Vertex.php"/>
     </dir>
     <dir name="FileTransactions">
      <file role="php" name="Installedas.php"/>
      <file role="php" name="Rename.php"/>
      <file role="php" name="Rmdir.php"/>
     </dir>
     <dir name="Installer">
      <dir name="Role">
       <file role="php" name="Common.php"/>
       <file role="php" name="Data.php"/>
       <file role="php" name="Data.xml"/>
       <file role="php" name="Doc.php"/>
       <file role="php" name="Doc.xml"/>
       <file role="php" name="Exception.php"/>
       <file role="php" name="Ext.php"/>
       <file role="php" name="Ext.xml"/>
       <file role="php" name="Php.php"/>
       <file role="php" name="Php.xml"/>
       <file role="php" name="Script.php"/>
       <file role="php" name="Script.xml"/>
       <file role="php" name="Src.php"/>
       <file role="php" name="Src.xml"/>
       <file role="php" name="Test.php"/>
       <file role="php" name="Test.xml"/>
       <file role="php" name="Www.php"/>
       <file role="php" name="Www.xml"/>
      </dir>
      <file role="php" name="Exception.php"/>
      <file role="php" name="Role.php"/>
     </dir>
     <dir name="Package">
      <dir name="Creator">
       <file role="php" name="Exception.php"/>
       <file role="php" name="TaskIterator.php"/>
      </dir>
      <dir name="Phar">
       <file role="php" name="Exception.php"/>
      </dir>
      <dir name="Tar">
       <file role="php" name="Exception.php"/>
      </dir>
      <dir name="Zip">
       <file role="php" name="Exception.php"/>
      </dir>
      <file role="php" name="Base.php"/>
      <file role="php" name="Creator.php"/>
      <file role="php" name="Dependency.php"/>
      <file role="php" name="Exception.php"/>
      <file role="php" name="ICreator.php"/>
      <file role="php" name="InstalledException.php"/>
      <file role="php" name="Phar.php"/>
      <file role="php" name="Remote.php"/>
      <file role="php" name="Tar.php"/>
      <file role="php" name="Xml.php"/>
      <file role="php" name="Zip.php"/>
     </dir>
     <dir name="PackageFile">
      <dir name="Parser">
       <file role="php" name="v2.php"/>
      </dir>
      <dir name="v2">
       <dir name="Compatible">
        <file role="php" name="Exception.php"/>
       </dir>
       <dir name="Dependencies">
        <file role="php" name="Exception.php"/>
       </dir>
       <dir name="Developer">
        <file role="php" name="Exception.php"/>
       </dir>
       <dir name="Files">
        <file role="php" name="Exception.php"/>
       </dir>
       <dir name="Release">
        <file role="php" name="Exception.php"/>
       </dir>
       <file role="php" name="Compatible.php"/>
       <file role="php" name="Dependencies.php"/>
       <file role="php" name="Developer.php"/>
       <file role="php" name="Files.php"/>
       <file role="php" name="Release.php"/>
       <file role="php" name="Remote.php"/>
       <file role="php" name="Validator.php"/>
      </dir>
      <dir name="v2Iterator">
       <file role="php" name="File.php"/>
       <file role="php" name="FileAttribsFilter.php"/>
       <file role="php" name="FileContents.php"/>
       <file role="php" name="FileContentsMulti.php"/>
       <file role="php" name="FileInstallationFilter.php"/>
       <file role="php" name="FileTag.php"/>
       <file role="php" name="PackagingIterator.php"/>
      </dir>
      <file role="php" name="Exception.php"/>
      <file role="php" name="IValidator.php"/>
      <file role="php" name="v2.php"/>
     </dir>
     <dir name="Registry">
      <dir name="Sqlite">
       <dir name="Channel">
        <file role="php" name="Mirror.php"/>
        <file role="php" name="Mirrors.php"/>
       </dir>
       <file role="php" name="Creator.php"/>
       <file role="php" name="Package.php"/>
      </dir>
      <file role="php" name="Base.php"/>
      <file role="php" name="Channel.php"/>
      <file role="php" name="Config.php"/>
      <file role="php" name="Exception.php"/>
      <file role="php" name="Package.php"/>
      <file role="php" name="Sqlite.php"/>
      <file role="php" name="Xml.php"/>
     </dir>
     <dir name="REST">
      <file role="php" name="10.php"/>
      <file role="php" name="11.php"/>
      <file role="php" name="13.php"/>
      <file role="php" name="Exception.php"/>
      <file role="php" name="HTTPException.php"/>
     </dir>
     <dir name="ScriptFrontend">
      <file role="php" name="Commands.php"/>
     </dir>
     <dir name="Task">
      <dir name="Postinstallscript">
       <file role="php" name="rw.php"/>
      </dir>
      <dir name="Replace">
       <file role="php" name="rw.php"/>
      </dir>
      <dir name="Unixeol">
       <file role="php" name="rw.php"/>
      </dir>
      <dir name="Windowseol">
       <file role="php" name="rw.php"/>
      </dir>
      <file role="php" name="Common.php"/>
      <file role="php" name="Exception.php"/>
      <file role="php" name="Postinstallscript.php"/>
      <file role="php" name="Replace.php"/>
      <file role="php" name="Unixeol.php"/>
      <file role="php" name="Windowseol.php"/>
     </dir>
     <dir name="Validate">
      <file role="php" name="Exception.php"/>
     </dir>
     <dir name="Validator">
      <file role="php" name="PECL.php"/>
     </dir>
     <dir name="XMLParser">
      <file role="php" name="Exception.php"/>
     </dir>
     <dir name="XMLWriter">
      <file role="php" name="Exception.php"/>
     </dir>
     <file role="php" name="Channel.php"/>
     <file role="php" name="ChannelRegistry.php"/>
     <file role="php" name="Config.php"/>
     <file role="php" name="DirectedGraph.php"/>
     <file role="php" name="Downloader.php"/>
     <file role="php" name="Exception.php"/>
     <file role="php" name="FileTransactions.php"/>
     <file role="php" name="IChannel.php"/>
     <file role="php" name="IChannelRegistry.php"/>
     <file role="php" name="IFileTransaction.php"/>
     <file role="php" name="Installer.php"/>
     <file role="php" name="IPackage.php"/>
     <file role="php" name="IRegistry.php"/>
     <file role="php" name="Log.php"/>
     <file role="php" name="OSGuess.php"/>
     <file role="php" name="Package.php"/>
     <file role="php" name="PackageFile.php"/>
     <file role="php" name="Registry.php"/>
     <file role="php" name="REST.php"/>
     <file role="php" name="Validate.php"/>
     <file role="php" name="XMLParser.php"/>
     <file role="php" name="XMLWriter.php"/>
    </dir>
    <file role="php" name="Pyrus.php"/>
   </dir>
  </dir>
 </contents>
 <dependencies>
  <required>
   <php>
    <min>5.2.0</min>
   </php>
   <pearinstaller>
    <min>2.0.0a1</min>
   </pearinstaller>
  </required>
 </dependencies>
 <phprelease></phprelease>
</package>
<?xml version="1.0" encoding="UTF-8"?>
<package version="2.0" xmlns="http://pear.php.net/dtd/package-2.0" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0
http://pear.php.net/dtd/tasks-1.0.xsd
http://pear.php.net/dtd/package-2.0
http://pear.php.net/dtd/package-2.0.xsd">
 <name>PEAR</name>
 <channel>pear.php.net</channel>
 <summary>PEAR Base System</summary>
 <description>The PEAR package contains:
 * the PEAR installer, for creating, distributing
   and installing packages
 * the PEAR_Exception PHP5 error handling mechanism
 * the PEAR_ErrorStack advanced error handling mechanism
 * the PEAR_Error error handling mechanism
 * the OS_Guess class for retrieving info about the OS
   where PHP is running on
 * the System class for quick handling of common operations
   with files and directories
 * the PEAR base class

  Features in a nutshell:
  * full support for channels
  * pre-download dependency validation
  * new package.xml 2.0 format allows tremendous flexibility while maintaining BC
  * support for optional dependency groups and limited support for sub-packaging
  * robust dependency support
  * full dependency validation on uninstall
  * remote install for hosts with only ftp access - no more problems with
    restricted host installation
  * full support for mirroring
  * support for bundling several packages into a single tarball
  * support for static dependencies on a url-based package
  * support for custom file roles and installation tasks
 </description>
 <lead>
  <name>Greg Beaver</name>
  <user>cellog</user>
  <email>cellog@php.net</email>
  <active>yes</active>
 </lead>
 <lead>
  <name>Pierre-Alain Joye</name>
  <user>pajoye</user>
  <email>pierre@php.net</email>
  <active>no</active>
 </lead>
 <lead>
  <name>Stig Bakken</name>
  <user>ssb</user>
  <email>stig@php.net</email>
  <active>no</active>
 </lead>
 <lead>
  <name>Tomas V.V.Cox</name>
  <user>cox</user>
  <email>cox@idecnet.com</email>
  <active>no</active>
 </lead>
 <developer>
  <name>Helgi Thormar</name>
  <user>dufuz</user>
  <email>dufuz@php.net</email>
  <active>yes</active>
 </developer>
 <developer>
  <name>Tias Guns</name>
  <user>tias</user>
  <email>tias@php.net</email>
  <active>yes</active>
 </developer>
 <helper>
  <name>Tim Jackson</name>
  <user>timj</user>
  <email>timj@php.net</email>
  <active>no</active>
 </helper>
 <helper>
  <name>Bertrand Gugger</name>
  <user>toggg</user>
  <email>toggg@php.net</email>
  <active>no</active>
 </helper>
 <helper>
  <name>Martin Jansen</name>
  <user>mj</user>
  <email>mj@php.net</email>
  <active>no</active>
 </helper>
 <date>2007-10-01</date>
 <version>
  <release>1.7.0</release>
  <api>1.7.0</api>
 </version>
 <stability>
  <release>stable</release>
  <api>stable</api>
 </stability>
 <license uri="http://www.php.net/license">PHP License</license>
 <notes>
  * implement Request #11964: introduce www role, www_dir config variable [cellog]
 </notes>
 <contents>
  <dir name="/">
   <dir name="OS">
    <file name="Guess.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
   </dir> <!-- /OS -->
   <dir name="PEAR">
    <dir name="ChannelFile">
     <file name="Parser.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
    </dir> <!-- /PEAR/ChannelFile -->
    <dir name="Command">
     <file name="Auth.xml" role="php"/>
     <file name="Auth.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Build.xml" role="php"/>
     <file name="Build.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Channels.xml" role="php"/>
     <file name="Channels.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Common.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Config.xml" role="php"/>
     <file name="Config.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Install.xml" role="php"/>
     <file name="Install.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Mirror.xml" role="php"/>
     <file name="Mirror.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Package.xml" role="php"/>
     <file name="Package.php" role="php">
      <tasks:replace from="@DATA-DIR@" to="data_dir" type="pear-config" />
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Pickle.xml" role="php"/>
     <file name="Pickle.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Registry.xml" role="php"/>
     <file name="Registry.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Remote.xml" role="php"/>
     <file name="Remote.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Test.xml" role="php"/>
     <file name="Test.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
    </dir> <!-- /PEAR/Command -->
    <dir name="Downloader">
     <file name="Package.php" role="php">
      <tasks:replace from="@PEAR-VER@" to="version" type="package-info" />
     </file>
    </dir> <!-- /PEAR/Downloader -->
    <dir name="Frontend">
     <file name="CLI.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
    </dir> <!-- /PEAR/Frontend -->
    <dir name="Installer">
     <dir name="Role">
      <file name="Common.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
      <file name="Data.xml" role="php"/>
      <file name="Data.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
      <file name="Doc.xml" role="php"/>
      <file name="Doc.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
      <file name="Ext.xml" role="php"/>
      <file name="Ext.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
      <file name="Php.xml" role="php"/>
      <file name="Php.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
      <file name="Script.xml" role="php"/>
      <file name="Script.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
      <file name="Src.xml" role="php"/>
      <file name="Src.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
      <file name="Test.xml" role="php"/>
      <file name="Test.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
      <file name="Www.xml" role="php"/>
      <file name="Www.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
     </dir> <!-- /PEAR/Installer/Role -->
     <file name="Role.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
    </dir> <!-- /PEAR/Installer -->
    <dir name="PackageFile">
     <dir name="Generator">
      <file name="v1.php" role="php">
       <tasks:replace from="@PEAR-VER@" to="version" type="package-info" />
      </file>
      <file name="v2.php" role="php">
       <tasks:replace from="@PEAR-VER@" to="version" type="package-info" />
      </file>
     </dir> <!-- /PEAR/PackageFile/Generator -->
     <dir name="Parser">
      <file name="v1.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
      <file name="v2.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
     </dir> <!-- /PEAR/PackageFile/Parser -->
     <dir name="v2">
      <file role="php" name="rw.php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
      <file role="php" name="Validator.php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
     </dir> <!-- /PEAR/PackageFile/v2 -->
     <file name="v1.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="v2.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
    </dir> <!-- /PEAR/PackageFile -->
    <dir name="REST">
     <file name="10.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="11.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="13.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
    </dir> <!-- /PEAR/REST -->
    <dir name="Task">
     <dir name="Postinstallscript">
      <file name="rw.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
     </dir> <!-- /PEAR/Task/Postinstallscript -->
     <dir name="Replace">
      <file name="rw.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
     </dir> <!-- /PEAR/Task/Replace -->
     <dir name="Unixeol">
      <file name="rw.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
     </dir> <!-- /PEAR/Task/Unixeol -->
     <dir name="Windowseol">
      <file name="rw.php" role="php">
       <tasks:replace from="@package_version@" to="version" type="package-info" />
      </file>
     </dir> <!-- /PEAR/Task/Windowseol -->
     <file name="Common.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Postinstallscript.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Replace.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Unixeol.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
     <file name="Windowseol.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
    </dir> <!-- /PEAR/Task -->
    <dir name="Validator">
     <file name="PECL.php" role="php">
      <tasks:replace from="@package_version@" to="version" type="package-info" />
     </file>
    </dir> <!-- /PEAR/Validator -->
    <file name="Autoloader.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Builder.php" role="php">
     <tasks:replace from="@PEAR-VER@" to="version" type="package-info"/>
    </file>
    <file name="ChannelFile.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Command.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Common.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Config.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Dependency.php" role="php" />
    <file name="DependencyDB.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Dependency2.php" role="php">
     <tasks:replace from="@PEAR-VER@" to="version" type="package-info"/>
    </file>
    <file name="Downloader.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="ErrorStack.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Exception.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Frontend.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Installer.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="PackageFile.php" role="php">
     <tasks:replace from="@PEAR-VER@" to="version" type="package-info" />
    </file>
    <file name="Packager.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Registry.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Remote.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="REST.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="RunTest.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="Validate.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
    <file name="XMLParser.php" role="php">
     <tasks:replace from="@package_version@" to="version" type="package-info" />
    </file>
   </dir> <!-- /PEAR -->
   <dir name="scripts" baseinstalldir="/">
    <file name="pear.bat" role="script">
     <tasks:replace from="@bin_dir@" to="bin_dir" type="pear-config" />
     <tasks:replace from="@php_bin@" to="php_bin" type="pear-config" />
     <tasks:replace from="@include_path@" to="php_dir" type="pear-config" />
     <tasks:windowseol/>
    </file>
    <file name="peardev.bat" role="script">
     <tasks:replace from="@bin_dir@" to="bin_dir" type="pear-config" />
     <tasks:replace from="@php_bin@" to="php_bin" type="pear-config" />
     <tasks:replace from="@include_path@" to="php_dir" type="pear-config" />
     <tasks:windowseol/>
    </file>
    <file name="pecl.bat" role="script">
     <tasks:replace from="@bin_dir@" to="bin_dir" type="pear-config" />
     <tasks:replace from="@php_bin@" to="php_bin" type="pear-config" />
     <tasks:replace from="@include_path@" to="php_dir" type="pear-config" />
     <tasks:windowseol/>
    </file>
    <file name="pear.sh" role="script">
     <tasks:replace from="@php_bin@" to="php_bin" type="pear-config" />
     <tasks:replace from="@php_dir@" to="php_dir" type="pear-config" />
     <tasks:replace from="@pear_version@" to="version" type="package-info" />
     <tasks:replace from="@include_path@" to="php_dir" type="pear-config" />
     <tasks:unixeol/>
    </file>
    <file name="peardev.sh" role="script">
     <tasks:replace from="@php_bin@" to="php_bin" type="pear-config" />
     <tasks:replace from="@php_dir@" to="php_dir" type="pear-config" />
     <tasks:replace from="@pear_version@" to="version" type="package-info" />
     <tasks:replace from="@include_path@" to="php_dir" type="pear-config" />
     <tasks:unixeol/>
    </file>
    <file name="pecl.sh" role="script">
     <tasks:replace from="@php_bin@" to="php_bin" type="pear-config" />
     <tasks:replace from="@php_dir@" to="php_dir" type="pear-config" />
     <tasks:replace from="@pear_version@" to="version" type="package-info" />
     <tasks:replace from="@include_path@" to="php_dir" type="pear-config" />
     <tasks:unixeol/>
    </file>
    <file name="pearcmd.php" role="php">
     <tasks:replace from="@php_bin@" to="php_bin" type="pear-config" />
     <tasks:replace from="@php_dir@" to="php_dir" type="pear-config" />
     <tasks:replace from="@pear_version@" to="version" type="package-info" />
     <tasks:replace from="@include_path@" to="php_dir" type="pear-config" />
    </file>
    <file name="peclcmd.php" role="php">
     <tasks:replace from="@php_bin@" to="php_bin" type="pear-config" />
     <tasks:replace from="@php_dir@" to="php_dir" type="pear-config" />
     <tasks:replace from="@pear_version@" to="version" type="package-info" />
     <tasks:replace from="@include_path@" to="php_dir" type="pear-config" />
    </file>
   </dir> <!-- /scripts -->
   <file name="INSTALL" role="doc" />
   <file name="package.dtd" role="data" />
   <file name="PEAR.php" role="php">
    <tasks:replace from="@package_version@" to="version" type="package-info" />
   </file>
   <file name="README" role="doc" />
   <file name="System.php" role="php">
    <tasks:replace from="@package_version@" to="version" type="package-info" />
   </file>
   <file name="template.spec" role="data" />
  </dir> <!-- / -->
 </contents>
 <dependencies>
  <required>
   <php>
    <min>4.3.0</min>
   </php>
   <pearinstaller>
    <min>1.4.3</min>
   </pearinstaller>
   <package>
    <name>Archive_Tar</name>
    <channel>pear.php.net</channel>
    <min>1.1</min>
    <recommended>1.3.2</recommended>
    <exclude>1.3.0</exclude>
   </package>
   <package>
    <name>Structures_Graph</name>
    <channel>pear.php.net</channel>
    <min>1.0.2</min>
    <recommended>1.0.2</recommended>
   </package>
   <package>
    <name>Console_Getopt</name>
    <channel>pear.php.net</channel>
    <min>1.2</min>
    <recommended>1.2.3</recommended>
   </package>
   <package>
    <name>PEAR_Frontend_Web</name>
    <channel>pear.php.net</channel>
    <max>0.4</max>
    <conflicts/>
   </package>
   <package>
    <name>PEAR_Frontend_Gtk</name>
    <channel>pear.php.net</channel>
    <max>0.4.0</max>
    <exclude>0.4.0</exclude>
    <conflicts/>
   </package>
   <extension>
    <name>xml</name>
   </extension>
   <extension>
    <name>pcre</name>
   </extension>
  </required>
  <optional>
   <package>
    <name>XML_RPC</name>
    <channel>pear.php.net</channel>
    <min>1.4.0</min>
   </package>
  </optional>
<!--  <group name="remoteinstall" hint="adds the ability to install packages to a remote ftp server">
   <subpackage>
    <name>PEAR_RemoteInstaller</name>
    <channel>pear.php.net</channel>
    <min>0.1.0</min>
    <recommended>0.1.0</recommended>
   </subpackage>
  </group> -->
  <group name="webinstaller" hint="PEAR's web-based installer">
   <package>
    <name>PEAR_Frontend_Web</name>
    <channel>pear.php.net</channel>
    <min>0.5.1</min>
   </package>
  </group>
  <group name="gtkinstaller" hint="PEAR's PHP-GTK-based installer">
   <package>
    <name>PEAR_Frontend_Gtk</name>
    <channel>pear.php.net</channel>
    <min>0.4.0</min>
   </package>
  </group>
  <group name="gtk2installer" hint="PEAR's PHP-GTK2-based installer">
   <package>
    <name>PEAR_Frontend_Gtk2</name>
    <channel>pear.php.net</channel>
   </package>
  </group>
 </dependencies>
 <phprelease>
  <installconditions>
   <os>
    <name>windows</name>
   </os>
  </installconditions>
  <filelist>
   <install as="pear.bat" name="scripts/pear.bat" />
   <install as="peardev.bat" name="scripts/peardev.bat" />
   <install as="pecl.bat" name="scripts/pecl.bat" />
   <install as="pearcmd.php" name="scripts/pearcmd.php" />
   <install as="peclcmd.php" name="scripts/peclcmd.php" />
   <ignore name="scripts/peardev.sh" />
   <ignore name="scripts/pear.sh" />
   <ignore name="scripts/pecl.sh" />
  </filelist>
 </phprelease>
 <phprelease>
  <filelist>
   <install as="pear" name="scripts/pear.sh" />
   <install as="peardev" name="scripts/peardev.sh" />
   <install as="pecl" name="scripts/pecl.sh" />
   <install as="pearcmd.php" name="scripts/pearcmd.php" />
   <install as="peclcmd.php" name="scripts/peclcmd.php" />
   <ignore name="scripts/pear.bat" />
   <ignore name="scripts/peardev.bat" />
   <ignore name="scripts/pecl.bat" />
  </filelist>
 </phprelease>
 <changelog>
  <release>
   <version>
    <release>1.6.2</release>
    <api>1.6.0</api>
   </version>
   <stability>
    <release>stable</release>
    <api>stable</api>
   </stability>
   <date>2007-09-09</date>
   <license uri="http://www.php.net/license">PHP License</license>
   <notes>
  Minor bugfix release
  * fix Bug #11420: warning on pecl (un)install with --register-only option [cellog]
  * fix Bug #11481: PEAR_PackageFile_Parser_v1 skips single-char directories [pmjones]
  * fix Bug #11517: Error : download directory &quot;/var/cache/php-pear&quot;
    is not writeable. [remicollet]
  * fix Bug #11616: Incorrect equality operator used when comparing md5 check sums [robham]
  * fix Bug #11642: PEAR fails to authenticate when downloading deps from non-default
    channels [timj]
  * fix Bug #11657: Installer generate bad "dirtree" using INSTALL_ROOT [remicollet]
  * fix Bug #11678: Registry.php getChannel() deadlocks [cellog]
  * fix Bug #11703: pear convert and package.xml with optional dependencies fails [cellog]
  * fix Bug #11754: Error at upgrade-all command run [cellog]
  * fix Bug #11861: uninstall of package did not delete directory created during install
    of package [cellog]
  * fix Bug #11862: Notice: Array to string conversion in PEAR/PackageFile.php on line 433
    [cellog]
  * fix Bug #11883: run-tests -u -p SomePackage should run the topmost
    &quot;AllTests.php&quot; file [cellog]
  * fix Bug #11936: run-tests fails to preserve SYSTEMROOT environment variable [cellog]
   </notes>
  </release>
 </changelog>
</package>
<?php
include dirname(__FILE__) . '/../test_framework.php.inc';
$parser = new PEAR2_Pyrus_PackageFile_Parser_v2;
class Mockv2 extends PEAR2_Pyrus_PackageFile_v2
{
    public $arr;
    public $filelist;
    public $baseinstalls;
    public $packagefile;

    function setFilelist($list)
    {
        $this->filelist = $list;
    }

    function setBaseInstallDirs($dirs)
    {
        $this->baseinstalls = $dirs;
    }

    function setPackageFile($file)
    {
        $this->packagefile = $file;
    }

    function getThingy()
    {
        return array(
            'filelist' => $this->filelist,
            'baseinstalls' => $this->baseinstalls,
            'packagefile' => $this->packagefile,
            'packageinfo' => $this->packageInfo);
    }
}--TEST--
packagefile parser for package.xml 2.0
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$pxml = dirname(__FILE__) . '/packages/package2.xml';
$ret = $parser->parse(file_get_contents($pxml), $pxml, 'Mockv2');
$test->assertEquals(array (
  'filelist' => 
  array (
    'OS/Guess.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Guess.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/ChannelFile/Parser.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Parser.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command/Auth.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Auth.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Command/Auth.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Auth.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command/Build.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Build.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Command/Build.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Build.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command/Channels.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Channels.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Command/Channels.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Channels.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command/Common.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Common.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command/Config.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Config.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Command/Config.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Config.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command/Install.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Install.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Command/Install.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Install.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command/Mirror.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Mirror.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Command/Mirror.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Mirror.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command/Package.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Package.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Command/Package.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Package.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'from' => '@DATA-DIR@',
            'to' => 'data_dir',
            'type' => 'pear-config',
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'from' => '@package_version@',
            'to' => 'version',
            'type' => 'package-info',
          ),
        ),
      ),
    ),
    'PEAR/Command/Pickle.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Pickle.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Command/Pickle.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Pickle.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command/Registry.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Registry.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Command/Registry.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Registry.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command/Remote.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Remote.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Command/Remote.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Remote.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command/Test.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Test.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Command/Test.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Test.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Downloader/Package.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Package.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@PEAR-VER@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Frontend/CLI.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'CLI.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Installer/Role/Common.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Common.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Installer/Role/Data.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Data.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Installer/Role/Data.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Data.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Installer/Role/Doc.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Doc.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Installer/Role/Doc.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Doc.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Installer/Role/Ext.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Ext.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Installer/Role/Ext.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Ext.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Installer/Role/Php.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Php.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Installer/Role/Php.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Php.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Installer/Role/Script.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Script.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Installer/Role/Script.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Script.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Installer/Role/Src.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Src.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Installer/Role/Src.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Src.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Installer/Role/Test.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Test.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Installer/Role/Test.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Test.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Installer/Role/Www.xml' => 
    array (
      'attribs' => 
      array (
        'name' => 'Www.xml',
        'role' => 'php',
      ),
    ),
    'PEAR/Installer/Role/Www.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Www.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Installer/Role.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Role.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/PackageFile/Generator/v1.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'v1.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@PEAR-VER@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/PackageFile/Generator/v2.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'v2.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@PEAR-VER@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/PackageFile/Parser/v1.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'v1.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/PackageFile/Parser/v2.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'v2.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/PackageFile/v2/rw.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'rw.php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/PackageFile/v2/Validator.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Validator.php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/PackageFile/v1.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'v1.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/PackageFile/v2.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'v2.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/REST/10.php' => 
    array (
      'attribs' => 
      array (
        'name' => '10.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/REST/11.php' => 
    array (
      'attribs' => 
      array (
        'name' => '11.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/REST/13.php' => 
    array (
      'attribs' => 
      array (
        'name' => '13.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Task/Postinstallscript/rw.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'rw.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Task/Replace/rw.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'rw.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Task/Unixeol/rw.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'rw.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Task/Windowseol/rw.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'rw.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Task/Common.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Common.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Task/Postinstallscript.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Postinstallscript.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Task/Replace.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Replace.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Task/Unixeol.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Unixeol.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Task/Windowseol.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Windowseol.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Validator/PECL.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'PECL.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Autoloader.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Autoloader.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Builder.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Builder.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@PEAR-VER@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/ChannelFile.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'ChannelFile.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Command.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Command.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Common.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Common.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Config.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Config.php',
         'role' => 'php',
       ),
       'tasks:replace' => 
       array (
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Dependency.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Dependency.php',
        'role' => 'php',
      ),
    ),
    'PEAR/DependencyDB.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'DependencyDB.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Dependency2.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Dependency2.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@PEAR-VER@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Downloader.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Downloader.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/ErrorStack.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'ErrorStack.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Exception.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Exception.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Frontend.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Frontend.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Installer.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Installer.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/PackageFile.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'PackageFile.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@PEAR-VER@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Packager.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Packager.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Registry.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Registry.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Remote.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Remote.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/REST.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'REST.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/RunTest.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'RunTest.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/Validate.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'Validate.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'PEAR/XMLParser.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'XMLParser.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'scripts/pear.bat' => 
    array (
      'attribs' => 
      array (
        'name' => 'pear.bat',
        'role' => 'script',
      ),
      'tasks:replace' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'from' => '@bin_dir@',
            'to' => 'bin_dir',
            'type' => 'pear-config',
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_bin@',
            'to' => 'php_bin',
            'type' => 'pear-config',
          ),
        ),
        2 => 
        array (
          'attribs' => 
          array (
            'from' => '@include_path@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
      ),
      'tasks:windowseol' => '',
    ),
    'scripts/peardev.bat' => 
    array (
      'attribs' => 
      array (
        'name' => 'peardev.bat',
        'role' => 'script',
      ),
      'tasks:replace' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'from' => '@bin_dir@',
            'to' => 'bin_dir',
            'type' => 'pear-config',
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_bin@',
            'to' => 'php_bin',
            'type' => 'pear-config',
          ),
        ),
        2 => 
        array (
          'attribs' => 
          array (
            'from' => '@include_path@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
      ),
      'tasks:windowseol' => '',
    ),
    'scripts/pecl.bat' => 
    array (
      'attribs' => 
      array (
        'name' => 'pecl.bat',
        'role' => 'script',
      ),
      'tasks:replace' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'from' => '@bin_dir@',
            'to' => 'bin_dir',
            'type' => 'pear-config',
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_bin@',
            'to' => 'php_bin',
            'type' => 'pear-config',
          ),
        ),
        2 => 
        array (
          'attribs' => 
          array (
            'from' => '@include_path@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
      ),
      'tasks:windowseol' => '',
    ),
    'scripts/pear.sh' => 
    array (
      'attribs' => 
      array (
        'name' => 'pear.sh',
        'role' => 'script',
      ),
      'tasks:replace' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_bin@',
            'to' => 'php_bin',
            'type' => 'pear-config',
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_dir@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
        2 => 
        array (
          'attribs' => 
          array (
            'from' => '@pear_version@',
            'to' => 'version',
            'type' => 'package-info',
          ),
        ),
        3 => 
        array (
          'attribs' => 
          array (
            'from' => '@include_path@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
      ),
      'tasks:unixeol' => '',
    ),
    'scripts/peardev.sh' => 
    array (
      'attribs' => 
      array (
        'name' => 'peardev.sh',
        'role' => 'script',
      ),
      'tasks:replace' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_bin@',
            'to' => 'php_bin',
            'type' => 'pear-config',
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_dir@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
        2 => 
        array (
          'attribs' => 
          array (
            'from' => '@pear_version@',
            'to' => 'version',
            'type' => 'package-info',
          ),
        ),
        3 => 
        array (
          'attribs' => 
          array (
            'from' => '@include_path@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
      ),
      'tasks:unixeol' => '',
    ),
    'scripts/pecl.sh' => 
    array (
      'attribs' => 
      array (
        'name' => 'pecl.sh',
        'role' => 'script',
      ),
      'tasks:replace' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_bin@',
            'to' => 'php_bin',
            'type' => 'pear-config',
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_dir@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
        2 => 
        array (
          'attribs' => 
          array (
            'from' => '@pear_version@',
            'to' => 'version',
            'type' => 'package-info',
          ),
        ),
        3 => 
        array (
          'attribs' => 
          array (
            'from' => '@include_path@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
      ),
      'tasks:unixeol' => '',
    ),
    'scripts/pearcmd.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'pearcmd.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_bin@',
            'to' => 'php_bin',
            'type' => 'pear-config',
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_dir@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
        2 => 
        array (
          'attribs' => 
          array (
            'from' => '@pear_version@',
            'to' => 'version',
            'type' => 'package-info',
          ),
        ),
        3 => 
        array (
          'attribs' => 
          array (
            'from' => '@include_path@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
      ),
    ),
    'scripts/peclcmd.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'peclcmd.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_bin@',
            'to' => 'php_bin',
            'type' => 'pear-config',
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'from' => '@php_dir@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
        2 => 
        array (
          'attribs' => 
          array (
            'from' => '@pear_version@',
            'to' => 'version',
            'type' => 'package-info',
          ),
        ),
        3 => 
        array (
          'attribs' => 
          array (
            'from' => '@include_path@',
            'to' => 'php_dir',
            'type' => 'pear-config',
          ),
        ),
      ),
    ),
    'INSTALL' => 
    array (
      'attribs' => 
      array (
        'name' => 'INSTALL',
        'role' => 'doc',
      ),
    ),
    'package.dtd' => 
    array (
      'attribs' => 
      array (
        'name' => 'package.dtd',
        'role' => 'data',
      ),
    ),
    'PEAR.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'PEAR.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'README' => 
    array (
      'attribs' => 
      array (
        'name' => 'README',
        'role' => 'doc',
      ),
    ),
    'System.php' => 
    array (
      'attribs' => 
      array (
        'name' => 'System.php',
        'role' => 'php',
      ),
      'tasks:replace' => 
      array (
        'attribs' => 
        array (
          'from' => '@package_version@',
          'to' => 'version',
          'type' => 'package-info',
        ),
      ),
    ),
    'template.spec' => 
    array (
      'attribs' => 
      array (
        'name' => 'template.spec',
        'role' => 'data',
      ),
    ),
  ),
  'baseinstalls' => 
  array (
    'scripts' => '/',
  ),
  'packagefile' => dirname(__FILE__) . '/packages/package2.xml',
  'packageinfo' => 
  array (
    'attribs' => 
    array (
      'xmlns' => 'http://pear.php.net/dtd/package-2.0',
      'xmlns:tasks' => 'http://pear.php.net/dtd/tasks-1.0',
      'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
      'version' => '2.0',
      'xsi:schemaLocation' => 'http://pear.php.net/dtd/tasks-1.0 http://pear.php.net/dtd/tasks-1.0.xsd http://pear.php.net/dtd/package-2.0 http://pear.php.net/dtd/package-2.0.xsd',
    ),
    'name' => 'PEAR',
    'channel' => 'pear.php.net',
    'summary' => 'PEAR Base System',
    'description' => 'The PEAR package contains:
 * the PEAR installer, for creating, distributing
   and installing packages
 * the PEAR_Exception PHP5 error handling mechanism
 * the PEAR_ErrorStack advanced error handling mechanism
 * the PEAR_Error error handling mechanism
 * the OS_Guess class for retrieving info about the OS
   where PHP is running on
 * the System class for quick handling of common operations
   with files and directories
 * the PEAR base class

  Features in a nutshell:
  * full support for channels
  * pre-download dependency validation
  * new package.xml 2.0 format allows tremendous flexibility while maintaining BC
  * support for optional dependency groups and limited support for sub-packaging
  * robust dependency support
  * full dependency validation on uninstall
  * remote install for hosts with only ftp access - no more problems with
    restricted host installation
  * full support for mirroring
  * support for bundling several packages into a single tarball
  * support for static dependencies on a url-based package
  * support for custom file roles and installation tasks
 ',
    'lead' => 
    array (
      0 => 
      array (
        'name' => 'Greg Beaver',
        'user' => 'cellog',
        'email' => 'cellog@php.net',
        'active' => 'yes',
      ),
      1 => 
      array (
        'name' => 'Pierre-Alain Joye',
        'user' => 'pajoye',
        'email' => 'pierre@php.net',
        'active' => 'no',
      ),
      2 => 
      array (
        'name' => 'Stig Bakken',
        'user' => 'ssb',
        'email' => 'stig@php.net',
        'active' => 'no',
      ),
      3 => 
      array (
        'name' => 'Tomas V.V.Cox',
        'user' => 'cox',
        'email' => 'cox@idecnet.com',
        'active' => 'no',
      ),
    ),
    'developer' => 
    array (
      0 => 
      array (
        'name' => 'Helgi Thormar',
        'user' => 'dufuz',
        'email' => 'dufuz@php.net',
        'active' => 'yes',
      ),
      1 => 
      array (
        'name' => 'Tias Guns',
        'user' => 'tias',
        'email' => 'tias@php.net',
        'active' => 'yes',
      ),
    ),
    'helper' => 
    array (
      0 => 
      array (
        'name' => 'Tim Jackson',
        'user' => 'timj',
        'email' => 'timj@php.net',
        'active' => 'no',
      ),
      1 => 
      array (
        'name' => 'Bertrand Gugger',
        'user' => 'toggg',
        'email' => 'toggg@php.net',
        'active' => 'no',
      ),
      2 => 
      array (
        'name' => 'Martin Jansen',
        'user' => 'mj',
        'email' => 'mj@php.net',
        'active' => 'no',
      ),
    ),
    'date' => '2007-10-01',
    'version' => 
    array (
      'release' => '1.7.0',
      'api' => '1.7.0',
    ),
    'stability' => 
    array (
      'release' => 'stable',
      'api' => 'stable',
    ),
    'license' => 
    array (
      'attribs' => 
      array (
        'uri' => 'http://www.php.net/license',
      ),
      '_content' => 'PHP License',
    ),
    'notes' => '
  * implement Request #11964: introduce www role, www_dir config variable [cellog]
 ',
    'contents' => 
    array (
      'dir' => 
      array (
        'attribs' => 
        array (
          'name' => '/',
        ),
        'dir' => 
        array (
          0 => 
          array (
            'attribs' => 
            array (
              'name' => 'OS',
            ),
            'file' => 
            array (
              'attribs' => 
              array (
                'name' => 'Guess.php',
                'role' => 'php',
              ),
              'tasks:replace' => 
              array (
                'attribs' => 
                array (
                  'from' => '@package_version@',
                  'to' => 'version',
                  'type' => 'package-info',
                ),
              ),
            ),
          ),
          1 => 
          array (
            'attribs' => 
            array (
              'name' => 'PEAR',
            ),
            'dir' => 
            array (
              0 => 
              array (
                'attribs' => 
                array (
                  'name' => 'ChannelFile',
                ),
                'file' => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Parser.php',
                    'role' => 'php',
                  ),
                  'tasks:replace' => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@package_version@',
                      'to' => 'version',
                      'type' => 'package-info',
                    ),
                  ),
                ),
              ),
              1 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Command',
                ),
                'file' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Auth.xml',
                      'role' => 'php',
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Auth.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Build.xml',
                      'role' => 'php',
                    ),
                  ),
                  3 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Build.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  4 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Channels.xml',
                      'role' => 'php',
                    ),
                  ),
                  5 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Channels.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  6 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Common.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  7 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Config.xml',
                      'role' => 'php',
                    ),
                  ),
                  8 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Config.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  9 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Install.xml',
                      'role' => 'php',
                    ),
                  ),
                  10 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Install.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  11 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Mirror.xml',
                      'role' => 'php',
                    ),
                  ),
                  12 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Mirror.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  13 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Package.xml',
                      'role' => 'php',
                    ),
                  ),
                  14 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Package.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      0 => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@DATA-DIR@',
                          'to' => 'data_dir',
                          'type' => 'pear-config',
                        ),
                      ),
                      1 => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                  ),
                  15 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Pickle.xml',
                      'role' => 'php',
                    ),
                  ),
                  16 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Pickle.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  17 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Registry.xml',
                      'role' => 'php',
                    ),
                  ),
                  18 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Registry.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  19 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Remote.xml',
                      'role' => 'php',
                    ),
                  ),
                  20 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Remote.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  21 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Test.xml',
                      'role' => 'php',
                    ),
                  ),
                  22 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Test.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                ),
              ),
              2 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Downloader',
                ),
                'file' => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Package.php',
                    'role' => 'php',
                  ),
                  'tasks:replace' => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@PEAR-VER@',
                      'to' => 'version',
                      'type' => 'package-info',
                    ),
                  ),
                ),
              ),
              3 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Frontend',
                ),
                'file' => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'CLI.php',
                    'role' => 'php',
                  ),
                  'tasks:replace' => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@package_version@',
                      'to' => 'version',
                      'type' => 'package-info',
                    ),
                  ),
                ),
              ),
              4 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Installer',
                ),
                'dir' => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Role',
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Common.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Data.xml',
                        'role' => 'php',
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Data.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                    3 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Doc.xml',
                        'role' => 'php',
                      ),
                    ),
                    4 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Doc.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                    5 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Ext.xml',
                        'role' => 'php',
                      ),
                    ),
                    6 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Ext.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                    7 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Php.xml',
                        'role' => 'php',
                      ),
                    ),
                    8 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Php.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                    9 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Script.xml',
                        'role' => 'php',
                      ),
                    ),
                    10 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Script.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                    11 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Src.xml',
                        'role' => 'php',
                      ),
                    ),
                    12 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Src.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                    13 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Test.xml',
                        'role' => 'php',
                      ),
                    ),
                    14 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Test.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                    15 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Www.xml',
                        'role' => 'php',
                      ),
                    ),
                    16 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Www.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                  ),
                ),
                'file' => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Role.php',
                    'role' => 'php',
                  ),
                  'tasks:replace' => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@package_version@',
                      'to' => 'version',
                      'type' => 'package-info',
                    ),
                  ),
                ),
              ),
              5 => 
              array (
                'attribs' => 
                array (
                  'name' => 'PackageFile',
                ),
                'dir' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Generator',
                    ),
                    'file' => 
                    array (
                      0 => 
                      array (
                        'attribs' => 
                        array (
                          'name' => 'v1.php',
                          'role' => 'php',
                        ),
                        'tasks:replace' => 
                        array (
                          'attribs' => 
                          array (
                            'from' => '@PEAR-VER@',
                            'to' => 'version',
                            'type' => 'package-info',
                          ),
                        ),
                      ),
                      1 => 
                      array (
                        'attribs' => 
                        array (
                          'name' => 'v2.php',
                          'role' => 'php',
                        ),
                        'tasks:replace' => 
                        array (
                          'attribs' => 
                          array (
                            'from' => '@PEAR-VER@',
                            'to' => 'version',
                            'type' => 'package-info',
                          ),
                        ),
                      ),
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Parser',
                    ),
                    'file' => 
                    array (
                      0 => 
                      array (
                        'attribs' => 
                        array (
                          'name' => 'v1.php',
                          'role' => 'php',
                        ),
                        'tasks:replace' => 
                        array (
                          'attribs' => 
                          array (
                            'from' => '@package_version@',
                            'to' => 'version',
                            'type' => 'package-info',
                          ),
                        ),
                      ),
                      1 => 
                      array (
                        'attribs' => 
                        array (
                          'name' => 'v2.php',
                          'role' => 'php',
                        ),
                        'tasks:replace' => 
                        array (
                          'attribs' => 
                          array (
                            'from' => '@package_version@',
                            'to' => 'version',
                            'type' => 'package-info',
                          ),
                        ),
                      ),
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'v2',
                    ),
                    'file' => 
                    array (
                      0 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'rw.php',
                        ),
                        'tasks:replace' => 
                        array (
                          'attribs' => 
                          array (
                            'from' => '@package_version@',
                            'to' => 'version',
                            'type' => 'package-info',
                          ),
                        ),
                      ),
                      1 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Validator.php',
                        ),
                        'tasks:replace' => 
                        array (
                          'attribs' => 
                          array (
                            'from' => '@package_version@',
                            'to' => 'version',
                            'type' => 'package-info',
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
                'file' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'v1.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'v2.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                ),
              ),
              6 => 
              array (
                'attribs' => 
                array (
                  'name' => 'REST',
                ),
                'file' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => '10.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => '11.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => '13.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                ),
              ),
              7 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Task',
                ),
                'dir' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Postinstallscript',
                    ),
                    'file' => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'rw.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Replace',
                    ),
                    'file' => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'rw.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Unixeol',
                    ),
                    'file' => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'rw.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                  ),
                  3 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Windowseol',
                    ),
                    'file' => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'rw.php',
                        'role' => 'php',
                      ),
                      'tasks:replace' => 
                      array (
                        'attribs' => 
                        array (
                          'from' => '@package_version@',
                          'to' => 'version',
                          'type' => 'package-info',
                        ),
                      ),
                    ),
                  ),
                ),
                'file' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Common.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Postinstallscript.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Replace.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  3 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Unixeol.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                  4 => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Windowseol.php',
                      'role' => 'php',
                    ),
                    'tasks:replace' => 
                    array (
                      'attribs' => 
                      array (
                        'from' => '@package_version@',
                        'to' => 'version',
                        'type' => 'package-info',
                      ),
                    ),
                  ),
                ),
              ),
              8 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Validator',
                ),
                'file' => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'PECL.php',
                    'role' => 'php',
                  ),
                  'tasks:replace' => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@package_version@',
                      'to' => 'version',
                      'type' => 'package-info',
                    ),
                  ),
                ),
              ),
            ),
            'file' => 
            array (
              0 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Autoloader.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              1 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Builder.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@PEAR-VER@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              2 => 
              array (
                'attribs' => 
                array (
                  'name' => 'ChannelFile.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              3 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Command.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              4 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Common.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              5 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Config.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              6 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Dependency.php',
                  'role' => 'php',
                ),
              ),
              7 => 
              array (
                'attribs' => 
                array (
                  'name' => 'DependencyDB.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              8 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Dependency2.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@PEAR-VER@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              9 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Downloader.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              10 => 
              array (
                'attribs' => 
                array (
                  'name' => 'ErrorStack.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              11 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Exception.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              12 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Frontend.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              13 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Installer.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              14 => 
              array (
                'attribs' => 
                array (
                  'name' => 'PackageFile.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@PEAR-VER@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              15 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Packager.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              16 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Registry.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              17 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Remote.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              18 => 
              array (
                'attribs' => 
                array (
                  'name' => 'REST.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              19 => 
              array (
                'attribs' => 
                array (
                  'name' => 'RunTest.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              20 => 
              array (
                'attribs' => 
                array (
                  'name' => 'Validate.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
              21 => 
              array (
                'attribs' => 
                array (
                  'name' => 'XMLParser.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  'attribs' => 
                  array (
                    'from' => '@package_version@',
                    'to' => 'version',
                    'type' => 'package-info',
                  ),
                ),
              ),
            ),
          ),
          2 => 
          array (
            'attribs' => 
            array (
              'name' => 'scripts',
              'baseinstalldir' => '/',
            ),
            'file' => 
            array (
              0 => 
              array (
                'attribs' => 
                array (
                  'name' => 'pear.bat',
                  'role' => 'script',
                ),
                'tasks:replace' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@bin_dir@',
                      'to' => 'bin_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_bin@',
                      'to' => 'php_bin',
                      'type' => 'pear-config',
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@include_path@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                ),
                'tasks:windowseol' => '',
              ),
              1 => 
              array (
                'attribs' => 
                array (
                  'name' => 'peardev.bat',
                  'role' => 'script',
                ),
                'tasks:replace' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@bin_dir@',
                      'to' => 'bin_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_bin@',
                      'to' => 'php_bin',
                      'type' => 'pear-config',
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@include_path@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                ),
                'tasks:windowseol' => '',
              ),
              2 => 
              array (
                'attribs' => 
                array (
                  'name' => 'pecl.bat',
                  'role' => 'script',
                ),
                'tasks:replace' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@bin_dir@',
                      'to' => 'bin_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_bin@',
                      'to' => 'php_bin',
                      'type' => 'pear-config',
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@include_path@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                ),
                'tasks:windowseol' => '',
              ),
              3 => 
              array (
                'attribs' => 
                array (
                  'name' => 'pear.sh',
                  'role' => 'script',
                ),
                'tasks:replace' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_bin@',
                      'to' => 'php_bin',
                      'type' => 'pear-config',
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_dir@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@pear_version@',
                      'to' => 'version',
                      'type' => 'package-info',
                    ),
                  ),
                  3 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@include_path@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                ),
                'tasks:unixeol' => '',
              ),
              4 => 
              array (
                'attribs' => 
                array (
                  'name' => 'peardev.sh',
                  'role' => 'script',
                ),
                'tasks:replace' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_bin@',
                      'to' => 'php_bin',
                      'type' => 'pear-config',
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_dir@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@pear_version@',
                      'to' => 'version',
                      'type' => 'package-info',
                    ),
                  ),
                  3 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@include_path@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                ),
                'tasks:unixeol' => '',
              ),
              5 => 
              array (
                'attribs' => 
                array (
                  'name' => 'pecl.sh',
                  'role' => 'script',
                ),
                'tasks:replace' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_bin@',
                      'to' => 'php_bin',
                      'type' => 'pear-config',
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_dir@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@pear_version@',
                      'to' => 'version',
                      'type' => 'package-info',
                    ),
                  ),
                  3 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@include_path@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                ),
                'tasks:unixeol' => '',
              ),
              6 => 
              array (
                'attribs' => 
                array (
                  'name' => 'pearcmd.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_bin@',
                      'to' => 'php_bin',
                      'type' => 'pear-config',
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_dir@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@pear_version@',
                      'to' => 'version',
                      'type' => 'package-info',
                    ),
                  ),
                  3 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@include_path@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                ),
              ),
              7 => 
              array (
                'attribs' => 
                array (
                  'name' => 'peclcmd.php',
                  'role' => 'php',
                ),
                'tasks:replace' => 
                array (
                  0 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_bin@',
                      'to' => 'php_bin',
                      'type' => 'pear-config',
                    ),
                  ),
                  1 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@php_dir@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                  2 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@pear_version@',
                      'to' => 'version',
                      'type' => 'package-info',
                    ),
                  ),
                  3 => 
                  array (
                    'attribs' => 
                    array (
                      'from' => '@include_path@',
                      'to' => 'php_dir',
                      'type' => 'pear-config',
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
        'file' => 
        array (
          0 => 
          array (
            'attribs' => 
            array (
              'name' => 'INSTALL',
              'role' => 'doc',
            ),
          ),
          1 => 
          array (
            'attribs' => 
            array (
              'name' => 'package.dtd',
              'role' => 'data',
            ),
          ),
          2 => 
          array (
            'attribs' => 
            array (
              'name' => 'PEAR.php',
              'role' => 'php',
            ),
            'tasks:replace' => 
            array (
              'attribs' => 
              array (
                'from' => '@package_version@',
                'to' => 'version',
                'type' => 'package-info',
              ),
            ),
          ),
          3 => 
          array (
            'attribs' => 
            array (
              'name' => 'README',
              'role' => 'doc',
            ),
          ),
          4 => 
          array (
            'attribs' => 
            array (
              'name' => 'System.php',
              'role' => 'php',
            ),
            'tasks:replace' => 
            array (
              'attribs' => 
              array (
                'from' => '@package_version@',
                'to' => 'version',
                'type' => 'package-info',
              ),
            ),
          ),
          5 => 
          array (
            'attribs' => 
            array (
              'name' => 'template.spec',
              'role' => 'data',
            ),
          ),
        ),
      ),
    ),
    'dependencies' => 
    array (
      'required' => 
      array (
        'php' => 
        array (
          'min' => '4.3.0',
        ),
        'pearinstaller' => 
        array (
          'min' => '1.4.3',
        ),
        'package' => 
        array (
          0 => 
          array (
            'name' => 'Archive_Tar',
            'channel' => 'pear.php.net',
            'min' => '1.1',
            'recommended' => '1.3.2',
            'exclude' => '1.3.0',
          ),
          1 => 
          array (
            'name' => 'Structures_Graph',
            'channel' => 'pear.php.net',
            'min' => '1.0.2',
            'recommended' => '1.0.2',
          ),
          2 => 
          array (
            'name' => 'Console_Getopt',
            'channel' => 'pear.php.net',
            'min' => '1.2',
            'recommended' => '1.2.3',
          ),
          3 => 
          array (
            'name' => 'PEAR_Frontend_Web',
            'channel' => 'pear.php.net',
            'max' => '0.4',
            'conflicts' => '',
          ),
          4 => 
          array (
            'name' => 'PEAR_Frontend_Gtk',
            'channel' => 'pear.php.net',
            'max' => '0.4.0',
            'exclude' => '0.4.0',
            'conflicts' => '',
          ),
        ),
        'extension' => 
        array (
          0 => 
          array (
            'name' => 'xml',
          ),
          1 => 
          array (
            'name' => 'pcre',
          ),
        ),
      ),
      'optional' => 
      array (
        'package' => 
        array (
          'name' => 'XML_RPC',
          'channel' => 'pear.php.net',
          'min' => '1.4.0',
        ),
      ),
      'group' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'name' => 'webinstaller',
            'hint' => 'PEAR\'s web-based installer',
          ),
          'package' => 
          array (
            'name' => 'PEAR_Frontend_Web',
            'channel' => 'pear.php.net',
            'min' => '0.5.1',
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'name' => 'gtkinstaller',
            'hint' => 'PEAR\'s PHP-GTK-based installer',
          ),
          'package' => 
          array (
            'name' => 'PEAR_Frontend_Gtk',
            'channel' => 'pear.php.net',
            'min' => '0.4.0',
          ),
        ),
        2 => 
        array (
          'attribs' => 
          array (
            'name' => 'gtk2installer',
            'hint' => 'PEAR\'s PHP-GTK2-based installer',
          ),
          'package' => 
          array (
            'name' => 'PEAR_Frontend_Gtk2',
            'channel' => 'pear.php.net',
          ),
        ),
      ),
    ),
    'phprelease' => 
    array (
      0 => 
      array (
        'installconditions' => 
        array (
          'os' => 
          array (
            'name' => 'windows',
          ),
        ),
        'filelist' => 
        array (
          'install' => 
          array (
            0 => 
            array (
              'attribs' => 
              array (
                'as' => 'pear.bat',
                'name' => 'scripts/pear.bat',
              ),
            ),
            1 => 
            array (
              'attribs' => 
              array (
                'as' => 'peardev.bat',
                'name' => 'scripts/peardev.bat',
              ),
            ),
            2 => 
            array (
              'attribs' => 
              array (
                'as' => 'pecl.bat',
                'name' => 'scripts/pecl.bat',
              ),
            ),
            3 => 
            array (
              'attribs' => 
              array (
                'as' => 'pearcmd.php',
                'name' => 'scripts/pearcmd.php',
              ),
            ),
            4 => 
            array (
              'attribs' => 
              array (
                'as' => 'peclcmd.php',
                'name' => 'scripts/peclcmd.php',
              ),
            ),
          ),
          'ignore' => 
          array (
            0 => 
            array (
              'attribs' => 
              array (
                'name' => 'scripts/peardev.sh',
              ),
            ),
            1 => 
            array (
              'attribs' => 
              array (
                'name' => 'scripts/pear.sh',
              ),
            ),
            2 => 
            array (
              'attribs' => 
              array (
                'name' => 'scripts/pecl.sh',
              ),
            ),
          ),
        ),
      ),
      1 => 
      array (
        'filelist' => 
        array (
          'install' => 
          array (
            0 => 
            array (
              'attribs' => 
              array (
                'as' => 'pear',
                'name' => 'scripts/pear.sh',
              ),
            ),
            1 => 
            array (
              'attribs' => 
              array (
                'as' => 'peardev',
                'name' => 'scripts/peardev.sh',
              ),
            ),
            2 => 
            array (
              'attribs' => 
              array (
                'as' => 'pecl',
                'name' => 'scripts/pecl.sh',
              ),
            ),
            3 => 
            array (
              'attribs' => 
              array (
                'as' => 'pearcmd.php',
                'name' => 'scripts/pearcmd.php',
              ),
            ),
            4 => 
            array (
              'attribs' => 
              array (
                'as' => 'peclcmd.php',
                'name' => 'scripts/peclcmd.php',
              ),
            ),
          ),
          'ignore' => 
          array (
            0 => 
            array (
              'attribs' => 
              array (
                'name' => 'scripts/pear.bat',
              ),
            ),
            1 => 
            array (
              'attribs' => 
              array (
                'name' => 'scripts/peardev.bat',
              ),
            ),
            2 => 
            array (
              'attribs' => 
              array (
                'name' => 'scripts/pecl.bat',
              ),
            ),
          ),
        ),
      ),
    ),
    'changelog' => 
    array (
      'release' => 
      array (
        'version' => 
        array (
          'release' => '1.6.2',
          'api' => '1.6.0',
        ),
        'stability' => 
        array (
          'release' => 'stable',
          'api' => 'stable',
        ),
        'date' => '2007-09-09',
        'license' => 
        array (
          'attribs' => 
          array (
            'uri' => 'http://www.php.net/license',
          ),
          '_content' => 'PHP License',
        ),
        'notes' => '
  Minor bugfix release
  * fix Bug #11420: warning on pecl (un)install with --register-only option [cellog]
  * fix Bug #11481: PEAR_PackageFile_Parser_v1 skips single-char directories [pmjones]
  * fix Bug #11517: Error : download directory "/var/cache/php-pear"
    is not writeable. [remicollet]
  * fix Bug #11616: Incorrect equality operator used when comparing md5 check sums [robham]
  * fix Bug #11642: PEAR fails to authenticate when downloading deps from non-default
    channels [timj]
  * fix Bug #11657: Installer generate bad "dirtree" using INSTALL_ROOT [remicollet]
  * fix Bug #11678: Registry.php getChannel() deadlocks [cellog]
  * fix Bug #11703: pear convert and package.xml with optional dependencies fails [cellog]
  * fix Bug #11754: Error at upgrade-all command run [cellog]
  * fix Bug #11861: uninstall of package did not delete directory created during install
    of package [cellog]
  * fix Bug #11862: Notice: Array to string conversion in PEAR/PackageFile.php on line 433
    [cellog]
  * fix Bug #11883: run-tests -u -p SomePackage should run the topmost
    "AllTests.php" file [cellog]
  * fix Bug #11936: run-tests fails to preserve SYSTEMROOT environment variable [cellog]
   ',
      ),
    ),
  ),
), $ret->getThingy(), 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
packagefile parser for package.xml 2.1
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$pxml = dirname(__FILE__) . '/packages/package.xml';
$ret = $parser->parse(file_get_contents($pxml), $pxml, 'Mockv2');
$test->assertEquals(array (
  'filelist' => 
  array (
    'data/channel-1.0.xsd' => 
    array (
      'attribs' => 
      array (
        'role' => 'data',
        'name' => 'channel-1.0.xsd',
      ),
    ),
    'data/package-2.0.xsd' => 
    array (
      'attribs' => 
      array (
        'role' => 'data',
        'name' => 'package-2.0.xsd',
      ),
    ),
    'data/package-2.1.xsd' => 
    array (
      'attribs' => 
      array (
        'role' => 'data',
        'name' => 'package-2.1.xsd',
      ),
    ),
    'src/Pyrus/Channel/Base.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Base.php',
      ),
    ),
    'src/Pyrus/Channel/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Channel/IMirror.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'IMirror.php',
      ),
    ),
    'src/Pyrus/Channel/Mirror.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Mirror.php',
      ),
    ),
    'src/Pyrus/ChannelRegistry/Channel/Sqlite.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Sqlite.php',
      ),
    ),
    'src/Pyrus/ChannelRegistry/Channel/Xml.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Xml.php',
      ),
    ),
    'src/Pyrus/ChannelRegistry/Mirror/Sqlite.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Sqlite.php',
      ),
    ),
    'src/Pyrus/ChannelRegistry/Mirror/Xml.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Xml.php',
      ),
    ),
    'src/Pyrus/ChannelRegistry/Channel/Xml.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Xml.php',
      ),
    ),
    'src/Pyrus/ChannelRegistry/Base.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Base.php',
      ),
    ),
    'src/Pyrus/ChannelRegistry/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/ChannelRegistry/Sqlite.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Sqlite.php',
      ),
    ),
    'src/Pyrus/ChannelRegistry/Xml.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Xml.php',
      ),
    ),
    'src/Pyrus/Config/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Dependency/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Dependency/Validator.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Validator.php',
      ),
    ),
    'src/Pyrus/DirectedGraph/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/DirectedGraph/Vertex.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Vertex.php',
      ),
    ),
    'src/Pyrus/FileTransactions/Installedas.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Installedas.php',
      ),
    ),
    'src/Pyrus/FileTransactions/Rename.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Rename.php',
      ),
    ),
    'src/Pyrus/FileTransactions/Rmdir.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Rmdir.php',
      ),
    ),
    'src/Pyrus/Installer/Role/Common.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Common.php',
      ),
    ),
    'src/Pyrus/Installer/Role/Data.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Data.php',
      ),
    ),
    'src/Pyrus/Installer/Role/Data.xml' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Data.xml',
      ),
    ),
    'src/Pyrus/Installer/Role/Doc.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Doc.php',
      ),
    ),
    'src/Pyrus/Installer/Role/Doc.xml' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Doc.xml',
      ),
    ),
    'src/Pyrus/Installer/Role/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Installer/Role/Ext.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Ext.php',
      ),
    ),
    'src/Pyrus/Installer/Role/Ext.xml' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Ext.xml',
      ),
    ),
    'src/Pyrus/Installer/Role/Php.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Php.php',
      ),
    ),
    'src/Pyrus/Installer/Role/Php.xml' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Php.xml',
      ),
    ),
    'src/Pyrus/Installer/Role/Script.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Script.php',
      ),
    ),
    'src/Pyrus/Installer/Role/Script.xml' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Script.xml',
      ),
    ),
    'src/Pyrus/Installer/Role/Src.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Src.php',
      ),
    ),
    'src/Pyrus/Installer/Role/Src.xml' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Src.xml',
      ),
    ),
    'src/Pyrus/Installer/Role/Test.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Test.php',
      ),
    ),
    'src/Pyrus/Installer/Role/Test.xml' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Test.xml',
      ),
    ),
    'src/Pyrus/Installer/Role/Www.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Www.php',
      ),
    ),
    'src/Pyrus/Installer/Role/Www.xml' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Www.xml',
      ),
    ),
    'src/Pyrus/Installer/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Installer/Role.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Role.php',
      ),
    ),
    'src/Pyrus/Package/Creator/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Package/Creator/TaskIterator.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'TaskIterator.php',
      ),
    ),
    'src/Pyrus/Package/Phar/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Package/Tar/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Package/Zip/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Package/Base.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Base.php',
      ),
    ),
    'src/Pyrus/Package/Creator.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Creator.php',
      ),
    ),
    'src/Pyrus/Package/Dependency.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Dependency.php',
      ),
    ),
    'src/Pyrus/Package/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Package/ICreator.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'ICreator.php',
      ),
    ),
    'src/Pyrus/Package/InstalledException.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'InstalledException.php',
      ),
    ),
    'src/Pyrus/Package/Phar.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Phar.php',
      ),
    ),
    'src/Pyrus/Package/Remote.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Remote.php',
      ),
    ),
    'src/Pyrus/Package/Tar.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Tar.php',
      ),
    ),
    'src/Pyrus/Package/Xml.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Xml.php',
      ),
    ),
    'src/Pyrus/Package/Zip.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Zip.php',
      ),
    ),
    'src/Pyrus/PackageFile/Parser/v2.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'v2.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Compatible/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Dependencies/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Developer/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Files/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Release/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Compatible.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Compatible.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Dependencies.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Dependencies.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Developer.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Developer.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Files.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Files.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Release.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Release.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Remote.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Remote.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2/Validator.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Validator.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2Iterator/File.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'File.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2Iterator/FileAttribsFilter.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'FileAttribsFilter.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2Iterator/FileContents.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'FileContents.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2Iterator/FileContentsMulti.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'FileContentsMulti.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2Iterator/FileInstallationFilter.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'FileInstallationFilter.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2Iterator/FileTag.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'FileTag.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2Iterator/PackagingIterator.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'PackagingIterator.php',
      ),
    ),
    'src/Pyrus/PackageFile/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/PackageFile/IValidator.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'IValidator.php',
      ),
    ),
    'src/Pyrus/PackageFile/v2.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'v2.php',
      ),
    ),
    'src/Pyrus/Registry/Sqlite/Channel/Mirror.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Mirror.php',
      ),
    ),
    'src/Pyrus/Registry/Sqlite/Channel/Mirrors.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Mirrors.php',
      ),
    ),
    'src/Pyrus/Registry/Sqlite/Creator.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Creator.php',
      ),
    ),
    'src/Pyrus/Registry/Sqlite/Package.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Package.php',
      ),
    ),
    'src/Pyrus/Registry/Base.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Base.php',
      ),
    ),
    'src/Pyrus/Registry/Channel.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Channel.php',
      ),
    ),
    'src/Pyrus/Registry/Config.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Config.php',
      ),
    ),
    'src/Pyrus/Registry/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Registry/Package.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Package.php',
      ),
    ),
    'src/Pyrus/Registry/Sqlite.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Sqlite.php',
      ),
    ),
    'src/Pyrus/Registry/Xml.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Xml.php',
      ),
    ),
    'src/Pyrus/REST/10.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => '10.php',
      ),
    ),
    'src/Pyrus/REST/11.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => '11.php',
      ),
    ),
    'src/Pyrus/REST/13.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => '13.php',
      ),
    ),
    'src/Pyrus/REST/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/REST/HTTPException.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'HTTPException.php',
      ),
    ),
    'src/Pyrus/ScriptFrontend/Commands.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Commands.php',
      ),
    ),
    'src/Pyrus/Task/Postinstallscript/rw.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'rw.php',
      ),
    ),
    'src/Pyrus/Task/Replace/rw.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'rw.php',
      ),
    ),
    'src/Pyrus/Task/Unixeol/rw.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'rw.php',
      ),
    ),
    'src/Pyrus/Task/Windowseol/rw.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'rw.php',
      ),
    ),
    'src/Pyrus/Task/Common.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Common.php',
      ),
    ),
    'src/Pyrus/Task/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Task/Postinstallscript.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Postinstallscript.php',
      ),
    ),
    'src/Pyrus/Task/Replace.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Replace.php',
      ),
    ),
    'src/Pyrus/Task/Unixeol.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Unixeol.php',
      ),
    ),
    'src/Pyrus/Task/Windowseol.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Windowseol.php',
      ),
    ),
    'src/Pyrus/Validate/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Validator/PECL.php' => 
     array (
       'attribs' => 
       array (
         'role' => 'php',
         'name' => 'PECL.php',
      ),
    ),
    'src/Pyrus/XMLParser/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/XMLWriter/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/Channel.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Channel.php',
      ),
    ),
    'src/Pyrus/ChannelRegistry.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'ChannelRegistry.php',
      ),
    ),
    'src/Pyrus/Config.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Config.php',
      ),
    ),
    'src/Pyrus/DirectedGraph.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'DirectedGraph.php',
      ),
    ),
    'src/Pyrus/Downloader.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Downloader.php',
      ),
    ),
    'src/Pyrus/Exception.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Exception.php',
      ),
    ),
    'src/Pyrus/FileTransactions.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'FileTransactions.php',
      ),
    ),
    'src/Pyrus/IChannel.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'IChannel.php',
      ),
    ),
    'src/Pyrus/IChannelRegistry.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'IChannelRegistry.php',
      ),
    ),
    'src/Pyrus/IFileTransaction.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'IFileTransaction.php',
      ),
    ),
    'src/Pyrus/Installer.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Installer.php',
      ),
    ),
    'src/Pyrus/IPackage.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'IPackage.php',
      ),
    ),
    'src/Pyrus/IRegistry.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'IRegistry.php',
      ),
    ),
    'src/Pyrus/Log.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Log.php',
      ),
    ),
    'src/Pyrus/OSGuess.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'OSGuess.php',
      ),
    ),
    'src/Pyrus/Package.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Package.php',
      ),
    ),
    'src/Pyrus/PackageFile.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'PackageFile.php',
      ),
    ),
    'src/Pyrus/Registry.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Registry.php',
      ),
    ),
    'src/Pyrus/REST.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'REST.php',
      ),
    ),
    'src/Pyrus/Validate.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Validate.php',
      ),
    ),
    'src/Pyrus/XMLParser.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'XMLParser.php',
      ),
    ),
    'src/Pyrus/XMLWriter.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'XMLWriter.php',
      ),
    ),
    'src/Pyrus.php' => 
    array (
      'attribs' => 
      array (
        'role' => 'php',
        'name' => 'Pyrus.php',
      ),
    ),
  ),
  'baseinstalls' => 
  array (
    'data' => '/',
    'src' => 'PEAR2',
  ),
  'packagefile' => dirname(__FILE__) . '/packages/package.xml',
  'packageinfo' => 
  array (
    'attribs' => 
    array (
      'xmlns' => 'http://pear.php.net/dtd/package-2.1',
      'xmlns:tasks' => 'http://pear.php.net/dtd/tasks-1.0',
      'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
      'version' => '2.1',
      'xsi:schemaLocation' => 'http://pear.php.net/dtd/tasks-1.0     http://pear.php.net/dtd/tasks-1.0.xsd     http://pear.php.net/dtd/package-2.1     http://pear.php.net/dtd/package-2.1.xsd',
    ),
    'name' => 'PEAR2_Pyrus',
    'channel' => 'pear2.php.net',
    'summary' => 'Pyrus is the package manager and installer for PHP 5.2 or newer
',
    'description' => '
Pyrus provides the means to install and manage installations for
packages built using package.xml version 2.0 or newer.  Pyrus is
redesigned from the ground up for PHP 5.2 or newer, and provides
significant improvements over the older PEAR Installer.

To use Pyrus, in this development series of releases, you need to
instantiate a simple script that creates a package and installs it:

<?php
// use full path if include_path is not set up
include \'PEAR2/Autoload.php\';
require_once \'Net/URL2.php\'; // PEAR package needed for PEAR2_HTTP_Request dep
$config = PEAR2_Pyrus_Config::singleton(\'/where/to/install\');
// this can be a url to a remote package, a local .tgz, .zip or package.xml
$p = new PEAR2_Pyrus_Package(\'thingtoinstall\');
try {
    PEAR2_Pyrus_Installer::begin();
    PEAR2_Pyrus_Installer::prepare($p);
    PEAR2_Pyrus_Installer::commit();
} catch (Exception $e) {
    PEAR2_Pyrus_Installer::rollback();
    echo $e;
}
?>',
    'lead' => 
    array (
      'name' => 'Gregory Beaver',
      'user' => 'cellog',
      'email' => 'cellog@php.net',
      'active' => 'yes',
    ),
    'date' => '2007-10-06',
    'version' => 
    array (
      'release' => '2.0.0a1',
      'api' => '0.1.0',
    ),
    'stability' => 
    array (
      'release' => 'alpha',
      'api' => 'alpha',
    ),
    'license' => 
    array (
      'attribs' => 
      array (
        'uri' => 'http://www.opensource.org/licenses/bsd-license.php',
      ),
      '_content' => 'New BSD License',
    ),
    'notes' => 'Initial development release, no frontend is included',
    'contents' => 
    array (
      'dir' => 
      array (
        'attribs' => 
        array (
          'name' => '/',
        ),
        'dir' => 
        array (
          0 => 
          array (
            'attribs' => 
            array (
              'name' => 'data',
              'baseinstalldir' => '/',
            ),
            'file' => 
            array (
              0 => 
              array (
                'attribs' => 
                array (
                  'role' => 'data',
                  'name' => 'channel-1.0.xsd',
                ),
              ),
              1 => 
              array (
                'attribs' => 
                array (
                  'role' => 'data',
                  'name' => 'package-2.0.xsd',
                ),
              ),
              2 => 
              array (
                'attribs' => 
                array (
                  'role' => 'data',
                  'name' => 'package-2.1.xsd',
                ),
              ),
            ),
          ),
          1 => 
          array (
            'attribs' => 
            array (
              'name' => 'src',
              'baseinstalldir' => 'PEAR2',
            ),
            'dir' => 
            array (
              'attribs' => 
              array (
                'name' => 'Pyrus',
              ),
              'dir' => 
              array (
                0 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Channel',
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Base.php',
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Exception.php',
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'IMirror.php',
                      ),
                    ),
                    3 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Mirror.php',
                      ),
                    ),
                  ),
                ),
                1 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'ChannelRegistry',
                  ),
                  'dir' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Channel',
                      ),
                      'file' => 
                      array (
                        0 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Sqlite.php',
                          ),
                        ),
                        1 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Xml.php',
                          ),
                        ),
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Mirror',
                      ),
                      'file' => 
                      array (
                        0 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Sqlite.php',
                          ),
                        ),
                        1 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Xml.php',
                          ),
                        ),
                      ),
                    ),
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Base.php',
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Exception.php',
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Sqlite.php',
                      ),
                    ),
                    3 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Xml.php',
                      ),
                    ),
                  ),
                ),
                2 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Config',
                  ),
                  'file' => 
                  array (
                    'attribs' => 
                    array (
                      'role' => 'php',
                      'name' => 'Exception.php',
                    ),
                  ),
                ),
                3 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Dependency',
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Exception.php',
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Validator.php',
                      ),
                    ),
                  ),
                ),
                4 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'DirectedGraph',
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Exception.php',
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Vertex.php',
                      ),
                    ),
                  ),
                ),
                5 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'FileTransactions',
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Installedas.php',
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Rename.php',
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Rmdir.php',
                      ),
                    ),
                  ),
                ),
                6 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Installer',
                  ),
                  'dir' => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Role',
                    ),
                    'file' => 
                    array (
                      0 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Common.php',
                        ),
                      ),
                      1 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Data.php',
                        ),
                      ),
                      2 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Data.xml',
                        ),
                      ),
                      3 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Doc.php',
                        ),
                      ),
                      4 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Doc.xml',
                        ),
                      ),
                      5 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Exception.php',
                        ),
                      ),
                      6 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Ext.php',
                        ),
                      ),
                      7 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Ext.xml',
                        ),
                      ),
                      8 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Php.php',
                        ),
                      ),
                      9 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Php.xml',
                        ),
                      ),
                      10 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Script.php',
                        ),
                      ),
                      11 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Script.xml',
                        ),
                      ),
                      12 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Src.php',
                        ),
                      ),
                      13 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Src.xml',
                        ),
                      ),
                      14 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Test.php',
                        ),
                      ),
                      15 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Test.xml',
                        ),
                      ),
                      16 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Www.php',
                        ),
                      ),
                      17 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Www.xml',
                        ),
                      ),
                    ),
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Exception.php',
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Role.php',
                      ),
                    ),
                  ),
                ),
                7 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Package',
                  ),
                  'dir' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Creator',
                      ),
                      'file' => 
                      array (
                        0 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Exception.php',
                          ),
                        ),
                        1 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'TaskIterator.php',
                          ),
                        ),
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Phar',
                      ),
                      'file' => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Exception.php',
                        ),
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Tar',
                      ),
                      'file' => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Exception.php',
                        ),
                      ),
                    ),
                    3 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Zip',
                      ),
                      'file' => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Exception.php',
                        ),
                      ),
                    ),
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Base.php',
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Creator.php',
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Dependency.php',
                      ),
                    ),
                    3 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Exception.php',
                      ),
                    ),
                    4 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'ICreator.php',
                      ),
                    ),
                    5 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'InstalledException.php',
                      ),
                    ),
                    6 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Phar.php',
                      ),
                    ),
                    7 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Remote.php',
                      ),
                    ),
                    8 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Tar.php',
                      ),
                    ),
                    9 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Xml.php',
                      ),
                    ),
                    10 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Zip.php',
                      ),
                    ),
                  ),
                ),
                8 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'PackageFile',
                  ),
                  'dir' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Parser',
                      ),
                      'file' => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'v2.php',
                        ),
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'v2',
                      ),
                      'dir' => 
                      array (
                        0 => 
                        array (
                          'attribs' => 
                          array (
                            'name' => 'Compatible',
                          ),
                          'file' => 
                          array (
                            'attribs' => 
                            array (
                              'role' => 'php',
                              'name' => 'Exception.php',
                            ),
                          ),
                        ),
                        1 => 
                        array (
                          'attribs' => 
                          array (
                            'name' => 'Dependencies',
                          ),
                          'file' => 
                          array (
                            'attribs' => 
                            array (
                              'role' => 'php',
                              'name' => 'Exception.php',
                            ),
                          ),
                        ),
                        2 => 
                        array (
                          'attribs' => 
                          array (
                            'name' => 'Developer',
                          ),
                          'file' => 
                          array (
                            'attribs' => 
                            array (
                              'role' => 'php',
                              'name' => 'Exception.php',
                            ),
                          ),
                        ),
                        3 => 
                        array (
                          'attribs' => 
                          array (
                            'name' => 'Files',
                          ),
                          'file' => 
                          array (
                            'attribs' => 
                            array (
                              'role' => 'php',
                              'name' => 'Exception.php',
                            ),
                          ),
                        ),
                        4 => 
                        array (
                          'attribs' => 
                          array (
                            'name' => 'Release',
                          ),
                          'file' => 
                          array (
                            'attribs' => 
                            array (
                              'role' => 'php',
                              'name' => 'Exception.php',
                            ),
                          ),
                        ),
                      ),
                      'file' => 
                      array (
                        0 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Compatible.php',
                          ),
                        ),
                        1 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Dependencies.php',
                          ),
                        ),
                        2 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Developer.php',
                          ),
                        ),
                        3 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Files.php',
                          ),
                        ),
                        4 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Release.php',
                          ),
                        ),
                        5 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Remote.php',
                          ),
                        ),
                        6 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Validator.php',
                          ),
                        ),
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'v2Iterator',
                      ),
                      'file' => 
                      array (
                        0 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'File.php',
                          ),
                        ),
                        1 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'FileAttribsFilter.php',
                          ),
                        ),
                        2 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'FileContents.php',
                          ),
                        ),
                        3 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'FileContentsMulti.php',
                          ),
                        ),
                        4 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'FileInstallationFilter.php',
                          ),
                        ),
                        5 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'FileTag.php',
                          ),
                        ),
                        6 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'PackagingIterator.php',
                          ),
                        ),
                      ),
                    ),
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Exception.php',
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'IValidator.php',
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'v2.php',
                      ),
                    ),
                  ),
                ),
                9 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Registry',
                  ),
                  'dir' => 
                  array (
                    'attribs' => 
                    array (
                      'name' => 'Sqlite',
                    ),
                    'dir' => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Channel',
                      ),
                      'file' => 
                      array (
                        0 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Mirror.php',
                          ),
                        ),
                        1 => 
                        array (
                          'attribs' => 
                          array (
                            'role' => 'php',
                            'name' => 'Mirrors.php',
                          ),
                        ),
                      ),
                    ),
                    'file' => 
                    array (
                      0 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Creator.php',
                        ),
                      ),
                      1 => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'Package.php',
                        ),
                      ),
                    ),
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Base.php',
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Channel.php',
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Config.php',
                      ),
                    ),
                    3 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Exception.php',
                      ),
                    ),
                    4 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Package.php',
                      ),
                    ),
                    5 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Sqlite.php',
                      ),
                    ),
                    6 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Xml.php',
                      ),
                    ),
                  ),
                ),
                10 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'REST',
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => '10.php',
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => '11.php',
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => '13.php',
                      ),
                    ),
                    3 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Exception.php',
                      ),
                    ),
                    4 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'HTTPException.php',
                      ),
                    ),
                  ),
                ),
                11 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'ScriptFrontend',
                  ),
                  'file' => 
                  array (
                    'attribs' => 
                    array (
                      'role' => 'php',
                      'name' => 'Commands.php',
                    ),
                  ),
                ),
                12 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Task',
                  ),
                  'dir' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Postinstallscript',
                      ),
                      'file' => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'rw.php',
                        ),
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Replace',
                      ),
                      'file' => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'rw.php',
                        ),
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Unixeol',
                      ),
                      'file' => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'rw.php',
                        ),
                      ),
                    ),
                    3 => 
                    array (
                      'attribs' => 
                      array (
                        'name' => 'Windowseol',
                      ),
                      'file' => 
                      array (
                        'attribs' => 
                        array (
                          'role' => 'php',
                          'name' => 'rw.php',
                        ),
                      ),
                    ),
                  ),
                  'file' => 
                  array (
                    0 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Common.php',
                      ),
                    ),
                    1 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Exception.php',
                      ),
                    ),
                    2 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Postinstallscript.php',
                      ),
                    ),
                    3 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Replace.php',
                      ),
                    ),
                    4 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Unixeol.php',
                      ),
                    ),
                    5 => 
                    array (
                      'attribs' => 
                      array (
                        'role' => 'php',
                        'name' => 'Windowseol.php',
                      ),
                    ),
                  ),
                ),
                13 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Validate',
                  ),
                  'file' => 
                  array (
                    'attribs' => 
                    array (
                      'role' => 'php',
                      'name' => 'Exception.php',
                    ),
                  ),
                ),
                14 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'Validator',
                  ),
                  'file' => 
                  array (
                    'attribs' => 
                    array (
                      'role' => 'php',
                      'name' => 'PECL.php',
                    ),
                  ),
                ),
                15 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'XMLParser',
                  ),
                  'file' => 
                  array (
                    'attribs' => 
                    array (
                      'role' => 'php',
                      'name' => 'Exception.php',
                    ),
                  ),
                ),
                16 => 
                array (
                  'attribs' => 
                  array (
                    'name' => 'XMLWriter',
                  ),
                  'file' => 
                  array (
                    'attribs' => 
                    array (
                      'role' => 'php',
                      'name' => 'Exception.php',
                    ),
                  ),
                ),
              ),
              'file' => 
              array (
                0 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'Channel.php',
                  ),
                ),
                1 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'ChannelRegistry.php',
                  ),
                ),
                2 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'Config.php',
                  ),
                ),
                3 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'DirectedGraph.php',
                  ),
                ),
                4 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'Downloader.php',
                  ),
                ),
                5 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'Exception.php',
                  ),
                ),
                6 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'FileTransactions.php',
                  ),
                ),
                7 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'IChannel.php',
                  ),
                ),
                8 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'IChannelRegistry.php',
                  ),
                ),
                9 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'IFileTransaction.php',
                  ),
                ),
                10 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'Installer.php',
                  ),
                ),
                11 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'IPackage.php',
                  ),
                ),
                12 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'IRegistry.php',
                  ),
                ),
                13 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'Log.php',
                  ),
                ),
                14 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'OSGuess.php',
                  ),
                ),
                15 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'Package.php',
                  ),
                ),
                16 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'PackageFile.php',
                  ),
                ),
                17 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'Registry.php',
                  ),
                ),
                18 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'REST.php',
                  ),
                ),
                19 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'Validate.php',
                  ),
                ),
                20 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'XMLParser.php',
                  ),
                ),
                21 => 
                array (
                  'attribs' => 
                  array (
                    'role' => 'php',
                    'name' => 'XMLWriter.php',
                  ),
                ),
              ),
            ),
            'file' => 
            array (
              'attribs' => 
              array (
                'role' => 'php',
                'name' => 'Pyrus.php',
              ),
            ),
          ),
        ),
      ),
    ),
    'dependencies' => 
    array (
      'required' => 
      array (
        'php' => 
        array (
          'min' => '5.2.0',
        ),
        'pearinstaller' => 
        array (
          'min' => '2.0.0a1',
        ),
      ),
    ),
    'phprelease' => '',
  ),
), $ret->getThingy(), 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
test current returns singleton registry object
--FILE--
<?php
require dirname(__FILE__) . '/../setup.php.inc';
$test->assertEquals('PEAR2_Pyrus_Config',
                    get_class(PEAR2_Pyrus_Config::current()),
                    'test config');

$test->assertEquals('PEAR2_Pyrus_Registry',
                    get_class(PEAR2_Pyrus_Config::current()->registry),
                    'test registry');
?>
===DONE===
--EXPECT--
===DONE===<?php
include dirname(__FILE__) . '/../test_framework.php.inc';
$registryclass = 'PEAR2_Pyrus_Config';
TOTAL TIME: 00:03
28 PASSED TESTS
2 SKIPPED TESTS
9 FAILED TESTS:
/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/setCascadingRegistries/basic.phpt
/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/badsystemfile.phpt
/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/baduserfile.phpt
/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/defaults.phpt
/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/goodsystemfile.phpt
/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/gooduser.mypath.phpt
/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/loadConfigFile/gooduserfile.phpt
/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/configSnapshot/test.phpt
/Users/bbieber/Documents/workspace/PEAR2/Pyrus/tests/Config/addConfigValue/test.phpt
<?php
$__e = error_reporting();
error_reporting(E_ERROR|E_NOTICE|E_WARNING);
require_once __DIR__ . '/../../autoload.php';
@include_once 'Text/Diff.php';
@include_once 'Text/Diff/Renderer.php';
@include_once 'Text/Diff/Renderer/unified.php';
error_reporting($__e);
class PEAR2_PHPT
{
    var $_diffonly;
    function __construct($diffonly = false)
    {
        $this->_diffonly = $diffonly;
        $this->_errors = array();
    }

    function assertTrue($test, $message)
    {
        if ($test === true) {
            return true;
        }
        $this->_failTest(debug_backtrace(), $message);
        echo "Unexpected non-true value: \n";
        var_export($test);
        echo "\n'$message'\n";
        return false;
    }

    function assertIsa($control, $test, $message)
    {
        if (is_a($test, $control)) {
            return true;
        }
        $this->_failTest(debug_backtrace(), $message);
        echo "Unexpected non-$control object: \n";
        var_export($test);
        echo "\n'$message'\n";
        return false;
    }

    function assertNull($test, $message)
    {
        if ($test === null) {
            return true;
        }
        $this->_failTest(debug_backtrace(), $message);
        echo "Unexpected non-null value: \n";
        var_export($test);
        echo "\n'$message'\n";
        return false;
    }

    function assertNotNull($test, $message)
    {
        if ($test !== null) {
            return true;
        }
        $this->_failTest(debug_backtrace(), $message);
        echo "Unexpected null: \n";
        var_export($test);
        echo "\n'$message'\n";
        return false;
    }

    function assertSame($test, $test1, $message)
    {
        if ($test === $test1) {
            return true;
        }
        $this->_failTest(debug_backtrace(), $message);
        echo "Unexpectedly two vars are not the same thing: \n";
        echo "\n'$message'\n";
        return false;
    }

    function assertNotSame($test, $test1, $message)
    {
        if ($test !== $test1) {
            return true;
        }
        $this->_failTest(debug_backtrace(), $message);
        echo "Unexpectedly two vars are the same thing: \n";
        echo "\n'$message'\n";
        return false;
    }

    function assertFalse($test, $message)
    {
        if ($test === false) {
            return true;
        }
        $this->_failTest(debug_backtrace(), $message);
        echo "Unexpected non-false value: \n";
        var_export($test);
        echo "\n'$message'\n";
        return false;
    }

    function assertNotTrue($test, $message)
    {
        if (!$test) {
            return true;
        }
        $this->_failTest(debug_backtrace(), $message);
        echo "Unexpected loose true value: \n";
        var_export($test);
        echo "\n'$message'\n";
        return false;
    }

    function assertNotFalse($test, $message)
    {
        if ($test) {
            return true;
        }
        $this->_failTest(debug_backtrace(), $message);
        echo "Unexpected loose false value: \n";
        var_export($test);
        echo "\n'$message'\n";
        return false;
    }

    function assertRegex($regex, $test, $message)
    {
        if (!preg_match($regex, $test)) {
            $this->_failTest(debug_backtrace(), $message);
            echo "Expecting:\nText Matching Regular Expression $regex\n";
            echo "\nReceived:\n";
            var_export($test);
            echo "\n";
            return false;
        }
        return true;
    }

    function assertException($exception, $class, $emessage, $message)
    {
        if (!($exception instanceof $class)) {
            $this->_failTest(debug_backtrace(), $message);
            echo "Expecting class $class, got ", get_class($exception);
        }
        $this->assertEquals($emessage, $exception->getMessage(), $message, debug_backtrace());
    }

    function assertEquals($control, $test, $message, $trace = null)
    {
        if (!$trace) {
            $trace = debug_backtrace();
        }
        if (str_replace(array("\r", "\n"), array('', ''),
            var_export($control, true)) != str_replace(array("\r", "\n"), array('', ''),
            var_export($test, true))) {
            $this->_failTest($trace, $message);
            if (class_exists('Text_Diff')) {
                echo "Diff of expecting/received:\n";
                $diff = new Text_Diff(
                    explode("\n", var_export($control, true)),
                    explode("\n", var_export($test, true)));

                // Output the diff in unified format.
                $renderer = new Text_Diff_Renderer_unified();
                echo $renderer->render($diff);
                if ($this->_diffonly) {
                    return false;
                }
            }
            echo "Expecting:\n";
            var_export($control);
            echo "\nReceived:\n";
            var_export($test);
            echo "\n";
            return false;
        }
        return true;
    }

    function assertFileExists($fname, $message)
    {
        if (!@file_exists($fname)) {
            $this->_failTest(debug_backtrace(), $message);
            echo "File '$fname' does not exist, and should\n";
            return false;
        }
        return true;
    }

    function assertFileNotExists($fname, $message)
    {
        if (@file_exists($fname)) {
            $this->_failTest(debug_backtrace(), $message);
            echo "File '$fname' exists, and should not\n";
            return false;
        }
        return true;
    }

    function _failTest($trace, $message)
    {
        echo 'Test Failure: "' . $message  . "\"\n in " . $trace[0]['file'] . ' line ' .
            $trace[0]['line'] . "\n";
    }

    function showAll()
    {
        $this->_diffonly = false;
    }
}
$test = new PEAR2_PHPT();
?>
--TEST--
Pyrus XMLParser: attributes
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$res = $parser->parseString('<?xml version="1.0" ?><a one="two"/>');
$test->assertEquals(array('a' => array('attribs' => array('one' => 'two'))), $res, 'test');
$res = $parser->parseString('<?xml version="1.0" ?><a one="two" three="four"/>');
$test->assertEquals(array('a' => array('attribs' => array('one' => 'two', 'three' => 'four'))), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLParser: attributes + content
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$res = $parser->parseString('<?xml version="1.0" ?><a one="two">hi</a>');
$test->assertEquals(array(
  'a' =>
  array(
    'attribs' =>
    array(
      'one' => 'two',
    ),
    '_content' => 'hi',
  ),
), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLParser: <![CDATA[]]>
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$res = $parser->parseString('<?xml version="1.0" ?><a><![CDATA[hi<there>]]></a>');
$test->assertEquals(array('a' => 'hi<there>'), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLParser: child tag
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$res = $parser->parseString('<?xml version="1.0" ?><a><b/></a>');
$test->assertEquals(array(
  'a' =>
  array(
    'b' => '',
  ),
), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLParser: child tag + attributes
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$res = $parser->parseString('<?xml version="1.0" ?><a><b one="two"/></a>');
$test->assertEquals(array(
  'a' =>
  array(
    'b' =>
    array(
      'attribs' =>
      array(
        'one' => 'two'
      )
    ),
  ),
), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLParser: child tag + content
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$res = $parser->parseString('<?xml version="1.0" ?><a><b/>hi</a>');
$test->assertEquals(array(
  'a' =>
  array(
    'b' => '',
    '_content' => 'hi',
  ),
), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLParser: child tag + sibling attributes
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$res = $parser->parseString('<?xml version="1.0" ?><a><b /><b one="two"/></a>');
$test->assertEquals(array(
  'a' =>
  array(
    'b' =>
    array(
      '',
      array(
        'attribs' =>
        array(
          'one' => 'two'
        )
      ),
    ),
  ),
), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLParser: empty xml
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$res = $parser->parseString('<?xml version="1.0" ?><a/>');
$test->assertEquals(array('a' => ''), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLParser: complex recursive tags
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$res = $parser->parseString('<?xml version="1.0" ?><package>
<lead>
 <name>test</name>
 <another>tag</another>
</lead>
<lead>
 <name>second</name>
 <another>thing</another>
</lead>
<contents>
 <dir name="blah">
  <dir name="two">
   <dir name="three">
    <file name="my"/>
   </dir>
  </dir>
 </dir>
 <dir name="four">
  <file name="my2"/>
 </dir>
</contents>
</package>');
$test->assertEquals(array (
  'package' => 
  array (
    'lead' => 
    array (
      0 => 
      array (
        'name' => 'test',
        'another' => 'tag',
      ),
      1 => 
      array (
        'name' => 'second',
        'another' => 'thing',
      ),
    ),
    'contents' => 
    array (
      'dir' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'name' => 'blah',
          ),
          'dir' => 
          array (
            'attribs' => 
            array (
              'name' => 'two',
            ),
            'dir' => 
            array (
              'attribs' => 
              array (
                'name' => 'three',
              ),
              'file' => 
              array (
                'attribs' => 
                array (
                  'name' => 'my',
                ),
              ),
            ),
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'name' => 'four',
          ),
          'file' => 
          array (
            'attribs' => 
            array (
              'name' => 'my2',
            ),
          ),
        ),
      ),
    ),
  ),
), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===<?php
include dirname(__FILE__) . '/../test_framework.php.inc';
include dirname(__FILE__) . '/../../src/Pyrus/XMLParser.php';
$parser = new PEAR2_Pyrus_XMLParser;--TEST--
Pyrus XMLParser: sibling tags
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$res = $parser->parseString('<?xml version="1.0" ?><a><b/><b/></a>');
$test->assertEquals(array(
  'a' =>
  array(
    'b' => array('', ''),
  ),
), $res, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLWriter: attributes
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';

$write = new $xmlwriter(array('a' => array('attribs' => array('one' => 'two'))));
$test->assertEquals('<?xml version="1.0" encoding="UTF-8"?>
<a one="two"/>', (string) $write, 1);
$write = new $xmlwriter(array('a' => array('attribs' => array('one' => 'two', 'three' => 'four'))));
$test->assertEquals('<?xml version="1.0" encoding="UTF-8"?>
<a one="two" three="four"/>', (string) $write, 2);
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLWriter: attributes + content
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';

$write = new $xmlwriter(array(
  'a' =>
  array(
    'attribs' =>
    array(
      'one' => 'two',
    ),
    '_content' => 'hi',
  ),
));
$test->assertEquals('<?xml version="1.0" encoding="UTF-8"?>
<a one="two">hi</a>', (string) $write, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLWriter: child tag
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$write = new $xmlwriter(array(
  'a' =>
  array(
    'b' => '',
  ),
));
$test->assertEquals('<?xml version="1.0" encoding="UTF-8"?>
<a>
 <b/>
</a>', (string) $write, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLWriter: child tag + attributes
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$write = new $xmlwriter(array(
  'a' =>
  array(
    'b' =>
    array(
      'attribs' =>
      array(
        'one' => 'two'
      )
    ),
  ),
));
$test->assertEquals('<?xml version="1.0" encoding="UTF-8"?>
<a>
 <b one="two"/>
</a>', (string) $write, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLWriter: child tag + content
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$write = new $xmlwriter(array(
  'a' =>
  array(
    'b' => '',
    '_content' => 'hi',
  ),
));
$test->assertEquals('<?xml version="1.0" encoding="UTF-8"?>
<a>
 <b/>hi
</a>', (string) $write, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLWriter: child tag + sibling attributes
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$write = new $xmlwriter(array(
  'a' =>
  array(
    'b' =>
    array(
      '',
      array(
        'attribs' =>
        array(
          'one' => 'two'
        )
      ),
    ),
  ),
));
$test->assertEquals('<?xml version="1.0" encoding="UTF-8"?>
<a>
 <b></b>
 <b one="two"/>
</a>', (string) $write, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLWriter: empty xml
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$write = new $xmlwriter(array('a' => ''));
$test->assertEquals('<?xml version="1.0" encoding="UTF-8"?>
<a/>', (string) $write, 'test');
?>
===DONE===
--EXPECT--
===DONE===--TEST--
Pyrus XMLWriter: complex recursive tags
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$write = new $xmlwriter(array (
  'package' => 
  array (
    'lead' => 
    array (
      0 => 
      array (
        'name' => 'test',
        'another' => 'tag',
      ),
      1 => 
      array (
        'name' => 'second',
        'another' => 'thing',
      ),
    ),
    'contents' => 
    array (
      'dir' => 
      array (
        0 => 
        array (
          'attribs' => 
          array (
            'name' => 'blah',
          ),
          'dir' => 
          array (
            'attribs' => 
            array (
              'name' => 'two',
            ),
            'dir' => 
            array (
              'attribs' => 
              array (
                'name' => 'three',
              ),
              'file' => 
              array (
                'attribs' => 
                array (
                  'name' => 'my',
                ),
              ),
            ),
          ),
        ),
        1 => 
        array (
          'attribs' => 
          array (
            'name' => 'four',
          ),
          'file' => 
          array (
            'attribs' => 
            array (
              'name' => 'my2',
            ),
          ),
        ),
      ),
    ),
  ),
));
$test->assertEquals('<?xml version="1.0" encoding="UTF-8"?>
<package>
 <lead>
  <name>test</name>
  <another>tag</another>
 </lead>
 <lead>
  <name>second</name>
  <another>thing</another>
 </lead>
 <contents>
  <dir name="blah">
   <dir name="two">
    <dir name="three">
     <file name="my"/>
    </dir>
   </dir>
  </dir>
  <dir name="four">
   <file name="my2"/>
  </dir>
 </contents>
</package>', (string) $write, 'test');
?>
===DONE===
--EXPECT--
===DONE===<?php
include dirname(__FILE__) . '/../test_framework.php.inc';
// for easy move to namespaces
$xmlwriter = 'PEAR2_Pyrus_XMLWriter';
--TEST--
Pyrus XMLWriter: sibling tags
--FILE--
<?php
require dirname(__FILE__) . '/setup.php.inc';
$write = new $xmlwriter(array(
  'a' =>
  array(
    'b' => array('', ''),
  ),
));
$test->assertEquals('<?xml version="1.0" encoding="UTF-8"?>
<a>
 <b></b>
 <b/>
</a>', (string) $write, 'test');
?>
===DONE===
--EXPECT--
===DONE===<?php
function PEAR2_Autoload($class)
{
    if (substr($class, 0, 6) !== 'PEAR2_') {
        return false;
    }
    $fp = @fopen(str_replace('_', '/', $class) . '.php', 'r', true);
    if ($fp) {
        fclose($fp);
        require str_replace('_', '/', $class) . '.php';
        if (!class_exists($class, false) && !interface_exists($class, false)) {
            die(new Exception('Class ' . $class . ' was not present in ' .
                str_replace('_', '/', $class) . '.php (include_path="' . get_include_path() .
                '") [PEAR2_Autoload version 1.0]'));
        }
        return true;
    }
    $e = new Exception('Class ' . $class . ' could not be loaded from ' .
        str_replace('_', '/', $class) . '.php, file does not exist (include_path="' . get_include_path() .
        '") [PEAR2_Autoload version 1.0]');
    $trace = $e->getTrace();
    if (isset($trace[2]) && isset($trace[2]['function']) &&
          in_array($trace[2]['function'], array('class_exists', 'interface_exists'))) {
        return false;
    }
    if (isset($trace[1]) && isset($trace[1]['function']) &&
          in_array($trace[1]['function'], array('class_exists', 'interface_exists'))) {
        return false;
    }
    die ((string) $e);
}

// set up __autoload
if (function_exists('spl_autoload_register')) {
    if (!($_____t = spl_autoload_functions()) || !in_array('PEAR2_Autoload', spl_autoload_functions())) {
        spl_autoload_register('PEAR2_Autoload');
        if (function_exists('__autoload') && ($_____t === false)) {
            // __autoload() was being used, but now would be ignored, add
            // it to the autoload stack
            spl_autoload_register('__autoload');
        }
    }
    unset($_____t);
} elseif (!function_exists('__autoload')) {
    function __autoload($class) { return PEAR2_Autoload($class); }
}

// set up include_path if it doesn't register our current location
$____paths = explode(PATH_SEPARATOR, get_include_path());
$____found = false;
foreach ($____paths as $____path) {
    if ($____path == dirname(dirname(__FILE__))) {
        $____found = true;
        break;
    }
}
if (!$____found) {
    set_include_path(get_include_path() . PATH_SEPARATOR . dirname(dirname(__FILE__)));
}
unset($____paths);
unset($____path);
unset($____found);
<?php
/**
 * Multi-Error Error aggregator
 *
 * This class is designed to be extended for specific use.  It codifies easy
 * ways of aggregating error conditions that don't necessarily require an exception
 * to be thrown, but do need an easy way to retrieve them.
 * 
 * Usage:
 * 
 * <code>
 * $multi = new PEAR2_MultiErrors();
 * $multi->E_WARNING[] = new Exception('test');
 * $multi->E_ERROR[] = new Exception('test 2');
 * foreach ($multi as $error) {
 *     echo $error;
 * }
 * foreach ($multi->E_WARNING as $error) {
 *     echo $error;
 * }
 * foreach ($multi->E_ERROR as $error) {
 *     echo $error;
 * }
 * if (count($multi->E_ERROR)) {
 *     throw new PEAR2_Exception('Failure to do something', $multi);
 * }
 * </code>
 * @copyright 2007 Gregory Beaver
 * @package PEAR2_MultiErrors
 * @license http://www.php.net/license/3_0.txt PHP License
 */
class PEAR2_MultiErrors implements Iterator, Countable, ArrayAccess {

    private $_allowedLevels = array('E_NOTICE' => 0, 'E_WARNING' => 1, 'E_ERROR' => 2);
    /**
     * Errors are stored in the order that they are declared
     * @var array
     */
    private $_errors = array();

    /**
     * To allow $this->E_WARNING[] = new BlahException;
     *
     * @var int
     */
    private $_requestedLevel = false;

    /**
     * Internal PEAR2_MultiError objects for error levels
     * @var array
     */
    private $_subMulti = array();

    /**
     * Parent PEAR2_MultiErrors for an error level tracker
     *
     * @var PEAR2_MultiErrors
     */
    private $_parent;

    public function __construct($mylevel = false,
                                array $allowed = array('E_NOTICE', 'E_WARNING', 'E_ERROR'),
                                PEAR2_MultiErrors $parent = null)
    {
        foreach ($allowed as $level) {
            if (!is_string($level) || strpos($level, 'E_') !== 0) {
                throw new PEAR2_MultiErrors_Exception('Invalid level ' . (string) $level);
            }
        }
        $this->_allowedLevels = array_flip($allowed);
        $this->_requestedLevel = $mylevel;
        if ($mylevel) {
            $this->_parent = $parent;
        }
    }

    public function current()
    {
        return current($this->_errors);
    }

    public function key()
 	{
 	    return key($this->_errors);
 	}

 	public function next()
 	{
 	    return next($this->_errors);
 	}

 	public function rewind()
 	{
 	    return reset($this->_errors);
 	}

 	public function valid()
 	{
 	    return false !== current($this->_errors);
 	}

 	/**
 	 * Merge in errors from an existing PEAR2_MultiErrors
 	 * 
 	 * This also merges in any new error levels not supported in this instance.
 	 * @param PEAR2_MultiErrors $error
 	 */
 	public function merge(PEAR2_MultiErrors $error)
 	{
 	    $levels = $error->level;
 	    foreach ($error->levels as $level) {
 	        if (!isset($this->_allowedLevels[$level])) {
 	            $this->_allowedLevels[$level] = 1;
 	        }
 	        foreach ($error->$level as $e) {
 	            // we get fatal error if [] is put on $this->$level line
 	            $a = $this->$level;
 	            $a[] = $e;
 	        }
 	    }
 	}

 	public function count()
 	{
 	    return count($this->_errors);
 	}

 	public function offsetExists($offset)
 	{
 	    return isset($this->_errors[$offset]);
 	}

 	public function offsetGet ($offset)
 	{
 	    if (isset($this->_errors[$offset])) {
 	        return $this->_errors[$offset];
 	    }
 	    return null;
 	}

 	public function offsetSet ($offset, $value)
 	{
 	    if ($offset === null && !$this->_requestedLevel &&
 	          $value instanceof PEAR2_MultiErrors ) {
 	        $this->merge($value);
 	        return;
 	    }
 	    if (!($value instanceof Exception)) {
 	        throw new PEAR2_MultiErrors_Exception('offsetSet: $value is not an Exception object');
 	    }
 	    if ($this->_requestedLevel) {
     	    if ($offset === null) {
     	        // called with $a->E_BLAH[] = new Exception('hi');
     	        $offset = count($this->_errors);
     	    }
     	    if (!is_int($offset)) {
     	        throw new PEAR2_MultiErrors_Exception('offsetSet: $offset is not an integer');
     	    }
     	    $this->_errors[$offset] = $value;
 	        $this->_parent[$this->_requestedLevel . '-' . $offset] = $value;
 	    } else {
 	        if (!is_string($offset)) {
 	            throw new PEAR2_MultiErrors_Exception('Cannot add an error directly ' .
 	                'to a PEAR2_MultiErrors with $a[] = new Exception, use an ' .
 	                ' E_* constant like $a->E_WARNING[] = new Exception');
 	        }
 	        $offset = explode('-', $offset);
 	        $level = $offset[0];
 	        $offset = $offset[1];
 	        // this is called when the "$this->_parent[] = $value" line is executed.
 	        if (!isset($this->_subMulti[$level]) ||
 	              $this->_subMulti[$level][$offset] !== $value) {
                // must be in a child or it'll throw off the whole thingy
 	            throw new PEAR2_MultiErrors_Exception('Cannot add an error directly ' .
 	                'to a PEAR2_MultiErrors with $a[] = new Exception, use an ' .
 	                ' E_* constant like $a->E_WARNING[] = new Exception');
 	        }
 	        $this->_errors[] = $value;
 	    }
 	}

 	public function offsetUnset ($offset)
 	{
 	    if (isset($this->_errors[$offset])) {
 	        unset($this->_errors[$offset]);
 	    }
 	}

 	public function __get($level)
 	{
 	    if ($level === 'levels') {
 	        return $this->_allowedLevels;
 	    }
 	    if (!count($this->_allowedLevels)) {
 	        throw new PEAR2_MultiErrors_Exception('Cannot nest requests ' .
 	          '(like $multi->E_WARNING->E_ERROR[] = new Exception(\'\');)');
 	    }
 	    if (isset($this->_allowedLevels[$level])) {
 	        if (!isset($this->_subMulti[$level])) {
     	        $this->_subMulti[$level] = new PEAR2_MultiErrors($level,
     	          array(), $this);
 	        }
 	        return $this->_subMulti[$level];
 	    }
 	    throw new PEAR2_MultiErrors_Exception('Requested error level must be one of ' .
 	      implode(', ', $this->_allowedLevels));
 	}

 	public function toArray()
 	{
 	    return $this->_errors;
 	}
}
?><?php
/* vim: set expandtab tabstop=4 shiftwidth=4 foldmethod=marker: */
/**
 * PEAR2_Exception
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR2_Exception
 * @author     Tomas V. V. Cox <cox@idecnet.com>
 * @author     Hans Lellelid <hans@velum.net>
 * @author     Bertrand Mansion <bmansion@mamasam.com>
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2007 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: Exception.php,v 1.28 2007/05/07 01:58:54 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Release 0.1.0
 */


/**
 * Base PEAR2_Exception Class
 *
 * 1) Features:
 *
 * - Nestable exceptions (throw new PEAR2_Exception($msg, $prev_exception))
 * - Definable triggers, shot when exceptions occur
 * - Pretty and informative error messages
 * - Added more context info available (like class, method or cause)
 * - cause can be a PEAR2_Exception or an array of mixed
 *   PEAR2_Exceptions or a PEAR2_MultiErrors
 * - callbacks for specific exception classes and their children
 *
 * 2) Ideas:
 *
 * - Maybe a way to define a 'template' for the output
 *
 * 3) Inherited properties from PHP Exception Class:
 *
 * protected $message
 * protected $code
 * protected $line
 * protected $file
 * private   $trace
 *
 * 4) Inherited methods from PHP Exception Class:
 *
 * __clone
 * __construct
 * getMessage
 * getCode
 * getFile
 * getLine
 * getTraceSafe
 * getTraceSafeAsString
 * __toString
 *
 * 5) Usage example
 *
 * <code>
 * class PEAR2_MyPackage_Exception extends PEAR2_Exception {}
 *  class Test {
 *     function foo()
 *     {
 *         throw new PEAR2_MyPackage_Exception('Error Message', ERROR_CODE);
 *     }
 *  }
 *
 *  function myLogger($pear2_exception)
 *  {
 *     echo $pear2_exception->getMessage();
 *  }
 *  // each time a exception is thrown the 'myLogger' will be called
 *  // (its use is completely optional)
 *  PEAR2_Exception::addObserver('myLogger');
 *  $test = new Test;
 *  try {
 *     $test->foo();
 *  } catch (PEAR2_Exception $e) {
 *     print $e;
 *  }
 * </code>
 *
 * @category   pear
 * @package    PEAR
 * @author     Tomas V.V.Cox <cox@idecnet.com>
 * @author     Hans Lellelid <hans@velum.net>
 * @author     Bertrand Mansion <bmansion@mamasam.com>
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2007 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 0.1.0
 *
 */
abstract class PEAR2_Exception extends Exception
{
    public static $htmlError = false;
    const OBSERVER_PRINT = -2;
    const OBSERVER_TRIGGER = -4;
    const OBSERVER_DIE = -8;
    protected $cause;
    private static $_observers = array();
    private static $_uniqueid = 0;
    private $_trace;

    /**
     * Supported signatures:
     *  - PEAR2_Exception(string $message);
     *  - PEAR2_Exception(string $message, int $code);
     *  - PEAR2_Exception(string $message, Exception $cause);
     *  - PEAR2_Exception(string $message, Exception $cause, int $code);
     *  - PEAR2_Exception(string $message, PEAR2_MultiErrors $cause);
     *  - PEAR2_Exception(string $message, PEAR2_MultiErrors $cause, int $code);
     *  - PEAR2_Exception(string $message, array $causes);
     *  - PEAR2_Exception(string $message, array $causes, int $code);
     * @param string exception message
     * @param int|Exception|PEAR2_MultiErrors|array|null exception cause
     * @param int|null exception code or null
     */
    public function __construct($message, $p2 = null, $p3 = null)
    {
        if (is_int($p2)) {
            $code = $p2;
            $this->cause = null;
        } elseif (is_object($p2) || is_array($p2)) {
            if (!is_array($p2) && !($p2 instanceof Exception)) {
                if (!($p2 instanceof PEAR2_MultiErrors)) {
                    throw new Exception('exception cause must be Exception, ' .
                        'array, or PEAR2_MultiErrors');
                }
            }
            $code = $p3;
            $this->cause = $p2;
        } else {
            $code = null;
            $this->cause = null;
        }
        if (!is_string($message)) {
            throw new Exception('exception message must be a string, was ' . gettype($message));
        }
        parent::__construct($message, $code);
        $this->signal();
    }

    /**
     * @param mixed $callback  - A valid php callback, see php func is_callable()
     *                         - A PEAR2_Exception::OBSERVER_* constant
     *                         - An array(const PEAR2_Exception::OBSERVER_*,
     *                           mixed $options)
     * @param string $label    The name of the observer. Use this if you want
     *                         to remove it later with removeObserver()
     */
    public static function addObserver($callback, $label = 'default')
    {
        self::$_observers[$label] = $callback;
    }

    public static function removeObserver($label = 'default')
    {
        unset(self::$_observers[$label]);
    }

    /**
     * @return int unique identifier for an observer
     */
    public static function getUniqueId()
    {
        return self::$_uniqueid++;
    }

    private function signal()
    {
        foreach (self::$_observers as $func) {
            if (is_callable($func)) {
                call_user_func($func, $this);
                continue;
            }
            settype($func, 'array');
            switch ($func[0]) {
                case self::OBSERVER_PRINT :
                    $f = (isset($func[1])) ? $func[1] : '%s';
                    printf($f, $this->getMessage());
                    break;
                case self::OBSERVER_TRIGGER :
                    $f = (isset($func[1])) ? $func[1] : E_USER_NOTICE;
                    trigger_error($this->getMessage(), $f);
                    break;
                case self::OBSERVER_DIE :
                    $f = (isset($func[1])) ? $func[1] : '%s';
                    die(printf($f, $this->getMessage()));
                    break;
                default:
                    trigger_error('invalid observer type', E_USER_WARNING);
            }
        }
    }

    /**
     * Returns the exception that caused this exception to be thrown
     * @access public
     * @return Exception|array The context of the exception
     */
    public function getCause()
    {
        return $this->cause;
    }

    /**
     * Function must be public to call on caused exceptions
     * @param array
     */
    public function getCauseMessage(&$causes)
    {
        $trace = $this->getTraceSafe();
        $cause = array('class'   => get_class($this),
                       'message' => $this->message,
                       'file' => 'unknown',
                       'line' => 'unknown');
        if (isset($trace[0])) {
            if (isset($trace[0]['file'])) {
                $cause['file'] = $trace[0]['file'];
                $cause['line'] = $trace[0]['line'];
            }
        }
        $causes[] = $cause;
        if ($this->cause instanceof PEAR2_Exception) {
            $this->cause->getCauseMessage($causes);
        } elseif ($this->cause instanceof Exception) {
            $causes[] = array('class'   => get_class($this->cause),
                              'message' => $this->cause->getMessage(),
                              'file' => $this->cause->getFile(),
                              'line' => $this->cause->getLine());
        } elseif ($this->cause instanceof PEAR2_MultiErrors || is_array($this->cause)) {
            foreach ($this->cause as $cause) {
                if ($cause instanceof PEAR2_Exception) {
                    $cause->getCauseMessage($causes);
                } elseif ($cause instanceof Exception) {
                    $causes[] = array('class'   => get_class($cause),
                                   'message' => $cause->getMessage(),
                                   'file' => $cause->getFile(),
                                   'line' => $cause->getLine());
                }
            }
        }
    }

    public function getTraceSafe()
    {   
        if (!isset($this->_trace)) {
            $this->_trace = $this->getTrace();
            if (empty($this->_trace)) {
                $backtrace = debug_backtrace();
                $this->_trace = array($backtrace[count($backtrace)-1]);
            }
        }
        return $this->_trace;
    }

    public function getErrorClass()
    {
        $trace = $this->getTraceSafe();
        return $trace[0]['class'];
    }

    public function getErrorMethod()
    {
        $trace = $this->getTraceSafe();
        return $trace[0]['function'];
    }

    public function __toString()
    {
        if (self::$htmlError) {
            return $this->toHtml();
        }
        return $this->toText();
    }

    public function toHtml()
    {
        $trace = $this->getTraceSafe();
        $causes = array();
        $this->getCauseMessage($causes);
        $html =  '<table border="1" cellspacing="0">' . "\n";
        foreach ($causes as $i => $cause) {
            $html .= '<tr><td colspan="3" bgcolor="#ff9999">'
               . str_repeat('-', $i) . ' <b>' . $cause['class'] . '</b>: '
               . htmlspecialchars($cause['message']) . ' in <b>' . $cause['file'] . '</b> '
               . 'on line <b>' . $cause['line'] . '</b>'
               . "</td></tr>\n";
        }
        $html .= '<tr><td colspan="3" bgcolor="#aaaaaa" align="center"><b>Exception trace</b></td></tr>' . "\n"
               . '<tr><td align="center" bgcolor="#cccccc" width="20"><b>#</b></td>'
               . '<td align="center" bgcolor="#cccccc"><b>Function</b></td>'
               . '<td align="center" bgcolor="#cccccc"><b>Location</b></td></tr>' . "\n";

        foreach ($trace as $k => $v) {
            $html .= '<tr><td align="center">' . $k . '</td>'
                   . '<td>';
            if (!empty($v['class'])) {
                $html .= $v['class'] . $v['type'];
            }
            $html .= $v['function'];
            $args = array();
            if (!empty($v['args'])) {
                foreach ($v['args'] as $arg) {
                    if (is_null($arg)) $args[] = 'null';
                    elseif (is_array($arg)) $args[] = 'Array';
                    elseif (is_object($arg)) $args[] = 'Object('.get_class($arg).')';
                    elseif (is_bool($arg)) $args[] = $arg ? 'true' : 'false';
                    elseif (is_int($arg) || is_double($arg)) $args[] = $arg;
                    else {
                        $arg = (string)$arg;
                        $str = htmlspecialchars(substr($arg, 0, 16));
                        if (strlen($arg) > 16) $str .= '&hellip;';
                        $args[] = "'" . $str . "'";
                    }
                }
            }
            $html .= '(' . implode(', ',$args) . ')'
                   . '</td>'
                   . '<td>' . (isset($v['file']) ? $v['file'] : 'unknown')
                   . ':' . (isset($v['line']) ? $v['line'] : 'unknown')
                   . '</td></tr>' . "\n";
        }
        $html .= '<tr><td align="center">' . ($k+1) . '</td>'
               . '<td>{main}</td>'
               . '<td>&nbsp;</td></tr>' . "\n"
               . '</table>';
        return $html;
    }

    public function toText()
    {
        $causes = array();
        $this->getCauseMessage($causes);
        $causeMsg = '';
        foreach ($causes as $i => $cause) {
            $causeMsg .= str_repeat(' ', $i) . $cause['class'] . ': '
                   . $cause['message'] . ' in ' . $cause['file']
                   . ' on line ' . $cause['line'] . "\n";
        }
        return $causeMsg . $this->getTraceAsString();
    }
}
?><?php
class PEAR2_MultiErrors_Exception extends PEAR2_Exception {}<?php
/**
 * class to do http requests, uses a adapter based system for performing those requests
 *
 * Loosely Based on PEAR HTTP_Response
 *
 * @version $Id$
 */
class PEAR2_HTTP_Request 
{

    /**
     * The adapter that the requester uses.
     *
     * @see adapters
     */
    protected $adapter;

    /**
     * The listeners
     *
     * This variable contains the listeners that are
     * set (can be set) on this object.
     *
     * @var array $_listeners  The listeners
     */
    protected $_listeners = array();
    
    /**
     * Magic to retrieve items that are actually stored in the adapter
     *
     * @param  string $name name of var to get
     */
    public function __get($name)
    {
        if (isset($this->adapter->$name)) {
            return $this->adapter->$name;
        }
    }

    /**
     * Magic to set items that are actually stored in the adapter
     *
     * @param  string $name name of var to set
     * @param  mixed $value to give to var
     */
    public function __set($name, $value)
    {
        switch($name) {
            case 'verb':
                $this->adapter->verb = strtoupper($value);
                break;
            case 'uri':
            case 'url':
                $this->adapter->uri = new PEAR2_HTTP_Request_Uri($value);
                break;
            case 'body':
            case 'content':
                if (is_array($value)) {
                    $this->adapter->body = http_build_query($value);
                    $this->setHeader('Content-Type','application/x-www-form-urlencoded');
                    if ($this->adapter->verb == 'GET') {
                        $this->adapter->verb = 'POST';
                    }
                } else {
                    $this->adapter->body = $value;
                }
                break;
            case 'requestTimeout':
                $this->adapter->$name = (int)$value;
            case 'proxy':
                $this->adapter->$name = new PEAR2_HTTP_Request_Uri($value);
                break;
            default:
                $this->adapter->$name = $value;
                break;
        }
    }

    /**
     * sets up the adapter
     *
     * @param  string $class adapter to use
     */
    public function __construct($url = null, $instance = null) 
    {
        if (!is_null($instance) && $instance instanceof PEAR2_HTTP_Request_Adapter) {
            $this->adapter = $instance;
        } elseif (extension_loaded('http')) {
            $this->adapter = new PEAR2_HTTP_Request_Adapter_Http;
        } elseif (ini_get('allow_url_fopen') == true) {
            $this->adapter = new PEAR2_HTTP_Request_Adapter_Phpstream;
        } else {
            $this->adapter = new PEAR2_HTTP_Request_Adapter_Phpsocket;
        }

        $this->adapter->setListeners($this->_listeners);

        if ($url) {
            $this->url = $url;
        }
    }

    /**
     * asks for a response class from the adapter
     *
     * @return PEAR2_HTTP_Request_Response
     */
    public function sendRequest() 
    {
        $response = $this->adapter->sendRequest();
        return $response;
    }

    /**
     * Sends a request storing the output to a file
     *
     * @param  string $file File to store too
     * @return PEAR2_HTTP_Request_Response with no body
     */
    public function requestToFile($file) {
        $response = $this->adapter->requestToFile($file);
        return $response;
    }

    /**
     * Setter for request headers
     * 
     * @see $this->adapter->headers
     */
    public function setHeader($header, $value) 
    {
        $this->adapter->headers[$header] = $value;
    }

    /**
     * Attach a listener
     *
     * This method adds a listener to the list of listeners that are 
     * notified of the object's events.
     *
     * Events sent by the HTTP_Request Object
     *  - 'connect'     : On connection to server
     *  - 'sentRequest' : After the request was sent to server
     *  - 'disconnect'  : Upon server disconnection
     *
     * Events sent by the HTTP_Response object
     *  - 'gotHeaders' : After receiving response header
     *  - 'tick'       : On receiving part of response
     *  - 'gzTick'     : On receiving a gzip-encoded part
     *  - 'gotBody'    : Upon receiving body of the message
     *
     *
     * @param  PEAR2_HTTP_Request_Listener $listener  The listener object
     * @return boolean Whether object is a listener or not
     */
    public function attach(PEAR2_HTTP_Request_Listener &$listener)
    {
        $this->_listeners[$listener->getId()] =& $listener;
        return true;
    }

    /**
     * Detach a listener
     *
     * This method will detach the listener that was set
     * to a request.
     *
     * @param  PEAR2_HTTP_Request_Listener $listener   The listener
     * @return bool true
     */
    public function detach(PEAR2_HTTP_Request_Listener &$listener)
    {
        if (isset($this->_listeners[$listener->getId()])) {
            $this->_listeners[$listener->getId()] = null;
        }

        return true;
    }

    /**
     * Notify
     *
     * This method notifies all registered listeners of
     * the event that just happened.
     *
     * @param     string  $event  The event name
     * @param     mixed  $data   Additional data
     * @see       PEAR2_HTTP_Request->attach()
     * @return    void
     */
    protected function _notify($event, $data = null)
    {
        if (!empty($this->_listeners)) {
            foreach (array_keys($this->_listeners) as $id) {
                $this->_listeners[$id]->update($this, $event, $data);
            }
        }
    }

    /**
     * Get the class name of the adapter that is being used
     */
    public function getAdapterName() {
        return get_class($this->adapter);
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php
abstract class PEAR2_HTTP_Request_Adapter 
{

    /**
     * HTTP Version
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.1
     */
    public $httpVersion = 'HTTP/1.1';

    /**
     * Uri to make the request too
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2
     */
    public $uri;

    /**
     * Called Method in the spec
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1
     */
    public $verb = 'GET';

    /**
     * Additional headers to send
     * @var array   Header Name => Header value
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.3
     */
    public $headers = array();

    /**
     * Value to send as the body of the message, you need to handle the encoding
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
     */
    public $body;

    /**
     * How long to wait until a request times out
     * @float seconds
     */
    public $requestTimeout = 10;

    /**
     * Full uri of the proxy server
     * @var PEAR2_HTTP_Request_Uri
     */
    public $proxy = null;

    /**
     * HTTP Return code
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
     */
    public $code = 100;

    /**
     * Listeners from the parent
     */
    protected $_listeners;

    /**
     * Parsed cookies
     * @var array
     */
    public $cookies = array();

    /**
     * @todo i don't like this approach
     */
    public function setListeners(&$listeners) {
        $this->_listeners &= $listeners;
    }

    /**
     * Send the specified request
     */
    public function sendRequest() 
    {
    }

    /**
     * Send a request storing the results to a file and return a response class with no body
     *
     * Base Adapter contains a non efficient baseline method
     */
    public function requestToFile($file) 
    {
        $response = $this->sendRequest();

        file_put_contents($file,$response->body);
        unset($response->body);
    }

    protected function parseResponseCode($line) 
    {
        if (sscanf($line, 'HTTP/%s %s', $http_version, $returncode) != 2) {
            throw new PEAR2_HTTP_Request_Exception('Malformed response.');
        } else {
            return array('code' => intval($returncode), 'httpVersion' => $http_version);
        }
    }

   /**
    * Processes the response header
    *
    * @access private
    * @param  string    HTTP header
    */
    protected function processHeader($header)
    {
        if (strpos($header, ':') === false) {
            return;
        }

        list($headername, $headervalue) = explode(':', $header, 2);
        if (strstr($headername,'-')) {
            list($p1,$p2) = explode('-',$headername);
            $headername  = ucfirst(strtolower($p1)).'-'.ucfirst(strtolower($p2));
        }
        else {
            $headername  = ucfirst($headername);
        }
        $headervalue = ltrim($headervalue);

        if ('set-cookie' != $headername) {
            if (isset($this->headers[$headername])) {
                $this->headers[$headername] .= ',' . $headervalue;
            } else {
                $this->headers[$headername]  = $headervalue;
            }
        } else {
            $this->cookies[] = $this->parseCookie($headervalue);
        }
    }


    /**
     * Parse a Set-Cookie header to fill $cookies array
     *
     * @access private
     * @param  string    value of Set-Cookie header
     */
    protected function parseCookie($headervalue)
    {
        $cookie = array(
            'expires' => null,
            'domain'  => null,
            'path'    => null,
            'secure'  => false
        );

        // Only a name=value pair
        if (!strpos($headervalue, ';')) {
            $pos = strpos($headervalue, '=');
            $cookie['name']  = trim(substr($headervalue, 0, $pos));
            $cookie['value'] = trim(substr($headervalue, $pos + 1));

            // Some optional parameters are supplied
        } else {
            $elements = explode(';', $headervalue);
            $pos = strpos($elements[0], '=');
            $cookie['name']  = trim(substr($elements[0], 0, $pos));
            $cookie['value'] = trim(substr($elements[0], $pos + 1));

            for ($i = 1; $i < count($elements); $i++) {
                if (false === strpos($elements[$i], '=')) {
                    $elName  = trim($elements[$i]);
                    $elValue = null;
                } else {
                    list ($elName, $elValue) = array_map('trim', explode('=', $elements[$i]));
                }

                $elName = strtolower($elName);

                if ($elName == 'secure') {
                    $cookie['secure'] = true;
                } elseif ($elName == 'expires') {
                    $cookie['expires'] = str_replace('"', '', $elValue);
                } elseif ($elName == 'path' || $elName == 'domain') {
                    $cookie[$elName] = urldecode($elValue);
                } else {
                    $cookie[$elName] = $elValue;
                }
            }
        }
        return $cookie;
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
<?php
class PEAR2_HTTP_Request_Adapter_Phpsocket_Socket {
        public $lineLength = 2048;
        private $_handle;

        public function __construct($handle) {
                $this->_handle = $handle;
        }

        public function readLine() {
                $line = '';
                while(!$this->eof()) {
                        $line .= @fgets($this->_handle, $this->lineLength);
                        if (substr($line, -1) == "\n") {
                                return rtrim($line, "\r\n");
                        }
                }
                return false;
        }

        public function read($size) {
                if ($this->eof()) {
                        return false;
                }
                return @fread($this->_handle,$size);
        }

        public function write($payload) {
                return fwrite($this->_handle,$payload,strlen($payload));
        }

        public function eof() {
                return feof($this->_handle);
        }
}

/**
 * A class which represents an Http Reponse
 * Handles parsing cookies and headers
 *
 * Based on PEAR HTTP_Response
 *
 * @version $Revision: 1.52 $
 */
class PEAR2_HTTP_Request_Adapter_Phpsocket extends PEAR2_HTTP_Request_Adapter {

    
    /**
     * Used by _readChunked(): remaining length of the current chunk
     * @var string
     */
    private $_chunkLength = 0;

    /**
     * Bytes left to read from message-body
     * @var null|int
     */
    private $_toRead = null;

    /**
     * Raw Response to be parsed
     */
    private $_stream;

    public function sendRequest() {
        $payload = $this->_buildHeaders($this->uri->path,$this->uri->host,$this->headers,strlen($this->body));
        $payload .= $this->body;
        $this->body = '';

        $errno    = 0;
        $errstr   = '';
        $handle   = @fsockopen($this->uri->host, $this->uri->port, $errno, $errstr, 30);

        if (!is_resource($handle)) {
            throw new PEAR2_HTTP_Request_Exception("Couldn't connection to host using Phpsocket Adapter, fsockopen errors($errstr,$errno)");
        }
        stream_set_timeout($handle,10);

        $this->_stream = new PEAR2_HTTP_Request_Adapter_Phpsocket_Socket($handle);

        $this->_stream->write($payload);

        $this->parse();

        $details['code'] = $this->code;
        $details['httpVersion'] = $this->httpVersion;


        $response = new PEAR2_HTTP_Request_Response(
            $details,$this->body,new PEAR2_HTTP_Request_Headers($this->headers),$this->cookies);
        return $response;
    }

    /**
     * Parse a HTTP response
     * 
     * This extracts response code, headers, cookies and decodes body if it 
     * was encoded in some way
     *
     * @access public
     * @param  bool      Whether to store response body in object property, set
     *                   this to false if downloading a LARGE file and using a Listener.
     *                   This is assumed to be true if body is gzip-encoded.
     * @param  bool      Whether the response can actually have a message-body.
     *                   Will be set to false for HEAD requests.
     * @throws Exception
     * @return boolean     true on success
     */
    public function parse($saveBody = true, $canHaveBody = true)
    {
        do {
            $line = $this->_stream->readLine();
            $code = $this->parseResponseCode($line);
            $this->httpVersion = 'HTTP/' . $code['httpVersion'];
            $this->code     = $code['code'];

            while ('' !== ($header = $this->_stream->readLine())) {
                $this->processHeader($header);
            }
        } while ($this->code == 100);

        // RFC 2616, section 4.4:
        // 1. Any response message which "MUST NOT" include a message-body ... 
        // is always terminated by the first empty line after the header fields 
        // 3. ... If a message is received with both a
        // Transfer-Encoding header field and a Content-Length header field,
        // the latter MUST be ignored.
        $canHaveBody = $canHaveBody && $this->code >= 200 && 
                       $this->code != 204 && $this->code != 304;

        // If response body is present, read it and decode
        $chunked = isset($this->headers['transfer-encoding']) && ('chunked' == $this->headers['transfer-encoding']);
        $gzipped = isset($this->headers['content-encoding']) && ('gzip' == $this->headers['content-encoding']);
        $hasBody = false;
        if ($canHaveBody && ($chunked || !isset($this->headers['content-length']) || 
                0 != $this->headers['content-length']))
        {
            if ($chunked || !isset($this->headers['content-length'])) {
                $this->_toRead = null;
            } else {
                $this->_toRead = $this->headers['content-length'];
            }
            while (!$this->_stream->eof() && (is_null($this->_toRead) || $this->_toRead > 0)) {
                if ($chunked) {
                    $data = $this->_readChunked();
                } elseif (is_null($this->_toRead)) {
                    $data = $this->_stream->read(4096);
                } else {
                    $data = $this->_stream->read(min(4096, $this->_toRead));
                    $this->_toRead -= strlen($data);
                }
                if ($data == '') {
                    break;
                } else {
                    $hasBody = true;
                    if ($saveBody || $gzipped) {
                        $this->body .= $data;
                    }
                }
            }
        }

        if ($hasBody) {
            // Uncompress the body if needed
            if ($gzipped) {
                $body = $this->_decodeGzip($this->body);
                if (PEAR::isError($body)) {
                    return $body;
                }
                $this->body = $body;
            }
        }
        return true;
    }

   /**
    * Read a part of response body encoded with chunked Transfer-Encoding
    * 
    * @access private
    * @return string
    */
    private function _readChunked()
    {
        // at start of the next chunk?
        if (0 == $this->_chunkLength) {
            $line = $this->_stream->readLine();
            if (preg_match('/^([0-9a-f]+)/i', $line, $matches)) {
                $this->_chunkLength = hexdec($matches[1]); 
                // Chunk with zero length indicates the end
                if (0 == $this->_chunkLength) {
                    $this->_stream->readLine(); // make this an eof()
                    return '';
                }
            } else {
                return '';
            }
        }
        $data = $this->_stream->read($this->_chunkLength);
        $this->_chunkLength -= strlen($data);
        if (0 == $this->_chunkLength) {
            $this->_stream->readLine(); // Trailing CRLF
        }
        return $data;
    }

   /**
    * Decodes the message-body encoded by gzip
    *
    * The real decoding work is done by gzinflate() built-in function, this
    * method only parses the header and checks data for compliance with
    * RFC 1952  
    *
    * @access   private
    * @param    string  gzip-encoded data
    * @return   string  decoded data
    */
    private function _decodeGzip($data)
    {
        $length = strlen($data);
        // If it doesn't look like gzip-encoded data, don't bother
        if ($length < 18 || strcmp(substr($data, 0, 2), "\x1f\x8b")) {
            return $data;
        }
        $method = ord(substr($data, 2, 1));
        if ($method != 8) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): unknown compression method');
        }
        
        $flags = ord(substr($data, 3, 1));

        if ($flags & 224) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): reserved bits are set');
        }

        // header is 10 bytes minimum. may be longer, though.
        $headerLength = 10;
        // extra fields, need to skip 'em
        if ($flags & 4) {
            if ($length - $headerLength - 2 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            
            $extraLength = unpack('v', substr($data, 10, 2));
            if ($length - $headerLength - 2 - $extraLength[1] < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }

            $headerLength += $extraLength[1] + 2;
        }
        // file name, need to skip that
        if ($flags & 8) {
            if ($length - $headerLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $filenameLength = strpos(substr($data, $headerLength), chr(0));
            if (false === $filenameLength || $length - $headerLength - $filenameLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $headerLength += $filenameLength + 1;
        }
        // comment, need to skip that also
        if ($flags & 16) {
            if ($length - $headerLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $commentLength = strpos(substr($data, $headerLength), chr(0));
            if (false === $commentLength || $length - $headerLength - $commentLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $headerLength += $commentLength + 1;
        }
        // have a CRC for header. let's check
        if ($flags & 1) {
            if ($length - $headerLength - 2 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $crcReal   = 0xffff & crc32(substr($data, 0, $headerLength));
            $crcStored = unpack('v', substr($data, $headerLength, 2));
            if ($crcReal != $crcStored[1]) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): header CRC check failed');
            }
            $headerLength += 2;
        }
        // unpacked data CRC and size at the end of encoded data
        $tmp = unpack('V2', substr($data, -8));
        $dataCrc  = $tmp[1];
        $dataSize = $tmp[2];

        // finally, call the gzinflate() function
        $unpacked = @gzinflate(substr($data, $headerLength, -8), $dataSize);
        if (false === $unpacked) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): gzinflate() call failed');
        } elseif ($dataSize != strlen($unpacked)) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data size check failed');
        } elseif ($dataCrc != crc32($unpacked)) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data CRC check failed');
        }
        return $unpacked;
    }

    private function _buildHeaders($path, $host, $headers,$bodySize) {
        $httpRequest  = "$this->verb $path $this->httpVersion\r\n";
        $httpRequest .= "Host: $host\r\n";
        foreach($headers as $key => $value) {
            $httpRequest .= "$key: $value\r\n";
        }
        if ($bodySize > 0) {
            $httpRequest .= "Content-Length:".$bodySize."\r\n";
        }
        $httpRequest .= "\r\n";

        return $httpRequest;
    }
} // End class PEAR2_HTTP_Response
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php
/**
 * driver that uses php http:// stream to do requests
 *
 * Loosely Based on PEAR HTTP_Response
 *
 * @version $Revision: 1.52 $
 */
class PEAR2_HTTP_Request_Adapter_PhpStream extends PEAR2_HTTP_Request_Adapter
{
    private $_phpErrorStr;

    /**
     * Throws exception if allow_url_fopen is off
     */
    public function __construct()
    {
        if (ini_get('allow_url_fopen') == false) {
            throw new PEAR2_HTTP_Request_Exception(
                'allow_url_fopen is off, the http:// stream wrapper will not function'
            );
        }
    }


    /**
     * Send the request
     *
     * This function sends the actual request to the
     * remote/local webserver using php streams.
     */
    public function sendRequest()
    {

        $proxyurl = '';
        if (!is_null($this->proxy)) {
            $proxyurl = $this->proxy->url;
        }
        // create context with proper junk
        $ctx = stream_context_create(
            array(
                $this->uri->protocol => array(
                    'method' => $this->verb,
                    'content' => $this->body,
                    'header' => $this->buildHeaderString(),
                    'proxy'  => $proxyurl,
                )
            )
        );

        set_error_handler(array($this,'_errorHandler'));
        $fp = fopen($this->uri->url, 'rb', false, $ctx);
        if (!is_resource($fp)) {
            // php sucks
            if (strpos($this->_phpErrorStr, 'HTTP/1.1 304')) {
                restore_error_handler();
                $details = $this->uri->toArray();

                $details['code'] = '304';
                $details['httpVersion'] = '1.1';

                return new PEAR2_HTTP_Request_Response($details,'',array(),array());
            }
            restore_error_handler();
            throw new PEAR2_HTTP_Request_Exception('Url ' . $this->uri->url . ' could not be opened (PhpStream Adapter ('.$this->_phpErrorStr.'))');
        } else {
            restore_error_handler();
        }

        stream_set_timeout($fp, $this->requestTimeout);
        $body = stream_get_contents($fp);

        if ($body === false) {
            throw new PEAR2_HTTP_Request_Exception(
                'Url ' . $this->uri->url . ' did not return a response'
            );
        }

        $meta = stream_get_meta_data($fp);
        fclose($fp);

        $headers = $meta['wrapper_data'];

        $details = $this->uri->toArray();

        $tmp = $this->parseResponseCode($headers[0]);
        $details['code'] = $tmp['code'];
        $details['httpVersion'] = $tmp['httpVersion'];

        $cookies = array();
        $this->headers = $this->cookies = array();

        foreach($headers as $line) {
            $this->processHeader($line);
        }

        return new PEAR2_HTTP_Request_Response(
            $details,$body,new PEAR2_HTTP_Request_Headers($this->headers),$this->cookies);
    }

    /**
     * Build header String
     *
     * This method builds the header string
     * to be passed to the request.
     *
     * @return string $out  The headers
     */
    private function buildHeaderString()
    {
        $out = '';
        foreach($this->headers as $header => $value) {
            $out .= "$header: $value\r\n";
        }
        return $out;
    }

    /**
     * This has to be public to be used as a callback but its actually private
     */
    public function _errorHandler($errno,$errstr) {
        $this->_phpErrorStr = $errstr;
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php
class PEAR2_HTTP_Request_Exception extends PEAR2_Exception {
}
<?php

/**
 * A container for HTTP request headers provides case insensitive access
 *
 * Array style access and object style access is provided
 *
 * Lazy processing of case insensitive access is provided so we don't strtolower the keys
 * until the headers are actually used
 *
 * @todo decide if this should be pulled out of the package and provided as a generic class
 */
class PEAR2_HTTP_Request_Headers implements Iterator, ArrayAccess, Countable {

	const ORIGINAL_CASE = 'fields';
	const LOWER_CASE = 'lowerCase';
	const CAMEL_CASE = 'camelCase';

	public $iterationStyle = self::LOWER_CASE;

	protected $fields = array();
	protected $camelCase = null;
	protected $lowerCase = null;

	/**
	 * Takes the headers to provide access too
	 */
	public function __construct($fields) {
		$this->fields = $fields;
	}

	/**
	 * Magic getter for object access
	 */
	public function __get($key) {
		if (is_null($this->camelCase)) {
			$this->camelCaseFields();
		}

		if (isset($this->camelCase[$key])) {
			return $this->camelCase[$key];
		}
		return null;
	}

	/**
	 * Magic setter for object access
	 *
	 * @todo set $this->fields and $this->lowerCase
	 */
	public function __set($key,$value) {
		$this->camelCase[$key] = $value;
	}

	/**
	 * Magic isset for object access
	 */
	public function __isset($key) {
		if (is_null($this->camelCase)) {
			$this->camelCaseFields();
		}
		return isset($this->camelCase[$key]);
	}

	/**
	 * Magic unset for object access
	 */
	public function __unset($key) {
		if (is_null($this->camelCase)) {
			$this->camelCaseFields();
		}
		unset($this->camelCase[$key]);
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetExists($key) {
		if (is_null($this->lowerCase)) {
			$this->lowerCaseFields();
		}
		$key = strtolower($key);
		return isset($this->lowerCase[$key]);
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetGet($key) {
		if (is_null($this->lowerCase)) {
			$this->lowerCaseFields();
		}
		$key = strtolower($key);
		if (isset($this->lowerCase[$key])) {
			return $this->lowerCase[$key];
		}
		return null;
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetSet($key,$value) {
		$key = strtolower($key);

		$this->lowerCase[$key] = $value;
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetUnset($key) {
		if (is_null($this->lowerCase)) {
			$this->lowerCaseFields();
		}
		$key = strtolower($key);
		unset($this->lowerCase[$key]);
	}

	/**
	 * Return the number of headers
	 * Countable interface implmentation
	 */
	public function count() {
		return count($this->fields);
	}

	/**
	 * Iterator Implmentation
	 */
	public function current() {
		return current($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function key() {
		return key($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function next() {
		return next($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function rewind() {
		if (is_null($this->{$this->iterationStyle})) {
			$m = $this->iterationStyle."Fields";
			$this->$m();
		}
		reset($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function valid() {
		return (boolean) current($this->{$this->iterationStyle});
	}

	/**
	 * Make all keys lower case
	 */
	protected function lowerCaseFields() {
		$fields = array();
		foreach($this->fields as $k => $v) {
			$fields[strtolower($k)] = $v;
		}
		$this->lowerCase = $fields;
	}

	/**
	 * Make all keys camel case, removing dashes
	 */
	protected function camelCaseFields() {
		$fields = array();
		foreach($this->fields as $k => $v) {
			$pieces = explode('-',$k);
			$pieces = array_map('ucfirst',$pieces);
			$fields[implode('',$pieces)] = $v;
		}
		$this->camelCase = $fields;
	}
}
<?php
/**
 * A class which represents an HTTP Reponse
 *
 */
class PEAR2_HTTP_Request_Response
{
    /**
     * HTTP Return code
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
     */
    public $code = 100;

    /**
     * Response headers
     * @var array
     */
    public $headers;

    /**
     * Cookies set in response
     * @var array
     */
    public $cookies;

    /**
     * Response body
     * @var string
     */
    public $body = '';

    /**
     * Constructor
     *
     *
     * @see $this->body
     * @see $this->headers
     * @see $this->cookies
     */
    public function __construct($details, $body, $headers, $cookies)
    {
        foreach($details as $name => $value) {
            $this->$name = $value;
        }

        $this->body    = $body;
        $this->headers = $headers;
        $this->cookies = $cookies;
    }

    /**
     * Return the body of the response
     */
    public function __toString() {
        return $this->body;
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php

/**
 * Simple class for parsing url/uris
 *
 * Basically compatiable with Net_URL2 propery names but not methods
 */
class PEAR2_HTTP_Request_Uri {

	protected $pieces = array();
	protected $map = array(
			'url' => 'uri',
			'querystring' => 'query',
			'anchor' => 'fragment',
			'protocol' => 'scheme',
			);
	protected $schemes = array(
			'http' => 80,
			'https'=> 443,
		);

	public function __construct($uri) {
		$this->pieces = parse_url($uri);
		$this->pieces['uri'] = $uri;
		if (!isset($this->pieces['port'])) {
			if (isset($this->schemes[$this->pieces['scheme']])) {
				$this->pieces['port'] = $this->schemes[$this->pieces['scheme']];
			}
			else {
				$this->pieces['port'] = 80;
			}
		}
	}

	public function __get($key) {
		if (isset($this->map[$key])) {
			$key = $this->map[$key];
		}
		if (isset($this->pieces[$key])) {
			return $this->pieces[$key];
		}
		return null;
	}

	public function toArray() {
		return $this->pieces;
	}
}
Ùæs∆Ä˙£JD)Ò˝;õ:“`‚3   GBMB