<?php
if (!class_exists('Phar')) {
    if (!class_exists('PHP_Archive')) {
?><?php
/**
 * PHP_Archive Class (implements .phar)
 *
 * @package PHP_Archive
 * @category PHP
 */
/**
 * PHP_Archive Class (implements .phar)
 *
 * PHAR files a singular archive from which an entire application can run.
 * To use it, simply package it using {@see PHP_Archive_Creator} and use phar://
 * URIs to your includes. i.e. require_once 'phar://config.php' will include config.php
 * from the root of the PHAR file.
 *
 * Gz code borrowed from the excellent File_Archive package by Vincent Lascaux.
 *
 * @copyright Copyright David Shafik and Synaptic Media 2004. All rights reserved.
 * @author Davey Shafik <davey@synapticmedia.net>
 * @author Greg Beaver <cellog@php.net>
 * @link http://www.synapticmedia.net Synaptic Media
 * @version $Id: Archive.php,v 1.52 2007/09/01 20:28:14 cellog Exp $
 * @package PHP_Archive
 * @category PHP
 */
 
class PHP_Archive
{
    const GZ = 0x00001000;
    const BZ2 = 0x00002000;
    const SIG = 0x00010000;
    const SHA1 = 0x0002;
    const MD5 = 0x0001;
    /**
     * Whether this archive is compressed with zlib
     *
     * @var bool
     */
    private $_compressed;
    /**
     * @var string Real path to the .phar archive
     */
    private $_archiveName = null;
    /**
     * Current file name in the phar
     * @var string
     */
    protected $currentFilename = null;
    /**
     * Length of current file in the phar
     * @var string
     */
    protected $internalFileLength = null;
    /**
     * Current file statistics (size, creation date, etc.)
     * @var string
     */
    protected $currentStat = null;
    /**
     * @var resource|null Pointer to open .phar
     */
    protected $fp = null;
    /**
     * @var int Current Position of the pointer
     */
    protected $position = 0;

    /**
     * Map actual realpath of phars to meta-data about the phar
     *
     * Data is indexed by the alias that is used by internal files.  In other
     * words, if a file is included via:
     * <code>
     * require_once 'phar://PEAR.phar/PEAR/Installer.php';
     * </code>
     * then the alias is "PEAR.phar"
     * 
     * Information stored is a boolean indicating whether this .phar is compressed
     * with zlib, another for bzip2, phar-specific meta-data, and
     * the precise offset of internal files
     * within the .phar, used with the {@link $_manifest} to load actual file contents
     * @var array
     */
    private static $_pharMapping = array();
    /**
     * Map real file paths to alias used
     *
     * @var array
     */
    private static $_pharFiles = array();
    /**
     * File listing for the .phar
     * 
     * The manifest is indexed per phar.
     * 
     * Files within the .phar are indexed by their relative path within the
     * .phar.  Each file has this information in its internal array
     *
     * - 0 = uncompressed file size
     * - 1 = timestamp of when file was added to phar
     * - 2 = offset of file within phar relative to internal file's start
     * - 3 = compressed file size (actual size in the phar)
     * @var array
     */
    private static $_manifest = array();
    /**
     * Absolute offset of internal files within the .phar, indexed by absolute
     * path to the .phar
     *
     * @var array
     */
    private static $_fileStart = array();
    /**
     * file name of the phar
     *
     * @var string
     */
    private $_basename;


    /**
     * Default MIME types used for the web front controller
     *
     * @var array
     */
    public static $defaultmimes = array(
            'aif' => 'audio/x-aiff',
            'aiff' => 'audio/x-aiff',
            'arc' => 'application/octet-stream',
            'arj' => 'application/octet-stream',
            'art' => 'image/x-jg',
            'asf' => 'video/x-ms-asf',
            'asx' => 'video/x-ms-asf',
            'avi' => 'video/avi',
            'bin' => 'application/octet-stream',
            'bm' => 'image/bmp',
            'bmp' => 'image/bmp',
            'bz2' => 'application/x-bzip2',
            'css' => 'text/css',
            'doc' => 'application/msword',
            'dot' => 'application/msword',
            'dv' => 'video/x-dv',
            'dvi' => 'application/x-dvi',
            'eps' => 'application/postscript',
            'exe' => 'application/octet-stream',
            'gif' => 'image/gif',
            'gz' => 'application/x-gzip',
            'gzip' => 'application/x-gzip',
            'htm' => 'text/html',
            'html' => 'text/html',
            'ico' => 'image/x-icon',
            'jpe' => 'image/jpeg',
            'jpg' => 'image/jpeg',
            'jpeg' => 'image/jpeg',
            'js' => 'application/x-javascript',
            'log' => 'text/plain',
            'mid' => 'audio/x-midi',
            'mov' => 'video/quicktime',
            'mp2' => 'audio/mpeg',
            'mp3' => 'audio/mpeg3',
            'mpg' => 'audio/mpeg',
            'pdf' => 'aplication/pdf',
            'png' => 'image/png',
            'rtf' => 'application/rtf',
            'tif' => 'image/tiff',
            'tiff' => 'image/tiff',
            'txt' => 'text/plain',
            'xml' => 'text/xml',
        );

    public static $defaultphp = array(
        'php' => true
        );

    public static $defaultphps = array(
        'phps' => true
        );

    public static $deny = array('/.+\.inc$/');

    public static function viewSource($archive, $file)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        if (self::_fileExists($archive, $_GET['viewsource'])) {
            $source = highlight_file('phar://@ALIAS@/' .
                $_GET['viewsource'], true);
            header('Content-Type: text/html');
            header('Content-Length: ' . strlen($source));
            echo '<html><head><title>Source of ',
                htmlspecialchars($_GET['viewsource']), '</title></head>';
            echo '<body><h1>Source of ',
                htmlspecialchars($_GET['viewsource']), '</h1>';
            if (isset($_GET['introspect'])) {
                echo '<a href="', htmlspecialchars($_SERVER['PHP_SELF']),
                    '?introspect=', urlencode(htmlspecialchars($_GET['introspect'])),
                    '">Return to ', htmlspecialchars($_GET['introspect']), '</a><br />';
            }
            echo $source;
            return false;
        } else {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        
    }

    public static function introspect($archive, $dir)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        if (!$dir) {
            $dir = '/';
        }
        $dir = self::processFile($dir);
        if ($dir[0] != '/') {
            $dir = '/' . $dir;
        }
        try {
            $self = htmlspecialchars($_SERVER['PHP_SELF']);
            $iterate = new DirectoryIterator('phar://@ALIAS@' . $dir);
            echo '<html><head><title>Introspect ', htmlspecialchars($dir),
                '</title></head><body><h1>Introspect ', htmlspecialchars($dir),
                '</h1><ul>';
            if ($dir != '/') {
                echo '<li><a href="', $self, '?introspect=',
                    htmlspecialchars(dirname($dir)), '">..</a></li>';
            }
            foreach ($iterate as $entry) {
                if ($entry->isDot()) continue;
                $name = self::processFile($entry->getPathname());
                $name = str_replace('phar://@ALIAS@/', '', $name);
                if ($entry->isDir()) {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '/</a> [directory]</li>';
                } else {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($dir)), '&viewsource=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '</a></li>';
                }
            }
            return false;
        } catch (Exception $e) {
            echo '<html><head><title>Directory not found: ',
                htmlspecialchars($dir), '</title></head>',
                '<body><h1>Directory not found: ', htmlspecialchars($dir), '</h1>',
                '<p>Try <a href="', htmlspecialchars($_SERVER['PHP_SELF']), '?introspect=/">',
                'This link</a></p></body></html>';
            return false;
        }
    }

    public static function webFrontController($initfile)
    {
        if (isset($_SERVER) && isset($_SERVER['REQUEST_URI'])) {
            $uri = parse_url($_SERVER['REQUEST_URI']);
            $archive = realpath($_SERVER['SCRIPT_FILENAME']);
            $subpath = str_replace('/' . basename($archive), '', $uri['path']);
            if (!$subpath || $subpath == '/') {
                if (isset($_GET['viewsource'])) {
                    return self::viewSource($archive, $_GET['viewsource']);
                }
                if (isset($_GET['introspect'])) {
                    return self::introspect($archive, $_GET['introspect']);
                }
                $subpath = '/' . $initfile;
            }
            if (!self::_fileExists($archive, substr($subpath, 1))) {
                header("HTTP/1.0 404 Not Found");
                return false;
            }
            foreach (self::$deny as $pattern) {
                if (preg_match($pattern, $subpath)) {
                    header("HTTP/1.0 404 Not Found");
                    return false;
                }
            }
            $inf = pathinfo(basename($subpath));
            if (!isset($inf['extension'])) {
                header('Content-Type: text/plain');
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://@ALIAS@' . $subpath);
                return false;
            }
            if (isset(self::$defaultphp[$inf['extension']])) {
                include 'phar://@ALIAS@' . $subpath;
                return false;
            }
            if (isset(self::$defaultmimes[$inf['extension']])) {
                header('Content-Type: ' . self::$defaultmimes[$inf['extension']]);
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://@ALIAS@' . $subpath);
                return false;
            }
            if (isset(self::$defaultphps[$inf['extension']])) {
                header('Content-Type: text/html');
                $c = highlight_file('phar://@ALIAS@' . $subpath, true);
                header('Content-Length: ' . strlen($c));
                echo $c;
                return false;
            }
            header('Content-Type: text/plain');
            header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
            readfile('phar://@ALIAS@' . $subpath);
        }
    }

    /**
     * Detect end of stub
     *
     * @param string $buffer stub past '__HALT_'.'COMPILER();'
     * @return end of stub, prior to length of manifest.
     */
    private static final function _endOfStubLength($buffer)
    {
        $pos = 0;
        if (!strlen($buffer)) {
            return $pos;
        }
        if (($buffer[0] == ' ' || $buffer[0] == "\n") && @substr($buffer, 1, 2) == '?>')
        {
            $pos += 3;
            if ($buffer[$pos] == "\r" && $buffer[$pos+1] == "\n") {
                $pos += 2;
            }
            else if ($buffer[$pos] == "\n") {
                $pos += 1;
            }
        }
        return $pos;
    }

    /**
     * Allows loading an external Phar archive without include()ing it
     *
     * @param string $file  phar package to load
     * @param string $alias alias to use
     * @throws Exception
     */
    public static final function loadPhar($file, $alias = NULL)
    {
        $file = realpath($file);
        if ($file) {
            $fp = fopen($file, 'rb');
            $buffer = '';
            while (!feof($fp)) {
                $buffer .= fread($fp, 8192);
                // don't break phars
                if ($pos = strpos($buffer, '__HALT_COMPI' . 'LER();')) {
                    $buffer .= fread($fp, 5);
                    fclose($fp);
                    $pos += 18;
                    $pos += self::_endOfStubLength(substr($buffer, $pos));
                    return self::_mapPhar($file, $pos, $alias);
                }
            }
            fclose($fp);
        }
    }

    /**
     * Map a full real file path to an alias used to refer to the .phar
     *
     * This function can only be called from the initialization of the .phar itself.
     * Any attempt to call from outside the .phar or to re-alias the .phar will fail
     * as a security measure.
     * @param string $alias
     * @param int $dataoffset the value of __COMPILER_HALT_OFFSET__
     */
    public static final function mapPhar($alias = NULL, $dataoffset = NULL)
    {
        try {
            $trace = debug_backtrace();
            $file = $trace[0]['file'];
            // this ensures that this is safe
            if (!in_array($file, get_included_files())) {
                die('SECURITY ERROR: PHP_Archive::mapPhar can only be called from within ' .
                    'the phar that initiates it');
            }
            $file = realpath($file);
            if (!isset($dataoffset)) {
                $dataoffset = constant('__COMPILER_HALT_OFFSET'.'__');
                $fp = fopen($file, 'rb');
                fseek($fp, $dataoffset, SEEK_SET);
                $dataoffset = $dataoffset + self::_endOfStubLength(fread($fp, 5));
                fclose($fp);
            }

            self::_mapPhar($file, $dataoffset);
        } catch (Exception $e) {
            die($e->getMessage());
        }
    }

    /**
     * Sub-function, allows recovery from errors
     *
     * @param unknown_type $file
     * @param unknown_type $dataoffset
     */
    private static function _mapPhar($file, $dataoffset, $alias = NULL)
    {
        $file = realpath($file);
        if (isset(self::$_manifest[$file])) {
            return;
        }
        if (!is_array(self::$_pharMapping)) {
            self::$_pharMapping = array();
        }
        $fp = fopen($file, 'rb');
        // seek to __HALT_COMPILER_OFFSET__
        fseek($fp, $dataoffset);
        $manifest_length = unpack('Vlen', fread($fp, 4));
        $manifest = '';
        $last = '1';
        while (strlen($last) && strlen($manifest) < $manifest_length['len']) {
            $read = 8192;
            if ($manifest_length['len'] - strlen($manifest) < 8192) {
                $read = $manifest_length['len'] - strlen($manifest);
            }
            $last = fread($fp, $read);
            $manifest .= $last;
        }
        if (strlen($manifest) < $manifest_length['len']) {
            throw new Exception('ERROR: manifest length read was "' . 
                strlen($manifest) .'" should be "' .
                $manifest_length['len'] . '"');
        }
        $info = self::_unserializeManifest($manifest);
        if ($info['alias']) {
            $alias = $info['alias'];
            $explicit = true;
        } else {
            if (!isset($alias)) {
                $alias = $file;
            }
            $explicit = false;
        }
        self::$_manifest[$file] = $info['manifest'];
        $compressed = $info['compressed'];
        self::$_fileStart[$file] = ftell($fp);
        fclose($fp);
        if ($compressed & 0x00001000) {
            if (!function_exists('gzinflate')) {
                throw new Exception('Error: zlib extension is not enabled - gzinflate() function needed' .
                    ' for compressed .phars');
            }
        }
        if ($compressed & 0x00002000) {
            if (!function_exists('bzdecompress')) {
                throw new Exception('Error: bzip2 extension is not enabled - bzdecompress() function needed' .
                    ' for compressed .phars');
            }
        }
        if (isset(self::$_pharMapping[$alias])) {
            throw new Exception('ERROR: PHP_Archive::mapPhar has already been called for alias "' .
                $alias . '" cannot re-alias to "' . $file . '"');
        }
        self::$_pharMapping[$alias] = array($file, $compressed, $dataoffset, $explicit,
            $info['metadata']);
        self::$_pharFiles[$file] = $alias;
    }

    /**
     * extract the manifest into an internal array
     *
     * @param string $manifest
     * @return false|array
     */
    private static function _unserializeManifest($manifest)
    {
        // retrieve the number of files in the manifest
        $info = unpack('V', substr($manifest, 0, 4));
        $apiver = substr($manifest, 4, 2);
        $apiver = bin2hex($apiver);
        $apiver_dots = hexdec($apiver[0]) . '.' . hexdec($apiver[1]) . '.' . hexdec($apiver[2]);
        $majorcompat = hexdec($apiver[0]);
        $calcapi = explode('.', self::APIVersion());
        if ($calcapi[0] != $majorcompat) {
            throw new Exception('Phar is incompatible API version ' . $apiver_dots . ', but ' .
                'PHP_Archive is API version '.self::APIVersion());
        }
        if ($calcapi[0] === '0') {
            if (self::APIVersion() != $apiver_dots) {
                throw new Exception('Phar is API version ' . $apiver_dots .
                    ', but PHP_Archive is API version '.self::APIVersion(), E_USER_ERROR);
            }
        }
        $flags = unpack('V', substr($manifest, 6, 4));
        $ret = array('compressed' => $flags & 0x00003000);
        // signature is not verified by default in PHP_Archive, phar is better
        $ret['hassignature'] = $flags & 0x00010000;
        $aliaslen = unpack('V', substr($manifest, 10, 4));
        if ($aliaslen) {
            $ret['alias'] = substr($manifest, 14, $aliaslen[1]);
        } else {
            $ret['alias'] = false;
        }
        $manifest = substr($manifest, 14 + $aliaslen[1]);
        $metadatalen = unpack('V', substr($manifest, 0, 4));
        if ($metadatalen[1]) {
            $ret['metadata'] = unserialize(substr($manifest, 4, $metadatalen[1]));
            $manifest = substr($manifest, 4 + $metadatalen[1]);
        } else {
            $ret['metadata'] = null;
            $manifest = substr($manifest, 4);
        }
        $offset = 0;
        $start = 0;
        for ($i = 0; $i < $info[1]; $i++) {
            // length of the file name
            $len = unpack('V', substr($manifest, $start, 4));
            $start += 4;
            // file name
            $savepath = substr($manifest, $start, $len[1]);
            $start += $len[1];
            // retrieve manifest data:
            // 0 = uncompressed file size
            // 1 = timestamp of when file was added to phar
            // 2 = compressed filesize
            // 3 = crc32
            // 4 = flags
            // 5 = metadata length
            $ret['manifest'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($manifest, $start, 24)));
            $ret['manifest'][$savepath][3] = sprintf('%u', $ret['manifest'][$savepath][3]
                & 0xffffffff);
            if ($ret['manifest'][$savepath][5]) {
                $ret['manifest'][$savepath][6] = unserialize(substr($manifest, $start + 24,
                    $ret['manifest'][$savepath][5]));
            } else {
                $ret['manifest'][$savepath][6] = null;
            }
            $ret['manifest'][$savepath][7] = $offset;
            $offset += $ret['manifest'][$savepath][2];
            $start += 24 + $ret['manifest'][$savepath][5];
        }
        return $ret;
    }

    /**
     * @param string
     */
    private static function processFile($path)
    {
        if ($path == '.') {
            return '';
        }
        $std = str_replace("\\", "/", $path);
        while ($std != ($std = ereg_replace("[^\/:?]+/\.\./", "", $std))) ;
        $std = str_replace("/./", "", $std);
        if (strlen($std) > 1 && $std[0] == '/') {
            $std = substr($std, 1);
        }
        if (strncmp($std, "./", 2) == 0) {
            return substr($std, 2);
        } else {
            return $std;
        }
    }

    /**
     * Seek in the master archive to a matching file or directory
     * @param string
     */
    protected function selectFile($path, $allowdirs = true)
    {
        $std = self::processFile($path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            $this->_setCurrentFile($path);
            return true;
        }
        if (!$allowdirs) {
            return 'Error: "' . $path . '" is not a file in phar "' . $this->_basename . '"';
        }
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if (empty($std) ||
                  //$std is a directory
                  strncmp($std.'/', $path, strlen($std)+1) == 0) {
                $this->currentFilename = $this->internalFileLength = $this->currentStat = null;
                return true;
            }
        }
        return 'Error: "' . $path . '" not found in phar "' . $this->_basename . '"';
    }

    private function _setCurrentFile($path)
    {
        $this->currentStat = array(
            2 => 0100444, // file mode, readable by all, writeable by none
            4 => 0, // uid
            5 => 0, // gid
            7 => self::$_manifest[$this->_archiveName][$path][0], // size
            9 => self::$_manifest[$this->_archiveName][$path][1], // creation time
            );
        $this->currentFilename = $path;
        $this->internalFileLength = self::$_manifest[$this->_archiveName][$path][2];
        // seek to offset of file header within the .phar
        if (is_resource(@$this->fp)) {
            fseek($this->fp, self::$_fileStart[$this->_archiveName] + self::$_manifest[$this->_archiveName][$path][7]);
        }
    }

    private static function _fileExists($archive, $path)
    {
        return isset(self::$_manifest[$archive]) &&
            isset(self::$_manifest[$archive][$path]);
    }

    private static function _filesize($archive, $path)
    {
        return self::$_manifest[$archive][$path][0];
    }

    /**
     * Seek to a file within the master archive, and extract its contents
     * @param string
     * @return array|string an array containing an error message string is returned
     *                      upon error, otherwise the file contents are returned
     */
    public function extractFile($path)
    {
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            return array('Error: cannot open phar "' . $this->_archiveName . '"');
        }
        if (($e = $this->selectFile($path, false)) === true) {
            $data = '';
            $count = $this->internalFileLength;
            while ($count) {
                if ($count < 8192) {
                    $data .= @fread($this->fp, $count);
                    $count = 0;
                } else {
                    $count -= 8192;
                    $data .= @fread($this->fp, 8192);
                }
            }
            @fclose($this->fp);
            if (self::$_manifest[$this->_archiveName][$path][4] & self::GZ) {
                $data = gzinflate($data);
            } elseif (self::$_manifest[$this->_archiveName][$path][4] & self::BZ2) {
                $data = bzdecompress($data);
            }
            if (!isset(self::$_manifest[$this->_archiveName][$path]['ok'])) {
                if (strlen($data) != $this->currentStat[7]) {
                    return array("Not valid internal .phar file (size error {$size} != " .
                        $this->currentStat[7] . ")");
                }
                if (self::$_manifest[$this->_archiveName][$path][3] != sprintf("%u", crc32($data) & 0xffffffff)) {
                    return array("Not valid internal .phar file (checksum error)");
                }
                self::$_manifest[$this->_archiveName][$path]['ok'] = true;
            }
            return $data;
        } else {
            @fclose($this->fp);
            return array($e);
        }
    }

    /**
     * Parse urls like phar:///fullpath/to/my.phar/file.txt
     *
     * @param string $file
     * @return false|array
     */
    static protected function parseUrl($file)
    {
        if (substr($file, 0, 7) != 'phar://') {
            return false;
        }
        $file = substr($file, 7);
    
        $ret = array('scheme' => 'phar');
        $pos_p = strpos($file, '.phar.php');
        $pos_z = strpos($file, '.phar.gz');
        $pos_b = strpos($file, '.phar.bz2');
        if ($pos_p) {
            if ($pos_z) {
                return false;
            }
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar.php'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_z) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.gz'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_b) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.bz2'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif (($pos_p = strpos($file, ".phar")) !== false) {
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } else {
            return false;
        }
        if (!$ret['path']) {
            $ret['path'] = '/';
        }
        return $ret;
    }
    
    /**
     * Locate the .phar archive in the include_path and detect the file to open within
     * the archive.
     *
     * Possible parameters are phar://pharname.phar/filename_within_phar.ext
     * @param string a file within the archive
     * @return string the filename within the .phar to retrieve
     */
    public function initializeStream($file)
    {
        $file = self::processFile($file);
        $info = @parse_url($file);
        if (!$info) {
            $info = self::parseUrl($file);
        }
        if (!$info) {
            return false;
        }
        if (!isset($info['host'])) {
            // malformed internal file
            return false;
        }
        if (!isset(self::$_pharFiles[$info['host']]) &&
              !isset(self::$_pharMapping[$info['host']])) {
            try {
                self::loadPhar($info['host']);
                // use alias from here out
                $info['host'] = self::$_pharFiles[$info['host']];
            } catch (Exception $e) {
                return false;
            }
        }
        if (!isset($info['path'])) {
            return false;
        } elseif (strlen($info['path']) > 1) {
            $info['path'] = substr($info['path'], 1);
        }
        if (isset(self::$_pharMapping[$info['host']])) {
            $this->_basename = $info['host'];
            $this->_archiveName = self::$_pharMapping[$info['host']][0];
            $this->_compressed = self::$_pharMapping[$info['host']][1];
        } elseif (isset(self::$_pharFiles[$info['host']])) {
            $this->_archiveName = $info['host'];
            $this->_basename = self::$_pharFiles[$info['host']];
            $this->_compressed = self::$_pharMapping[$this->_basename][1];
        }
        $file = $info['path'];
        return $file;
    }

    /**
     * Open the requested file - PHP streams API
     *
     * @param string $file String provided by the Stream wrapper
     * @access private
     */
    public function stream_open($file)
    {
        return $this->_streamOpen($file);
    }

    /**
     * @param string filename to opne, or directory name
     * @param bool if true, a directory will be matched, otherwise only files
     *             will be matched
     * @uses trigger_error()
     * @return bool success of opening
     * @access private
     */
    private function _streamOpen($file, $searchForDir = false)
    {
        $path = $this->initializeStream($file);
        if (!$path) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
        }
        if (is_array($this->file = $this->extractFile($path))) {
            trigger_error($this->file[0], E_USER_ERROR);
            return false;
        }
        if ($path != $this->currentFilename) {
            if (!$searchForDir) {
                trigger_error("Cannot open '$file', is a directory", E_USER_ERROR);
                return false;
            } else {
                $this->file = '';
                return true;
            }
        }

        if (!is_null($this->file) && $this->file !== false) {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Read the data - PHP streams API
     *
     * @param int
     * @access private
     */
    public function stream_read($count)
    {
        $ret = substr($this->file, $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }
    
    /**
     * Whether we've hit the end of the file - PHP streams API
     * @access private
     */
    function stream_eof()
    {
        return $this->position >= $this->currentStat[7];
    }
    
    /**
     * For seeking the stream - PHP streams API
     * @param int
     * @param SEEK_SET|SEEK_CUR|SEEK_END
     * @access private
     */
    public function stream_seek($pos, $whence)
    {
        switch ($whence) {
            case SEEK_SET:
                if ($pos < 0) {
                    return false;
                }
                $this->position = $pos;
                break;
            case SEEK_CUR:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position += $pos;
                break;
            case SEEK_END:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position = $pos + $this->currentStat[7];
                break;
            default:
                return false;
        }
        return true;
    }
    
    /**
     * The current position in the stream - PHP streams API
     * @access private
     */
    public function stream_tell()
    {
        return $this->position;
    }

    /**
     * The result of an fstat call, returns mod time from creation, and file size -
     * PHP streams API
     * @uses _stream_stat()
     * @access private
     */
    public function stream_stat()
    {
        return $this->_stream_stat();
    }

    /**
     * Retrieve statistics on a file or directory within the .phar
     * @param string file/directory to stat
     * @access private
     */
    public function _stream_stat($file = null)
    {
        $std = $file ? self::processFile($file) : $this->currentFilename;
        if ($file) {
            if (isset(self::$_manifest[$this->_archiveName][$file])) {
                $this->_setCurrentFile($file);
                $isdir = false;
            } else {
                do {
                    $isdir = false;
                    if ($file == '/') {
                        break;
                    }
                    foreach (self::$_manifest[$this->_archiveName] as $path => $info) {
                        if (strpos($path, $file) === 0) {
                            if (strlen($path) > strlen($file) &&
                                  $path[strlen($file)] == '/') {
                                break 2;
                            }
                        }
                    }
                    // no files exist and no directories match this string
                    return false;
                } while (false);
                $isdir = true;
            }
        } else {
            $isdir = false; // open streams must be files
        }
        $mode = $isdir ? 0040444 : 0100444;
        // 040000 = dir, 010000 = file
        // everything is readable, nothing is writeable
        return array(
           0, 0, $mode, 0, 0, 0, 0, 0, 0, 0, 0, 0, // non-associative indices
           'dev' => 0, 'ino' => 0,
           'mode' => $mode,
           'nlink' => 0, 'uid' => 0, 'gid' => 0, 'rdev' => 0, 'blksize' => 0, 'blocks' => 0,
           'size' => $this->currentStat[7],
           'atime' => $this->currentStat[9],
           'mtime' => $this->currentStat[9],
           'ctime' => $this->currentStat[9],
           );
    }

    /**
     * Stat a closed file or directory - PHP streams API
     * @param string
     * @param int
     * @access private
     */
    public function url_stat($url, $flags)
    {
        $path = $this->initializeStream($url);
        return $this->_stream_stat($path);
    }

    /**
     * Open a directory in the .phar for reading - PHP streams API
     * @param string directory name
     * @access private
     */
    public function dir_opendir($path)
    {
        $info = @parse_url($path);
        if (!$info) {
            $info = self::parseUrl($path);
            if (!$info) {
                trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                    E_USER_ERROR);
                return false;
            }
        }
        $path = !empty($info['path']) ?
            $info['host'] . $info['path'] : $info['host'] . '/';
        $path = $this->initializeStream('phar://' . $path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                E_USER_ERROR);
            return false;
        }
        if ($path == false) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
            return false;
        }
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            trigger_error('Error: cannot open phar "' . $this->_archiveName . '"');
            return false;
        }
        $this->_dirFiles = array();
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if ($path == '/') {
                if (strpos($file, '/')) {
                    $a = explode('/', $file);
                    $this->_dirFiles[array_shift($a)] = true;
                } else {
                    $this->_dirFiles[$file] = true;
                }
            } elseif (strpos($file, $path) === 0) {
                $fname = substr($file, strlen($path) + 1);
                if (strpos($fname, '/')) {
                    // this is a directory
                    $a = explode('/', $fname);
                    $this->_dirFiles[array_shift($a)] = true;
                } elseif ($file[strlen($path)] == '/') {
                    // this is a file
                    $this->_dirFiles[$fname] = true;
                }
            }
        }
        @fclose($this->fp);
        if (!count($this->_dirFiles)) {
            return false;
        }
        @uksort($this->_dirFiles, 'strnatcmp');
        return true;
    }

    /**
     * Read the next directory entry - PHP streams API
     * @access private
     */
    public function dir_readdir()
    {
        $ret = key($this->_dirFiles);
        @next($this->_dirFiles);
        if (!$ret) {
            return false;
        }
        return $ret;
    }

    /**
     * Close a directory handle opened with opendir() - PHP streams API
     * @access private
     */
    public function dir_closedir()
    {
        $this->_dirFiles = array();
        return true;
    }

    /**
     * Rewind to the first directory entry - PHP streams API
     * @access private
     */
    public function dir_rewinddir()
    {
        @reset($this->_dirFiles);
        return true;
    }

    /**
     * API version of this class
     * @return string
     */
    public static final function APIVersion()
    {
        return '1.0.0';
    }

    /**
     * Retrieve Phar-specific metadata for a Phar archive
     *
     * @param string $phar full path to Phar archive, or alias
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getPharMetadata($phar)
    {
        if (isset(self::$_pharFiles[$phar])) {
            $phar = self::$_pharFiles[$phar];
        }
        if (!isset(self::$_pharMapping[$phar])) {
            throw new Exception('Unknown Phar archive: "' . $phar . '"');
        }
        return self::$_pharMapping[$phar][4];
    }

    /**
     * Retrieve File-specific metadata for a Phar archive file
     *
     * @param string $phar full path to Phar archive, or alias
     * @param string $file relative path to file within Phar archive
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getFileMetadata($phar, $file)
    {
        if (!isset(self::$_pharFiles[$phar])) {
            if (!isset(self::$_pharMapping[$phar])) {
                throw new Exception('Unknown Phar archive: "' . $phar . '"');
            }
            $phar = self::$_pharMapping[$phar][0];
        }
        if (!isset(self::$_manifest[$phar])) {
            throw new Exception('Unknown Phar: "' . $phar . '"');
        }
        $file = self::processFile($file);
        if (!isset(self::$_manifest[$phar][$file])) {
            throw new Exception('Unknown file "' . $file . '" within Phar "'. $phar . '"');
        }
        return self::$_manifest[$phar][$file][6];
    }

    /**
     * @return list of supported signature algorithmns.
     */
    public static function getsupportedsignatures()
    {
        $ret = array('MD5', 'SHA-1');
        if (extension_loaded('hash')) {
            $ret[] = 'SHA-256';
            $ret[] = 'SHA-512';
        }
        return $ret;
    }
}
?><?php
    }
    if (!in_array('phar', stream_get_wrappers(), true)) {
        stream_wrapper_register('phar', 'PHP_Archive');
    }
}
define('PYRUS_PHAR_FILE', __FILE__);
include 'phar://' . __FILE__ . '/__index.php';
__HALT_COMPILER(); ?>
J           5   s:45:"package-pear2.php.net-PEAR2_Pyrus-2.0.0a1.xml";   __index.phpþ   ¥I>Hþ   ,O¸#¶      -   package-pear2.php.net-PEAR2_Pyrus-2.0.0a1.xmlpT  ¥I>HpT  ¨Ôe7¶         data/pear2.php.net/PEAR2_Pyrus/    ¥I>H        ÿ      .   data/pear2.php.net/PEAR2_Pyrus/channel-1.0.xsd    ¥I>H        ¶      .   data/pear2.php.net/PEAR2_Pyrus/package-2.0.xsd    ¥I>H        ¶      .   data/pear2.php.net/PEAR2_Pyrus/package-2.1.xsd    ¥I>H        ¶      
   src/PEAR2/    ¥I>H        ÿ         src/PEAR2/Pyrus.php    ¥I>H        ¶         src/PEAR2/Pyrus/    ¥I>H        ÿ         src/PEAR2/Pyrus/Channel.php    ¥I>H        ¶         src/PEAR2/Pyrus/Channel/    ¥I>H        ÿ          src/PEAR2/Pyrus/Channel/Base.php    ¥I>H        ¶      %   src/PEAR2/Pyrus/Channel/Exception.php    ¥I>H        ¶      #   src/PEAR2/Pyrus/Channel/IMirror.php    ¥I>H        ¶      "   src/PEAR2/Pyrus/Channel/Mirror.php    ¥I>H        ¶      #   src/PEAR2/Pyrus/ChannelRegistry.php    ¥I>H        ¶          src/PEAR2/Pyrus/ChannelRegistry/    ¥I>H        ÿ      (   src/PEAR2/Pyrus/ChannelRegistry/Base.php    ¥I>H        ¶      (   src/PEAR2/Pyrus/ChannelRegistry/Channel/    ¥I>H        ÿ      1   src/PEAR2/Pyrus/ChannelRegistry/Channel/Pear1.php    ¥I>H        ¶      2   src/PEAR2/Pyrus/ChannelRegistry/Channel/Sqlite.php    ¥I>H        ¶      /   src/PEAR2/Pyrus/ChannelRegistry/Channel/Xml.php    ¥I>H        ¶      -   src/PEAR2/Pyrus/ChannelRegistry/Exception.php    ¥I>H        ¶      '   src/PEAR2/Pyrus/ChannelRegistry/Mirror/    ¥I>H        ÿ      1   src/PEAR2/Pyrus/ChannelRegistry/Mirror/Sqlite.php    ¥I>H        ¶      .   src/PEAR2/Pyrus/ChannelRegistry/Mirror/Xml.php    ¥I>H        ¶      2   src/PEAR2/Pyrus/ChannelRegistry/ParseException.php    ¥I>H        ¶      )   src/PEAR2/Pyrus/ChannelRegistry/Pear1.php    ¥I>H        ¶      *   src/PEAR2/Pyrus/ChannelRegistry/Sqlite.php    ¥I>H        ¶      '   src/PEAR2/Pyrus/ChannelRegistry/Xml.php    ¥I>H        ¶         src/PEAR2/Pyrus/Config.php    ¥I>H        ¶         src/PEAR2/Pyrus/Config/    ¥I>H        ÿ      $   src/PEAR2/Pyrus/Config/Exception.php    ¥I>H        ¶         src/PEAR2/Pyrus/Dependency/    ¥I>H        ÿ      (   src/PEAR2/Pyrus/Dependency/Exception.php    ¥I>H        ¶      (   src/PEAR2/Pyrus/Dependency/Validator.php    ¥I>H        ¶      !   src/PEAR2/Pyrus/DirectedGraph.php    ¥I>H        ¶         src/PEAR2/Pyrus/DirectedGraph/    ¥I>H        ÿ      +   src/PEAR2/Pyrus/DirectedGraph/Exception.php    ¥I>H        ¶      (   src/PEAR2/Pyrus/DirectedGraph/Vertex.php    ¥I>H        ¶         src/PEAR2/Pyrus/Downloader.php    ¥I>H        ¶         src/PEAR2/Pyrus/Exception.php    ¥I>H        ¶      $   src/PEAR2/Pyrus/FileTransactions.php    ¥I>H        ¶      !   src/PEAR2/Pyrus/FileTransactions/    ¥I>H        ÿ      0   src/PEAR2/Pyrus/FileTransactions/Installedas.php    ¥I>H        ¶      +   src/PEAR2/Pyrus/FileTransactions/Rename.php    ¥I>H        ¶      *   src/PEAR2/Pyrus/FileTransactions/Rmdir.php    ¥I>H        ¶         src/PEAR2/Pyrus/IChannel.php    ¥I>H        ¶      $   src/PEAR2/Pyrus/IChannelRegistry.php    ¥I>H        ¶      $   src/PEAR2/Pyrus/IFileTransaction.php    ¥I>H        ¶         src/PEAR2/Pyrus/ILog.php    ¥I>H        ¶         src/PEAR2/Pyrus/Installer.php    ¥I>H        ¶         src/PEAR2/Pyrus/Installer/    ¥I>H        ÿ      '   src/PEAR2/Pyrus/Installer/Exception.php    ¥I>H        ¶      "   src/PEAR2/Pyrus/Installer/Role.php    ¥I>H        ¶         src/PEAR2/Pyrus/Installer/Role/    ¥I>H        ÿ      )   src/PEAR2/Pyrus/Installer/Role/Common.php    ¥I>H        ¶      '   src/PEAR2/Pyrus/Installer/Role/Data.php    ¥I>H        ¶      '   src/PEAR2/Pyrus/Installer/Role/Data.xml    ¥I>H        ¶      &   src/PEAR2/Pyrus/Installer/Role/Doc.php    ¥I>H        ¶      &   src/PEAR2/Pyrus/Installer/Role/Doc.xml    ¥I>H        ¶      ,   src/PEAR2/Pyrus/Installer/Role/Exception.php    ¥I>H        ¶      &   src/PEAR2/Pyrus/Installer/Role/Ext.php    ¥I>H        ¶      &   src/PEAR2/Pyrus/Installer/Role/Ext.xml    ¥I>H        ¶      &   src/PEAR2/Pyrus/Installer/Role/Php.php    ¥I>H        ¶      &   src/PEAR2/Pyrus/Installer/Role/Php.xml    ¥I>H        ¶      )   src/PEAR2/Pyrus/Installer/Role/Script.php    ¥I>H        ¶      )   src/PEAR2/Pyrus/Installer/Role/Script.xml    ¥I>H        ¶      &   src/PEAR2/Pyrus/Installer/Role/Src.php    ¥I>H        ¶      &   src/PEAR2/Pyrus/Installer/Role/Src.xml    ¥I>H        ¶      '   src/PEAR2/Pyrus/Installer/Role/Test.php    ¥I>H        ¶      '   src/PEAR2/Pyrus/Installer/Role/Test.xml    ¥I>H        ¶      &   src/PEAR2/Pyrus/Installer/Role/Www.php    ¥I>H        ¶      &   src/PEAR2/Pyrus/Installer/Role/Www.xml    ¥I>H        ¶         src/PEAR2/Pyrus/IPackage.php    ¥I>H        ¶         src/PEAR2/Pyrus/IRegistry.php    ¥I>H        ¶         src/PEAR2/Pyrus/Log.php    ¥I>H        ¶         src/PEAR2/Pyrus/OSGuess.php    ¥I>H        ¶         src/PEAR2/Pyrus/Package.php    ¥I>H        ¶         src/PEAR2/Pyrus/Package/    ¥I>H        ÿ          src/PEAR2/Pyrus/Package/Base.php    ¥I>H        ¶      #   src/PEAR2/Pyrus/Package/Creator.php    ¥I>H        ¶          src/PEAR2/Pyrus/Package/Creator/    ¥I>H        ÿ      -   src/PEAR2/Pyrus/Package/Creator/Exception.php    ¥I>H        ¶      0   src/PEAR2/Pyrus/Package/Creator/TaskIterator.php    ¥I>H        ¶      &   src/PEAR2/Pyrus/Package/Dependency.php    ¥I>H        ¶      %   src/PEAR2/Pyrus/Package/Exception.php    ¥I>H        ¶      $   src/PEAR2/Pyrus/Package/ICreator.php    ¥I>H        ¶      .   src/PEAR2/Pyrus/Package/InstalledException.php    ¥I>H        ¶          src/PEAR2/Pyrus/Package/Phar.php    ¥I>H        ¶         src/PEAR2/Pyrus/Package/Phar/    ¥I>H        ÿ      *   src/PEAR2/Pyrus/Package/Phar/Exception.php    ¥I>H        ¶      "   src/PEAR2/Pyrus/Package/Remote.php    ¥I>H        ¶         src/PEAR2/Pyrus/Package/Tar.php    ¥I>H        ¶         src/PEAR2/Pyrus/Package/Tar/    ¥I>H        ÿ      )   src/PEAR2/Pyrus/Package/Tar/Exception.php    ¥I>H        ¶         src/PEAR2/Pyrus/Package/Xml.php    ¥I>H        ¶         src/PEAR2/Pyrus/Package/Zip.php    ¥I>H        ¶         src/PEAR2/Pyrus/Package/Zip/    ¥I>H        ÿ      )   src/PEAR2/Pyrus/Package/Zip/Exception.php    ¥I>H        ¶         src/PEAR2/Pyrus/PackageFile.php    ¥I>H        ¶         src/PEAR2/Pyrus/PackageFile/    ¥I>H        ÿ      )   src/PEAR2/Pyrus/PackageFile/Exception.php    ¥I>H        ¶      *   src/PEAR2/Pyrus/PackageFile/IValidator.php    ¥I>H        ¶      #   src/PEAR2/Pyrus/PackageFile/Parser/    ¥I>H        ÿ      )   src/PEAR2/Pyrus/PackageFile/Parser/v2.php    ¥I>H        ¶      "   src/PEAR2/Pyrus/PackageFile/v2.php    ¥I>H        ¶         src/PEAR2/Pyrus/PackageFile/v2/    ¥I>H        ÿ      -   src/PEAR2/Pyrus/PackageFile/v2/Compatible.php    ¥I>H        ¶      *   src/PEAR2/Pyrus/PackageFile/v2/Compatible/    ¥I>H        ÿ      7   src/PEAR2/Pyrus/PackageFile/v2/Compatible/Exception.php    ¥I>H        ¶      /   src/PEAR2/Pyrus/PackageFile/v2/Dependencies.php    ¥I>H        ¶      ,   src/PEAR2/Pyrus/PackageFile/v2/Dependencies/    ¥I>H        ÿ      9   src/PEAR2/Pyrus/PackageFile/v2/Dependencies/Exception.php    ¥I>H        ¶      ,   src/PEAR2/Pyrus/PackageFile/v2/Developer.php    ¥I>H        ¶      )   src/PEAR2/Pyrus/PackageFile/v2/Developer/    ¥I>H        ÿ      6   src/PEAR2/Pyrus/PackageFile/v2/Developer/Exception.php    ¥I>H        ¶      (   src/PEAR2/Pyrus/PackageFile/v2/Files.php    ¥I>H        ¶      %   src/PEAR2/Pyrus/PackageFile/v2/Files/    ¥I>H        ÿ      2   src/PEAR2/Pyrus/PackageFile/v2/Files/Exception.php    ¥I>H        ¶      *   src/PEAR2/Pyrus/PackageFile/v2/Release.php    ¥I>H        ¶      '   src/PEAR2/Pyrus/PackageFile/v2/Release/    ¥I>H        ÿ      4   src/PEAR2/Pyrus/PackageFile/v2/Release/Exception.php    ¥I>H        ¶      )   src/PEAR2/Pyrus/PackageFile/v2/Remote.php    ¥I>H        ¶      ,   src/PEAR2/Pyrus/PackageFile/v2/Validator.php    ¥I>H        ¶      '   src/PEAR2/Pyrus/PackageFile/v2Iterator/    ¥I>H        ÿ      /   src/PEAR2/Pyrus/PackageFile/v2Iterator/File.php    ¥I>H        ¶      <   src/PEAR2/Pyrus/PackageFile/v2Iterator/FileAttribsFilter.php    ¥I>H        ¶      7   src/PEAR2/Pyrus/PackageFile/v2Iterator/FileContents.php    ¥I>H        ¶      <   src/PEAR2/Pyrus/PackageFile/v2Iterator/FileContentsMulti.php    ¥I>H        ¶      A   src/PEAR2/Pyrus/PackageFile/v2Iterator/FileInstallationFilter.php    ¥I>H        ¶      2   src/PEAR2/Pyrus/PackageFile/v2Iterator/FileTag.php    ¥I>H        ¶      <   src/PEAR2/Pyrus/PackageFile/v2Iterator/PackagingIterator.php    ¥I>H        ¶         src/PEAR2/Pyrus/Registry.php    ¥I>H        ¶         src/PEAR2/Pyrus/Registry/    ¥I>H        ÿ      !   src/PEAR2/Pyrus/Registry/Base.php    ¥I>H        ¶      $   src/PEAR2/Pyrus/Registry/Channel.php    ¥I>H        ¶      #   src/PEAR2/Pyrus/Registry/Config.php    ¥I>H        ¶      &   src/PEAR2/Pyrus/Registry/Exception.php    ¥I>H        ¶      $   src/PEAR2/Pyrus/Registry/Package.php    ¥I>H        ¶      "   src/PEAR2/Pyrus/Registry/Pear1.php    ¥I>H        ¶         src/PEAR2/Pyrus/Registry/Pear1/    ¥I>H        ÿ      *   src/PEAR2/Pyrus/Registry/Pear1/Package.php    ¥I>H        ¶      #   src/PEAR2/Pyrus/Registry/Sqlite.php    ¥I>H        ¶          src/PEAR2/Pyrus/Registry/Sqlite/    ¥I>H        ÿ      +   src/PEAR2/Pyrus/Registry/Sqlite/Creator.php    ¥I>H        ¶      +   src/PEAR2/Pyrus/Registry/Sqlite/Package.php    ¥I>H        ¶          src/PEAR2/Pyrus/Registry/Xml.php    ¥I>H        ¶         src/PEAR2/Pyrus/REST.php    ¥I>H        ¶         src/PEAR2/Pyrus/REST/    ¥I>H        ÿ         src/PEAR2/Pyrus/REST/10.php    ¥I>H        ¶         src/PEAR2/Pyrus/REST/11.php    ¥I>H        ¶         src/PEAR2/Pyrus/REST/13.php    ¥I>H        ¶      "   src/PEAR2/Pyrus/REST/Exception.php    ¥I>H        ¶      &   src/PEAR2/Pyrus/REST/HTTPException.php    ¥I>H        ¶         src/PEAR2/Pyrus/ScriptFrontend/    ¥I>H        ÿ      +   src/PEAR2/Pyrus/ScriptFrontend/Commands.php    ¥I>H        ¶         src/PEAR2/Pyrus/Task/    ¥I>H        ÿ         src/PEAR2/Pyrus/Task/Common.php    ¥I>H        ¶      "   src/PEAR2/Pyrus/Task/Exception.php    ¥I>H        ¶      *   src/PEAR2/Pyrus/Task/Postinstallscript.php    ¥I>H        ¶      '   src/PEAR2/Pyrus/Task/Postinstallscript/    ¥I>H        ÿ      -   src/PEAR2/Pyrus/Task/Postinstallscript/rw.php    ¥I>H        ¶          src/PEAR2/Pyrus/Task/Replace.php    ¥I>H        ¶         src/PEAR2/Pyrus/Task/Replace/    ¥I>H        ÿ      #   src/PEAR2/Pyrus/Task/Replace/rw.php    ¥I>H        ¶          src/PEAR2/Pyrus/Task/Unixeol.php    ¥I>H        ¶         src/PEAR2/Pyrus/Task/Unixeol/    ¥I>H        ÿ      #   src/PEAR2/Pyrus/Task/Unixeol/rw.php    ¥I>H        ¶      #   src/PEAR2/Pyrus/Task/Windowseol.php    ¥I>H        ¶          src/PEAR2/Pyrus/Task/Windowseol/    ¥I>H        ÿ      &   src/PEAR2/Pyrus/Task/Windowseol/rw.php    ¥I>H        ¶         src/PEAR2/Pyrus/test.php    ¥I>H        ¶         src/PEAR2/Pyrus/test1.php    ¥I>H        ¶         src/PEAR2/Pyrus/test2.php    ¥I>H        ¶         src/PEAR2/Pyrus/test3.php    ¥I>H        ¶         src/PEAR2/Pyrus/test4.php    ¥I>H        ¶         src/PEAR2/Pyrus/Validate.php    ¥I>H        ¶         src/PEAR2/Pyrus/Validate/    ¥I>H        ÿ      &   src/PEAR2/Pyrus/Validate/Exception.php    ¥I>H        ¶         src/PEAR2/Pyrus/Validator/    ¥I>H        ÿ      "   src/PEAR2/Pyrus/Validator/PECL.php    ¥I>H        ¶         src/PEAR2/Pyrus/XMLParser.php    ¥I>H        ¶         src/PEAR2/Pyrus/XMLParser/    ¥I>H        ÿ      '   src/PEAR2/Pyrus/XMLParser/Exception.php    ¥I>H        ¶         src/PEAR2/Pyrus/XMLWriter.php    ¥I>H        ¶         src/PEAR2/Pyrus/XMLWriter/    ¥I>H        ÿ      '   src/PEAR2/Pyrus/XMLWriter/Exception.php    ¥I>H        ¶         test/pear2.php.net/PEAR2_Pyrus/    ¥I>H        ÿ      ,   test/pear2.php.net/PEAR2_Pyrus/clean.php.inc    ¥I>H        ¶      5   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/    ¥I>H        ÿ      B   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/setup.php.inc    ¥I>H        ¶      >   test/pear2.php.net/PEAR2_Pyrus/Config/addConfigValue/test.phpt    ¥I>H        ¶      5   test/pear2.php.net/PEAR2_Pyrus/Config/configSnapshot/    ¥I>H        ÿ      B   test/pear2.php.net/PEAR2_Pyrus/Config/configSnapshot/setup.php.inc    ¥I>H        ¶      >   test/pear2.php.net/PEAR2_Pyrus/Config/configSnapshot/test.phpt    ¥I>H        ¶      8   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/    ¥I>H        ÿ      B   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/basic.phpt    ¥I>H        ¶      H   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/bin_dir.env.phpt    ¥I>H        ¶      I   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/bin_dir.env2.phpt    ¥I>H        ¶      H   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/bin_dir.win.phpt    ¥I>H        ¶      N   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/extension_dir.env.phpt    ¥I>H        ¶      O   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/extension_dir.env2.phpt    ¥I>H        ¶      N   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/extension_dir.ini.phpt    ¥I>H        ¶      E   test/pear2.php.net/PEAR2_Pyrus/Config/constructDefaults/setup.php.inc    ¥I>H        ¶      5   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/    ¥I>H        ÿ      G   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/badsystemfile.phpt    ¥I>H        ¶      E   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/baduserfile.phpt    ¥I>H        ¶      B   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/defaults.phpt    ¥I>H        ¶      H   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/goodsystemfile.phpt    ¥I>H        ¶      I   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/gooduser.mypath.phpt    ¥I>H        ¶      F   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/gooduserfile.phpt    ¥I>H        ¶      B   test/pear2.php.net/PEAR2_Pyrus/Config/loadConfigFile/setup.php.inc    ¥I>H        ¶      =   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/    ¥I>H        ÿ      G   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/basic.phpt    ¥I>H        ¶      J   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/run-tests.log    ¥I>H        ¶      J   test/pear2.php.net/PEAR2_Pyrus/Config/setCascadingRegistries/setup.php.inc    ¥I>H        ¶      3   test/pear2.php.net/PEAR2_Pyrus/Config/setup.php.inc    ¥I>H        ¶      -   test/pear2.php.net/PEAR2_Pyrus/DirectedGraph/    ¥I>H        ÿ      7   test/pear2.php.net/PEAR2_Pyrus/DirectedGraph/basic.phpt    ¥I>H        ¶      8   test/pear2.php.net/PEAR2_Pyrus/DirectedGraph/cycles.phpt    ¥I>H        ¶      :   test/pear2.php.net/PEAR2_Pyrus/DirectedGraph/setup.php.inc    ¥I>H        ¶      >   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/packages/    ¥I>H        ÿ      I   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/packages/package.xml    ¥I>H        ¶      J   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/packages/package2.xml    ¥I>H        ¶      B   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/setup.php.inc    ¥I>H        ¶      B   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/test_2.0.phpt    ¥I>H        ¶      B   test/pear2.php.net/PEAR2_Pyrus/PackageFile_Parser_v2/test_2.1.phpt    ¥I>H        ¶      (   test/pear2.php.net/PEAR2_Pyrus/Registry/    ¥I>H        ÿ      5   test/pear2.php.net/PEAR2_Pyrus/Registry/setup.php.inc    ¥I>H        ¶      5   test/pear2.php.net/PEAR2_Pyrus/test_framework.php.inc    ¥I>H        ¶      )   test/pear2.php.net/PEAR2_Pyrus/XMLParser/    ¥I>H        ÿ      5   test/pear2.php.net/PEAR2_Pyrus/XMLParser/attribs.phpt    ¥I>H        ¶      =   test/pear2.php.net/PEAR2_Pyrus/XMLParser/attribs_content.phpt    ¥I>H        ¶      3   test/pear2.php.net/PEAR2_Pyrus/XMLParser/cdata.phpt    ¥I>H        ¶      6   test/pear2.php.net/PEAR2_Pyrus/XMLParser/childtag.phpt    ¥I>H        ¶      >   test/pear2.php.net/PEAR2_Pyrus/XMLParser/childtag_attribs.phpt    ¥I>H        ¶      >   test/pear2.php.net/PEAR2_Pyrus/XMLParser/childtag_content.phpt    ¥I>H        ¶      F   test/pear2.php.net/PEAR2_Pyrus/XMLParser/childtag_sibling_attribs.phpt    ¥I>H        ¶      3   test/pear2.php.net/PEAR2_Pyrus/XMLParser/empty.phpt    ¥I>H        ¶      :   test/pear2.php.net/PEAR2_Pyrus/XMLParser/recursivetag.phpt    ¥I>H        ¶      6   test/pear2.php.net/PEAR2_Pyrus/XMLParser/setup.php.inc    ¥I>H        ¶      9   test/pear2.php.net/PEAR2_Pyrus/XMLParser/siblingtags.phpt    ¥I>H        ¶      )   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/    ¥I>H        ÿ      5   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/attribs.phpt    ¥I>H        ¶      =   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/attribs_content.phpt    ¥I>H        ¶      6   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/childtag.phpt    ¥I>H        ¶      >   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/childtag_attribs.phpt    ¥I>H        ¶      >   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/childtag_content.phpt    ¥I>H        ¶      F   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/childtag_sibling_attribs.phpt    ¥I>H        ¶      3   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/empty.phpt    ¥I>H        ¶      :   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/recursivetag.phpt    ¥I>H        ¶      6   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/setup.php.inc    ¥I>H        ¶      9   test/pear2.php.net/PEAR2_Pyrus/XMLWriter/siblingtags.phpt    ¥I>H        ¶         src/PEAR2/Autoload.php7	  ¥I>H7	  ®&&É¶         src/PEAR2/MultiErrors.phpN  ¥I>HN  <Á±¶         src/PEAR2/Exception.php 0  ¥I>H 0  zbÃ2¶         src/PEAR2/MultiErrors/    ¥I>H        ÿ      #   src/PEAR2/MultiErrors/Exception.phpB   ¥I>HB   úÇz²¶         src/PEAR2/HTTP/    ¥I>H        ÿ         src/PEAR2/HTTP/Request.php÷  ¥I>H÷  ÀUG¶         src/PEAR2/HTTP/Request/    ¥I>H        ÿ      "   src/PEAR2/HTTP/Request/Adapter.php  ¥I>H  XðÓ¶         src/PEAR2/HTTP/Request/Adapter/    ¥I>H        ÿ      ,   src/PEAR2/HTTP/Request/Adapter/Phpsocket.phpë,  ¥I>Hë,  Ñ~¦¶      ,   src/PEAR2/HTTP/Request/Adapter/Phpstream.php÷  ¥I>H÷  SøÄ¶      $   src/PEAR2/HTTP/Request/Exception.phpE   ¥I>HE   5Åö,¶      "   src/PEAR2/HTTP/Request/Headers.phpÙ  ¥I>HÙ  =2d¶      #   src/PEAR2/HTTP/Request/Response.phpD  ¥I>HD  t5üñ¶         src/PEAR2/HTTP/Request/Uri.phpÁ  ¥I>HÁ  m[º\¶      <?php
function __autoload($class)
{
    include 'phar://' . PYRUS_PHAR_FILE . '/src/' . implode('/', explode('_', $class)) . '.php';
}
$frontend = new PEAR2_Pyrus_ScriptFrontend_Commands;
@array_shift($_SERVER['argv']);
$frontend->run($_SERVER['argv']);
<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://pear.php.net/dtd/package-2.1" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.1" xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0     http://pear.php.net/dtd/tasks-1.0.xsd     http://pear.php.net/dtd/package-2.1     http://pear.php.net/dtd/package-2.1.xsd">
 <name>PEAR2_Pyrus</name>
 <channel>pear2.php.net</channel>
 <summary>Pyrus is the package manager and installer for PHP 5.3 or newer
</summary>
 <description>
Pyrus provides the means to install and manage installations for
packages built using package.xml version 2.0 or newer.  Pyrus is
redesigned from the ground up for PHP 5.3 or newer, and provides
significant improvements over the older PEAR Installer.

To use Pyrus, in this development series of releases, you need to
instantiate a simple script that creates a package and installs it:

&lt;?php
// use full path if include_path is not set up
include 'PEAR2/Autoload.php';
$config = PEAR2_Pyrus_Config::singleton('/where/to/install');
// this can be a url to a remote package, a local .tgz, .zip or package.xml
$p = new PEAR2_Pyrus_Package('thingtoinstall');
try {
    PEAR2_Pyrus_Installer::begin();
    PEAR2_Pyrus_Installer::prepare($p);
    PEAR2_Pyrus_Installer::commit();
} catch (Exception $e) {
    PEAR2_Pyrus_Installer::rollback();
    echo $e;
}
?&gt;</description>
 <lead>
  <name>Gregory Beaver</name>
  <user>cellog</user>
  <email>cellog@php.net</email>
  <active>yes</active>
 </lead>
 <date>2008-05-29</date>
 <version>
  <release>2.0.0a1</release>
  <api>0.1.0</api>
 </version>
 <stability>
  <release>alpha</release>
  <api>alpha</api>
 </stability>
 <license uri="http://www.opensource.org/licenses/bsd-license.php">New BSD License</license>
 <notes>Initial development release, no frontend is included</notes>
 <contents>
  <dir name="/">
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/siblingtags.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/recursivetag.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/empty.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/childtag_sibling_attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/childtag_content.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/childtag_attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/childtag.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/attribs_content.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLWriter/attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/siblingtags.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/recursivetag.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/empty.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/childtag_sibling_attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/childtag_content.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/childtag_attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/childtag.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/cdata.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/attribs_content.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//XMLParser/attribs.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//test_framework.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Registry/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//PackageFile_Parser_v2/test_2.1.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//PackageFile_Parser_v2/test_2.0.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//PackageFile_Parser_v2/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//PackageFile_Parser_v2/packages/package2.xml" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//PackageFile_Parser_v2/packages/package.xml" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//DirectedGraph/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//DirectedGraph/cycles.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//DirectedGraph/basic.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setCascadingRegistries/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setCascadingRegistries/run-tests.log" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/setCascadingRegistries/basic.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/gooduserfile.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/gooduser.mypath.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/goodsystemfile.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/defaults.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/baduserfile.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/loadConfigFile/badsystemfile.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/extension_dir.ini.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/extension_dir.env2.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/extension_dir.env.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/bin_dir.win.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/bin_dir.env2.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/bin_dir.env.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/constructDefaults/basic.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/configSnapshot/test.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/configSnapshot/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/addConfigValue/test.phpt" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//Config/addConfigValue/setup.php.inc" baseinstalldir="/"/>
   <file role="test" name="test/pear2.php.net/PEAR2_Pyrus//clean.php.inc" baseinstalldir="/"/>
   <file role="php" name="src/PEAR2/Pyrus/XMLWriter/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/XMLWriter.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/XMLParser/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/XMLParser.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Validator/PECL.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Validate/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Validate.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/test4.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/test3.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/test2.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/test1.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/test.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Windowseol/rw.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Windowseol.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Unixeol/rw.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Unixeol.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Replace/rw.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Replace.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Postinstallscript/rw.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Postinstallscript.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Task/Common.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ScriptFrontend/Commands.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST/HTTPException.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST/13.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST/11.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST/10.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/REST.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Xml.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Sqlite/Package.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Sqlite/Creator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Sqlite.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Pear1/Package.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Pear1.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Package.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Config.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Channel.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry/Base.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Registry.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/PackagingIterator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/FileTag.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/FileInstallationFilter.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/FileContentsMulti.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/FileContents.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/FileAttribsFilter.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2Iterator/File.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Validator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Remote.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Release/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Release.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Files/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Files.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Developer/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Developer.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Dependencies/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Dependencies.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Compatible/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2/Compatible.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/v2.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/Parser/v2.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/IValidator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/PackageFile.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Zip/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Zip.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Xml.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Tar/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Tar.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Remote.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Phar/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Phar.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/InstalledException.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/ICreator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Dependency.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Creator/TaskIterator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Creator/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Creator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package/Base.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Package.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/OSGuess.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Log.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/IRegistry.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/IPackage.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Www.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Www.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Test.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Test.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Src.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Src.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Script.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Script.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Php.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Php.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Ext.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Ext.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Doc.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Doc.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Data.xml" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Data.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role/Common.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Role.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Installer.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ILog.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/IFileTransaction.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/IChannelRegistry.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/IChannel.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/FileTransactions/Rmdir.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/FileTransactions/Rename.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/FileTransactions/Installedas.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/FileTransactions.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Downloader.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/DirectedGraph/Vertex.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/DirectedGraph/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/DirectedGraph.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Dependency/Validator.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Dependency/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Config/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Config.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Xml.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Sqlite.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Pear1.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/ParseException.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Mirror/Xml.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Mirror/Sqlite.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Channel/Xml.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Channel/Sqlite.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Channel/Pear1.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry/Base.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/ChannelRegistry.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Channel/Mirror.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Channel/IMirror.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Channel/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Channel/Base.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus/Channel.php" baseinstalldir="PEAR2"/>
   <file role="php" name="src/PEAR2/Pyrus.php" baseinstalldir="PEAR2"/>
   <file role="data" name="data/pear2.php.net/PEAR2_Pyrus/package-2.1.xsd" baseinstalldir="/"/>
   <file role="data" name="data/pear2.php.net/PEAR2_Pyrus/package-2.0.xsd" baseinstalldir="/"/>
   <file role="data" name="data/pear2.php.net/PEAR2_Pyrus/channel-1.0.xsd" baseinstalldir="/"/>
  </dir>
 </contents>
 <dependencies>
  <required>
   <php>
    <min>5.2.0</min>
   </php>
   <pearinstaller>
    <min>2.0.0a1</min>
   </pearinstaller>
  </required>
 </dependencies>
 <phprelease/>
</package>
<?php
function PEAR2_Autoload($class)
{
    if (substr($class, 0, 6) !== 'PEAR2_') {
        return false;
    }
    $fp = @fopen(str_replace('_', '/', $class) . '.php', 'r', true);
    if ($fp) {
        fclose($fp);
        require str_replace('_', '/', $class) . '.php';
        if (!class_exists($class, false) && !interface_exists($class, false)) {
            die(new Exception('Class ' . $class . ' was not present in ' .
                str_replace('_', '/', $class) . '.php (include_path="' . get_include_path() .
                '") [PEAR2_Autoload version 1.0]'));
        }
        return true;
    }
    $e = new Exception('Class ' . $class . ' could not be loaded from ' .
        str_replace('_', '/', $class) . '.php, file does not exist (include_path="' . get_include_path() .
        '") [PEAR2_Autoload version 1.0]');
    $trace = $e->getTrace();
    if (isset($trace[2]) && isset($trace[2]['function']) &&
          in_array($trace[2]['function'], array('class_exists', 'interface_exists'))) {
        return false;
    }
    if (isset($trace[1]) && isset($trace[1]['function']) &&
          in_array($trace[1]['function'], array('class_exists', 'interface_exists'))) {
        return false;
    }
    die ((string) $e);
}

// set up __autoload
if (function_exists('spl_autoload_register')) {
    if (!($_____t = spl_autoload_functions()) || !in_array('PEAR2_Autoload', spl_autoload_functions())) {
        spl_autoload_register('PEAR2_Autoload');
        if (function_exists('__autoload') && ($_____t === false)) {
            // __autoload() was being used, but now would be ignored, add
            // it to the autoload stack
            spl_autoload_register('__autoload');
        }
    }
    unset($_____t);
} elseif (!function_exists('__autoload')) {
    function __autoload($class) { return PEAR2_Autoload($class); }
}

// set up include_path if it doesn't register our current location
$____paths = explode(PATH_SEPARATOR, get_include_path());
$____found = false;
foreach ($____paths as $____path) {
    if ($____path == dirname(dirname(__FILE__))) {
        $____found = true;
        break;
    }
}
if (!$____found) {
    set_include_path(get_include_path() . PATH_SEPARATOR . dirname(dirname(__FILE__)));
}
unset($____paths);
unset($____path);
unset($____found);
<?php
/**
 * Multi-Error Error aggregator
 *
 * This class is designed to be extended for specific use.  It codifies easy
 * ways of aggregating error conditions that don't necessarily require an exception
 * to be thrown, but do need an easy way to retrieve them.
 * 
 * Usage:
 * 
 * <code>
 * $multi = new PEAR2_MultiErrors();
 * $multi->E_WARNING[] = new Exception('test');
 * $multi->E_ERROR[] = new Exception('test 2');
 * foreach ($multi as $error) {
 *     echo $error;
 * }
 * foreach ($multi->E_WARNING as $error) {
 *     echo $error;
 * }
 * foreach ($multi->E_ERROR as $error) {
 *     echo $error;
 * }
 * if (count($multi->E_ERROR)) {
 *     throw new PEAR2_Exception('Failure to do something', $multi);
 * }
 * </code>
 * @copyright 2007 Gregory Beaver
 * @package PEAR2_MultiErrors
 * @license http://www.php.net/license/3_0.txt PHP License
 */
class PEAR2_MultiErrors implements Iterator, Countable, ArrayAccess {

    private $_allowedLevels = array('E_NOTICE' => 0, 'E_WARNING' => 1, 'E_ERROR' => 2);
    /**
     * Errors are stored in the order that they are declared
     * @var array
     */
    private $_errors = array();

    /**
     * To allow $this->E_WARNING[] = new BlahException;
     *
     * @var int
     */
    private $_requestedLevel = false;

    /**
     * Internal PEAR2_MultiError objects for error levels
     * @var array
     */
    private $_subMulti = array();

    /**
     * Parent PEAR2_MultiErrors for an error level tracker
     *
     * @var PEAR2_MultiErrors
     */
    private $_parent;

    public function __construct($mylevel = false,
                                array $allowed = array('E_NOTICE', 'E_WARNING', 'E_ERROR'),
                                PEAR2_MultiErrors $parent = null)
    {
        foreach ($allowed as $level) {
            if (!is_string($level) || strpos($level, 'E_') !== 0) {
                throw new PEAR2_MultiErrors_Exception('Invalid level ' . (string) $level);
            }
        }
        $this->_allowedLevels = array_flip($allowed);
        $this->_requestedLevel = $mylevel;
        if ($mylevel) {
            $this->_parent = $parent;
        }
    }

    public function current()
    {
        return current($this->_errors);
    }

    public function key()
 	{
 	    return key($this->_errors);
 	}

 	public function next()
 	{
 	    return next($this->_errors);
 	}

 	public function rewind()
 	{
 	    return reset($this->_errors);
 	}

 	public function valid()
 	{
 	    return false !== current($this->_errors);
 	}

 	/**
 	 * Merge in errors from an existing PEAR2_MultiErrors
 	 * 
 	 * This also merges in any new error levels not supported in this instance.
 	 * @param PEAR2_MultiErrors $error
 	 */
 	public function merge(PEAR2_MultiErrors $error)
 	{
 	    $levels = $error->level;
 	    foreach ($error->levels as $level) {
 	        if (!isset($this->_allowedLevels[$level])) {
 	            $this->_allowedLevels[$level] = 1;
 	        }
 	        foreach ($error->$level as $e) {
 	            // we get fatal error if [] is put on $this->$level line
 	            $a = $this->$level;
 	            $a[] = $e;
 	        }
 	    }
 	}

 	public function count()
 	{
 	    return count($this->_errors);
 	}

 	public function offsetExists($offset)
 	{
 	    return isset($this->_errors[$offset]);
 	}

 	public function offsetGet ($offset)
 	{
 	    if (isset($this->_errors[$offset])) {
 	        return $this->_errors[$offset];
 	    }
 	    return null;
 	}

 	public function offsetSet ($offset, $value)
 	{
 	    if ($offset === null && !$this->_requestedLevel &&
 	          $value instanceof PEAR2_MultiErrors ) {
 	        $this->merge($value);
 	        return;
 	    }
 	    if (!($value instanceof Exception)) {
 	        throw new PEAR2_MultiErrors_Exception('offsetSet: $value is not an Exception object');
 	    }
 	    if ($this->_requestedLevel) {
     	    if ($offset === null) {
     	        // called with $a->E_BLAH[] = new Exception('hi');
     	        $offset = count($this->_errors);
     	    }
     	    if (!is_int($offset)) {
     	        throw new PEAR2_MultiErrors_Exception('offsetSet: $offset is not an integer');
     	    }
     	    $this->_errors[$offset] = $value;
 	        $this->_parent[$this->_requestedLevel . '-' . $offset] = $value;
 	    } else {
 	        if (!is_string($offset)) {
 	            throw new PEAR2_MultiErrors_Exception('Cannot add an error directly ' .
 	                'to a PEAR2_MultiErrors with $a[] = new Exception, use an ' .
 	                ' E_* constant like $a->E_WARNING[] = new Exception');
 	        }
 	        $offset = explode('-', $offset);
 	        $level = $offset[0];
 	        $offset = $offset[1];
 	        // this is called when the "$this->_parent[] = $value" line is executed.
 	        if (!isset($this->_subMulti[$level]) ||
 	              $this->_subMulti[$level][$offset] !== $value) {
                // must be in a child or it'll throw off the whole thingy
 	            throw new PEAR2_MultiErrors_Exception('Cannot add an error directly ' .
 	                'to a PEAR2_MultiErrors with $a[] = new Exception, use an ' .
 	                ' E_* constant like $a->E_WARNING[] = new Exception');
 	        }
 	        $this->_errors[] = $value;
 	    }
 	}

 	public function offsetUnset ($offset)
 	{
 	    if (isset($this->_errors[$offset])) {
 	        unset($this->_errors[$offset]);
 	    }
 	}

 	public function __get($level)
 	{
 	    if ($level === 'levels') {
 	        return $this->_allowedLevels;
 	    }
 	    if (!count($this->_allowedLevels)) {
 	        throw new PEAR2_MultiErrors_Exception('Cannot nest requests ' .
 	          '(like $multi->E_WARNING->E_ERROR[] = new Exception(\'\');)');
 	    }
 	    if (isset($this->_allowedLevels[$level])) {
 	        if (!isset($this->_subMulti[$level])) {
     	        $this->_subMulti[$level] = new PEAR2_MultiErrors($level,
     	          array(), $this);
 	        }
 	        return $this->_subMulti[$level];
 	    }
 	    throw new PEAR2_MultiErrors_Exception('Requested error level must be one of ' .
 	      implode(', ', $this->_allowedLevels));
 	}

 	public function toArray()
 	{
 	    return $this->_errors;
 	}
}
?><?php
/* vim: set expandtab tabstop=4 shiftwidth=4 foldmethod=marker: */
/**
 * PEAR2_Exception
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR2_Exception
 * @author     Tomas V. V. Cox <cox@idecnet.com>
 * @author     Hans Lellelid <hans@velum.net>
 * @author     Bertrand Mansion <bmansion@mamasam.com>
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2007 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: Exception.php,v 1.28 2007/05/07 01:58:54 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Release 0.1.0
 */


/**
 * Base PEAR2_Exception Class
 *
 * 1) Features:
 *
 * - Nestable exceptions (throw new PEAR2_Exception($msg, $prev_exception))
 * - Definable triggers, shot when exceptions occur
 * - Pretty and informative error messages
 * - Added more context info available (like class, method or cause)
 * - cause can be a PEAR2_Exception or an array of mixed
 *   PEAR2_Exceptions or a PEAR2_MultiErrors
 * - callbacks for specific exception classes and their children
 *
 * 2) Ideas:
 *
 * - Maybe a way to define a 'template' for the output
 *
 * 3) Inherited properties from PHP Exception Class:
 *
 * protected $message
 * protected $code
 * protected $line
 * protected $file
 * private   $trace
 *
 * 4) Inherited methods from PHP Exception Class:
 *
 * __clone
 * __construct
 * getMessage
 * getCode
 * getFile
 * getLine
 * getTraceSafe
 * getTraceSafeAsString
 * __toString
 *
 * 5) Usage example
 *
 * <code>
 * class PEAR2_MyPackage_Exception extends PEAR2_Exception {}
 *  class Test {
 *     function foo()
 *     {
 *         throw new PEAR2_MyPackage_Exception('Error Message', ERROR_CODE);
 *     }
 *  }
 *
 *  function myLogger($pear2_exception)
 *  {
 *     echo $pear2_exception->getMessage();
 *  }
 *  // each time a exception is thrown the 'myLogger' will be called
 *  // (its use is completely optional)
 *  PEAR2_Exception::addObserver('myLogger');
 *  $test = new Test;
 *  try {
 *     $test->foo();
 *  } catch (PEAR2_Exception $e) {
 *     print $e;
 *  }
 * </code>
 *
 * @category   pear
 * @package    PEAR
 * @author     Tomas V.V.Cox <cox@idecnet.com>
 * @author     Hans Lellelid <hans@velum.net>
 * @author     Bertrand Mansion <bmansion@mamasam.com>
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2007 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 0.1.0
 *
 */
abstract class PEAR2_Exception extends Exception
{
    public static $htmlError = false;
    const OBSERVER_PRINT = -2;
    const OBSERVER_TRIGGER = -4;
    const OBSERVER_DIE = -8;
    protected $cause;
    private static $_observers = array();
    private static $_uniqueid = 0;
    private $_trace;

    /**
     * Supported signatures:
     *  - PEAR2_Exception(string $message);
     *  - PEAR2_Exception(string $message, int $code);
     *  - PEAR2_Exception(string $message, Exception $cause);
     *  - PEAR2_Exception(string $message, Exception $cause, int $code);
     *  - PEAR2_Exception(string $message, PEAR2_MultiErrors $cause);
     *  - PEAR2_Exception(string $message, PEAR2_MultiErrors $cause, int $code);
     *  - PEAR2_Exception(string $message, array $causes);
     *  - PEAR2_Exception(string $message, array $causes, int $code);
     * @param string exception message
     * @param int|Exception|PEAR2_MultiErrors|array|null exception cause
     * @param int|null exception code or null
     */
    public function __construct($message, $p2 = null, $p3 = null)
    {
        if (is_int($p2)) {
            $code = $p2;
            $this->cause = null;
        } elseif (is_object($p2) || is_array($p2)) {
            if (!is_array($p2) && !($p2 instanceof Exception)) {
                if (!($p2 instanceof PEAR2_MultiErrors)) {
                    throw new Exception('exception cause must be Exception, ' .
                        'array, or PEAR2_MultiErrors');
                }
            }
            $code = $p3;
            $this->cause = $p2;
        } else {
            $code = null;
            $this->cause = null;
        }
        if (!is_string($message)) {
            throw new Exception('exception message must be a string, was ' . gettype($message));
        }
        parent::__construct($message, $code);
        $this->signal();
    }

    /**
     * @param mixed $callback  - A valid php callback, see php func is_callable()
     *                         - A PEAR2_Exception::OBSERVER_* constant
     *                         - An array(const PEAR2_Exception::OBSERVER_*,
     *                           mixed $options)
     * @param string $label    The name of the observer. Use this if you want
     *                         to remove it later with removeObserver()
     */
    public static function addObserver($callback, $label = 'default')
    {
        self::$_observers[$label] = $callback;
    }

    public static function removeObserver($label = 'default')
    {
        unset(self::$_observers[$label]);
    }

    /**
     * @return int unique identifier for an observer
     */
    public static function getUniqueId()
    {
        return self::$_uniqueid++;
    }

    private function signal()
    {
        foreach (self::$_observers as $func) {
            if (is_callable($func)) {
                call_user_func($func, $this);
                continue;
            }
            settype($func, 'array');
            switch ($func[0]) {
                case self::OBSERVER_PRINT :
                    $f = (isset($func[1])) ? $func[1] : '%s';
                    printf($f, $this->getMessage());
                    break;
                case self::OBSERVER_TRIGGER :
                    $f = (isset($func[1])) ? $func[1] : E_USER_NOTICE;
                    trigger_error($this->getMessage(), $f);
                    break;
                case self::OBSERVER_DIE :
                    $f = (isset($func[1])) ? $func[1] : '%s';
                    die(printf($f, $this->getMessage()));
                    break;
                default:
                    trigger_error('invalid observer type', E_USER_WARNING);
            }
        }
    }

    /**
     * Returns the exception that caused this exception to be thrown
     * @access public
     * @return Exception|array The context of the exception
     */
    public function getCause()
    {
        return $this->cause;
    }

    /**
     * Function must be public to call on caused exceptions
     * @param array
     */
    public function getCauseMessage(&$causes)
    {
        $trace = $this->getTraceSafe();
        $cause = array('class'   => get_class($this),
                       'message' => $this->message,
                       'file' => 'unknown',
                       'line' => 'unknown');
        if (isset($trace[0])) {
            if (isset($trace[0]['file'])) {
                $cause['file'] = $trace[0]['file'];
                $cause['line'] = $trace[0]['line'];
            }
        }
        $causes[] = $cause;
        if ($this->cause instanceof PEAR2_Exception) {
            $this->cause->getCauseMessage($causes);
        } elseif ($this->cause instanceof Exception) {
            $causes[] = array('class'   => get_class($this->cause),
                              'message' => $this->cause->getMessage(),
                              'file' => $this->cause->getFile(),
                              'line' => $this->cause->getLine());
        } elseif ($this->cause instanceof PEAR2_MultiErrors || is_array($this->cause)) {
            foreach ($this->cause as $cause) {
                if ($cause instanceof PEAR2_Exception) {
                    $cause->getCauseMessage($causes);
                } elseif ($cause instanceof Exception) {
                    $causes[] = array('class'   => get_class($cause),
                                   'message' => $cause->getMessage(),
                                   'file' => $cause->getFile(),
                                   'line' => $cause->getLine());
                }
            }
        }
    }

    public function getTraceSafe()
    {   
        if (!isset($this->_trace)) {
            $this->_trace = $this->getTrace();
            if (empty($this->_trace)) {
                $backtrace = debug_backtrace();
                $this->_trace = array($backtrace[count($backtrace)-1]);
            }
        }
        return $this->_trace;
    }

    public function getErrorClass()
    {
        $trace = $this->getTraceSafe();
        return $trace[0]['class'];
    }

    public function getErrorMethod()
    {
        $trace = $this->getTraceSafe();
        return $trace[0]['function'];
    }

    public function __toString()
    {
        if (self::$htmlError) {
            return $this->toHtml();
        }
        return $this->toText();
    }

    public function toHtml()
    {
        $trace = $this->getTraceSafe();
        $causes = array();
        $this->getCauseMessage($causes);
        $html =  '<table border="1" cellspacing="0">' . "\n";
        foreach ($causes as $i => $cause) {
            $html .= '<tr><td colspan="3" bgcolor="#ff9999">'
               . str_repeat('-', $i) . ' <b>' . $cause['class'] . '</b>: '
               . htmlspecialchars($cause['message']) . ' in <b>' . $cause['file'] . '</b> '
               . 'on line <b>' . $cause['line'] . '</b>'
               . "</td></tr>\n";
        }
        $html .= '<tr><td colspan="3" bgcolor="#aaaaaa" align="center"><b>Exception trace</b></td></tr>' . "\n"
               . '<tr><td align="center" bgcolor="#cccccc" width="20"><b>#</b></td>'
               . '<td align="center" bgcolor="#cccccc"><b>Function</b></td>'
               . '<td align="center" bgcolor="#cccccc"><b>Location</b></td></tr>' . "\n";

        foreach ($trace as $k => $v) {
            $html .= '<tr><td align="center">' . $k . '</td>'
                   . '<td>';
            if (!empty($v['class'])) {
                $html .= $v['class'] . $v['type'];
            }
            $html .= $v['function'];
            $args = array();
            if (!empty($v['args'])) {
                foreach ($v['args'] as $arg) {
                    if (is_null($arg)) $args[] = 'null';
                    elseif (is_array($arg)) $args[] = 'Array';
                    elseif (is_object($arg)) $args[] = 'Object('.get_class($arg).')';
                    elseif (is_bool($arg)) $args[] = $arg ? 'true' : 'false';
                    elseif (is_int($arg) || is_double($arg)) $args[] = $arg;
                    else {
                        $arg = (string)$arg;
                        $str = htmlspecialchars(substr($arg, 0, 16));
                        if (strlen($arg) > 16) $str .= '&hellip;';
                        $args[] = "'" . $str . "'";
                    }
                }
            }
            $html .= '(' . implode(', ',$args) . ')'
                   . '</td>'
                   . '<td>' . (isset($v['file']) ? $v['file'] : 'unknown')
                   . ':' . (isset($v['line']) ? $v['line'] : 'unknown')
                   . '</td></tr>' . "\n";
        }
        $html .= '<tr><td align="center">' . ($k+1) . '</td>'
               . '<td>{main}</td>'
               . '<td>&nbsp;</td></tr>' . "\n"
               . '</table>';
        return $html;
    }

    public function toText()
    {
        $causes = array();
        $this->getCauseMessage($causes);
        $causeMsg = '';
        foreach ($causes as $i => $cause) {
            $causeMsg .= str_repeat(' ', $i) . $cause['class'] . ': '
                   . $cause['message'] . ' in ' . $cause['file']
                   . ' on line ' . $cause['line'] . "\n";
        }
        return $causeMsg . $this->getTraceAsString();
    }
}
?><?php
class PEAR2_MultiErrors_Exception extends PEAR2_Exception {}<?php
/**
 * class to do http requests, uses a adapter based system for performing those requests
 *
 * Loosely Based on PEAR HTTP_Response
 *
 * @version $Id$
 */
class PEAR2_HTTP_Request 
{

    /**
     * The adapter that the requester uses.
     *
     * @see adapters
     */
    protected $adapter;

    /**
     * The listeners
     *
     * This variable contains the listeners that are
     * set (can be set) on this object.
     *
     * @var array $_listeners  The listeners
     */
    protected $_listeners = array();
    
    /**
     * Magic to retrieve items that are actually stored in the adapter
     *
     * @param  string $name name of var to get
     */
    public function __get($name)
    {
        if (isset($this->adapter->$name)) {
            return $this->adapter->$name;
        }
    }

    /**
     * Magic to set items that are actually stored in the adapter
     *
     * @param  string $name name of var to set
     * @param  mixed $value to give to var
     */
    public function __set($name, $value)
    {
        switch($name) {
            case 'verb':
                $this->adapter->verb = strtoupper($value);
                break;
            case 'uri':
            case 'url':
                $this->adapter->uri = new PEAR2_HTTP_Request_Uri($value);
                break;
            case 'body':
            case 'content':
                if (is_array($value)) {
                    $this->adapter->body = http_build_query($value);
                    $this->setHeader('Content-Type','application/x-www-form-urlencoded');
                    if ($this->adapter->verb == 'GET') {
                        $this->adapter->verb = 'POST';
                    }
                } else {
                    $this->adapter->body = $value;
                }
                break;
            case 'requestTimeout':
                $this->adapter->$name = (int)$value;
            case 'proxy':
                $this->adapter->$name = new PEAR2_HTTP_Request_Uri($value);
                break;
            default:
                $this->adapter->$name = $value;
                break;
        }
    }

    /**
     * sets up the adapter
     *
     * @param  string $class adapter to use
     */
    public function __construct($url = null, $instance = null) 
    {
        if (!is_null($instance) && $instance instanceof PEAR2_HTTP_Request_Adapter) {
            $this->adapter = $instance;
        } elseif (extension_loaded('http')) {
            $this->adapter = new PEAR2_HTTP_Request_Adapter_Http;
        } elseif (ini_get('allow_url_fopen') == true) {
            $this->adapter = new PEAR2_HTTP_Request_Adapter_Phpstream;
        } else {
            $this->adapter = new PEAR2_HTTP_Request_Adapter_Phpsocket;
        }

        $this->adapter->setListeners($this->_listeners);

        if ($url) {
            $this->url = $url;
        }
    }

    /**
     * asks for a response class from the adapter
     *
     * @param  string $class adapter to use
     * @return mixed  The response from the adapter
     */
    public function sendRequest() 
    {
        $response = $this->adapter->sendRequest();
        return $response;
    }

    /**
     * Setter for request headers
     * 
     * @see $this->adapter->headers
     */
    public function setHeader($header, $value) 
    {
        $this->adapter->headers[$header] = $value;
    }

    /**
     * Attach a listener
     *
     * This method adds a listener to the list of listeners that are 
     * notified of the object's events.
     *
     * Events sent by the HTTP_Request Object
     *  - 'connect'     : On connection to server
     *  - 'sentRequest' : After the request was sent to server
     *  - 'disconnect'  : Upon server disconnection
     *
     * Events sent by the HTTP_Response object
     *  - 'gotHeaders' : After receiving response header
     *  - 'tick'       : On receiving part of response
     *  - 'gzTick'     : On receiving a gzip-encoded part
     *  - 'gotBody'    : Upon receiving body of the message
     *
     *
     * @param  PEAR2_HTTP_Request_Listener $listener  The listener object
     * @return boolean Whether object is a listener or not
     */
    public function attach(PEAR2_HTTP_Request_Listener &$listener)
    {
        $this->_listeners[$listener->getId()] =& $listener;
        return true;
    }

    /**
     * Detach a listener
     *
     * This method will detach the listener that was set
     * to a request.
     *
     * @param  PEAR2_HTTP_Request_Listener $listener   The listener
     * @return bool true
     */
    public function detach(PEAR2_HTTP_Request_Listener &$listener)
    {
        if (isset($this->_listeners[$listener->getId()])) {
            $this->_listeners[$listener->getId()] = null;
        }

        return true;
    }

    /**
     * Notify
     *
     * This method notifies all registered listeners of
     * the event that just happened.
     *
     * @param     string  $event  The event name
     * @param     mixed  $data   Additional data
     * @see       PEAR2_HTTP_Request->attach()
     * @return    void
     */
    protected function _notify($event, $data = null)
    {
        if (!empty($this->_listeners)) {
            foreach (array_keys($this->_listeners) as $id) {
                $this->_listeners[$id]->update($this, $event, $data);
            }
        }
    }

    /**
     * Get the class name of the adapter that is being used
     */
    public function getAdapterName() {
        return get_class($this->adapter);
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php
abstract class PEAR2_HTTP_Request_Adapter 
{

    /**
     * HTTP Version
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.1
     */
    public $httpVersion = 'HTTP/1.1';

    /**
     * Uri to make the request too
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2
     */
    public $uri;

    /**
     * Called Method in the spec
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1
     */
    public $verb = 'GET';

    /**
     * Additional headers to send
     * @var array   Header Name => Header value
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.3
     */
    public $headers = array();

    /**
     * Value to send as the body of the message, you need to handle the encoding
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
     */
    public $body;

    /**
     * How long to wait until a request times out
     * @float seconds
     */
    public $requestTimeout = 10;

    /**
     * Full uri of the proxy server
     * @var PEAR2_HTTP_Request_Uri
     */
    public $proxy = null;

    /**
     * HTTP Return code
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
     */
    public $code = 100;

    /**
     * Listeners from the parent
     */
    protected $_listeners;

    /**
     * Parsed cookies
     * @var array
     */
    public $cookies = array();

    /**
     * @todo i don't like this approach
     */
    public function setListeners(&$listeners) {
        $this->_listeners &= $listeners;
    }

    /**
     * Send the specified request
     */
    public function sendRequest() 
    {
    }

    /**
     * Send a request storing the results to a file and returning headers
     * @return array
     * @todo create a non Implemented exception
     */
    public function requestToFile() 
    {
        throw new PEAR2_HTTP_Request_Exception(
            'Not Implemented'
        );
    }

    protected function parseResponseCode($line) 
    {
        if (sscanf($line, 'HTTP/%s %s', $http_version, $returncode) != 2) {
            throw new PEAR2_HTTP_Request_Exception('Malformed response.');
        } else {
            return array('code' => intval($returncode), 'httpVersion' => $http_version);
        }
    }

   /**
    * Processes the response header
    *
    * @access private
    * @param  string    HTTP header
    */
    protected function processHeader($header)
    {
        if (strpos($header, ':') === false) {
            return;
        }

        list($headername, $headervalue) = explode(':', $header, 2);
        if (strstr($headername,'-')) {
            list($p1,$p2) = explode('-',$headername);
            $headername  = ucfirst(strtolower($p1)).'-'.ucfirst(strtolower($p2));
        }
        else {
            $headername  = ucfirst($headername);
        }
        $headervalue = ltrim($headervalue);

        if ('set-cookie' != $headername) {
            if (isset($this->headers[$headername])) {
                $this->headers[$headername] .= ',' . $headervalue;
            } else {
                $this->headers[$headername]  = $headervalue;
            }
        } else {
            $this->cookies[] = $this->parseCookie($headervalue);
        }
    }


    /**
     * Parse a Set-Cookie header to fill $cookies array
     *
     * @access private
     * @param  string    value of Set-Cookie header
     */
    protected function parseCookie($headervalue)
    {
        $cookie = array(
            'expires' => null,
            'domain'  => null,
            'path'    => null,
            'secure'  => false
        );

        // Only a name=value pair
        if (!strpos($headervalue, ';')) {
            $pos = strpos($headervalue, '=');
            $cookie['name']  = trim(substr($headervalue, 0, $pos));
            $cookie['value'] = trim(substr($headervalue, $pos + 1));

            // Some optional parameters are supplied
        } else {
            $elements = explode(';', $headervalue);
            $pos = strpos($elements[0], '=');
            $cookie['name']  = trim(substr($elements[0], 0, $pos));
            $cookie['value'] = trim(substr($elements[0], $pos + 1));

            for ($i = 1; $i < count($elements); $i++) {
                if (false === strpos($elements[$i], '=')) {
                    $elName  = trim($elements[$i]);
                    $elValue = null;
                } else {
                    list ($elName, $elValue) = array_map('trim', explode('=', $elements[$i]));
                }

                $elName = strtolower($elName);

                if ($elName == 'secure') {
                    $cookie['secure'] = true;
                } elseif ($elName == 'expires') {
                    $cookie['expires'] = str_replace('"', '', $elValue);
                } elseif ($elName == 'path' || $elName == 'domain') {
                    $cookie[$elName] = urldecode($elValue);
                } else {
                    $cookie[$elName] = $elValue;
                }
            }
        }
        return $cookie;
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
<?php
class PEAR2_HTTP_Request_Adapter_Phpsocket_Socket {
        public $lineLength = 2048;
        private $_handle;

        public function __construct($handle) {
                $this->_handle = $handle;
        }

        public function readLine() {
                $line = '';
                while(!$this->eof()) {
                        $line .= @fgets($this->_handle, $this->lineLength);
                        if (substr($line, -1) == "\n") {
                                return rtrim($line, "\r\n");
                        }
                }
                return false;
        }

        public function read($size) {
                if ($this->eof()) {
                        return false;
                }
                return @fread($this->_handle,$size);
        }

        public function write($payload) {
                return fwrite($this->_handle,$payload,strlen($payload));
        }

        public function eof() {
                return feof($this->_handle);
        }
}

/**
 * A class which represents an Http Reponse
 * Handles parsing cookies and headers
 *
 * Based on PEAR HTTP_Response
 *
 * @version $Revision: 1.52 $
 */
class PEAR2_HTTP_Request_Adapter_Phpsocket extends PEAR2_HTTP_Request_Adapter {

    
    /**
     * Used by _readChunked(): remaining length of the current chunk
     * @var string
     */
    private $_chunkLength = 0;

    /**
     * Bytes left to read from message-body
     * @var null|int
     */
    private $_toRead = null;

    /**
     * Raw Response to be parsed
     */
    private $_stream;

    public function sendRequest() {
        $payload = $this->_buildHeaders($this->uri->path,$this->uri->host,$this->headers,strlen($this->body));
        $payload .= $this->body;
        $this->body = '';

        $errno    = 0;
        $errstr   = '';
        $handle   = @fsockopen($this->uri->host, $this->uri->port, $errno, $errstr, 30);

        if (!is_resource($handle)) {
            throw new PEAR2_HTTP_Request_Exception("Couldn't connection to host using Phpsocket Adapter, fsockopen errors($errstr,$errno)");
        }
        stream_set_timeout($handle,10);

        $this->_stream = new PEAR2_HTTP_Request_Adapter_Phpsocket_Socket($handle);

        $this->_stream->write($payload);

        $this->parse();

        $details['code'] = $this->code;
        $details['httpVersion'] = $this->httpVersion;


        $response = new PEAR2_HTTP_Request_Response(
            $details,$this->body,new PEAR2_HTTP_Request_Headers($this->headers),$this->cookies);
        return $response;
    }

    /**
     * Parse a HTTP response
     * 
     * This extracts response code, headers, cookies and decodes body if it 
     * was encoded in some way
     *
     * @access public
     * @param  bool      Whether to store response body in object property, set
     *                   this to false if downloading a LARGE file and using a Listener.
     *                   This is assumed to be true if body is gzip-encoded.
     * @param  bool      Whether the response can actually have a message-body.
     *                   Will be set to false for HEAD requests.
     * @throws Exception
     * @return boolean     true on success
     */
    public function parse($saveBody = true, $canHaveBody = true)
    {
        do {
            $line = $this->_stream->readLine();
            $code = $this->parseResponseCode($line);
            $this->httpVersion = 'HTTP/' . $code['httpVersion'];
            $this->code     = $code['code'];

            while ('' !== ($header = $this->_stream->readLine())) {
                $this->processHeader($header);
            }
        } while ($this->code == 100);

        // RFC 2616, section 4.4:
        // 1. Any response message which "MUST NOT" include a message-body ... 
        // is always terminated by the first empty line after the header fields 
        // 3. ... If a message is received with both a
        // Transfer-Encoding header field and a Content-Length header field,
        // the latter MUST be ignored.
        $canHaveBody = $canHaveBody && $this->code >= 200 && 
                       $this->code != 204 && $this->code != 304;

        // If response body is present, read it and decode
        $chunked = isset($this->headers['transfer-encoding']) && ('chunked' == $this->headers['transfer-encoding']);
        $gzipped = isset($this->headers['content-encoding']) && ('gzip' == $this->headers['content-encoding']);
        $hasBody = false;
        if ($canHaveBody && ($chunked || !isset($this->headers['content-length']) || 
                0 != $this->headers['content-length']))
        {
            if ($chunked || !isset($this->headers['content-length'])) {
                $this->_toRead = null;
            } else {
                $this->_toRead = $this->headers['content-length'];
            }
            while (!$this->_stream->eof() && (is_null($this->_toRead) || $this->_toRead > 0)) {
                if ($chunked) {
                    $data = $this->_readChunked();
                } elseif (is_null($this->_toRead)) {
                    $data = $this->_stream->read(4096);
                } else {
                    $data = $this->_stream->read(min(4096, $this->_toRead));
                    $this->_toRead -= strlen($data);
                }
                if ($data == '') {
                    break;
                } else {
                    $hasBody = true;
                    if ($saveBody || $gzipped) {
                        $this->body .= $data;
                    }
                }
            }
        }

        if ($hasBody) {
            // Uncompress the body if needed
            if ($gzipped) {
                $body = $this->_decodeGzip($this->body);
                if (PEAR::isError($body)) {
                    return $body;
                }
                $this->body = $body;
            }
        }
        return true;
    }

   /**
    * Read a part of response body encoded with chunked Transfer-Encoding
    * 
    * @access private
    * @return string
    */
    private function _readChunked()
    {
        // at start of the next chunk?
        if (0 == $this->_chunkLength) {
            $line = $this->_stream->readLine();
            if (preg_match('/^([0-9a-f]+)/i', $line, $matches)) {
                $this->_chunkLength = hexdec($matches[1]); 
                // Chunk with zero length indicates the end
                if (0 == $this->_chunkLength) {
                    $this->_stream->readLine(); // make this an eof()
                    return '';
                }
            } else {
                return '';
            }
        }
        $data = $this->_stream->read($this->_chunkLength);
        $this->_chunkLength -= strlen($data);
        if (0 == $this->_chunkLength) {
            $this->_stream->readLine(); // Trailing CRLF
        }
        return $data;
    }

   /**
    * Decodes the message-body encoded by gzip
    *
    * The real decoding work is done by gzinflate() built-in function, this
    * method only parses the header and checks data for compliance with
    * RFC 1952  
    *
    * @access   private
    * @param    string  gzip-encoded data
    * @return   string  decoded data
    */
    private function _decodeGzip($data)
    {
        $length = strlen($data);
        // If it doesn't look like gzip-encoded data, don't bother
        if ($length < 18 || strcmp(substr($data, 0, 2), "\x1f\x8b")) {
            return $data;
        }
        $method = ord(substr($data, 2, 1));
        if ($method != 8) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): unknown compression method');
        }
        
        $flags = ord(substr($data, 3, 1));

        if ($flags & 224) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): reserved bits are set');
        }

        // header is 10 bytes minimum. may be longer, though.
        $headerLength = 10;
        // extra fields, need to skip 'em
        if ($flags & 4) {
            if ($length - $headerLength - 2 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            
            $extraLength = unpack('v', substr($data, 10, 2));
            if ($length - $headerLength - 2 - $extraLength[1] < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }

            $headerLength += $extraLength[1] + 2;
        }
        // file name, need to skip that
        if ($flags & 8) {
            if ($length - $headerLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $filenameLength = strpos(substr($data, $headerLength), chr(0));
            if (false === $filenameLength || $length - $headerLength - $filenameLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $headerLength += $filenameLength + 1;
        }
        // comment, need to skip that also
        if ($flags & 16) {
            if ($length - $headerLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $commentLength = strpos(substr($data, $headerLength), chr(0));
            if (false === $commentLength || $length - $headerLength - $commentLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $headerLength += $commentLength + 1;
        }
        // have a CRC for header. let's check
        if ($flags & 1) {
            if ($length - $headerLength - 2 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $crcReal   = 0xffff & crc32(substr($data, 0, $headerLength));
            $crcStored = unpack('v', substr($data, $headerLength, 2));
            if ($crcReal != $crcStored[1]) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): header CRC check failed');
            }
            $headerLength += 2;
        }
        // unpacked data CRC and size at the end of encoded data
        $tmp = unpack('V2', substr($data, -8));
        $dataCrc  = $tmp[1];
        $dataSize = $tmp[2];

        // finally, call the gzinflate() function
        $unpacked = @gzinflate(substr($data, $headerLength, -8), $dataSize);
        if (false === $unpacked) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): gzinflate() call failed');
        } elseif ($dataSize != strlen($unpacked)) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data size check failed');
        } elseif ($dataCrc != crc32($unpacked)) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data CRC check failed');
        }
        return $unpacked;
    }

    private function _buildHeaders($path, $host, $headers,$bodySize) {
        $httpRequest  = "$this->verb $path $this->httpVersion\r\n";
        $httpRequest .= "Host: $host\r\n";
        foreach($headers as $key => $value) {
            $httpRequest .= "$key: $value\r\n";
        }
        if ($bodySize > 0) {
            $httpRequest .= "Content-Length:".$bodySize."\r\n";
        }
        $httpRequest .= "\r\n";

        return $httpRequest;
    }
} // End class PEAR2_HTTP_Response
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php
/**
 * driver that uses php http:// stream to do requests
 *
 * Loosely Based on PEAR HTTP_Response
 *
 * @version $Revision: 1.52 $
 */
class PEAR2_HTTP_Request_Adapter_PhpStream extends PEAR2_HTTP_Request_Adapter
{
    private $_phpErrorStr;

    /**
     * Throws exception if allow_url_fopen is off
     */
    public function __construct()
    {
        if (ini_get('allow_url_fopen') == false) {
            throw new PEAR2_HTTP_Request_Exception(
                'allow_url_fopen is off, the http:// stream wrapper will not function'
            );
        }
    }


    /**
     * Send the request
     *
     * This function sends the actual request to the
     * remote/local webserver using php streams.
     */
    public function sendRequest()
    {

        $proxyurl = '';
        if (!is_null($this->proxy)) {
            $proxyurl = $this->proxy->url;
        }
        // create context with proper junk
        $ctx = stream_context_create(
            array(
                $this->uri->protocol => array(
                    'method' => $this->verb,
                    'content' => $this->body,
                    'header' => $this->buildHeaderString(),
                    'proxy'  => $proxyurl,
                )
            )
        );

        set_error_handler(array($this,'_errorHandler'));
        $fp = fopen($this->uri->url, 'rb', false, $ctx);
        if (!is_resource($fp)) {
            // php sucks
            if (strpos($this->_phpErrorStr, 'HTTP/1.1 304')) {
                restore_error_handler();
                $details = $this->uri->toArray();

                $details['code'] = '304';
                $details['httpVersion'] = '1.1';

                return new PEAR2_HTTP_Request_Response($details,'',array(),array());
            }
            restore_error_handler();
            throw new PEAR2_HTTP_Request_Exception('Url ' . $this->uri->url . ' could not be opened (PhpStream Adapter ('.$this->_phpErrorStr.'))');
        } else {
            restore_error_handler();
        }

        stream_set_timeout($fp, $this->requestTimeout);
        $body = stream_get_contents($fp);

        if ($body === false) {
            throw new PEAR2_HTTP_Request_Exception(
                'Url ' . $this->uri->url . ' did not return a response'
            );
        }

        $meta = stream_get_meta_data($fp);
        fclose($fp);

        $headers = $meta['wrapper_data'];

        $details = $this->uri->toArray();

        $tmp = $this->parseResponseCode($headers[0]);
        $details['code'] = $tmp['code'];
        $details['httpVersion'] = $tmp['httpVersion'];

        $cookies = array();
        $this->headers = $this->cookies = array();

        foreach($headers as $line) {
            $this->processHeader($line);
        }

        return new PEAR2_HTTP_Request_Response(
            $details,$body,new PEAR2_HTTP_Request_Headers($this->headers),$this->cookies);
    }

    /**
     * Build header String
     *
     * This method builds the header string
     * to be passed to the request.
     *
     * @return string $out  The headers
     */
    private function buildHeaderString()
    {
        $out = '';
        foreach($this->headers as $header => $value) {
            $out .= "$header: $value\r\n";
        }
        return $out;
    }

    /**
     * This has to be public to be used as a callback but its actually private
     */
    public function _errorHandler($errno,$errstr) {
        $this->_phpErrorStr = $errstr;
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php
class PEAR2_HTTP_Request_Exception extends PEAR2_Exception {
}
<?php

/**
 * A container for HTTP request headers provides case insensitive access
 *
 * Array style access and object style access is provided
 *
 * Lazy processing of case insensitive access is provided so we don't strtolower the keys
 * until the headers are actually used
 *
 * @todo decide if this should be pulled out of the package and provided as a generic class
 */
class PEAR2_HTTP_Request_Headers implements Iterator, ArrayAccess, Countable {

	const ORIGINAL_CASE = 'fields';
	const LOWER_CASE = 'lowerCase';
	const CAMEL_CASE = 'camelCase';

	public $iterationStyle = self::LOWER_CASE;

	protected $fields = array();
	protected $camelCase = null;
	protected $lowerCase = null;

	/**
	 * Takes the headers to provide access too
	 */
	public function __construct($fields) {
		$this->fields = $fields;
	}

	/**
	 * Magic getter for object access
	 */
	public function __get($key) {
		if (is_null($this->camelCase)) {
			$this->camelCaseFields();
		}

		if (isset($this->camelCase[$key])) {
			return $this->camelCase[$key];
		}
		return null;
	}

	/**
	 * Magic setter for object access
	 *
	 * @todo set $this->fields and $this->lowerCase
	 */
	public function __set($key,$value) {
		$this->camelCase[$key] = $value;
	}

	/**
	 * Magic isset for object access
	 */
	public function __isset($key) {
		if (is_null($this->camelCase)) {
			$this->camelCaseFields();
		}
		return isset($this->camelCase[$key]);
	}

	/**
	 * Magic unset for object access
	 */
	public function __unset($key) {
		if (is_null($this->camelCase)) {
			$this->camelCaseFields();
		}
		unset($this->camelCase[$key]);
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetExists($key) {
		if (is_null($this->lowerCase)) {
			$this->lowerCaseFields();
		}
		$key = strtolower($key);
		return isset($this->lowerCase[$key]);
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetGet($key) {
		if (is_null($this->lowerCase)) {
			$this->lowerCaseFields();
		}
		$key = strtolower($key);
		if (isset($this->lowerCase[$key])) {
			return $this->lowerCase[$key];
		}
		return null;
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetSet($key,$value) {
		$key = strtolower($key);

		$this->lowerCase[$key] = $value;
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetUnset($key) {
		if (is_null($this->lowerCase)) {
			$this->lowerCaseFields();
		}
		$key = strtolower($key);
		unset($this->lowerCase[$key]);
	}

	/**
	 * Return the number of headers
	 * Countable interface implmentation
	 */
	public function count() {
		return count($this->fields);
	}

	/**
	 * Iterator Implmentation
	 */
	public function current() {
		return current($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function key() {
		return key($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function next() {
		return next($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function rewind() {
		if (is_null($this->{$this->iterationStyle})) {
			$m = $this->iterationStyle."Fields";
			$this->$m();
		}
		reset($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function valid() {
		return (boolean) current($this->{$this->iterationStyle});
	}

	/**
	 * Make all keys lower case
	 */
	protected function lowerCaseFields() {
		$fields = array();
		foreach($this->fields as $k => $v) {
			$fields[strtolower($k)] = $v;
		}
		$this->lowerCase = $fields;
	}

	/**
	 * Make all keys camel case, removing dashes
	 */
	protected function camelCaseFields() {
		$fields = array();
		foreach($this->fields as $k => $v) {
			$pieces = explode('-',$k);
			$pieces = array_map('ucfirst',$pieces);
			$fields[implode('',$pieces)] = $v;
		}
		$this->camelCase = $fields;
	}
}
<?php
/**
 * A class which represents an HTTP Reponse
 *
 */
class PEAR2_HTTP_Request_Response
{
    /**
     * HTTP Return code
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
     */
    public $code = 100;

    /**
     * Response headers
     * @var array
     */
    public $headers;

    /**
     * Cookies set in response
     * @var array
     */
    public $cookies;

    /**
     * Response body
     * @var string
     */
    public $body = '';

    /**
     * Constructor
     *
     *
     * @see $this->body
     * @see $this->headers
     * @see $this->cookies
     */
    public function __construct($details, $body, $headers, $cookies)
    {
        foreach($details as $name => $value) {
            $this->$name = $value;
        }

        $this->body    = $body;
        $this->headers = $headers;
        $this->cookies = $cookies;
    }

    /**
     * Return the body of the response
     */
    public function __toString() {
        return $this->body;
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php

/**
 * Simple class for parsing url/uris
 *
 * Basically compatiable with Net_URL2 propery names but not methods
 */
class PEAR2_HTTP_Request_Uri {

	protected $pieces = array();
	protected $map = array(
			'url' => 'uri',
			'querystring' => 'query',
			'anchor' => 'fragment',
			'protocol' => 'scheme',
			);
	protected $schemes = array(
			'http' => 80,
			'https'=> 443,
		);

	public function __construct($uri) {
		$this->pieces = parse_url($uri);
		$this->pieces['uri'] = $uri;
		if (!isset($this->pieces['port'])) {
			if (isset($this->schemes[$this->pieces['scheme']])) {
				$this->pieces['port'] = $this->schemes[$this->pieces['scheme']];
			}
			else {
				$this->pieces['port'] = 80;
			}
		}
	}

	public function __get($key) {
		if (isset($this->map[$key])) {
			$key = $this->map[$key];
		}
		if (isset($this->pieces[$key])) {
			return $this->pieces[$key];
		}
		return null;
	}

	public function toArray() {
		return $this->pieces;
	}
}
9£Dz-ðkf¸¾çÂn>4ÿ   GBMB