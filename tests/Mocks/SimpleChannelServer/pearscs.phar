<?php
if (!class_exists('Phar')) {
    if (!class_exists('PHP_Archive')) {
?><?php
/**
 * PHP_Archive Class (implements .phar)
 *
 * @package PHP_Archive
 * @category PHP
 */
/**
 * PHP_Archive Class (implements .phar)
 *
 * PHAR files a singular archive from which an entire application can run.
 * To use it, simply package it using {@see PHP_Archive_Creator} and use phar://
 * URIs to your includes. i.e. require_once 'phar://config.php' will include config.php
 * from the root of the PHAR file.
 *
 * Gz code borrowed from the excellent File_Archive package by Vincent Lascaux.
 *
 * @copyright Copyright David Shafik and Synaptic Media 2004. All rights reserved.
 * @author Davey Shafik <davey@synapticmedia.net>
 * @author Greg Beaver <cellog@php.net>
 * @link http://www.synapticmedia.net Synaptic Media
 * @version $Id: Archive.php,v 1.52 2007/09/01 20:28:14 cellog Exp $
 * @package PHP_Archive
 * @category PHP
 */
 
class PHP_Archive
{
    const GZ = 0x00001000;
    const BZ2 = 0x00002000;
    const SIG = 0x00010000;
    const SHA1 = 0x0002;
    const MD5 = 0x0001;
    /**
     * Whether this archive is compressed with zlib
     *
     * @var bool
     */
    private $_compressed;
    /**
     * @var string Real path to the .phar archive
     */
    private $_archiveName = null;
    /**
     * Current file name in the phar
     * @var string
     */
    protected $currentFilename = null;
    /**
     * Length of current file in the phar
     * @var string
     */
    protected $internalFileLength = null;
    /**
     * Current file statistics (size, creation date, etc.)
     * @var string
     */
    protected $currentStat = null;
    /**
     * @var resource|null Pointer to open .phar
     */
    protected $fp = null;
    /**
     * @var int Current Position of the pointer
     */
    protected $position = 0;

    /**
     * Map actual realpath of phars to meta-data about the phar
     *
     * Data is indexed by the alias that is used by internal files.  In other
     * words, if a file is included via:
     * <code>
     * require_once 'phar://PEAR.phar/PEAR/Installer.php';
     * </code>
     * then the alias is "PEAR.phar"
     * 
     * Information stored is a boolean indicating whether this .phar is compressed
     * with zlib, another for bzip2, phar-specific meta-data, and
     * the precise offset of internal files
     * within the .phar, used with the {@link $_manifest} to load actual file contents
     * @var array
     */
    private static $_pharMapping = array();
    /**
     * Map real file paths to alias used
     *
     * @var array
     */
    private static $_pharFiles = array();
    /**
     * File listing for the .phar
     * 
     * The manifest is indexed per phar.
     * 
     * Files within the .phar are indexed by their relative path within the
     * .phar.  Each file has this information in its internal array
     *
     * - 0 = uncompressed file size
     * - 1 = timestamp of when file was added to phar
     * - 2 = offset of file within phar relative to internal file's start
     * - 3 = compressed file size (actual size in the phar)
     * @var array
     */
    private static $_manifest = array();
    /**
     * Absolute offset of internal files within the .phar, indexed by absolute
     * path to the .phar
     *
     * @var array
     */
    private static $_fileStart = array();
    /**
     * file name of the phar
     *
     * @var string
     */
    private $_basename;


    /**
     * Default MIME types used for the web front controller
     *
     * @var array
     */
    public static $defaultmimes = array(
            'aif' => 'audio/x-aiff',
            'aiff' => 'audio/x-aiff',
            'arc' => 'application/octet-stream',
            'arj' => 'application/octet-stream',
            'art' => 'image/x-jg',
            'asf' => 'video/x-ms-asf',
            'asx' => 'video/x-ms-asf',
            'avi' => 'video/avi',
            'bin' => 'application/octet-stream',
            'bm' => 'image/bmp',
            'bmp' => 'image/bmp',
            'bz2' => 'application/x-bzip2',
            'css' => 'text/css',
            'doc' => 'application/msword',
            'dot' => 'application/msword',
            'dv' => 'video/x-dv',
            'dvi' => 'application/x-dvi',
            'eps' => 'application/postscript',
            'exe' => 'application/octet-stream',
            'gif' => 'image/gif',
            'gz' => 'application/x-gzip',
            'gzip' => 'application/x-gzip',
            'htm' => 'text/html',
            'html' => 'text/html',
            'ico' => 'image/x-icon',
            'jpe' => 'image/jpeg',
            'jpg' => 'image/jpeg',
            'jpeg' => 'image/jpeg',
            'js' => 'application/x-javascript',
            'log' => 'text/plain',
            'mid' => 'audio/x-midi',
            'mov' => 'video/quicktime',
            'mp2' => 'audio/mpeg',
            'mp3' => 'audio/mpeg3',
            'mpg' => 'audio/mpeg',
            'pdf' => 'aplication/pdf',
            'png' => 'image/png',
            'rtf' => 'application/rtf',
            'tif' => 'image/tiff',
            'tiff' => 'image/tiff',
            'txt' => 'text/plain',
            'xml' => 'text/xml',
        );

    public static $defaultphp = array(
        'php' => true
        );

    public static $defaultphps = array(
        'phps' => true
        );

    public static $deny = array('/.+\.inc$/');

    public static function viewSource($archive, $file)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        if (self::_fileExists($archive, $_GET['viewsource'])) {
            $source = highlight_file('phar://@ALIAS@/' .
                $_GET['viewsource'], true);
            header('Content-Type: text/html');
            header('Content-Length: ' . strlen($source));
            echo '<html><head><title>Source of ',
                htmlspecialchars($_GET['viewsource']), '</title></head>';
            echo '<body><h1>Source of ',
                htmlspecialchars($_GET['viewsource']), '</h1>';
            if (isset($_GET['introspect'])) {
                echo '<a href="', htmlspecialchars($_SERVER['PHP_SELF']),
                    '?introspect=', urlencode(htmlspecialchars($_GET['introspect'])),
                    '">Return to ', htmlspecialchars($_GET['introspect']), '</a><br />';
            }
            echo $source;
            return false;
        } else {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        
    }

    public static function introspect($archive, $dir)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        if (!$dir) {
            $dir = '/';
        }
        $dir = self::processFile($dir);
        if ($dir[0] != '/') {
            $dir = '/' . $dir;
        }
        try {
            $self = htmlspecialchars($_SERVER['PHP_SELF']);
            $iterate = new DirectoryIterator('phar://@ALIAS@' . $dir);
            echo '<html><head><title>Introspect ', htmlspecialchars($dir),
                '</title></head><body><h1>Introspect ', htmlspecialchars($dir),
                '</h1><ul>';
            if ($dir != '/') {
                echo '<li><a href="', $self, '?introspect=',
                    htmlspecialchars(dirname($dir)), '">..</a></li>';
            }
            foreach ($iterate as $entry) {
                if ($entry->isDot()) continue;
                $name = self::processFile($entry->getPathname());
                $name = str_replace('phar://@ALIAS@/', '', $name);
                if ($entry->isDir()) {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '/</a> [directory]</li>';
                } else {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($dir)), '&viewsource=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '</a></li>';
                }
            }
            return false;
        } catch (Exception $e) {
            echo '<html><head><title>Directory not found: ',
                htmlspecialchars($dir), '</title></head>',
                '<body><h1>Directory not found: ', htmlspecialchars($dir), '</h1>',
                '<p>Try <a href="', htmlspecialchars($_SERVER['PHP_SELF']), '?introspect=/">',
                'This link</a></p></body></html>';
            return false;
        }
    }

    public static function webFrontController($initfile)
    {
        if (isset($_SERVER) && isset($_SERVER['REQUEST_URI'])) {
            $uri = parse_url($_SERVER['REQUEST_URI']);
            $archive = realpath($_SERVER['SCRIPT_FILENAME']);
            $subpath = str_replace('/' . basename($archive), '', $uri['path']);
            if (!$subpath || $subpath == '/') {
                if (isset($_GET['viewsource'])) {
                    return self::viewSource($archive, $_GET['viewsource']);
                }
                if (isset($_GET['introspect'])) {
                    return self::introspect($archive, $_GET['introspect']);
                }
                $subpath = '/' . $initfile;
            }
            if (!self::_fileExists($archive, substr($subpath, 1))) {
                header("HTTP/1.0 404 Not Found");
                return false;
            }
            foreach (self::$deny as $pattern) {
                if (preg_match($pattern, $subpath)) {
                    header("HTTP/1.0 404 Not Found");
                    return false;
                }
            }
            $inf = pathinfo(basename($subpath));
            if (!isset($inf['extension'])) {
                header('Content-Type: text/plain');
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://@ALIAS@' . $subpath);
                return false;
            }
            if (isset(self::$defaultphp[$inf['extension']])) {
                include 'phar://@ALIAS@' . $subpath;
                return false;
            }
            if (isset(self::$defaultmimes[$inf['extension']])) {
                header('Content-Type: ' . self::$defaultmimes[$inf['extension']]);
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://@ALIAS@' . $subpath);
                return false;
            }
            if (isset(self::$defaultphps[$inf['extension']])) {
                header('Content-Type: text/html');
                $c = highlight_file('phar://@ALIAS@' . $subpath, true);
                header('Content-Length: ' . strlen($c));
                echo $c;
                return false;
            }
            header('Content-Type: text/plain');
            header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
            readfile('phar://@ALIAS@' . $subpath);
        }
    }

    /**
     * Detect end of stub
     *
     * @param string $buffer stub past '__HALT_'.'COMPILER();'
     * @return end of stub, prior to length of manifest.
     */
    private static final function _endOfStubLength($buffer)
    {
        $pos = 0;
        if (!strlen($buffer)) {
            return $pos;
        }
        if (($buffer[0] == ' ' || $buffer[0] == "\n") && @substr($buffer, 1, 2) == '?>')
        {
            $pos += 3;
            if ($buffer[$pos] == "\r" && $buffer[$pos+1] == "\n") {
                $pos += 2;
            }
            else if ($buffer[$pos] == "\n") {
                $pos += 1;
            }
        }
        return $pos;
    }

    /**
     * Allows loading an external Phar archive without include()ing it
     *
     * @param string $file  phar package to load
     * @param string $alias alias to use
     * @throws Exception
     */
    public static final function loadPhar($file, $alias = NULL)
    {
        $file = realpath($file);
        if ($file) {
            $fp = fopen($file, 'rb');
            $buffer = '';
            while (!feof($fp)) {
                $buffer .= fread($fp, 8192);
                // don't break phars
                if ($pos = strpos($buffer, '__HALT_COMPI' . 'LER();')) {
                    $buffer .= fread($fp, 5);
                    fclose($fp);
                    $pos += 18;
                    $pos += self::_endOfStubLength(substr($buffer, $pos));
                    return self::_mapPhar($file, $pos, $alias);
                }
            }
            fclose($fp);
        }
    }

    /**
     * Map a full real file path to an alias used to refer to the .phar
     *
     * This function can only be called from the initialization of the .phar itself.
     * Any attempt to call from outside the .phar or to re-alias the .phar will fail
     * as a security measure.
     * @param string $alias
     * @param int $dataoffset the value of __COMPILER_HALT_OFFSET__
     */
    public static final function mapPhar($alias = NULL, $dataoffset = NULL)
    {
        try {
            $trace = debug_backtrace();
            $file = $trace[0]['file'];
            // this ensures that this is safe
            if (!in_array($file, get_included_files())) {
                die('SECURITY ERROR: PHP_Archive::mapPhar can only be called from within ' .
                    'the phar that initiates it');
            }
            $file = realpath($file);
            if (!isset($dataoffset)) {
                $dataoffset = constant('__COMPILER_HALT_OFFSET'.'__');
                $fp = fopen($file, 'rb');
                fseek($fp, $dataoffset, SEEK_SET);
                $dataoffset = $dataoffset + self::_endOfStubLength(fread($fp, 5));
                fclose($fp);
            }

            self::_mapPhar($file, $dataoffset);
        } catch (Exception $e) {
            die($e->getMessage());
        }
    }

    /**
     * Sub-function, allows recovery from errors
     *
     * @param unknown_type $file
     * @param unknown_type $dataoffset
     */
    private static function _mapPhar($file, $dataoffset, $alias = NULL)
    {
        $file = realpath($file);
        if (isset(self::$_manifest[$file])) {
            return;
        }
        if (!is_array(self::$_pharMapping)) {
            self::$_pharMapping = array();
        }
        $fp = fopen($file, 'rb');
        // seek to __HALT_COMPILER_OFFSET__
        fseek($fp, $dataoffset);
        $manifest_length = unpack('Vlen', fread($fp, 4));
        $manifest = '';
        $last = '1';
        while (strlen($last) && strlen($manifest) < $manifest_length['len']) {
            $read = 8192;
            if ($manifest_length['len'] - strlen($manifest) < 8192) {
                $read = $manifest_length['len'] - strlen($manifest);
            }
            $last = fread($fp, $read);
            $manifest .= $last;
        }
        if (strlen($manifest) < $manifest_length['len']) {
            throw new Exception('ERROR: manifest length read was "' . 
                strlen($manifest) .'" should be "' .
                $manifest_length['len'] . '"');
        }
        $info = self::_unserializeManifest($manifest);
        if ($info['alias']) {
            $alias = $info['alias'];
            $explicit = true;
        } else {
            if (!isset($alias)) {
                $alias = $file;
            }
            $explicit = false;
        }
        self::$_manifest[$file] = $info['manifest'];
        $compressed = $info['compressed'];
        self::$_fileStart[$file] = ftell($fp);
        fclose($fp);
        if ($compressed & 0x00001000) {
            if (!function_exists('gzinflate')) {
                throw new Exception('Error: zlib extension is not enabled - gzinflate() function needed' .
                    ' for compressed .phars');
            }
        }
        if ($compressed & 0x00002000) {
            if (!function_exists('bzdecompress')) {
                throw new Exception('Error: bzip2 extension is not enabled - bzdecompress() function needed' .
                    ' for compressed .phars');
            }
        }
        if (isset(self::$_pharMapping[$alias])) {
            throw new Exception('ERROR: PHP_Archive::mapPhar has already been called for alias "' .
                $alias . '" cannot re-alias to "' . $file . '"');
        }
        self::$_pharMapping[$alias] = array($file, $compressed, $dataoffset, $explicit,
            $info['metadata']);
        self::$_pharFiles[$file] = $alias;
    }

    /**
     * extract the manifest into an internal array
     *
     * @param string $manifest
     * @return false|array
     */
    private static function _unserializeManifest($manifest)
    {
        // retrieve the number of files in the manifest
        $info = unpack('V', substr($manifest, 0, 4));
        $apiver = substr($manifest, 4, 2);
        $apiver = bin2hex($apiver);
        $apiver_dots = hexdec($apiver[0]) . '.' . hexdec($apiver[1]) . '.' . hexdec($apiver[2]);
        $majorcompat = hexdec($apiver[0]);
        $calcapi = explode('.', self::APIVersion());
        if ($calcapi[0] != $majorcompat) {
            throw new Exception('Phar is incompatible API version ' . $apiver_dots . ', but ' .
                'PHP_Archive is API version '.self::APIVersion());
        }
        if ($calcapi[0] === '0') {
            if (self::APIVersion() != $apiver_dots) {
                throw new Exception('Phar is API version ' . $apiver_dots .
                    ', but PHP_Archive is API version '.self::APIVersion(), E_USER_ERROR);
            }
        }
        $flags = unpack('V', substr($manifest, 6, 4));
        $ret = array('compressed' => $flags & 0x00003000);
        // signature is not verified by default in PHP_Archive, phar is better
        $ret['hassignature'] = $flags & 0x00010000;
        $aliaslen = unpack('V', substr($manifest, 10, 4));
        if ($aliaslen) {
            $ret['alias'] = substr($manifest, 14, $aliaslen[1]);
        } else {
            $ret['alias'] = false;
        }
        $manifest = substr($manifest, 14 + $aliaslen[1]);
        $metadatalen = unpack('V', substr($manifest, 0, 4));
        if ($metadatalen[1]) {
            $ret['metadata'] = unserialize(substr($manifest, 4, $metadatalen[1]));
            $manifest = substr($manifest, 4 + $metadatalen[1]);
        } else {
            $ret['metadata'] = null;
            $manifest = substr($manifest, 4);
        }
        $offset = 0;
        $start = 0;
        for ($i = 0; $i < $info[1]; $i++) {
            // length of the file name
            $len = unpack('V', substr($manifest, $start, 4));
            $start += 4;
            // file name
            $savepath = substr($manifest, $start, $len[1]);
            $start += $len[1];
            // retrieve manifest data:
            // 0 = uncompressed file size
            // 1 = timestamp of when file was added to phar
            // 2 = compressed filesize
            // 3 = crc32
            // 4 = flags
            // 5 = metadata length
            $ret['manifest'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($manifest, $start, 24)));
            $ret['manifest'][$savepath][3] = sprintf('%u', $ret['manifest'][$savepath][3]
                & 0xffffffff);
            if ($ret['manifest'][$savepath][5]) {
                $ret['manifest'][$savepath][6] = unserialize(substr($manifest, $start + 24,
                    $ret['manifest'][$savepath][5]));
            } else {
                $ret['manifest'][$savepath][6] = null;
            }
            $ret['manifest'][$savepath][7] = $offset;
            $offset += $ret['manifest'][$savepath][2];
            $start += 24 + $ret['manifest'][$savepath][5];
        }
        return $ret;
    }

    /**
     * @param string
     */
    private static function processFile($path)
    {
        if ($path == '.') {
            return '';
        }
        $std = str_replace("\\", "/", $path);
        while ($std != ($std = ereg_replace("[^\/:?]+/\.\./", "", $std))) ;
        $std = str_replace("/./", "", $std);
        if (strlen($std) > 1 && $std[0] == '/') {
            $std = substr($std, 1);
        }
        if (strncmp($std, "./", 2) == 0) {
            return substr($std, 2);
        } else {
            return $std;
        }
    }

    /**
     * Seek in the master archive to a matching file or directory
     * @param string
     */
    protected function selectFile($path, $allowdirs = true)
    {
        $std = self::processFile($path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            $this->_setCurrentFile($path);
            return true;
        }
        if (!$allowdirs) {
            return 'Error: "' . $path . '" is not a file in phar "' . $this->_basename . '"';
        }
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if (empty($std) ||
                  //$std is a directory
                  strncmp($std.'/', $path, strlen($std)+1) == 0) {
                $this->currentFilename = $this->internalFileLength = $this->currentStat = null;
                return true;
            }
        }
        return 'Error: "' . $path . '" not found in phar "' . $this->_basename . '"';
    }

    private function _setCurrentFile($path)
    {
        $this->currentStat = array(
            2 => 0100444, // file mode, readable by all, writeable by none
            4 => 0, // uid
            5 => 0, // gid
            7 => self::$_manifest[$this->_archiveName][$path][0], // size
            9 => self::$_manifest[$this->_archiveName][$path][1], // creation time
            );
        $this->currentFilename = $path;
        $this->internalFileLength = self::$_manifest[$this->_archiveName][$path][2];
        // seek to offset of file header within the .phar
        if (is_resource(@$this->fp)) {
            fseek($this->fp, self::$_fileStart[$this->_archiveName] + self::$_manifest[$this->_archiveName][$path][7]);
        }
    }

    private static function _fileExists($archive, $path)
    {
        return isset(self::$_manifest[$archive]) &&
            isset(self::$_manifest[$archive][$path]);
    }

    private static function _filesize($archive, $path)
    {
        return self::$_manifest[$archive][$path][0];
    }

    /**
     * Seek to a file within the master archive, and extract its contents
     * @param string
     * @return array|string an array containing an error message string is returned
     *                      upon error, otherwise the file contents are returned
     */
    public function extractFile($path)
    {
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            return array('Error: cannot open phar "' . $this->_archiveName . '"');
        }
        if (($e = $this->selectFile($path, false)) === true) {
            $data = '';
            $count = $this->internalFileLength;
            while ($count) {
                if ($count < 8192) {
                    $data .= @fread($this->fp, $count);
                    $count = 0;
                } else {
                    $count -= 8192;
                    $data .= @fread($this->fp, 8192);
                }
            }
            @fclose($this->fp);
            if (self::$_manifest[$this->_archiveName][$path][4] & self::GZ) {
                $data = gzinflate($data);
            } elseif (self::$_manifest[$this->_archiveName][$path][4] & self::BZ2) {
                $data = bzdecompress($data);
            }
            if (!isset(self::$_manifest[$this->_archiveName][$path]['ok'])) {
                if (strlen($data) != $this->currentStat[7]) {
                    return array("Not valid internal .phar file (size error {$size} != " .
                        $this->currentStat[7] . ")");
                }
                if (self::$_manifest[$this->_archiveName][$path][3] != sprintf("%u", crc32($data) & 0xffffffff)) {
                    return array("Not valid internal .phar file (checksum error)");
                }
                self::$_manifest[$this->_archiveName][$path]['ok'] = true;
            }
            return $data;
        } else {
            @fclose($this->fp);
            return array($e);
        }
    }

    /**
     * Parse urls like phar:///fullpath/to/my.phar/file.txt
     *
     * @param string $file
     * @return false|array
     */
    static protected function parseUrl($file)
    {
        if (substr($file, 0, 7) != 'phar://') {
            return false;
        }
        $file = substr($file, 7);
    
        $ret = array('scheme' => 'phar');
        $pos_p = strpos($file, '.phar.php');
        $pos_z = strpos($file, '.phar.gz');
        $pos_b = strpos($file, '.phar.bz2');
        if ($pos_p) {
            if ($pos_z) {
                return false;
            }
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar.php'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_z) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.gz'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_b) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.bz2'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif (($pos_p = strpos($file, ".phar")) !== false) {
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } else {
            return false;
        }
        if (!$ret['path']) {
            $ret['path'] = '/';
        }
        return $ret;
    }
    
    /**
     * Locate the .phar archive in the include_path and detect the file to open within
     * the archive.
     *
     * Possible parameters are phar://pharname.phar/filename_within_phar.ext
     * @param string a file within the archive
     * @return string the filename within the .phar to retrieve
     */
    public function initializeStream($file)
    {
        $file = self::processFile($file);
        $info = @parse_url($file);
        if (!$info) {
            $info = self::parseUrl($file);
        }
        if (!$info) {
            return false;
        }
        if (!isset($info['host'])) {
            // malformed internal file
            return false;
        }
        if (!isset(self::$_pharFiles[$info['host']]) &&
              !isset(self::$_pharMapping[$info['host']])) {
            try {
                self::loadPhar($info['host']);
                // use alias from here out
                $info['host'] = self::$_pharFiles[$info['host']];
            } catch (Exception $e) {
                return false;
            }
        }
        if (!isset($info['path'])) {
            return false;
        } elseif (strlen($info['path']) > 1) {
            $info['path'] = substr($info['path'], 1);
        }
        if (isset(self::$_pharMapping[$info['host']])) {
            $this->_basename = $info['host'];
            $this->_archiveName = self::$_pharMapping[$info['host']][0];
            $this->_compressed = self::$_pharMapping[$info['host']][1];
        } elseif (isset(self::$_pharFiles[$info['host']])) {
            $this->_archiveName = $info['host'];
            $this->_basename = self::$_pharFiles[$info['host']];
            $this->_compressed = self::$_pharMapping[$this->_basename][1];
        }
        $file = $info['path'];
        return $file;
    }

    /**
     * Open the requested file - PHP streams API
     *
     * @param string $file String provided by the Stream wrapper
     * @access private
     */
    public function stream_open($file)
    {
        return $this->_streamOpen($file);
    }

    /**
     * @param string filename to opne, or directory name
     * @param bool if true, a directory will be matched, otherwise only files
     *             will be matched
     * @uses trigger_error()
     * @return bool success of opening
     * @access private
     */
    private function _streamOpen($file, $searchForDir = false)
    {
        $path = $this->initializeStream($file);
        if (!$path) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
        }
        if (is_array($this->file = $this->extractFile($path))) {
            trigger_error($this->file[0], E_USER_ERROR);
            return false;
        }
        if ($path != $this->currentFilename) {
            if (!$searchForDir) {
                trigger_error("Cannot open '$file', is a directory", E_USER_ERROR);
                return false;
            } else {
                $this->file = '';
                return true;
            }
        }

        if (!is_null($this->file) && $this->file !== false) {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Read the data - PHP streams API
     *
     * @param int
     * @access private
     */
    public function stream_read($count)
    {
        $ret = substr($this->file, $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }
    
    /**
     * Whether we've hit the end of the file - PHP streams API
     * @access private
     */
    function stream_eof()
    {
        return $this->position >= $this->currentStat[7];
    }
    
    /**
     * For seeking the stream - PHP streams API
     * @param int
     * @param SEEK_SET|SEEK_CUR|SEEK_END
     * @access private
     */
    public function stream_seek($pos, $whence)
    {
        switch ($whence) {
            case SEEK_SET:
                if ($pos < 0) {
                    return false;
                }
                $this->position = $pos;
                break;
            case SEEK_CUR:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position += $pos;
                break;
            case SEEK_END:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position = $pos + $this->currentStat[7];
                break;
            default:
                return false;
        }
        return true;
    }
    
    /**
     * The current position in the stream - PHP streams API
     * @access private
     */
    public function stream_tell()
    {
        return $this->position;
    }

    /**
     * The result of an fstat call, returns mod time from creation, and file size -
     * PHP streams API
     * @uses _stream_stat()
     * @access private
     */
    public function stream_stat()
    {
        return $this->_stream_stat();
    }

    /**
     * Retrieve statistics on a file or directory within the .phar
     * @param string file/directory to stat
     * @access private
     */
    public function _stream_stat($file = null)
    {
        $std = $file ? self::processFile($file) : $this->currentFilename;
        if ($file) {
            if (isset(self::$_manifest[$this->_archiveName][$file])) {
                $this->_setCurrentFile($file);
                $isdir = false;
            } else {
                do {
                    $isdir = false;
                    if ($file == '/') {
                        break;
                    }
                    foreach (self::$_manifest[$this->_archiveName] as $path => $info) {
                        if (strpos($path, $file) === 0) {
                            if (strlen($path) > strlen($file) &&
                                  $path[strlen($file)] == '/') {
                                break 2;
                            }
                        }
                    }
                    // no files exist and no directories match this string
                    return false;
                } while (false);
                $isdir = true;
            }
        } else {
            $isdir = false; // open streams must be files
        }
        $mode = $isdir ? 0040444 : 0100444;
        // 040000 = dir, 010000 = file
        // everything is readable, nothing is writeable
        return array(
           0, 0, $mode, 0, 0, 0, 0, 0, 0, 0, 0, 0, // non-associative indices
           'dev' => 0, 'ino' => 0,
           'mode' => $mode,
           'nlink' => 0, 'uid' => 0, 'gid' => 0, 'rdev' => 0, 'blksize' => 0, 'blocks' => 0,
           'size' => $this->currentStat[7],
           'atime' => $this->currentStat[9],
           'mtime' => $this->currentStat[9],
           'ctime' => $this->currentStat[9],
           );
    }

    /**
     * Stat a closed file or directory - PHP streams API
     * @param string
     * @param int
     * @access private
     */
    public function url_stat($url, $flags)
    {
        $path = $this->initializeStream($url);
        return $this->_stream_stat($path);
    }

    /**
     * Open a directory in the .phar for reading - PHP streams API
     * @param string directory name
     * @access private
     */
    public function dir_opendir($path)
    {
        $info = @parse_url($path);
        if (!$info) {
            $info = self::parseUrl($path);
            if (!$info) {
                trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                    E_USER_ERROR);
                return false;
            }
        }
        $path = !empty($info['path']) ?
            $info['host'] . $info['path'] : $info['host'] . '/';
        $path = $this->initializeStream('phar://' . $path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                E_USER_ERROR);
            return false;
        }
        if ($path == false) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
            return false;
        }
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            trigger_error('Error: cannot open phar "' . $this->_archiveName . '"');
            return false;
        }
        $this->_dirFiles = array();
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if ($path == '/') {
                if (strpos($file, '/')) {
                    $a = explode('/', $file);
                    $this->_dirFiles[array_shift($a)] = true;
                } else {
                    $this->_dirFiles[$file] = true;
                }
            } elseif (strpos($file, $path) === 0) {
                $fname = substr($file, strlen($path) + 1);
                if (strpos($fname, '/')) {
                    // this is a directory
                    $a = explode('/', $fname);
                    $this->_dirFiles[array_shift($a)] = true;
                } elseif ($file[strlen($path)] == '/') {
                    // this is a file
                    $this->_dirFiles[$fname] = true;
                }
            }
        }
        @fclose($this->fp);
        if (!count($this->_dirFiles)) {
            return false;
        }
        @uksort($this->_dirFiles, 'strnatcmp');
        return true;
    }

    /**
     * Read the next directory entry - PHP streams API
     * @access private
     */
    public function dir_readdir()
    {
        $ret = key($this->_dirFiles);
        @next($this->_dirFiles);
        if (!$ret) {
            return false;
        }
        return $ret;
    }

    /**
     * Close a directory handle opened with opendir() - PHP streams API
     * @access private
     */
    public function dir_closedir()
    {
        $this->_dirFiles = array();
        return true;
    }

    /**
     * Rewind to the first directory entry - PHP streams API
     * @access private
     */
    public function dir_rewinddir()
    {
        @reset($this->_dirFiles);
        return true;
    }

    /**
     * API version of this class
     * @return string
     */
    public static final function APIVersion()
    {
        return '1.0.0';
    }

    /**
     * Retrieve Phar-specific metadata for a Phar archive
     *
     * @param string $phar full path to Phar archive, or alias
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getPharMetadata($phar)
    {
        if (isset(self::$_pharFiles[$phar])) {
            $phar = self::$_pharFiles[$phar];
        }
        if (!isset(self::$_pharMapping[$phar])) {
            throw new Exception('Unknown Phar archive: "' . $phar . '"');
        }
        return self::$_pharMapping[$phar][4];
    }

    /**
     * Retrieve File-specific metadata for a Phar archive file
     *
     * @param string $phar full path to Phar archive, or alias
     * @param string $file relative path to file within Phar archive
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getFileMetadata($phar, $file)
    {
        if (!isset(self::$_pharFiles[$phar])) {
            if (!isset(self::$_pharMapping[$phar])) {
                throw new Exception('Unknown Phar archive: "' . $phar . '"');
            }
            $phar = self::$_pharMapping[$phar][0];
        }
        if (!isset(self::$_manifest[$phar])) {
            throw new Exception('Unknown Phar: "' . $phar . '"');
        }
        $file = self::processFile($file);
        if (!isset(self::$_manifest[$phar][$file])) {
            throw new Exception('Unknown file "' . $file . '" within Phar "'. $phar . '"');
        }
        return self::$_manifest[$phar][$file][6];
    }

    /**
     * @return list of supported signature algorithmns.
     */
    public static function getsupportedsignatures()
    {
        $ret = array('MD5', 'SHA-1');
        if (extension_loaded('hash')) {
            $ret[] = 'SHA-256';
            $ret[] = 'SHA-512';
        }
        return $ret;
    }
}
?><?php
    }
    if (!in_array('phar', stream_get_wrappers(), true)) {
        stream_wrapper_register('phar', 'PHP_Archive');
    }
}
define('PYRUS_PHAR_FILE', __FILE__);
include 'phar://' . __FILE__ . '/__index.php';
__HALT_COMPILER(); ?>
ÊF           W   s:79:".xmlregistry/packages/pear2.php.net/PEAR2_SimpleChannelServer/0.1.0-package.xml";   __index.php  "ö!J  ~ıÈ˚∂      O   .xmlregistry/packages/pear2.php.net/PEAR2_SimpleChannelServer/0.1.0-package.xmlÈ  "ö!JÈ  *Uƒ∂      P   doc/pear2.php.net/PEAR2_SimpleChannelServer/examples/examples/update_channel.php¢  "ö!J¢  x^Ωµ∂      6   php/PEAR2/SimpleChannelServer/Categories/Exception.phpU   "ö!JU   Xe∂      ,   php/PEAR2/SimpleChannelServer/Categories.php˝  "ö!J˝  ‚˘òi∂      )   php/PEAR2/SimpleChannelServer/Channel.php•  "ö!J•  õBae∂      %   php/PEAR2/SimpleChannelServer/CLI.phpô  "ö!Jô  0Ì@®∂      +   php/PEAR2/SimpleChannelServer/Exception.phpJ   "ö!JJ   d∞Úu∂      %   php/PEAR2/SimpleChannelServer/Get.phpñ	  "ö!Jñ	  y'ÕŸ∂      /   php/PEAR2/SimpleChannelServer/REST/Category.phpN  "ö!JN  .¸Él∂      1   php/PEAR2/SimpleChannelServer/REST/Maintainer.php
  "ö!J
  ã!ªr∂      .   php/PEAR2/SimpleChannelServer/REST/Manager.php~  "ö!J~  ó#‰∂      .   php/PEAR2/SimpleChannelServer/REST/Package.php‡  "ö!J‡  ≠RY(∂      .   php/PEAR2/SimpleChannelServer/REST/Release.php-+  "ö!J-+  [’ß+∂      !   php/PEAR2/SimpleChannelServer.php‚(  "ö!J‚(  ¯º£∂         script/pearscs#  "ö!J#  KU'ß∂         php/PEAR2/Autoload.php7	  "ö!J7	  Æ&&…∂         php/PEAR2/MultiErrors.php•  "ö!J•  ∆ıï∂      #   php/PEAR2/MultiErrors/Exception.phpB   "ö!JB   ˙«z≤∂         php/PEAR2/Exception.php 0  "ö!J 0  zb√2∂         php/PEAR2/HTTP/    "ö!J        ˇ         php/PEAR2/HTTP/Request.phpÄ  "ö!JÄ  ¢:ñ∂         php/PEAR2/HTTP/Request/    "ö!J        ˇ      "   php/PEAR2/HTTP/Request/Adapter.phpw  "ö!Jw  	ˇ∂         php/PEAR2/HTTP/Request/Adapter/    "ö!J        ˇ      ,   php/PEAR2/HTTP/Request/Adapter/Phpsocket.phpÎ,  "ö!JÎ,  —ê~¶∂      ,   php/PEAR2/HTTP/Request/Adapter/Phpstream.php˜  "ö!J˜  Sö¯ƒ∂      $   php/PEAR2/HTTP/Request/Exception.phpE   "ö!JE   5≈ˆ,∂      "   php/PEAR2/HTTP/Request/Headers.phpŸ  "ö!JŸ  =2d∂      #   php/PEAR2/HTTP/Request/Response.phpD  "ö!JD  t5¸Ò∂         php/PEAR2/HTTP/Request/Uri.php¡  "ö!J¡  m[∫\∂         php/data/default_channels/    "ö!J        ˇ      *   php/data/default_channels/pear.php.net.xmlù  "ö!Jù  dHˇ∂         data/default_channels/    "ö!J        ˇ      &   data/default_channels/pear.php.net.xmlù  "ö!Jù  dHˇ∂      +   php/data/default_channels/pear2.php.net.xmlŸ  "ö!JŸ  ‘wø∂      '   data/default_channels/pear2.php.net.xmlŸ  "ö!JŸ  ‘wø∂      *   php/data/default_channels/pecl.php.net.xmlp  "ö!Jp  r∞±∂      &   data/default_channels/pecl.php.net.xmlp  "ö!Jp  r∞±∂      #   php/data/default_channels/__uri.xmlÒ  "ö!JÒ  "∂∂         data/default_channels/__uri.xmlÒ  "ö!JÒ  "∂∂         php/data/channel-1.0.xsd∫  "ö!J∫  ä≤vw∂         data/channel-1.0.xsd∫  "ö!J∫  ä≤vw∂         php/data/package-2.0.xsd/N  "ö!J/N  ≈∞ì∂         data/package-2.0.xsd/N  "ö!J/N  ≈∞ì∂         php/data/package-2.1.xsd1Q  "ö!J1Q  ïo·∂         data/package-2.1.xsd1Q  "ö!J1Q  ïo·∂      &   php/PEAR2/Pyrus/AtomicFileTransaction/    "ö!J        ˇ      3   php/PEAR2/Pyrus/AtomicFileTransaction/Exception.php  "ö!J  F5„6∂         php/PEAR2/Pyrus/Channel/    "ö!J        ˇ      %   php/PEAR2/Pyrus/Channel/Exception.phpŒ  "ö!JŒ  Ma-ö∂      #   php/PEAR2/Pyrus/Channel/IMirror.php‡  "ö!J‡  ô*(å∂      )   php/PEAR2/Pyrus/Channel/Remotepackage.phpH@  "ö!JH@  ı√b∂      *   php/PEAR2/Pyrus/Channel/Remotepackages.php€  "ö!J€  	«*∞∂      #   php/PEAR2/Pyrus/ChannelFile/Parser/    "ö!J        ˇ      )   php/PEAR2/Pyrus/ChannelFile/Parser/v1.php'  "ö!J'  ˝ì(:∂      1   php/PEAR2/Pyrus/ChannelFile/v1/Servers/Protocols/    "ö!J        ˇ      9   php/PEAR2/Pyrus/ChannelFile/v1/Servers/Protocols/REST.php∞  "ö!J∞  ‡ ûW∂      4   php/PEAR2/Pyrus/ChannelFile/v1/Servers/Protocols.php¯  "ö!J¯  qãZ∂      )   php/PEAR2/Pyrus/ChannelFile/v1/Mirror.php  "ö!J  K¬˙à∂      *   php/PEAR2/Pyrus/ChannelFile/v1/Servers.phpã  "ö!Jã  ~¸Fã∂      )   php/PEAR2/Pyrus/ChannelFile/Exception.phpB   "ö!JB   ⁄◊X∂      "   php/PEAR2/Pyrus/ChannelFile/v1.php^;  "ö!J^;  üÁÂ‹∂      '   php/PEAR2/Pyrus/ChannelRegistry/Mirror/    "ö!J        ˇ      2   php/PEAR2/Pyrus/ChannelRegistry/Mirror/Sqlite3.php   "ö!J   (O/∂      .   php/PEAR2/Pyrus/ChannelRegistry/Mirror/Xml.phpÀ  "ö!JÀ  ∞∆ê-∂      (   php/PEAR2/Pyrus/ChannelRegistry/Base.phpÈ*  "ö!JÈ*  ∫›ıä∂      +   php/PEAR2/Pyrus/ChannelRegistry/Channel.php  "ö!J  Ó≈-∂      -   php/PEAR2/Pyrus/ChannelRegistry/Exception.php  "ö!J  ˜<^∂      2   php/PEAR2/Pyrus/ChannelRegistry/ParseException.php‹  "ö!J‹  ˜.…)∂      )   php/PEAR2/Pyrus/ChannelRegistry/Pear1.php_!  "ö!J_!  Ë YU∂      +   php/PEAR2/Pyrus/ChannelRegistry/Sqlite3.phpü>  "ö!Jü>  uÕ§∂      '   php/PEAR2/Pyrus/ChannelRegistry/Xml.php∞  "ö!J∞  {(3‡∂         php/PEAR2/Pyrus/Config/    "ö!J        ˇ      $   php/PEAR2/Pyrus/Config/Exception.php›  "ö!J›  ∑æ„∂      #   php/PEAR2/Pyrus/Config/Snapshot.phpç  "ö!Jç  SH1◊∂         php/PEAR2/Pyrus/Dependency/    "ö!J        ˇ      (   php/PEAR2/Pyrus/Dependency/Exception.phpÿ  "ö!Jÿ  PÎõ}∂      (   php/PEAR2/Pyrus/Dependency/Validator.php+ì  "ö!J+ì  R¢¸à∂         php/PEAR2/Pyrus/DirectedGraph/    "ö!J        ˇ      +   php/PEAR2/Pyrus/DirectedGraph/Exception.phpﬂ  "ö!Jﬂ  ú≈ßq∂      (   php/PEAR2/Pyrus/DirectedGraph/Vertex.phpÒ  "ö!JÒ  YÑ«*∂         php/PEAR2/Pyrus/Installer/Role/    "ö!J        ˇ      )   php/PEAR2/Pyrus/Installer/Role/Common.php"  "ö!J"  ·˘ö=∂      '   php/PEAR2/Pyrus/Installer/Role/Data.php⁄  "ö!J⁄  /ÿ“∂      '   php/PEAR2/Pyrus/Installer/Role/Data.xml¥  "ö!J¥  Õ†åQ∂      &   php/PEAR2/Pyrus/Installer/Role/Doc.php◊  "ö!J◊  ®πkP∂      &   php/PEAR2/Pyrus/Installer/Role/Doc.xml≥  "ö!J≥  A‚êé∂      ,   php/PEAR2/Pyrus/Installer/Role/Exception.php‹  "ö!J‹  &üFí∂      &   php/PEAR2/Pyrus/Installer/Role/Ext.php◊  "ö!J◊  Hë◊∂      &   php/PEAR2/Pyrus/Installer/Role/Ext.xmlM  "ö!JM  $®Fƒ∂      &   php/PEAR2/Pyrus/Installer/Role/Php.php◊  "ö!J◊  î,ñ∂      &   php/PEAR2/Pyrus/Installer/Role/Php.xmlª  "ö!Jª  ÈÄ!Ë∂      )   php/PEAR2/Pyrus/Installer/Role/Script.php‡  "ö!J‡  ›äÑ∂      )   php/PEAR2/Pyrus/Installer/Role/Script.xmlæ  "ö!Jæ  –Tƒ∂      &   php/PEAR2/Pyrus/Installer/Role/Src.php◊  "ö!J◊  “jˇ∂      &   php/PEAR2/Pyrus/Installer/Role/Src.xml@  "ö!J@  øïÁ∂      '   php/PEAR2/Pyrus/Installer/Role/Test.php⁄  "ö!J⁄  l∆∑–∂      '   php/PEAR2/Pyrus/Installer/Role/Test.xml¥  "ö!J¥  ˚|∂      &   php/PEAR2/Pyrus/Installer/Role/Www.php⁄  "ö!J⁄  àˇÅ∂      &   php/PEAR2/Pyrus/Installer/Role/Www.xml•  "ö!J•  ˝$P$∂      '   php/PEAR2/Pyrus/Installer/Exception.phpﬂ  "ö!Jﬂ  ™/P∂      "   php/PEAR2/Pyrus/Installer/Role.php¢  "ö!J¢  πÚº∂          php/PEAR2/Pyrus/Package/Creator/    "ö!J        ˇ      -   php/PEAR2/Pyrus/Package/Creator/Exception.phpÎ  "ö!JÎ  ¯¯[Ú∂      0   php/PEAR2/Pyrus/Package/Creator/TaskIterator.phpù  "ö!Jù  ÁÏ0≠∂         php/PEAR2/Pyrus/Package/Phar/    "ö!J        ˇ      *   php/PEAR2/Pyrus/Package/Phar/Exception.php„  "ö!J„  +cé¶∂         php/PEAR2/Pyrus/Package/Tar/    "ö!J        ˇ      )   php/PEAR2/Pyrus/Package/Tar/Exception.php‡  "ö!J‡  yG8O∂         php/PEAR2/Pyrus/Package/Zip/    "ö!J        ˇ      )   php/PEAR2/Pyrus/Package/Zip/Exception.php‡  "ö!J‡  ∆Ó0¡∂          php/PEAR2/Pyrus/Package/Base.phpé  "ö!Jé  ˝ﬁw ∂      #   php/PEAR2/Pyrus/Package/Creator.php÷4  "ö!J÷4  ∏=>∂      &   php/PEAR2/Pyrus/Package/Dependency.php∞/  "ö!J∞/  ¿ßøÑ∂      %   php/PEAR2/Pyrus/Package/Exception.php‘  "ö!J‘  Ê1‰∂      $   php/PEAR2/Pyrus/Package/ICreator.phpW  "ö!JW  Å©Ì˘∂      .   php/PEAR2/Pyrus/Package/InstalledException.php˛  "ö!J˛  '~Ö2∂          php/PEAR2/Pyrus/Package/Phar.php   "ö!J   _l#g∂      "   php/PEAR2/Pyrus/Package/Remote.phpç0  "ö!Jç0  ü’Ω∂         php/PEAR2/Pyrus/Package/Tar.phpÉ,  "ö!JÉ,  Íu $∂         php/PEAR2/Pyrus/Package/Xml.php∫  "ö!J∫  ıíá-∂         php/PEAR2/Pyrus/Package/Zip.phpÑ  "ö!JÑ  ÙAÊT∂      #   php/PEAR2/Pyrus/PackageFile/Parser/    "ö!J        ˇ      )   php/PEAR2/Pyrus/PackageFile/Parser/v2.phpá  "ö!Já  â∂      *   php/PEAR2/Pyrus/PackageFile/v2/Compatible/    "ö!J        ˇ      7   php/PEAR2/Pyrus/PackageFile/v2/Compatible/Exception.php  "ö!J  yzZ∂      /   php/PEAR2/Pyrus/PackageFile/v2/Configureoption/    "ö!J        ˇ      <   php/PEAR2/Pyrus/PackageFile/v2/Configureoption/Exception.php  "ö!J  “Ñ›¥∂      ,   php/PEAR2/Pyrus/PackageFile/v2/Dependencies/    "ö!J        ˇ      3   php/PEAR2/Pyrus/PackageFile/v2/Dependencies/Dep.phpM  "ö!JM  ‘9ÛÄ∂      9   php/PEAR2/Pyrus/PackageFile/v2/Dependencies/Exception.php  "ö!J  UƒB+∂      5   php/PEAR2/Pyrus/PackageFile/v2/Dependencies/Group.php_  "ö!J_  95∂      7   php/PEAR2/Pyrus/PackageFile/v2/Dependencies/Package.phpc<  "ö!Jc<  GiDä∂      )   php/PEAR2/Pyrus/PackageFile/v2/Developer/    "ö!J        ˇ      6   php/PEAR2/Pyrus/PackageFile/v2/Developer/Exception.php  "ö!J  Õw∂      %   php/PEAR2/Pyrus/PackageFile/v2/Files/    "ö!J        ˇ      2   php/PEAR2/Pyrus/PackageFile/v2/Files/Exception.php  "ö!J  ÄG6√∂      -   php/PEAR2/Pyrus/PackageFile/v2/Files/File.php@
  "ö!J@
  3+ ∂      '   php/PEAR2/Pyrus/PackageFile/v2/License/    "ö!J        ˇ      4   php/PEAR2/Pyrus/PackageFile/v2/License/Exception.php  "ö!J  k¿:∂      '   php/PEAR2/Pyrus/PackageFile/v2/Release/    "ö!J        ˇ      8   php/PEAR2/Pyrus/PackageFile/v2/Release/BinaryPackage.phpè	  "ö!Jè	  Án´Z∂      :   php/PEAR2/Pyrus/PackageFile/v2/Release/ConfigureOption.php  "ö!J  ∏øZi∂      4   php/PEAR2/Pyrus/PackageFile/v2/Release/Exception.php	  "ö!J	  uWA∂      ;   php/PEAR2/Pyrus/PackageFile/v2/Release/InstallCondition.phpï.  "ö!Jï.  É€ÑÕ∂      ,   php/PEAR2/Pyrus/PackageFile/v2/UsesRoleTask/    "ö!J        ˇ      9   php/PEAR2/Pyrus/PackageFile/v2/UsesRoleTask/Exception.php   "ö!J   ≈z∫'∂      1   php/PEAR2/Pyrus/PackageFile/v2/BundledPackage.phph  "ö!Jh  	1∂      -   php/PEAR2/Pyrus/PackageFile/v2/Compatible.php"  "ö!J"  à∞àv∂      2   php/PEAR2/Pyrus/PackageFile/v2/Configureoption.php«  "ö!J«  †pDÈ∂      /   php/PEAR2/Pyrus/PackageFile/v2/Dependencies.phpÂ/  "ö!JÂ/  —ŸÓ∂      ,   php/PEAR2/Pyrus/PackageFile/v2/Developer.php¡+  "ö!J¡+  r>∏
∂      (   php/PEAR2/Pyrus/PackageFile/v2/Files.phpK  "ö!JK  ltez∂      *   php/PEAR2/Pyrus/PackageFile/v2/License.php‹  "ö!J‹  Q$ı∂      *   php/PEAR2/Pyrus/PackageFile/v2/Release.phpÉ<  "ö!JÉ<  €qR∂      1   php/PEAR2/Pyrus/PackageFile/v2/SimpleProperty.phpG
  "ö!JG
  H1
?∂      /   php/PEAR2/Pyrus/PackageFile/v2/UsesRoleTask.phpó  "ö!Jó  nx¿∂      ,   php/PEAR2/Pyrus/PackageFile/v2/Validator.phpíd  "ö!Jíd  åbÆ∂      '   php/PEAR2/Pyrus/PackageFile/v2Iterator/    "ö!J        ˇ      /   php/PEAR2/Pyrus/PackageFile/v2Iterator/File.phpÃ  "ö!JÃ  ≤ ÕÌ∂      <   php/PEAR2/Pyrus/PackageFile/v2Iterator/FileAttribsFilter.php:  "ö!J:  CO¬h∂      7   php/PEAR2/Pyrus/PackageFile/v2Iterator/FileContents.phpÔ	  "ö!JÔ	  0?ë¡∂      <   php/PEAR2/Pyrus/PackageFile/v2Iterator/FileContentsMulti.phpj  "ö!Jj  ´x@Ê∂      A   php/PEAR2/Pyrus/PackageFile/v2Iterator/FileInstallationFilter.php0  "ö!J0  
Ã]∂      2   php/PEAR2/Pyrus/PackageFile/v2Iterator/FileTag.php‰  "ö!J‰  ¯%∂      <   php/PEAR2/Pyrus/PackageFile/v2Iterator/PackagingIterator.phpê  "ö!Jê  ÏVÖy∂      C   php/PEAR2/Pyrus/PackageFile/v2Iterator/ScriptFileFilterIterator.php÷  "ö!J÷  ÖX&∂      )   php/PEAR2/Pyrus/PackageFile/Exception.phpﬂ  "ö!Jﬂ  !‘V∂      *   php/PEAR2/Pyrus/PackageFile/IValidator.php  "ö!J  ÉÕö∂      "   php/PEAR2/Pyrus/PackageFile/v2.php,¨  "ö!J,¨  ‰[?∂         php/PEAR2/Pyrus/PECLBuild/    "ö!J        ˇ      '   php/PEAR2/Pyrus/PECLBuild/Exception.phpË  "ö!JË  K,∂o∂      !   php/PEAR2/Pyrus/Registry/Package/    "ö!J        ˇ      )   php/PEAR2/Pyrus/Registry/Package/Base.php;  "ö!J;  A®{Ó∂         php/PEAR2/Pyrus/Registry/Pear1/    "ö!J        ˇ      /   php/PEAR2/Pyrus/Registry/Pear1/DependencyDB.phpØI  "ö!JØI  Õp∂      *   php/PEAR2/Pyrus/Registry/Pear1/Package.php^  "ö!J^  ‹ƒ∂      !   php/PEAR2/Pyrus/Registry/Sqlite3/    "ö!J        ˇ      ,   php/PEAR2/Pyrus/Registry/Sqlite3/Creator.phplW  "ö!JlW  Nñô∂      ,   php/PEAR2/Pyrus/Registry/Sqlite3/Package.phpû  "ö!Jû  óìU‡∂         php/PEAR2/Pyrus/Registry/Xml/    "ö!J        ˇ      (   php/PEAR2/Pyrus/Registry/Xml/Package.php  "ö!J  U=LŸ∂      !   php/PEAR2/Pyrus/Registry/Base.phpâ  "ö!Jâ  æ˛ãü∂      &   php/PEAR2/Pyrus/Registry/Exception.php›  "ö!J›  Ó}i∂      "   php/PEAR2/Pyrus/Registry/Pear1.php\  "ö!J\  ¡C≤Ë∂      $   php/PEAR2/Pyrus/Registry/Sqlite3.php/˙  "ö!J/˙  $°™$∂          php/PEAR2/Pyrus/Registry/Xml.php2  "ö!J2  Çê*∂         php/PEAR2/Pyrus/REST/    "ö!J        ˇ         php/PEAR2/Pyrus/REST/10.phpäp  "ö!Jäp  Ö.9∂         php/PEAR2/Pyrus/REST/11.php…&  "ö!J…&  ˇaÕ∂         php/PEAR2/Pyrus/REST/13.phpÇ(  "ö!JÇ(  Ü˚D1∂      "   php/PEAR2/Pyrus/REST/Exception.php   "ö!J   «€ÒB∂      &   php/PEAR2/Pyrus/REST/HTTPException.php‹  "ö!J‹  DÑ:∂         php/PEAR2/Pyrus/ScriptFrontend/    "ö!J        ˇ      +   php/PEAR2/Pyrus/ScriptFrontend/Commands.phpñ^  "ö!Jñ^  ç™a∂         php/PEAR2/Pyrus/Task/Exception/    "ö!J        ˇ      .   php/PEAR2/Pyrus/Task/Exception/InvalidTask.php€  "ö!J€  Ãƒñà∂      3   php/PEAR2/Pyrus/Task/Exception/MissingAttribute.php„  "ö!J„  j’È∂      /   php/PEAR2/Pyrus/Task/Exception/NoAttributes.php∞  "ö!J∞  Cı√∂      6   php/PEAR2/Pyrus/Task/Exception/WrongAttributeValue.phpã  "ö!Jã  +s∂      2   php/PEAR2/Pyrus/Task/Postinstallscript/Paramgroup/    "ö!J        ˇ      ;   php/PEAR2/Pyrus/Task/Postinstallscript/Paramgroup/Param.php≥$  "ö!J≥$  Á¿ƒ»∂      5   php/PEAR2/Pyrus/Task/Postinstallscript/Paramgroup.php.9  "ö!J.9  lVPﬁ∂         php/PEAR2/Pyrus/Task/Replace/    "ö!J        ˇ      #   php/PEAR2/Pyrus/Task/Replace/rw.php¯  "ö!J¯  Ä≤∂         php/PEAR2/Pyrus/Task/Unixeol/    "ö!J        ˇ      #   php/PEAR2/Pyrus/Task/Unixeol/rw.php  "ö!J  ƒÙìç∂          php/PEAR2/Pyrus/Task/Windowseol/    "ö!J        ˇ      &   php/PEAR2/Pyrus/Task/Windowseol/rw.php  "ö!J  1Ï⁄∂         php/PEAR2/Pyrus/Task/Common.php  "ö!J  †«%∂      "   php/PEAR2/Pyrus/Task/Exception.phpí  "ö!Jí  ¨XƒØ∂      &   php/PEAR2/Pyrus/Task/MultipleProxy.phph  "ö!Jh  Ùÿ.∂      *   php/PEAR2/Pyrus/Task/Postinstallscript.phpÏG  "ö!JÏG  ìÈú∂          php/PEAR2/Pyrus/Task/Replace.php  "ö!J  {(©∂          php/PEAR2/Pyrus/Task/Unixeol.php7
  "ö!J7
  *pôI∂      #   php/PEAR2/Pyrus/Task/Windowseol.php6
  "ö!J6
  ”IÏ∫∂         php/PEAR2/Pyrus/Validate/    "ö!J        ˇ      &   php/PEAR2/Pyrus/Validate/Exception.phpF  "ö!JF  h6‡B∂         php/PEAR2/Pyrus/Validator/    "ö!J        ˇ      "   php/PEAR2/Pyrus/Validator/PECL.phpk  "ö!Jk  €÷‘†∂         php/PEAR2/Pyrus/XMLParser/    "ö!J        ˇ      '   php/PEAR2/Pyrus/XMLParser/Exception.php›  "ö!J›  J+ñr∂         php/PEAR2/Pyrus/XMLWriter/    "ö!J        ˇ      '   php/PEAR2/Pyrus/XMLWriter/Exception.php›  "ö!J›  ÀÔ<Ö∂      )   php/PEAR2/Pyrus/AtomicFileTransaction.phpçU  "ö!JçU  „õáﬁ∂         php/PEAR2/Pyrus/Channel.php2  "ö!J2  ∫1iü∂         php/PEAR2/Pyrus/ChannelFile.phpí  "ö!Jí  öX±∂      #   php/PEAR2/Pyrus/ChannelRegistry.phpÎ  "ö!JÎ  êq°∂         php/PEAR2/Pyrus/Config.php,™  "ö!J,™  :÷ï∂      !   php/PEAR2/Pyrus/DirectedGraph.phpâ  "ö!Jâ  \U˘∂         php/PEAR2/Pyrus/Exception.php«  "ö!J«  $ΩÙ<∂      $   php/PEAR2/Pyrus/FileTransactions.php$  "ö!J$  ®svÀ∂         php/PEAR2/Pyrus/IChannel.phpF  "ö!JF  AdÕ∂∂          php/PEAR2/Pyrus/IChannelFile.php  "ö!J  Ã+º∑∂      $   php/PEAR2/Pyrus/IChannelRegistry.phpÅ  "ö!JÅ  Y‡.j∂      $   php/PEAR2/Pyrus/IFileTransaction.phpi  "ö!Ji  ((∂         php/PEAR2/Pyrus/ILog.php”  "ö!J”  æ/∂         php/PEAR2/Pyrus/Installer.phpñQ  "ö!JñQ  v˙)m∂         php/PEAR2/Pyrus/IPackage.php‹  "ö!J‹  /∞“Õ∂          php/PEAR2/Pyrus/IPackageFile.php
  "ö!J
  04äˆ∂         php/PEAR2/Pyrus/IRegistry.phpæ  "ö!Jæ  ∏ÿ£–∂         php/PEAR2/Pyrus/Log.phpx  "ö!Jx  ÿ+V8∂         php/PEAR2/Pyrus/OSGuess.phpB+  "ö!JB+  ›…∂Œ∂         php/PEAR2/Pyrus/Package.php∞  "ö!J∞  '˘lÆ∂         php/PEAR2/Pyrus/PackageFile.php¡  "ö!J¡  ∫NV˙∂         php/PEAR2/Pyrus/PECLBuild.php›E  "ö!J›E  æe6|∂      "   php/PEAR2/Pyrus/PluginRegistry.phpÑ  "ö!JÑ  ‚≥ï∂         php/PEAR2/Pyrus/Registry.php "  "ö!J "  ˛äs)∂         php/PEAR2/Pyrus/REST.php+4  "ö!J+4  ⁄“hv∂          php/PEAR2/Pyrus/ScriptRunner.php  "ö!J  <?‹Ò∂         php/PEAR2/Pyrus/test.phpπ  "ö!Jπ  ä¥∂         php/PEAR2/Pyrus/test1.phpî  "ö!Jî  ∂D˚7∂         php/PEAR2/Pyrus/test2.php  "ö!J  qè∂         php/PEAR2/Pyrus/Uninstaller.php«  "ö!J«  &#6w∂         php/PEAR2/Pyrus/Validate.php‚O  "ö!J‚O  d¢B	∂         php/PEAR2/Pyrus/XMLParser.php∂!  "ö!J∂!  ¡êwŸ∂         php/PEAR2/Pyrus/XMLWriter.php⁄#  "ö!J⁄#  
‘{ﬂ∂         php/PEAR2/Pyrus.phpm  "ö!Jm  ^≈¡‚∂         php/data/phartemplate.php>  "ö!J>  Nßà∂         data/phartemplate.php>  "ö!J>  Nßà∂      '   php/PEAR2/Pyrus/Developer/Creator/Phar/    "ö!J        ˇ      5   php/PEAR2/Pyrus/Developer/Creator/Phar/PHPArchive.phpÃ  "ö!JÃ  1≤Ø>∂      /   php/PEAR2/Pyrus/Developer/Creator/Exception.phpN   "ö!JN   ó,Ñ∂      *   php/PEAR2/Pyrus/Developer/Creator/Phar.phpX  "ö!JX  ¯Ö∫∂∂      )   php/PEAR2/Pyrus/Developer/Creator/Tar.php@  "ö!J@  !ˆÅ∂      )   php/PEAR2/Pyrus/Developer/Creator/Xml.phpO  "ö!JO  ïî/∂      )   php/PEAR2/Pyrus/Developer/Creator/Zip.phpÃ  "ö!JÃ  8˘]—∂      /   php/PEAR2/Pyrus/Developer/PackageFile/PEAR2SVN/    "ö!J        ˇ      9   php/PEAR2/Pyrus/Developer/PackageFile/PEAR2SVN/Filter.php˚  "ö!J˚  §¡€G∂      2   php/PEAR2/Pyrus/Developer/PackageFile/PEAR2SVN.php:  "ö!J:  NSB∂      ,   php/PEAR2/Pyrus/Developer/PackageFile/v2.phpÍ  "ö!JÍ  ¥ægÍ∂      <?php
function __autoload($class)
{
    include 'phar://' . PYRUS_PHAR_FILE . '/php/' . implode('/', explode('_', $class)) . '.php';
}
set_include_path('phar://' . PYRUS_PHAR_FILE . '/php/'.PATH_SEPARATOR.get_include_path());
$cli = new PEAR2_SimpleChannelServer_CLI();
$cli->process();
<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://pear.php.net/dtd/package-2.1" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.1" xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0     http://pear.php.net/dtd/tasks-1.0.xsd     http://pear.php.net/dtd/package-2.1     http://pear.php.net/dtd/package-2.1.xsd" packagerversion="2.0.0">
 <name>PEAR2_SimpleChannelServer</name>
 <channel>pear2.php.net</channel>
 <summary>A Simple Channel Server for PEAR2 compatible channels
</summary>
 <description>
This package contains a set of scripts to create a simple PEAR compatible
channel server. Included with the package is the pearscs command which you
can use for the command line to manage a pear channel.

The pearscs utility will be installed in the directory configured by the
bin_dir setting within Pyrus.
</description>
 <lead>
  <name>Gregory Beaver</name>
  <user>cellog</user>
  <email>cellog@php.net</email>
  <active>yes</active>
 </lead>
 <lead>
  <name>Brett Bieber</name>
  <user>saltybeagle</user>
  <email>brett.bieber@gmail.com</email>
  <active>yes</active>
 </lead>
 <date>2009-05-30</date>
 <time>15:41:57</time>
 <version>
  <release>0.1.0</release>
  <api>0.1.0</api>
 </version>
 <stability>
  <release>devel</release>
  <api>alpha</api>
 </stability>
 <license uri="http://www.opensource.org/licenses/bsd-license.php">New BSD License</license>
 <notes>First attempt.
</notes>
 <contents>
  <dir name="/">
   <file role="php" name="php/PEAR2/SimpleChannelServer/REST/Release.php" baseinstalldir="PEAR2"/>
   <file role="php" name="php/PEAR2/SimpleChannelServer/REST/Package.php" baseinstalldir="PEAR2"/>
   <file role="php" name="php/PEAR2/SimpleChannelServer/REST/Manager.php" baseinstalldir="PEAR2"/>
   <file role="php" name="php/PEAR2/SimpleChannelServer/REST/Maintainer.php" baseinstalldir="PEAR2"/>
   <file role="php" name="php/PEAR2/SimpleChannelServer/REST/Category.php" baseinstalldir="PEAR2"/>
   <file role="php" name="php/PEAR2/SimpleChannelServer/Get.php" baseinstalldir="PEAR2"/>
   <file role="php" name="php/PEAR2/SimpleChannelServer/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="php/PEAR2/SimpleChannelServer/CLI.php" baseinstalldir="PEAR2"/>
   <file role="php" name="php/PEAR2/SimpleChannelServer/Channel.php" baseinstalldir="PEAR2"/>
   <file role="php" name="php/PEAR2/SimpleChannelServer/Categories/Exception.php" baseinstalldir="PEAR2"/>
   <file role="php" name="php/PEAR2/SimpleChannelServer/Categories.php" baseinstalldir="PEAR2"/>
   <file role="php" name="php/PEAR2/SimpleChannelServer.php" baseinstalldir="PEAR2"/>
   <file role="script" name="script/pearscs" baseinstalldir="/"/>
   <file role="doc" name="doc/pear2.php.net/PEAR2_SimpleChannelServer/examples/examples/update_channel.php"/>
  </dir>
 </contents>
 <dependencies>
  <required>
   <php>
    <min>5.2.0</min>
   </php>
   <pearinstaller>
    <min>2.0.0a1</min>
   </pearinstaller>
  </required>
 </dependencies>
 <phprelease/>
</package>
<?php
error_reporting(E_ALL | E_NOTICE);
ini_set('display_errors',true);
// Get the autoloader
require __DIR__ . '/../../../autoload.php';

/*
$channel = new PEAR2_SimpleChannelServer('pear2.php.net','/Library/WebServer/Documents/pearserver', null, '/Users/bbieber/pyrus', array('saltybeagle','cellog'));
if (!@unserialize(file_get_contents('/tmp/categories.inf'))) {
      $cat = PEAR2_SimpleChannelServer_Categories::create('Name1',
          'Description 1', 'Alias1')->
          create('Name2', 'Description 2')->
          create('Name3', 'Description 3', 'Alias3')->
          create('Name4', 'Description 4');
      file_put_contents('/tmp/categories.inf', serialize($cat));
}

$categories = PEAR2_SimpleChannelServer_Categories::getCategories();
$categories = $channel->listCategories();
foreach($categories as $category) {
    var_dump($category);
}
*/
$channel = new PEAR2_SimpleChannelServer_Channel('pear2.php.net','Brett Bieber\'s PEAR Channel','salty');

//$scs = new PEAR2_SimpleChannelServer($channel,'/Library/WebServer/Documents/pearserver','/home/bbieber/pyrus/php');
$scs = new PEAR2_SimpleChannelServer($channel,'/home/cellog/testapache/htdocs',PEAR2_Pyrus_Config::current()->path);
$categories = PEAR2_SimpleChannelServer_Categories::create('Default', 'This is the default category');
$scs->saveChannel();
$scs->saveRelease(new PEAR2_Pyrus_Package(dirname(__FILE__) . '/../package.xml'), 'cellog');
echo 'did it'.PHP_EOL;
/*
$manager = new PEAR2_SimpleChannelServer_REST_Manager('/Library/WebServer/Documents/pearserver','pear2.php.net','rest/',array('cellog'));
var_dump($manager->saveRelease(new PEAR2_Pyrus_Package(dirname(__FILE__) . '/../package.xml'),'cellog'));
*/
?>
<?php
class PEAR2_SimpleChannelServer_Categories_Exception extends PEAR2_Exception {}<?php
/**
 * For easy serialization and validation, the category information is
 * designed to be created like:
 * <code>
 * // make sure the class exists prior to unserialize attempt
 * include '/path/to/PEAR2/SimpleChannelServer/Categories.php';
 * if (!@unserialize(file_get_contents('/path/to/serialize/categories.inf'))) {
 *      $cat = PEAR2_SimpleChannelServer_Categories::create('Name1',
 *          'Description 1', 'Alias1')->
 *          create('Name2', 'Description 2')->
 *          create('Name3', 'Description 3', 'Alias3')->
 *          create('Name4', 'Description 4');
 *      file_put_contents('/path/to/serialize/categories.inf', serialize($cat));
 * }
 * $categories = PEAR2_SimpleChannelServer_Categories::getCategories();
 * $categories->link('SimpleChannelServer', 'Developer');
 * </code>
 *
 * @category Developer
 * @package  PEAR2_SimpleChannelServer
 * @author   Greg Beaver <cellog@php.net>
 * @license  New BSD?
 * @link     http://svn.pear.php.net/wsvn/PEARSVN/sandbox/SimpleChannelServer/
 */
class PEAR2_SimpleChannelServer_Categories
{
    /**
     * Category information indexed by category name
     * @var array('Default' => array('desc' => 'Default Category', 'alias' => 'Default'));
     */
    private $_categories = array();
    private $_packages = array();
    /**
     * @var PEAR2_SimpleChannelServer_Categories
     */
    static private $_category;

    /**
     * No direct instantiation allowed
     */
    private function __construct()
    {
    }

    /**
     * Creates a channel category
     *
     * @param string $name        Category name
     * @param string $description Description of the category
     * @param string $alias       Alias of the category
     * 
     * @return PEAR2_SimpleChannelServer_Categories
     */
    static function create($name, $description, $alias = null)
    {
        $chan = new PEAR2_SimpleChannelServer_Categories;
        return $chan->_create($name, $description, $alias);
    }

    private function _create($name, $description, $alias = null)
    {
        if (isset($this->_categories[$name])) {
            throw new PEAR2_SimpleChannelServer_Categories_Exception(
                'Category "' . $name . '" has already been defined');
        }
        if (!$alias) {
            $alias = $name;
        }
        $this->_categories[$name] = array('desc' => $description, 'alias' => $alias);
        $this->_info = false;
        self::$_category = $this;
        $this->_info = $this->getCategories();
        return $this;
    }
    
    /**
     * returns categories which are defined
     *
     * @return array
     */
    static function getCategories()
    {
        if (self::$_category === null) {
            throw new PEAR2_SimpleChannelServer_Categories_Exception('You must construct a singleton instance with PEAR2_SimpleChannelServer_Categories::create($name, $description, $alias = null)');
        } else {
            return self::$_category->_categories;
        }
    }

    /**
     * get the category for a package
     *
     * @param string $package Name of package
     * 
     * @return string
     */
    static function getPackageCategory($package)
    {
        if (self::$_category === null) {
            throw new PEAR2_SimpleChannelServer_Categories_Exception('You must construct a singleton instance with PEAR2_SimpleChannelServer_Categories::create($name, $description, $alias = null)');
        } else {
            return self::$_category->getCategory($package);
        }
    }

    /**
     * link a package to a category
     *
     * @param string $package  name of the package
     * @param string $category name of the category
     * @param bool   $strict   if package is already in a category, throw exception
     * 
     * @return unknown
     */
    static function linkPackageToCategory($package, $category, $strict = false)
    {
        return self::$_category->link($package, $category, $strict);
    }

    /**
     * get the packages in a category
     *
     * @param string $category name of category
     * 
     * @return array
     */
    static function packagesInCategory($category)
    {
        return self::$_category->packages($category);
    }

    /**
     * return all known packages in a specific category
     *
     * @param string $category name of category
     * 
     * @return array(string) Names of packages in the category
     */
    public function packages($category)
    {
        $ret = array();
        foreach ($this->_packages as $p => $c) {
            if ($c === $category) {
                $ret[] = $p;
            }
        }
        return $ret;
    }
    
    /**
     * find what category a package is in - if the category for this package is not
     * defined, it will assign it to the default category
     *
     * @param string $package Name of the package to check
     * 
     * @return string name of the category
     */
    public function getCategory($package)
    {
        if (!isset($this->_packages[$package])) {
            $this->link($package, 'Default');
        }
        return $this->_packages[$package];
    }
    
    /**
     * Links a package to a specific category
     *
     * @param string $package  name of package
     * @param string $category name of category
     * @param bool   $strict   ensure packages are only in one category
     * 
     * @return void
     */
    public function link($package, $category, $strict = false)
    {
        if (isset($this->_packages[$package]) && $strict) {
            throw new PEAR2_SimpleChannelServer_Categories_Exception(
                'Package "' . $package . '" is already linked to category "' .
                $this->_packages[$package] . '"');
        }
        if (!isset($this->_categories[$category])) {
            throw new PEAR2_SimpleChannelServer_Categories_Exception(
                'Unknown category "' . $category . '"');
        }
        $this->_packages[$package] = $category;
    }

    /**
     * called after serialized and woken up
     * 
     * @return void
     */
    function __wakeup()
    {
        self::$_category = $this;
    }
}<?php
/**
 * Channel writer for simple channel server.
 *
 * @category Developer
 * @package  PEAR2_SimpleChannelServer
 * @author   Brett Bieber <brett.bieber@gmail.com>
 * @license  New BSD?
 * @link     http://svn.pear.php.net/wsvn/PEARSVN/sandbox/SimpleChannelServer/
 */
class PEAR2_SimpleChannelServer_Channel extends PEAR2_Pyrus_ChannelFile
{
    
    function __construct($name, $summary, $suggestedalias = null, $restpath = 'rest/')
    {
	parent::__construct('<?xml version="1.0" encoding="UTF-8"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xlink="http://www.w3.org/1999/xlink" xsi:schemaLocation="http://pear.php.net/dtd/channel-1.0 http://pear.php.net/dtd/channel-1.0.xsd">
 <name>pear2.php.net</name>
 <suggestedalias>salty</suggestedalias>
 <summary>Simple PEAR Channel</summary>
 <servers>
  <primary>
   <rest>
    <baseurl type="REST1.0">http://foo/rest/</baseurl>
    <baseurl type="REST1.1">http://foo/rest/</baseurl>
    <baseurl type="REST1.3">http://foo/rest/</baseurl>
   </rest>
  </primary>
 </servers>
</channel>', true);

	$this->name = $name;
	$this->summary = $summary;
        $this->resetREST();
	$this->protocols->rest['REST1.0']->baseurl = 'http://'.$name.'/'.$restpath;
	$this->protocols->rest['REST1.1']->baseurl = 'http://'.$name.'/'.$restpath;
	$this->protocols->rest['REST1.2']->baseurl = 'http://'.$name.'/'.$restpath;
	$this->protocols->rest['REST1.3']->baseurl = 'http://'.$name.'/'.$restpath;
        if ($suggestedalias) {
            $this->suggestedalias = $suggestedalias;
        }
    }
    
    function getChannelFile()
    {
        return $this->__toString();
    }
}
<?php

class PEAR2_SimpleChannelServer_CLI
{
    /**
     * Channel object
     *
     * @var PEAR2_Pyrus_Channel
     */
    protected $channel;
    
    /**
     * Directory to the channel we're managing.
     *
     * @var string
     */
    public $dir;
    
    public $pyruspath = false;
    
    public function __construct()
    {
        $channel_file = getcwd() . '/channel.xml';
        if (file_exists($channel_file)) {
            $this->channel = new PEAR2_Pyrus_Channel(new PEAR2_Pyrus_ChannelFile($channel_file));
        }
        $this->dir = getcwd();
    }
    
    public function process()
    {
        if ($_SERVER['argc'] < 2) {
            $this->printUsage();
            return false;
        }
        switch ($_SERVER['argv'][1]) {
            case 'update':
                $this->handleUpdate();
                break;
            case 'create':
                return $this->handleCreate();
            case 'add-maintainer':
                $scs = new PEAR2_SimpleChannelServer($this->channel,
                    $this->dir);
                    // is this even needed?
                break;
            case 'add-category':
                PEAR2_SimpleChannelServer_Categories::create($category, $description);
                break;
            case 'release':
                $this->handleRelease();
                break;
            default:
                echo 'Please use one of the following commands:'.PHP_EOL;
                $this->printUsage();
                break;
        }
    }
    
    public function handleUpdate()
    {
        if (!isset($_SERVER['argv'][2])) {
            $this->printUpdateUsage();
            return;
        }
        if (!isset($this->channel)) {
            $this->printUpdateUsage();
            return;
        }
        $scs = new PEAR2_SimpleChannelServer($this->channel, $this->dir);
        $dirname = $this->dir . '/get/';
        $dir = new DirectoryIterator($dirname);
        foreach ($dir as $file) {
            if (!$file->isDot()
                && !$file->isDir()
                && substr($file->getFilename(), -3) != 'tar'
                && substr($file->getFilename(), 0, 1) != '.') {
                $scs->saveRelease(new PEAR2_Pyrus_Package($dirname.$file->getFilename()), $_SERVER['argv'][2]);
            }
        }
    }
    
    public function handleRelease()
    {
        if (!isset($_SERVER['argv'][3])) {
            $this->printReleaseUsage();
            return;
        }
        $scs = new PEAR2_SimpleChannelServer($this->channel, $this->dir, $this->pyruspath);
        $scs->saveRelease(new PEAR2_Pyrus_Package($_SERVER['argv'][2]), $_SERVER['argv'][3]);
        echo 'Release successfully saved.'.PHP_EOL;
    }
    
    public function printReleaseUsage()
    {
        echo '
Usage: pearscs release packagefile maintainer
    This will release the package to the channel.
    
    packagefile The release .tgz file.
    maintainer  The channel maintainer performing the release.
    
';
    }
    
    public function handleCreate()
    {
        if ($_SERVER['argc'] < 4) {
            $this->printCreateUsage();
            return false;
        }
        $name        = $_SERVER['argv'][2];
        $summary     = $_SERVER['argv'][3];
        list($alias) = explode('.', $name);
        $file        = getcwd().'/channel.xml';
        if (isset($_SERVER['argv'][4])) {
            $alias = $_SERVER['argv'][4];
        }
        if (isset($_SERVER['argv'][5])) {
            $file = $_SERVER['argv'][5];
        }
        $this->channel = new PEAR2_SimpleChannelServer_Channel($name, $summary, $alias);
        $scs = new PEAR2_SimpleChannelServer($this->channel,
            $this->dir);
        $scs->saveChannel();
        echo '
Created '.$name.'
      | ./channel.xml
      | ./rest/
      | ./get/'.PHP_EOL;
        return true;
    }
    
    public function printCreateUsage()
    {
        echo '
Usage: pearscs create pear.example.com summary [alias] [./channel.xml]
    This will create a file named channel.xml for the pear channel pear.example.com.
    
    summary  This is the a description for the channel.
    alias    Channel alias pear users can use as a shorthand.
    filename Path to where to create the channel.xml file. Current directory will be
             used by default.
    
';
    }
    
    public function printUpdateUsage()
    {
        echo '
Usage: pearscs update maintainer [channel.xml]
    This will update all releases within the /get/ directory.
';
    }
    
    public function printUsage()
    {
        echo '
Usage: pearscs update|create|add-maintainer|add-category|release [option]
    Commands:
        update [channel.xml]                  Update the channel xml files.
        create pear.example.com summary [...] Create a new channel.
        add-maintainer handle                 Add a maintainer.
        add-category category                 Add a category.
        release package.tgz maintainer        Release package.
';
    }
}

?><?php
class PEAR2_SimpleChannelServer_Exception extends PEAR2_Exception {}<?php

class PEAR2_SimpleChannelServer_Get
{
    protected $get;

    protected $pyruspath;

    function __construct($savepath, $pyruspath)
    {
        $this->get = $savepath;
        $this->pyruspath = $pyruspath;
        if (!file_exists($savepath)) {
            if (!@mkdir($savepath, 0777, true)) {
                throw new PEAR2_SimpleChannelServer_Exception('Could not initialize' .
                    'GET storage directory "' . $savepath . '"');
            }
        }
    }

    function saveRelease(PEAR2_Pyrus_Package $new)
    {
        $outfile = $this->get.'/'.$new->name.'-'.$new->version['release'];
        if (!$new->isNewPackage()) {
            // this is a PEAR 1.x package
            $internal = $new->getInternalPackage();
            if ($internal instanceof PEAR2_Pyrus_Package_Tar || $internal instanceof PEAR2_Pyrus_Package_Phar) {
                $path = $internal->getTarballPath();
                $fp = fopen($path, 'rb');
                if (fread($fp, 3) == "\x1f\x8b\x08") {
                    // tgz
                    fclose($fp);
                    copy($path, $outfile . '.tgz');
                    $gp = gzopen($path, 'rb');
                    $fp = fopen($outfile . 'tar', 'wb');
                    stream_copy_to_stream($gp, $fp);
                    fclose($gp);
                    fclose($fp);
                } else {
                    // tar
                    copy($path, $outfile . '.tar');
                    $gp = gzopen($outfile . 'tgz', 'wb');
                    rewind($fp);
                    stream_copy_to_stream($fp, $gp);
                    fclose($gp);
                    fclose($fp);
                }
                return;
            }
        }
        $a = new PEAR2_Pyrus_Package_Creator(array(
                    new PEAR2_Pyrus_Developer_Creator_Phar($outfile.'.tar', false, Phar::TAR, Phar::NONE,
                                                           array(
                                                                 array('tgz', Phar::TAR, Phar::GZ),
                                                                 array('zip', Phar::ZIP, Phar::NONE),
                                                                ))),
                    $this->pyruspath,
                    $this->pyruspath,
                    $this->pyruspath);
        return $a->render($new);
    }

    function deleteRelease(PEAR2_Pyrus_Package $release)
    {

    }
}
<?php
/**
 * Class for managing category information for the PEAR channel.
 *
 * @category Developer
 * @package  PEAR2_SimpleChannelServer
 * @author   Greg Beaver <cellog@php.net>
 * @license  New BSD?
 * @link     http://svn.pear.php.net/wsvn/PEARSVN/sandbox/SimpleChannelServer/
 */
class PEAR2_SimpleChannelServer_REST_Category extends
      PEAR2_SimpleChannelServer_REST_Manager
{
    /**
     * Construct a new rest category object
     * 
     * @param string $savepath   full path to REST files
     * @param string $channel    the channel name
     * @param string $serverpath relative path within URI to REST files
     */
    function __construct($savepath, $channel, $serverpath = 'rest/')
    {
        parent::__construct($savepath, $channel, $serverpath);
    }

    /**
     * Save a package release's REST-related information
     *
     * @param PEAR2_Pyrus_Package $new Package to save category for
     * 
     * @return void
     */
    function save(PEAR2_Pyrus_Package $new)
    {
        $category = PEAR2_SimpleChannelServer_Categories::getPackageCategory($new->name);
        $this->savePackagesInfo($category);
        $this->saveAllCategories();
    }

    /**
     * Delete a package release's REST-related information
     *
     * @param PEAR2_Pyrus_Package $new Package to rease rest info for
     * 
     * @return void
     */
    function erase(PEAR2_Pyrus_Package $new)
    {
        $category = PEAR2_SimpleChannelServer_Categories::getPackageCategory($new->name);
        $this->savePackagesInfo($category);
    }

    /**
     * Save REST xml information for all categories
     * 
     * This is not release-dependent
     * 
     * @return void
     */
    function saveAllCategories()
    {
        $categories     = PEAR2_SimpleChannelServer_Categories::getCategories();
        $xml            = $this->_getProlog('a', 'allcategories');
        $xml['a']['ch'] = $this->channel;
        $xml['a']['c']  = array();
        if (count($categories) == 1) {
            $xml['a']['c'] = array('attribs' =>
                array('xlink:href' =>
                    $this->getCategoryRESTLink(urlencode(key($categories))
                        . '/info.xml')),
                '_content' => key($categories));
                $this->saveInfo(key($categories),
                                $categories[key($categories)]['desc'],
                                $categories[key($categories)]['alias']);
        } else {
            foreach ($categories as $category => $data) {
                $xml['a']['c'] = array(
                    'attribs' => array(
                        'xlink:href' =>
                        $this->getCategoryRESTLink(urlencode($category) . '/info.xml')),
                    '_content' => $category,
                );
                $this->saveInfo($category, $data['desc'], $data['alias']);
            }
        }
        $this->saveCategoryREST('categories.xml', $xml);
    }

    /**
     * Save information on a category
     * 
     * This is not release-dependent
     *
     * @param string $category The name of the category eg:Services
     * @param string $desc     Basic description for the category
     * @param string $alias    Optional alias category name
     * 
     * @return void
     */
    function saveInfo($category, $desc, $alias = false)
    {
        PEAR2_SimpleChannelServer_Categories::create($category, $desc, $alias);
        $xml           = $this->_getProlog('c', 'category');
        $xml['c']['n'] = $category;
        $xml['c']['a'] = $alias ? $category : $alias;
        $xml['c']['c'] = $this->channel;
        $xml['c']['d'] = $desc;
        $this->saveCategoryREST($category . '/info.xml', $xml);
    }

    /**
     * Save packagesinfo.xml for a category
     *
     * @param string $category Category to update packages info for
     * 
     * @return void
     */
    function savePackagesInfo($category)
    {
        $xml  = array();
        $pdir = $this->rest . DIRECTORY_SEPARATOR . 'p';
        $rdir = $this->rest . DIRECTORY_SEPARATOR . 'r';

        $packages = PEAR2_SimpleChannelServer_Categories::packagesInCategory($category);
        $reader   = new PEAR2_Pyrus_XMLParser;
        clearstatcache();
        $xml['pi'] = array();
        foreach ($packages as $package) {
            $next = array();
            if (!file_exists($pdir . DIRECTORY_SEPARATOR . strtolower($package['name']) .
                    DIRECTORY_SEPARATOR . 'info.xml')) {
                continue;
            }
            $f = $reader->parse($pdir . DIRECTORY_SEPARATOR . strtolower($package['name']) .
                    DIRECTORY_SEPARATOR . 'info.xml');
            unset($f['p']['attribs']);
            $next['p'] = $f['p'];
            if (file_exists($rdir . DIRECTORY_SEPARATOR . strtolower($package['name']) .
                    DIRECTORY_SEPARATOR . 'allreleases.xml')) {
                $r = $reader->parse($rdir . DIRECTORY_SEPARATOR .
                        strtolower($package['name']) . DIRECTORY_SEPARATOR .
                        'allreleases.xml');
                unset($r['a']['attribs']);
                unset($r['a']['p']);
                unset($r['a']['c']);
                $next['a'] = $r['a'];
                $dirhandle = opendir($rdir . DIRECTORY_SEPARATOR .
                    strtolower($package['name']));
                while (false !== ($entry = readdir($dirhandle))) {
                    if (strpos($entry, 'deps.') === 0) {
                        $version = str_replace(array('deps.', '.txt'), array('', ''), $entry);
                        
                        $next['deps']      = array();
                        $next['deps']['v'] = $version;
                        $next['deps']['d'] = file_get_contents($rdir . DIRECTORY_SEPARATOR .
                            strtolower($package['name']) . DIRECTORY_SEPARATOR .
                            $entry);
                    }
                }
            }
            $xml['pi'][] = $next;
        }
        $xmlinf        = $this->_getProlog('f', 'categorypackageinfo');
        $xmlinf['f'][] = $xml;
        $this->saveCategoryREST($category . DIRECTORY_SEPARATOR . 'packagesinfo.xml', $xmlinf);
    }
}<?php
/**
 * Class for managing Maintainer files within the SimpleChannelServer.
 *
 * @category Developer
 * @package  PEAR2_SimpleChannelServer
 * @author   Greg Beaver <cellog@php.net>
 * @license  New BSD?
 * @link     http://svn.pear.php.net/wsvn/PEARSVN/sandbox/SimpleChannelServer/
 */
class PEAR2_SimpleChannelServer_REST_Maintainer extends
      PEAR2_SimpleChannelServer_REST_Manager
{
    function save(PEAR2_Pyrus_Package $new)
    {
        foreach ($new->allmaintainers as $role => $maintainers) {
            foreach ($maintainers as $dev) {
                $this->saveInfo($dev->user, $dev->name);
            }
        }
        $this->saveAll();
    }

    /**
     * Save an individual maintainer's REST
     *
     * @param string $handle Maintainer's handle eg: cellog
     * @param string $name   The maintainers real name eg: Gregory Beaver
     * @param string $uri    URI to the person's blog etc.
     */
    function saveInfo($handle, $name, $uri = false)
    {
        $xml = $this->_getProlog('m', 'maintainer');
        $xml['m']['n'] = $handle;
        $xml['m']['h'] = $name;
        if ($uri) {
            $xml['m']['u'] = $uri;
        }
        $this->saveMaintainerREST(strtolower($handle) . '/info.xml', $xml);
    }

    /**
     * Grab information on a maintainer
     *
     * @param string $handle The user's handle eg: cellog
     * 
     * @return array
     */
    function getInfo($handle)
    {
        $path = $this->getRESTPath('m', strtolower($handle) . '/info.xml');
        $reader = new PEAR2_Pyrus_XMLParser;
        if (!file_exists($path)) {
            return false;
        }
        try {
            $info = $reader->parse($path);
            return $info['m'];
        } catch (Exception $e) {
            throw new PEAR2_SimpleChannelServer_Exception('Cannot read information on ' .
                'developer ' . $handle, $e);
        }
    }

    /**
     * Save a list of all maintainers in REST
     */
    function saveAll()
    {
        $xml = $this->_getProlog('m', 'allmaintainers');
        $xml['m']['h'] = array();
        foreach (new DirectoryIterator($this->rest . 'm') as $file) {
            if ($file->isDot()) continue;
            if ($file->isDir()) {
                $xml['m']['h'][] = array(
                    'attribs' => array(
                        'xlink:href' => $this->uri . 'm/' . $file
                    ),
                    '_content' => $file->__toString()
                );
            }
        }
        $this->saveMaintainerREST('allmaintainers.xml', $xml);
    }
}<?php
/**
 * Base class for managing a REST based PEAR compatible channel server.
 *
 * @category Developer
 * @package  PEAR2_SimpleChannelServer
 * @author   Greg Beaver <cellog@php.net>
 * @license  New BSD?
 * @link     http://svn.pear.php.net/wsvn/PEARSVN/sandbox/SimpleChannelServer/
 */
class PEAR2_SimpleChannelServer_REST_Manager
{
    /**
     * Full path on the filesystem to the REST files
     *
     * @var string
     */
    protected $rest;
    /**
     * Relative path to REST files for URI link construction
     *
     * @var string
     */
    protected $uri;
    /**
     * Channel name this REST server applies to
     *
     * @var string
     */
    protected $chan;

    /**
     * @param string $savepath   full path to REST files
     * @param string $channel    the channel name
     * @param string $serverpath relative path within URI to REST files
     * @param array  $admins     an array of handles that are channel administrators
     *                           and can release/delete any package
     */
    function __construct($savepath, $channel, $serverpath = 'rest/')
    {
        $this->rest = $savepath;
        if (!file_exists($savepath)) {
            if (!@mkdir($savepath, 0777, true)) {
                throw new PEAR2_SimpleChannelServer_Exception('Could not initialize' .
                    'REST storage directory "' . $savepath . '"');
            }
        }
        $this->uri     = $serverpath;
        $this->chan    = $channel;
    }

    /**
     * Save release REST for a new package release.
     * 
     * Prior to calling this, categories and category package links
     * should be set up, otherwise the package will be released under
     * the "Default" category. 
     *
     * @param PEAR2_Pyrus_Package $release
     * @param string              $releaser handle of person who is uploading this release
     */
    function saveRelease(PEAR2_Pyrus_Package $new, $releaser)
    {
        if ($new->channel !== $this->chan) {
            throw new PEAR2_SimpleChannelServer_Exception('Cannot release ' .
                $new->name . '-' . $new->version['release'] . ', we are managing ' .
                $this->chan . ' channel, and package is in ' .
                $new->channel . ' channel');
        }
        if (!isset($new->maintainer[$releaser]) ||
            $new->maintainer[$releaser]->role !== 'lead') {
            throw new PEAR2_SimpleChannelServer_Exception($releaser . ' is not a ' .
                'lead maintainer of this package, and cannot release');
        }
        $category = new PEAR2_SimpleChannelServer_REST_Category($this->rest, $this->chan,
            $this->uri);
        $package = new PEAR2_SimpleChannelServer_REST_Package($this->rest, $this->chan,
            $this->uri);
        $maintainer = new PEAR2_SimpleChannelServer_REST_Maintainer($this->rest, $this->chan,
            $this->uri);
        $release = new PEAR2_SimpleChannelServer_REST_Release($this->rest, $this->chan,
            $this->uri);
        $maintainer->save($new);
        $package->save($new);
        $release->save($new, $releaser);
        $category->save($new);
    }

    /**
     * Remove a release from package REST
     * 
     * Removes REST.  If $deleteorphaned is true, then
     * maintainers who no longer maintain a package will be
     * deleted from package maintainer REST.
     * @param PEAR2_Pyrus_Package $release
     * @param string $deleter handle of maintainer deleting this release
     * @param bool $deleteorphaned
     */
    function deleteRelease(PEAR2_Pyrus_Package $release, $deleter, $deleteorphaned = true)
    {
        if ($new->channel !== $this->chan) {
            throw new PEAR2_SimpleChannelServer_Exception('Cannot delete release ' .
                $new->name . '-' . $new->version['release'] . ', we are managing ' .
                $this->chan . ' channel, and package is in ' .
                $new->channel . ' channel');
        }
        if (!isset($this->_admins[$releaser]) && (!isset($new->maintainer[$releaser]) ||
              $new->maintainer[$releaser]->role !== 'lead')) {
            throw new PEAR2_SimpleChannelServer_Exception($releaser . ' is not a ' .
                'lead maintainer of this package, and cannot delete the release');
        }
        $category = new PEAR2_SimpleChannelServer_REST_Category($this->rest, $this->chan,
            $this->uri);
        $package = new PEAR2_SimpleChannelServer_REST_Package($this->rest, $this->chan,
            $this->uri);
        $maintainer = new PEAR2_SimpleChannelServer_REST_Maintainer($this->rest, $this->chan,
            $this->uri);
        $release = new PEAR2_SimpleChannelServer_REST_Release($this->rest, $this->chan,
            $this->uri);
        $maintainer->erase($new, $deleteorphaned);
        $package->erase($new);
        $release->erase($new);
        $category->erase($new);
    }

    function __get($var)
    {
        if ($var == 'path') {
            return $this->uri;
        }
        if ($var == 'channel') {
            return $this->chan;
        }
    }

    protected function _getProlog($basetag, $schema)
    {
        return array($basetag => array(
                'attribs' =>
                    array(
                        'xmlns' => 'http://pear.php.net/dtd/rest.' . $schema,
                        'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
                        'xmlns:xlink' => 'http://www.w3.org/1999/xlink',
                        'xsi:schemaLocation' => 'http://pear.php.net/dtd/rest.' .
                            $schema . ' http://pear.php.net/dtd/rest.' .
                            $schema . '.xsd',
                    ),
            ));
    }

    function getCategoryRESTLink($file)
    {
        return $this->uri . 'c/' . $file;
    }

    function getPackageRESTLink($file)
    {
        return $this->uri . 'p/' . $file;
    }

    function getReleaseRESTLink($file)
    {
        return $this->uri . 'r/' . $file;
    }

    function getMaintainerRESTLink($file)
    {
        return $this->uri . 'm/' . $file;
    }

    function getRESTPath($type, $file)
    {
        return $this->rest . DIRECTORY_SEPARATOR . $type . DIRECTORY_SEPARATOR .
            $file;
    }

    private function _initDir($dir, $dirname = false)
    {
        if (!$dirname) $dir = dirname($dir);
        if (!file_exists($dir)) {
            if (!@mkdir($dir, 0777, true)) {
                throw new PEAR2_SimpleChannelServer_Exception('Could not initialize' .
                    'REST category storage directory "' . $dir . '"');
            }
        }
    }

    private function _saveREST($path, $contents, $isxml, $type)
    {
        $this->_initDir($this->rest . '/' . $type . '/' . $path);
        if ($isxml) {
            $contents = (string) new PEAR2_Pyrus_XMLWriter($contents);
        }
        file_put_contents($this->rest . '/' . $type . '/' . $path, $contents);
        chmod($this->rest . '/' . $type . '/' . $path, 0666);
    }

    function saveReleaseREST($path, $contents, $isxml = true)
    {
        $this->_saveREST($path, $contents, $isxml, 'r');
    }

    function saveCategoryREST($path, $contents, $isxml = true)
    {
        $this->_saveREST($path, $contents, $isxml, 'c');
    }

    function savePackageREST($path, $contents, $isxml = true)
    {
        $this->_saveREST($path, $contents, $isxml, 'p');
    }

    function saveMaintainerREST($path, $contents, $isxml = true)
    {
        $this->_saveREST($path, $contents, $isxml, 'm');
    }
}<?php
/**
 * Package REST management class.
 *
 * This class should be serialized and re-loaded with each request in order to 
 * retain the list of packages in the channel
 *
 * @category Developer
 * @package  PEAR2_SimpleChannelServer
 * @author   Greg Beaver <cellog@php.net>
 * @license  New BSD?
 * @link     http://svn.pear.php.net/wsvn/PEARSVN/sandbox/SimpleChannelServer/
 */
class PEAR2_SimpleChannelServer_REST_Package extends
      PEAR2_SimpleChannelServer_REST_Manager
{
    private $_packages = array();

    /**
     * Save package REST based on a release
     *
     * @param PEAR2_Pyrus_package $new
     */
    function save(PEAR2_Pyrus_Package $new)
    {
        $this->_packages[$new->name] = true;
        $this->saveInfo($new);
        $this->saveAllPackages();
        $this->saveMaintainers($new);
    }

    /**
     * Remove package REST based on a release
     *
     * This does nothing
     * @param PEAR2_Pyrus_package $new
     */
    function erase(PEAR2_Pyrus_Package $new)
    {
    }

    /**
     * Mark a package as deprecated in favor of another package
     *
     * @param string $name
     * @param string $newpackage
     * @param string $newchannel
     */
    function deprecatePackage($name, $newpackage, $newchannel)
    {
        if (file_exists($this->rest . DIRECTORY_SEPARATOR . 'p' . DIRECTORY_SEPARATOR .
              strtolower($name) . DIRECTORY_SEPARATOR . 'info.xml')) {
            $oldinfo = $reader->parse($this->rest . DIRECTORY_SEPARATOR . 'p' .
                DIRECTORY_SEPARATOR . 'info.xml');
        }
        $oldinfo['p']['dc'] = $newchannel;
        $oldinfo['p']['dp'] = $newpackage;
        $this->savePackageREST(strtolower($name) . DIRECTORY_SEPARATOR . 'info.xml',
            $oldinfo);
    }

    /**
     * Remove a package from the REST list
     * 
     * @param unknown_type $name
     */
    function deletePackage($name)
    {
        unset($this->_packages[$name]);
        @unlink($this->rest . DIRECTORY_SEPARATOR . 'p' .
            DIRECTORY_SEPARATOR . 'info.xml');
        $this->saveAllPackages();
    }

    /**
     * Save package REST based on a release
     * 
     * @param PEAR2_Pyrus_Package $new
     */
    function saveInfo(PEAR2_Pyrus_Package $new)
    {
        $reader = new PEAR2_Pyrus_XMLParser;
        $deprecated = false;
        if (file_exists($this->rest . DIRECTORY_SEPARATOR . 'p' . DIRECTORY_SEPARATOR .
              'info.xml')) {
            $oldinfo = $reader->parse($this->rest . DIRECTORY_SEPARATOR . 'p' .
                DIRECTORY_SEPARATOR . 'info.xml');
            if (isset($oldinfo['p']['dp'])) {
                $deprecated = array('dp' => $oldinfo['p']['dp'], 'dc' => $oldinfo['p']['dc']);
            }
        }
        $xml = array();
        $xml['n'] = $new->name;
        $xml['c'] = $this->channel;
        try {
            $category = PEAR2_SimpleChannelServer_Categories::getPackageCategory($new->name);
        } catch (PEAR2_SimpleChannelServer_Categories_Exception $e) {
            $categories = PEAR2_SimpleChannelServer_Categories::create('Default', 'This is the default category');
            $categories->linkPackageToCategory($new->name,'Default');
            $category = PEAR2_SimpleChannelServer_Categories::getPackageCategory($new->name);
        }
        $xml['ca'] = array(
            'attribs' => array('xlink:href' => $this->getCategoryRESTLink($category)),
            '_content' => $category,
            );
        $xml['l'] = $new->license['name'];
        $xml['s'] = $new->summary;
        $xml['d'] = $new->description;
        $xml['r'] = array('attribs' => 
            $this->getReleaseRESTLink(strtolower($new->name)));
        if ($a = $new->extends) {
            $xml['pa'] = array('attribs' =>
                array('xlink:href' => $this->getPackageRESTLink(strtolower($a) . '/info.xml')),
                '_content' => $a);
        }
        $xmlinf = $this->_getProlog('p', 'package');
        $xml['attribs'] = $xmlinf['p']['attribs'];
        $xml = array('p' => $xml);
        $this->savePackageREST(strtolower($new->name) . '/info.xml', $xml);
    }

    /**
     * Save a list of all packages in REST
     *
     * This is not release dependent.
     */
    function saveAllPackages()
    {
        $xml = $this->_getProlog('a', 'allpackages');
        $xml['a']['p'] = array();
        foreach (new DirectoryIterator($this->rest . 'p') as $file) {
            if ($file->isDot()) continue;
            $a = (string) $file;
            if ($file->isDir() && $a[0] != '.') {
                $xml['a']['p'][] = $a;
            }
        }
        usort($xml['a']['p'], 'strnatcmp');
        $this->savePackageREST('packages.xml', $xml);
    }

    /**
     * Save package maintainers information for this release
     *
     * @param PEAR2_Pyrus_Package $new package to be saved
     *
     * @return void
     */
    function saveMaintainers(PEAR2_Pyrus_Package $new)
    {
        $m  = $this->_getProlog('m', 'packagemaintainers');
        $m2 = $this->_getProlog('m', 'packagemaintainers2');

        $m['m']['p'] = $m2['m']['p'] = $new->name;
        $m['m']['c'] = $m2['m']['c'] = $this->chan;
        $m['m']['m'] = $m2['m']['m'] = array();

        foreach ($new->allmaintainers as $role => $maintainers) {
            if (!$maintainers) continue;
            foreach ($maintainers as $dev) {
                $m['m']['m'][]  = array('h' => $dev->user, 'a' => $dev->active);
                $m2['m']['m'][] = array(
                    'h' => $dev->user,
                    'a' => $dev->active,
                    'r' => $role
                );
            }
        }
        $this->savePackageREST(strtolower($new->name) . '/maintainers.xml',
            $m);
        $this->savePackageREST(strtolower($new->name) . '/maintainers2.xml',
            $m2);
    }
}<?php
/**
 * Package release management within the SimpleChannelServer.
 *
 * @category Developer
 * @package  PEAR2_SimpleChannelServer
 * @author   Greg Beaver <cellog@php.net>
 * @license  New BSD?
 * @link     http://svn.pear.php.net/wsvn/PEARSVN/sandbox/SimpleChannelServer/
 */
class PEAR2_SimpleChannelServer_REST_Release extends
      PEAR2_SimpleChannelServer_REST_Manager
{
    /**
     * Save a package release's REST information
     *
     * @param PEAR2_Pyrus_Package $new      new package to be released
     * @param string              $releaser handle of the maintainer who released this package
     *
     * @return void
     */
    function save(PEAR2_Pyrus_Package $new, $releaser)
    {
        $this->saveInfo($new, $releaser);
        $this->saveInfo2($new, $releaser);
        $this->saveAll($new);
        $this->saveAll2($new);
        $this->saveStability($new);
        $this->savePackageDeps($new);
        $this->savePackageXml($new);
    }

    /**
     * Delete a release from REST information
     *
     * @param PEAR2_Pyrus_Package $new Package to be erased
     *
     * @return void
     */
    function erase(PEAR2_Pyrus_Package $new)
    {
        $this->saveAll($new, true);
        $xml = $this->saveAll2($new, true);
        if (!count($xml['a']['r'])) return;
        // reconstruct stability stuff
        foreach ($xml['a']['r'] as $release) {
            if (!isset($latest)) {
                $latest = $release['v'];
            }
            if ($release['s'] == 'stable' && !isset($stable)) {
                $stable = $release['v'];
            }
            if ($release['s'] == 'beta' && !isset($beta)) {
                $beta = $release['v'];
            }
            if ($release['s'] == 'alpha' && !isset($alpha)) {
                $alpha = $release['v'];
            }
        }
        $this->saveReleaseREST(strtolower($new->name) . '/latest.txt', $latest, false);
        if (isset($stable)) {
            $this->saveReleaseREST(strtolower($new->name) . '/stable.txt', $stable, false);
        }
        if (isset($beta)) {
            $this->saveReleaseREST(strtolower($new->name) . '/beta.txt', $beta, false);
        }
        if (isset($alpha)) {
            $this->saveReleaseREST(strtolower($new->name) . '/alpha.txt', $alpha, false);
        }
    }

    /**
     * save rest.release release REST
     *
     * @param PEAR2_Pyrus_Package $new      package to save info for
     * @param string              $releaser releasing maintainer's handle
     *
     * @return void
     */
    function saveInfo(PEAR2_Pyrus_Package $new, $releaser)
    {
        $xml            = $this->_getProlog('r', 'release');
        $xml['r']['p']  = array(
                'attribs' => array(
                'xlink:href' =>
                $this->getPackageRESTLink(strtolower($new->name))
            ),
            '_content' => $new->name);
        $xml['r']['c']  = $this->channel;
        $category       = PEAR2_SimpleChannelServer_Categories::getPackageCategory($new->name);
        $xml['r']['v']  = $new->version['release'];
        $xml['r']['st'] = $new->stability['release'];
        $xml['r']['l']  = $new->license['name'];
        $xml['r']['m']  = $releaser;
        $xml['r']['s']  = $new->summary;
        $xml['r']['d']  = $new->description;
        $xml['r']['da'] = $new->date. ' ' . $new->time;
        $xml['r']['n']  = $new->notes;
        $xml['r']['f']  = filesize($new->archivefile);
        $xml['r']['g']  = 'http://' . $this->channel . '/get/' . $new->name .
            '-' . $new->version['release'];
        $xml['r']['x']  = array('attribs' => array(
            'xlink:href' => 'package.' . $new->version['release'] . '.xml'
        ));
        $this->saveReleaseREST(strtolower($new->name) . '/' .
            $new->version['release'] . '.xml', $xml);
    }

    /**
     * save rest.release2 release REST
     *
     * @param PEAR2_Pyrus_Package $new      package to be saved
     * @param string              $releaser releasing maintainer's handle
     *
     * @return void
     */
    function saveInfo2(PEAR2_Pyrus_Package $new, $releaser)
    {
        $xml            = $this->_getProlog('r', 'release2');
        $xml['r']['p']  = array(
                'attribs' => array(
                'xlink:href' =>
                $this->getPackageRESTLink(strtolower($new->name))
            ),
            '_content' => $new->name);
        $xml['r']['c']  = $this->channel;
        $category       = PEAR2_SimpleChannelServer_Categories::getPackageCategory($new->name);
        $xml['r']['v']  = $new->version['release'];
        $xml['r']['a']  = $new->version['api'];
        $xml['r']['mp'] = $new->dependencies['required']->php->min;
        $xml['r']['st'] = $new->stability['release'];
        $xml['r']['l']  = $new->license['name'];
        $xml['r']['m']  = $releaser;
        $xml['r']['s']  = $new->summary;
        $xml['r']['d']  = $new->description;
        $xml['r']['da'] = $new->date . ' ' . $new->time;
        $xml['r']['n']  = $new->notes;
        $xml['r']['f']  = filesize($new->archivefile);
        $xml['r']['g']  = 'http://' . $this->channel . '/get/' . $new->name .
            '-' . $new->version['release'];
        $xml['r']['x']  = array('attribs' => array(
            'xlink:href' => 'package.' . $new->version['release'] . '.xml'
        ));
        $this->saveReleaseREST(strtolower($new->name) . '/v2.' .
            $new->version['release'] . '.xml', $xml);
    }

    /**
     * Save a release's package.xml contents
     *
     * @param PEAR2_Pyrus_Package $new package to be saved
     *
     * @return void
     */
    function savePackageXml(PEAR2_Pyrus_Package $new)
    {
        $this->saveReleaseREST(strtolower($new->name) . '/package.' .
            $new->version['release'] . '.xml', file_get_contents($new->packagefile),
            false);
    }

    /**
     * Save a serialized representation of a package's dependencies
     *
     * @param PEAR2_Pyrus_Package $new package to be saved
     *
     * @return void
     */
    function savePackageDeps(PEAR2_Pyrus_Package $new)
    {
        $this->saveReleaseREST(strtolower($new->name) . '/deps.' .
            $new->version['release'] . '.txt', serialize($new->rawdeps),
            false);
    }

    /**
     * save REST information for all releases of this package
     *
     * @param PEAR2_Pyrus_Package $new   package to save all release info for
     * @param bool                $erase if true, the release represented by the
     *                                   version of $new will be removed.
     *
     * @return void
     */
    function saveAll(PEAR2_Pyrus_Package $new, $erase = false, $is2 = false)
    {
        if ($is2) {
            $is2 = '2';
        } else {
            $is2 = '';
        }
        $reader = new PEAR2_Pyrus_XMLParser;
        $path   = $this->getRESTPath('r', strtolower($new->name) .
            DIRECTORY_SEPARATOR . 'allreleases' . $is2 . '.xml');
        if (file_exists($path)) {
            $xml = $reader->parse($path);
            if (isset($xml['a']['r']) && !isset($xml['a']['r'][0])) {
                $xml['a']['r'] = array($xml['a']['r']);
            }
        } else {
            $xml           = $this->_getProlog('a', 'allreleases' . $is2);
            $xml['a']['p'] = $new->name;
            $xml['a']['c'] = $this->chan;
            $xml['a']['r'] = array();
        }
        if ($erase) {
            foreach ($xml['a']['r'] as $i => $release) {
                if ($release['v'] === $new->version['release']) {
                    unset($xml['a']['r'][$i]);
                    $xml['a']['r'] = array_values($xml['a']['r']);
                    break;
                }
            }
            if (!count($xml['a']['r'])) {
                // no releases, erase all traces
                foreach (new DirectoryIterator($this->getRESTPath('r',
                         strtolower($new->name))) as $name => $info) {
                    if ($info->isDot()) continue;
                    unlink($name);
                }
            }
        } else {
            $info = array(
                'v' => $new->version['release'],
                's' => $new->stability['release'],
            );
            if ($is2) {
                $info['m'] = $new->dependencies['required']->php->min;
            }
            if (count($new->compatible)) {
                $info['co'] = array();
                foreach ($new->compatible as $package=>$cinfo) {
                    if (strpos($package, '/')) {
                        $c = substr($package, 0, strpos($package, '/'));
                        $package = str_replace(array($c, '/'), '', $package);
                    } else {
                        $c = 'pear.php.net';
                    }
                    unset($cinfo['channel']);
                    unset($cinfo['package']);
                    if (isset($cinfo['exclude'])) {
                        $info['x'] = $cinfo['exclude'];
                        unset($cinfo['exclude']);
                    }

                    $info['co'][] = array_merge(array('c' => $c, 'p' => $package), $cinfo);
                }
            }
            $test = $xml['a']['r'];
            if (count($test) && !isset($test[0])) {
                if ($test['v'] != $info['v']) {
                    $test = array($info, $test);
                }
            } else {
                $found = false;
                foreach ($test as $i => $rel) {
                    if ($rel['v'] == $info['v']) {
                        $found = true;
                        $test[$i] = $info;
                        break;
                    }
                }
                if (!$found) {
                    array_unshift($test, $info);
                }
            }
            if (count($test) == 1) {
                $test = $test[0];
            }
            $xml['a']['r'] = $test;
        }
        $this->saveReleaseREST(strtolower($new->name) . '/allreleases' . $is2 . '.xml', $xml);
        return $xml;
    }

    /**
     * save REST information for all releases (version 2) of this package
     *
     * @param PEAR2_Pyrus_Package $new   package to save all releases for
     * @param bool                $erase if true, the release represented by the
     *                                   version of $new will be removed.
     *
     * @return void
     */
    function saveAll2(PEAR2_Pyrus_Package $new, $erase = false)
    {
        return $this->saveAll($new, $erase, true);
    }

    /**
     * save REST stability version info in .txt files
     *
     * @param PEAR2_Pyrus_Package $new package to save stability for
     *
     * @return void
     */
    function saveStability(PEAR2_Pyrus_Package $new)
    {
        $this->saveReleaseREST(strtolower($new->name) . '/latest.txt',
            $new->version['release'], false);
        $this->saveReleaseREST(strtolower($new->name) . '/' . $new->state . '.txt',
            $new->version['release'], false);
    }
}
<?php
/**
 * Class for a filesystem only PEAR compatible channel server.
 *
 * @category Developer
 * @package  PEAR2_SimpleChannelServer
 * @author   Greg Beaver <cellog@php.net>
 * @license  New BSD?
 * @link     http://svn.pear.php.net/wsvn/PEARSVN/sandbox/SimpleChannelServer/
 */
class PEAR2_SimpleChannelServer
{
    /**
     * @var string
     */
    protected $channel;
    /**
     * @var string
     */
    protected $webpath;
    /**
     * @var string
     */
    protected $uri;
    /**
     * REST manager
     *
     * @var PEAR2_SimpleChannelServer_REST_Manager
     */
    protected $rest;

    /**
     * GET manager
     *
     * @var PEAR2_SimpleChannelServer_Get
     */
    protected $get;

    /**
     * Construct simple channel server
     *
     * @param PEAR2_SimpleChannelServer_Channel $channel   channel object
     * @param string $webpath   full path to web files eg: /var/www/pear/
     * @param string $pyruspath Path to the pyrus controlled PEAR installation
     */
    function __construct(PEAR2_Pyrus_Channel $channel, $webpath, $pyruspath = null)
    {
        if (!realpath($webpath) || !is_writable($webpath)) {
            throw new PEAR2_SimpleChannelServer_Exception('Path to channel web files ' .
                $webpath .
                ' must exist and be writable');
        } else {
            $this->webpath = $webpath;
        }
        if (!$pyruspath) {
        	$pyruspath = __DIR__;
        }
        $rest = $channel->protocols->rest;
        foreach ($rest as $restpath) {
            $restpath = str_replace('http://'.$channel->name.'/', '', $restpath);
            break;
        }
        if (dirname($restpath . 'a') . '/' !== $restpath) {
            $restpath .= '/';
        }
        $this->uri     = 'http://' . $channel->name . '/';
        $this->channel = $channel;
        $this->rest    = new PEAR2_SimpleChannelServer_REST_Manager($webpath.'/'.$restpath, $channel->name,
            $restpath);
        $this->get     = new PEAR2_SimpleChannelServer_Get($webpath.'/get', $pyruspath);
        try {
            $a = PEAR2_Pyrus_Config::singleton($pyruspath);
        } catch (Exception $e) {
            throw new PEAR2_SimpleChannelServer_Exception('Cannot initialize Pyrus Config',
                $e);
        }
    }

    function saveRelease(PEAR2_Pyrus_Package $package, $releaser)
    {
        $rest = $this->rest->saveRelease($package, $releaser);
        $get  = $this->get->saveRelease($package);
        return $rest && $get;
    }

    function saveChannel()
    {
        file_put_contents($this->webpath . '/channel.xml', $this->channel->getChannelFile());
        chmod($this->webpath . '/channel.xml', 0666);
    }

    /**
     * List all categories (unsorted)
     *
     * @return array
     */
    function listCategories()
    {
        return PEAR2_SimpleChannelServer_Categories::getCategories();
    }

    /**
     * List all packages, organized by category (unsorted)
     *
     * @return array
     */
    function listPackagesByCategory()
    {
        $ret = array();
        foreach (PEAR2_SimpleChannelServer_Categories::getCategories() as $cat) {
            $ret[$cat] = PEAR2_SimpleChannelServer_Categories::packagesInCategory($cat);
        }
        return $ret;
    }

    /**
     * List all packages, or all packages in a category
     *
     * @param string|null $category null to list all packages
     *
     * @return array
     */
    function listPackages($category = null)
    {
        if ($category) {
            return PEAR2_SimpleChannelServer_Categories::packagesInCategory($category);
        }
        if (!file_exists($this->rest->getRESTPath('p', 'allpackages.xml'))) {
            return array();
        }
        try {
            $list = $reader->parse($this->rest->getRESTPath('p', 'allpackages.xml'));
        } catch (Exception $e) {
            throw new PEAR2_SimpleChannelServer_Exception('Unable to list packages',
                $e);
        }
        return $list['a']['p'];
    }

    /**
     * List all maintainers, or maintainers of a specific package
     *
     * @param string|null $package null to list all maintainers
     *
     * @return array
     */
    function listMaintainers($package = null)
    {
        if ($package === null) {
            if (!file_exists($this->rest->getRESTPath('p', 'allpackages.xml'))) {
                return array();
            }
            try {
                $list  = $reader->parse($this->rest->getRESTPath('m', 'allmaintainers.xml'));
                $maint = new PEAR2_SimpleChannelServer_REST_Maintainer($this->webpath,
                    $this->channel, $this->uri);
                $ret   = array();
                foreach ($list['m']['h'] as $info) {
                    $inf = $maint->getInfo($info['_content']);
                    if (!$inf) {
                        throw new PEAR2_SimpleChannelServer_Exception('Maintainer ' .
                            $info['_content'] . ' is listed as a maintainer, ' .
                            'but does not have an info file');
                    }
                    $ret[] = array(
                        'user' => $info['_content'],
                        'name' => $inf['n']
                    );
                }
                return $ret;
            } catch (Exception $e) {
                throw new PEAR2_SimpleChannelServer_Exception('Unable to list maintainers',
                    $e);
            }
        }
        $reader = new PEAR2_Pyrus_XMLParser;
        $path   = $this->rest->getRESTPath('r', strtolower($package) . '/maintainers2.xml');
        if (!file_exists($path)) {
            return array();
        }
        try {
            $list = $reader->parse($path);
        } catch (Exception $e) {
            throw new PEAR2_SimpleChannelServer_Exception('Unable to list maintainers for' .
                ' package ' . $package,
                $e);
        }
        $ret = array();
        if (!isset($list['m']['m'][0])) {
            $list['m']['m'] = array($list['m']['m']);
        }
        $maint = new PEAR2_SimpleChannelServer_REST_Maintainer($this->webpath, $this->channel,
            $this->uri);
        foreach ($list['m']['m'] as $maintainer) {
            $info = $maint->getInfo($maintainer['h']);
            $inf  = array(
                'user' => $maintainer['h'],
            );
            if ($info) {
                $inf['name'] = $info['n'];
            }
            $inf['active'] = $maintainer['a'];
            $ret[]         = $inf;
        }
        return $ret;
    }

    /**
     * List release info with dependencies formatted for easy processing
     * by a web frontend.
     *
     * @param string $package Package name eg: PEAR2_SimpleChannelServer
     *
     * @return array
     */
    function listReleases($package)
    {
        $path = $this->rest->getRESTPath('r', strtolower($package) . '/allreleases2.xml');
        if (!file_exists($path)) {
            return array();
        }
        try {
            $list = $reader->parse($path);
        } catch (Exception $e) {
            throw new PEAR2_SimpleChannelServer_Exception('Unable to list releases of ' .
                $package . ' package',
                $e);
        }
        if (!isset($list['a']['r'][0])) {
            $list['a']['r'] = array($list['a']['r']);
        }
        $ret = array();
        foreach ($list['a']['r'] as $info) {
            $inf = array(
                'version' => $info['v'],
                'stability' => $info['s'],
                'minimum PHP version' => $info['m']
            );

            $deps = unserialize(file_get_contents($this->rest->getPath('r',
                strtolower($package) . '/deps.' . $info['v'] . '.txt')));

            $inf['required'] = array();
            if (isset($deps['required']['package'])) {
                $inf['required']['package'] = $deps['required']['package'];
                if (!isset($inf['required']['package'][0])) {
                    $inf['required']['package'] = array($inf['required']['package']);
                }
            }
            if (isset($deps['required']['subpackage'])) {
                if (!isset($deps['required']['subpackage'][0])) {
                    $deps['required']['subpackage'] = array($deps['required']['subpackage']);
                }
                foreach ($deps['required']['subpackage'] as $s) {
                    $inf['required']['package'][] = $s;
                }
            }
            if (isset($deps['required']['extension'])) {
                if (!isset($deps['required']['extension'][0])) {
                    $deps['required']['extension'] = array($deps['required']['extension']);
                }
                foreach ($deps['required']['extension'] as $s) {
                    $inf['required']['extension'][] = $s;
                }
            }
            if (isset($deps['optional']['package'])) {
                $inf['optional']            = array();
                $inf['optional']['package'] = $deps['optional']['package'];
                if (!isset($inf['optional']['package'][0])) {
                    $inf['optional']['package'] = array($inf['optional']['package']);
                }
            }
            if (isset($deps['optional']['extension'])) {
                if (!isset($deps['optional']['extension'][0])) {
                    $deps['optional']['extension'] = array($deps['optional']['extension']);
                }
                foreach ($deps['optional']['extension'] as $s) {
                    $inf['optional']['extension'][] = $s;
                }
            }
            if (isset($deps['optional']['subpackage'])) {
                if (!isset($deps['optional']['subpackage'][0])) {
                    $deps['optional']['subpackage'] = array($deps['optional']['subpackage']);
                }
                foreach ($deps['optional']['subpackage'] as $s) {
                    $inf['optional']['package'][] = $s;
                }
            }
            if (isset($deps['group'])) {
                $inf['groups'] = array();
                if (!isset($deps['group'][0])) {
                    $deps['group'] = array($deps['group']);
                }
                foreach ($deps['group'] as $group) {
                    $inf['groups'] = $group['attribs'];
                }
            }
            $ret[] = $inf;
        }
        return $ret;
    }
}
#!/usr/bin/php
<?php
if (file_exists(dirname(__FILE__).'/../../../autoload.php')) {
    $autoload =  dirname(__FILE__).'/../../../autoload.php';
} else {
    $autoload = '@php_dir@/PEAR2/Autoload.php';
}

require_once $autoload;

$cli = new PEAR2_SimpleChannelServer_CLI();
$cli->process();
<?php
function PEAR2_Autoload($class)
{
    if (substr($class, 0, 6) !== 'PEAR2_') {
        return false;
    }
    $fp = @fopen(str_replace('_', '/', $class) . '.php', 'r', true);
    if ($fp) {
        fclose($fp);
        require str_replace('_', '/', $class) . '.php';
        if (!class_exists($class, false) && !interface_exists($class, false)) {
            die(new Exception('Class ' . $class . ' was not present in ' .
                str_replace('_', '/', $class) . '.php (include_path="' . get_include_path() .
                '") [PEAR2_Autoload version 1.0]'));
        }
        return true;
    }
    $e = new Exception('Class ' . $class . ' could not be loaded from ' .
        str_replace('_', '/', $class) . '.php, file does not exist (include_path="' . get_include_path() .
        '") [PEAR2_Autoload version 1.0]');
    $trace = $e->getTrace();
    if (isset($trace[2]) && isset($trace[2]['function']) &&
          in_array($trace[2]['function'], array('class_exists', 'interface_exists'))) {
        return false;
    }
    if (isset($trace[1]) && isset($trace[1]['function']) &&
          in_array($trace[1]['function'], array('class_exists', 'interface_exists'))) {
        return false;
    }
    die ((string) $e);
}

// set up __autoload
if (function_exists('spl_autoload_register')) {
    if (!($_____t = spl_autoload_functions()) || !in_array('PEAR2_Autoload', spl_autoload_functions())) {
        spl_autoload_register('PEAR2_Autoload');
        if (function_exists('__autoload') && ($_____t === false)) {
            // __autoload() was being used, but now would be ignored, add
            // it to the autoload stack
            spl_autoload_register('__autoload');
        }
    }
    unset($_____t);
} elseif (!function_exists('__autoload')) {
    function __autoload($class) { return PEAR2_Autoload($class); }
}

// set up include_path if it doesn't register our current location
$____paths = explode(PATH_SEPARATOR, get_include_path());
$____found = false;
foreach ($____paths as $____path) {
    if ($____path == dirname(dirname(__FILE__))) {
        $____found = true;
        break;
    }
}
if (!$____found) {
    set_include_path(get_include_path() . PATH_SEPARATOR . dirname(dirname(__FILE__)));
}
unset($____paths);
unset($____path);
unset($____found);
<?php
/**
 * Multi-Error Error aggregator
 *
 * This class is designed to be extended for specific use.  It codifies easy
 * ways of aggregating error conditions that don't necessarily require an exception
 * to be thrown, but do need an easy way to retrieve them.
 * 
 * Usage:
 * 
 * <code>
 * $multi = new PEAR2_MultiErrors();
 * $multi->E_WARNING[] = new Exception('test');
 * $multi->E_ERROR[] = new Exception('test 2');
 * foreach ($multi as $error) {
 *     echo $error;
 * }
 * foreach ($multi->E_WARNING as $error) {
 *     echo $error;
 * }
 * foreach ($multi->E_ERROR as $error) {
 *     echo $error;
 * }
 * if (count($multi->E_ERROR)) {
 *     throw new PEAR2_Exception('Failure to do something', $multi);
 * }
 * </code>
 * @copyright 2007 Gregory Beaver
 * @package PEAR2_MultiErrors
 * @license http://www.php.net/license/3_0.txt PHP License
 */
class PEAR2_MultiErrors implements Iterator, Countable, ArrayAccess {

    private $_allowedLevels = array('E_NOTICE' => 0, 'E_WARNING' => 1, 'E_ERROR' => 2);
    /**
     * Errors are stored in the order that they are declared
     * @var array
     */
    private $_errors = array();

    /**
     * To allow $this->E_WARNING[] = new BlahException;
     *
     * @var int
     */
    private $_requestedLevel = false;

    /**
     * Internal PEAR2_MultiError objects for error levels
     * @var array
     */
    private $_subMulti = array();

    /**
     * Parent PEAR2_MultiErrors for an error level tracker
     *
     * @var PEAR2_MultiErrors
     */
    private $_parent;

    public function __construct($mylevel = false,
                                array $allowed = array('E_NOTICE', 'E_WARNING', 'E_ERROR'),
                                PEAR2_MultiErrors $parent = null)
    {
        foreach ($allowed as $level) {
            if (!is_string($level) || strpos($level, 'E_') !== 0) {
                throw new PEAR2_MultiErrors_Exception('Invalid level ' . (string) $level);
            }
        }
        $this->_allowedLevels = array_flip($allowed);
        $this->_requestedLevel = $mylevel;
        if ($mylevel) {
            $this->_parent = $parent;
        }
    }

    public function current()
    {
        return current($this->_errors);
    }

    public function key()
    {
        return key($this->_errors);
    }

    public function next()
    {
        return next($this->_errors);
    }

    public function rewind()
    {
        return reset($this->_errors);
    }

    public function valid()
    {
        return false !== current($this->_errors);
    }

    /**
     * Merge in errors from an existing PEAR2_MultiErrors
     * 
     * This also merges in any new error levels not supported in this instance.
     * @param PEAR2_MultiErrors $error
     */
    public function merge(PEAR2_MultiErrors $error)
    {
        foreach ($error->levels as $level) {
            if (!isset($this->_allowedLevels[$level])) {
                $this->_allowedLevels[$level] = 1;
            }
            foreach ($error->$level as $e) {
                $this->{$level}[] = $e;
            }
        }
    }

    public function count()
    {
        return count($this->_errors);
    }

    public function offsetExists($offset)
    {
        return isset($this->_errors[$offset]);
    }

    public function offsetGet ($offset)
    {
        if (isset($this->_errors[$offset])) {
            return $this->_errors[$offset];
        }
        return null;
    }

    public function offsetSet ($offset, $value)
    {
        if ($offset === null && !$this->_requestedLevel &&
              $value instanceof PEAR2_MultiErrors ) {
            $this->merge($value);
            return;
        }
        if (!($value instanceof Exception)) {
            throw new PEAR2_MultiErrors_Exception('offsetSet: $value is not an Exception object');
        }
        if ($this->_requestedLevel) {
        if ($offset === null) {
            // called with $a->E_BLAH[] = new Exception('hi');
            $offset = count($this->_errors);
        }
        if (!is_int($offset)) {
            throw new PEAR2_MultiErrors_Exception('offsetSet: $offset is not an integer');
        }
        $this->_errors[$offset] = $value;
            $this->_parent[$this->_requestedLevel . '-' . $offset] = $value;
        } else {
            if (!is_string($offset)) {
                throw new PEAR2_MultiErrors_Exception('Cannot add an error directly ' .
                    'to a PEAR2_MultiErrors with $a[] = new Exception, use an ' .
                    ' E_* constant like $a->E_WARNING[] = new Exception');
            }
            $offset = explode('-', $offset);
            $level = $offset[0];
            $offset = $offset[1];
            // this is called when the "$this->_parent[] = $value" line is executed.
            if (!isset($this->_subMulti[$level]) ||
                  $this->_subMulti[$level][$offset] !== $value) {
            // must be in a child or it'll throw off the whole thingy
                throw new PEAR2_MultiErrors_Exception('Cannot add an error directly ' .
                    'to a PEAR2_MultiErrors with $a[] = new Exception, use an ' .
                    ' E_* constant like $a->E_WARNING[] = new Exception');
            }
            $this->_errors[] = $value;
        }
    }

    public function offsetUnset ($offset)
    {
        if (isset($this->_errors[$offset])) {
            unset($this->_errors[$offset]);
        }
    }

    public function __get($level)
    {
        if ($level === 'levels') {
            return array_keys($this->_allowedLevels);
        }
        if (!count($this->_allowedLevels)) {
            throw new PEAR2_MultiErrors_Exception('Cannot nest requests ' .
              '(like $multi->E_WARNING->E_ERROR[] = new Exception(\'\');)');
        }
        if (isset($this->_allowedLevels[$level])) {
            if (!isset($this->_subMulti[$level])) {
            $this->_subMulti[$level] = new PEAR2_MultiErrors($level,
              array(), $this);
            }
            return $this->_subMulti[$level];
        }
        throw new PEAR2_MultiErrors_Exception('Requested error level must be one of ' .
          implode(', ', array_keys($this->_allowedLevels)));
    }

    public function toArray()
    {
        return $this->_errors;
    }
}
?><?php
class PEAR2_MultiErrors_Exception extends PEAR2_Exception {}<?php
/* vim: set expandtab tabstop=4 shiftwidth=4 foldmethod=marker: */
/**
 * PEAR2_Exception
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR2_Exception
 * @author     Tomas V. V. Cox <cox@idecnet.com>
 * @author     Hans Lellelid <hans@velum.net>
 * @author     Bertrand Mansion <bmansion@mamasam.com>
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2007 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: Exception.php,v 1.28 2007/05/07 01:58:54 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Release 0.1.0
 */


/**
 * Base PEAR2_Exception Class
 *
 * 1) Features:
 *
 * - Nestable exceptions (throw new PEAR2_Exception($msg, $prev_exception))
 * - Definable triggers, shot when exceptions occur
 * - Pretty and informative error messages
 * - Added more context info available (like class, method or cause)
 * - cause can be a PEAR2_Exception or an array of mixed
 *   PEAR2_Exceptions or a PEAR2_MultiErrors
 * - callbacks for specific exception classes and their children
 *
 * 2) Ideas:
 *
 * - Maybe a way to define a 'template' for the output
 *
 * 3) Inherited properties from PHP Exception Class:
 *
 * protected $message
 * protected $code
 * protected $line
 * protected $file
 * private   $trace
 *
 * 4) Inherited methods from PHP Exception Class:
 *
 * __clone
 * __construct
 * getMessage
 * getCode
 * getFile
 * getLine
 * getTraceSafe
 * getTraceSafeAsString
 * __toString
 *
 * 5) Usage example
 *
 * <code>
 * class PEAR2_MyPackage_Exception extends PEAR2_Exception {}
 *  class Test {
 *     function foo()
 *     {
 *         throw new PEAR2_MyPackage_Exception('Error Message', ERROR_CODE);
 *     }
 *  }
 *
 *  function myLogger($pear2_exception)
 *  {
 *     echo $pear2_exception->getMessage();
 *  }
 *  // each time a exception is thrown the 'myLogger' will be called
 *  // (its use is completely optional)
 *  PEAR2_Exception::addObserver('myLogger');
 *  $test = new Test;
 *  try {
 *     $test->foo();
 *  } catch (PEAR2_Exception $e) {
 *     print $e;
 *  }
 * </code>
 *
 * @category   pear
 * @package    PEAR
 * @author     Tomas V.V.Cox <cox@idecnet.com>
 * @author     Hans Lellelid <hans@velum.net>
 * @author     Bertrand Mansion <bmansion@mamasam.com>
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2007 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 0.1.0
 *
 */
abstract class PEAR2_Exception extends Exception
{
    public static $htmlError = false;
    const OBSERVER_PRINT = -2;
    const OBSERVER_TRIGGER = -4;
    const OBSERVER_DIE = -8;
    protected $cause;
    private static $_observers = array();
    private static $_uniqueid = 0;
    private $_trace;

    /**
     * Supported signatures:
     *  - PEAR2_Exception(string $message);
     *  - PEAR2_Exception(string $message, int $code);
     *  - PEAR2_Exception(string $message, Exception $cause);
     *  - PEAR2_Exception(string $message, Exception $cause, int $code);
     *  - PEAR2_Exception(string $message, PEAR2_MultiErrors $cause);
     *  - PEAR2_Exception(string $message, PEAR2_MultiErrors $cause, int $code);
     *  - PEAR2_Exception(string $message, array $causes);
     *  - PEAR2_Exception(string $message, array $causes, int $code);
     * @param string exception message
     * @param int|Exception|PEAR2_MultiErrors|array|null exception cause
     * @param int|null exception code or null
     */
    public function __construct($message, $p2 = null, $p3 = null)
    {
        if (is_int($p2)) {
            $code = $p2;
            $this->cause = null;
        } elseif (is_object($p2) || is_array($p2)) {
            if (!is_array($p2) && !($p2 instanceof Exception)) {
                if (!($p2 instanceof PEAR2_MultiErrors)) {
                    throw new Exception('exception cause must be Exception, ' .
                        'array, or PEAR2_MultiErrors');
                }
            }
            $code = $p3;
            $this->cause = $p2;
        } else {
            $code = null;
            $this->cause = null;
        }
        if (!is_string($message)) {
            throw new Exception('exception message must be a string, was ' . gettype($message));
        }
        parent::__construct($message, $code);
        $this->signal();
    }

    /**
     * @param mixed $callback  - A valid php callback, see php func is_callable()
     *                         - A PEAR2_Exception::OBSERVER_* constant
     *                         - An array(const PEAR2_Exception::OBSERVER_*,
     *                           mixed $options)
     * @param string $label    The name of the observer. Use this if you want
     *                         to remove it later with removeObserver()
     */
    public static function addObserver($callback, $label = 'default')
    {
        self::$_observers[$label] = $callback;
    }

    public static function removeObserver($label = 'default')
    {
        unset(self::$_observers[$label]);
    }

    /**
     * @return int unique identifier for an observer
     */
    public static function getUniqueId()
    {
        return self::$_uniqueid++;
    }

    private function signal()
    {
        foreach (self::$_observers as $func) {
            if (is_callable($func)) {
                call_user_func($func, $this);
                continue;
            }
            settype($func, 'array');
            switch ($func[0]) {
                case self::OBSERVER_PRINT :
                    $f = (isset($func[1])) ? $func[1] : '%s';
                    printf($f, $this->getMessage());
                    break;
                case self::OBSERVER_TRIGGER :
                    $f = (isset($func[1])) ? $func[1] : E_USER_NOTICE;
                    trigger_error($this->getMessage(), $f);
                    break;
                case self::OBSERVER_DIE :
                    $f = (isset($func[1])) ? $func[1] : '%s';
                    die(printf($f, $this->getMessage()));
                    break;
                default:
                    trigger_error('invalid observer type', E_USER_WARNING);
            }
        }
    }

    /**
     * Returns the exception that caused this exception to be thrown
     * @access public
     * @return Exception|array The context of the exception
     */
    public function getCause()
    {
        return $this->cause;
    }

    /**
     * Function must be public to call on caused exceptions
     * @param array
     */
    public function getCauseMessage(&$causes)
    {
        $trace = $this->getTraceSafe();
        $cause = array('class'   => get_class($this),
                       'message' => $this->message,
                       'file' => 'unknown',
                       'line' => 'unknown');
        if (isset($trace[0])) {
            if (isset($trace[0]['file'])) {
                $cause['file'] = $trace[0]['file'];
                $cause['line'] = $trace[0]['line'];
            }
        }
        $causes[] = $cause;
        if ($this->cause instanceof PEAR2_Exception) {
            $this->cause->getCauseMessage($causes);
        } elseif ($this->cause instanceof Exception) {
            $causes[] = array('class'   => get_class($this->cause),
                              'message' => $this->cause->getMessage(),
                              'file' => $this->cause->getFile(),
                              'line' => $this->cause->getLine());
        } elseif ($this->cause instanceof PEAR2_MultiErrors || is_array($this->cause)) {
            foreach ($this->cause as $cause) {
                if ($cause instanceof PEAR2_Exception) {
                    $cause->getCauseMessage($causes);
                } elseif ($cause instanceof Exception) {
                    $causes[] = array('class'   => get_class($cause),
                                   'message' => $cause->getMessage(),
                                   'file' => $cause->getFile(),
                                   'line' => $cause->getLine());
                }
            }
        }
    }

    public function getTraceSafe()
    {   
        if (!isset($this->_trace)) {
            $this->_trace = $this->getTrace();
            if (empty($this->_trace)) {
                $backtrace = debug_backtrace();
                $this->_trace = array($backtrace[count($backtrace)-1]);
            }
        }
        return $this->_trace;
    }

    public function getErrorClass()
    {
        $trace = $this->getTraceSafe();
        return $trace[0]['class'];
    }

    public function getErrorMethod()
    {
        $trace = $this->getTraceSafe();
        return $trace[0]['function'];
    }

    public function __toString()
    {
        if (self::$htmlError) {
            return $this->toHtml();
        }
        return $this->toText();
    }

    public function toHtml()
    {
        $trace = $this->getTraceSafe();
        $causes = array();
        $this->getCauseMessage($causes);
        $html =  '<table border="1" cellspacing="0">' . "\n";
        foreach ($causes as $i => $cause) {
            $html .= '<tr><td colspan="3" bgcolor="#ff9999">'
               . str_repeat('-', $i) . ' <b>' . $cause['class'] . '</b>: '
               . htmlspecialchars($cause['message']) . ' in <b>' . $cause['file'] . '</b> '
               . 'on line <b>' . $cause['line'] . '</b>'
               . "</td></tr>\n";
        }
        $html .= '<tr><td colspan="3" bgcolor="#aaaaaa" align="center"><b>Exception trace</b></td></tr>' . "\n"
               . '<tr><td align="center" bgcolor="#cccccc" width="20"><b>#</b></td>'
               . '<td align="center" bgcolor="#cccccc"><b>Function</b></td>'
               . '<td align="center" bgcolor="#cccccc"><b>Location</b></td></tr>' . "\n";

        foreach ($trace as $k => $v) {
            $html .= '<tr><td align="center">' . $k . '</td>'
                   . '<td>';
            if (!empty($v['class'])) {
                $html .= $v['class'] . $v['type'];
            }
            $html .= $v['function'];
            $args = array();
            if (!empty($v['args'])) {
                foreach ($v['args'] as $arg) {
                    if (is_null($arg)) $args[] = 'null';
                    elseif (is_array($arg)) $args[] = 'Array';
                    elseif (is_object($arg)) $args[] = 'Object('.get_class($arg).')';
                    elseif (is_bool($arg)) $args[] = $arg ? 'true' : 'false';
                    elseif (is_int($arg) || is_double($arg)) $args[] = $arg;
                    else {
                        $arg = (string)$arg;
                        $str = htmlspecialchars(substr($arg, 0, 16));
                        if (strlen($arg) > 16) $str .= '&hellip;';
                        $args[] = "'" . $str . "'";
                    }
                }
            }
            $html .= '(' . implode(', ',$args) . ')'
                   . '</td>'
                   . '<td>' . (isset($v['file']) ? $v['file'] : 'unknown')
                   . ':' . (isset($v['line']) ? $v['line'] : 'unknown')
                   . '</td></tr>' . "\n";
        }
        $html .= '<tr><td align="center">' . ($k+1) . '</td>'
               . '<td>{main}</td>'
               . '<td>&nbsp;</td></tr>' . "\n"
               . '</table>';
        return $html;
    }

    public function toText()
    {
        $causes = array();
        $this->getCauseMessage($causes);
        $causeMsg = '';
        foreach ($causes as $i => $cause) {
            $causeMsg .= str_repeat(' ', $i) . $cause['class'] . ': '
                   . $cause['message'] . ' in ' . $cause['file']
                   . ' on line ' . $cause['line'] . "\n";
        }
        return $causeMsg . $this->getTraceAsString();
    }
}
?><?php
/**
 * class to do http requests, uses a adapter based system for performing those requests
 *
 * Loosely Based on PEAR HTTP_Response
 *
 * @version $Id$
 */
class PEAR2_HTTP_Request 
{

    /**
     * The adapter that the requester uses.
     *
     * @see adapters
     */
    protected $adapter;

    /**
     * The listeners
     *
     * This variable contains the listeners that are
     * set (can be set) on this object.
     *
     * @var array $_listeners  The listeners
     */
    protected $_listeners = array();
    
    /**
     * Magic to retrieve items that are actually stored in the adapter
     *
     * @param  string $name name of var to get
     */
    public function __get($name)
    {
        if (isset($this->adapter->$name)) {
            return $this->adapter->$name;
        }
    }

    /**
     * Magic to set items that are actually stored in the adapter
     *
     * @param  string $name name of var to set
     * @param  mixed $value to give to var
     */
    public function __set($name, $value)
    {
        switch($name) {
            case 'verb':
                $this->adapter->verb = strtoupper($value);
                break;
            case 'uri':
            case 'url':
                $this->adapter->uri = new PEAR2_HTTP_Request_Uri($value);
                break;
            case 'body':
            case 'content':
                if (is_array($value)) {
                    $this->adapter->body = http_build_query($value);
                    $this->setHeader('Content-Type','application/x-www-form-urlencoded');
                    if ($this->adapter->verb == 'GET') {
                        $this->adapter->verb = 'POST';
                    }
                } else {
                    $this->adapter->body = $value;
                }
                break;
            case 'requestTimeout':
                $this->adapter->$name = (int)$value;
                break;
            case 'proxy':
                $this->adapter->$name = new PEAR2_HTTP_Request_Uri($value);
                break;
            default:
                $this->adapter->$name = $value;
                break;
        }
    }

    /**
     * sets up the adapter
     *
     * @param  string $class adapter to use
     */
    public function __construct($url = null, $instance = null) 
    {
        if (!is_null($instance) && $instance instanceof PEAR2_HTTP_Request_Adapter) {
            $this->adapter = $instance;
        } elseif (extension_loaded('curl')) {
            $this->adapter = new PEAR2_HTTP_Request_Adapter_Curl;
        } elseif (extension_loaded('http')) {
            $this->adapter = new PEAR2_HTTP_Request_Adapter_Http;
        } elseif (ini_get('allow_url_fopen') == true) {
            $this->adapter = new PEAR2_HTTP_Request_Adapter_Phpstream;
        } else {
            $this->adapter = new PEAR2_HTTP_Request_Adapter_Phpsocket;
        }

        $this->adapter->setListeners($this->_listeners);

        if ($url) {
            $this->url = $url;
        }
    }

    /**
     * asks for a response class from the adapter
     *
     * @return PEAR2_HTTP_Request_Response
     */
    public function sendRequest() 
    {
        $response = $this->adapter->sendRequest();
        return $response;
    }

    /**
     * Sends a request storing the output to a file
     *
     * @param  string $file File to store too
     * @return PEAR2_HTTP_Request_Response with no body
     */
    public function requestToFile($file) {
        $response = $this->adapter->requestToFile($file);
        return $response;
    }

    /**
     * Setter for request headers
     * 
     * @see $this->adapter->headers
     */
    public function setHeader($header, $value) 
    {
        $this->adapter->headers[$header] = $value;
    }

    /**
     * Attach a listener
     *
     * This method adds a listener to the list of listeners that are 
     * notified of the object's events.
     *
     * Events sent by the HTTP_Request Object
     *  - 'connect'     : On connection to server
     *  - 'sentRequest' : After the request was sent to server
     *  - 'disconnect'  : Upon server disconnection
     *
     * Events sent by the HTTP_Response object
     *  - 'gotHeaders' : After receiving response header
     *  - 'tick'       : On receiving part of response
     *  - 'gzTick'     : On receiving a gzip-encoded part
     *  - 'gotBody'    : Upon receiving body of the message
     *
     *
     * @param  PEAR2_HTTP_Request_Listener $listener  The listener object
     * @return boolean Whether object is a listener or not
     */
    public function attach(PEAR2_HTTP_Request_Listener &$listener)
    {
        $this->_listeners[$listener->getId()] =& $listener;
        return true;
    }

    /**
     * Detach a listener
     *
     * This method will detach the listener that was set
     * to a request.
     *
     * @param  PEAR2_HTTP_Request_Listener $listener   The listener
     * @return bool true
     */
    public function detach(PEAR2_HTTP_Request_Listener &$listener)
    {
        if (isset($this->_listeners[$listener->getId()])) {
            $this->_listeners[$listener->getId()] = null;
        }

        return true;
    }

    /**
     * Notify
     *
     * This method notifies all registered listeners of
     * the event that just happened.
     *
     * @param     string  $event  The event name
     * @param     mixed  $data   Additional data
     * @see       PEAR2_HTTP_Request->attach()
     * @return    void
     */
    protected function _notify($event, $data = null)
    {
        if (!empty($this->_listeners)) {
            foreach (array_keys($this->_listeners) as $id) {
                $this->_listeners[$id]->update($this, $event, $data);
            }
        }
    }

    /**
     * Get the class name of the adapter that is being used
     */
    public function getAdapterName() {
        return get_class($this->adapter);
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php
abstract class PEAR2_HTTP_Request_Adapter 
{

    /**
     * HTTP Version
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.1
     */
    public $httpVersion = 'HTTP/1.1';

    /**
     * Uri to make the request too
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2
     */
    public $uri;

    /**
     * Called Method in the spec
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1
     */
    public $verb = 'GET';

    /**
     * Additional headers to send
     * @var array   Header Name => Header value
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.3
     */
    public $headers = array();

    /**
     * Value to send as the body of the message, you need to handle the encoding
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
     */
    public $body;

    /**
     * How long to wait until a request times out
     * @float seconds
     */
    public $requestTimeout = 100;

    /**
     * Full uri of the proxy server
     * @var PEAR2_HTTP_Request_Uri
     */
    public $proxy = null;

    /**
     * HTTP Return code
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
     */
    public $code = 0;

    /**
     * Listeners from the parent
     */
    protected $_listeners = array();

    /**
     * Parsed cookies
     * @var array
     */
    public $cookies = array();

    /**
     * @todo i don't like this approach
     */
    public function setListeners(&$listeners) {
        $this->_listeners &= $listeners;
    }

    /**
     * Send the specified request
     */
    public function sendRequest() 
    {
    }

    /**
     * Send a request storing the results to a file and return a response class with no body
     *
     * Base Adapter contains a non efficient baseline method
     */
    public function requestToFile($file) 
    {
        $response = $this->sendRequest();

        file_put_contents($file,$response->body);
        unset($response->body);

        return $response;
    }

    protected function parseResponseCode($line) 
    {
        if (sscanf($line, 'HTTP/%s %s', $http_version, $returncode) != 2) {
            throw new PEAR2_HTTP_Request_Exception('Malformed response.');
        } else {
            return array('code' => intval($returncode), 'httpVersion' => $http_version);
        }
    }

   /**
    * Processes the response header
    *
    * @access private
    * @param  string    HTTP header
    */
    protected function processHeader($header)
    {
        if (strpos($header, ':') === false) {
            return;
        }

        list($headername, $headervalue) = explode(':', $header, 2);
        if (strstr($headername,'-')) {
            list($p1,$p2) = explode('-',$headername);
            $headername  = ucfirst(strtolower($p1)).'-'.ucfirst(strtolower($p2));
        }
        else {
            $headername  = ucfirst($headername);
        }
        $headervalue = ltrim($headervalue);

        if ('set-cookie' != $headername) {
            if (isset($this->headers[$headername])) {
                $this->headers[$headername] .= ',' . $headervalue;
            } else {
                $this->headers[$headername]  = $headervalue;
            }
        } else {
            $this->cookies[] = $this->parseCookie($headervalue);
        }
    }


    /**
     * Parse a Set-Cookie header to fill $cookies array
     *
     * @access private
     * @param  string    value of Set-Cookie header
     */
    protected function parseCookie($headervalue)
    {
        $cookie = array(
            'expires' => null,
            'domain'  => null,
            'path'    => null,
            'secure'  => false
        );

        // Only a name=value pair
        if (!strpos($headervalue, ';')) {
            $pos = strpos($headervalue, '=');
            $cookie['name']  = trim(substr($headervalue, 0, $pos));
            $cookie['value'] = trim(substr($headervalue, $pos + 1));

            // Some optional parameters are supplied
        } else {
            $elements = explode(';', $headervalue);
            $pos = strpos($elements[0], '=');
            $cookie['name']  = trim(substr($elements[0], 0, $pos));
            $cookie['value'] = trim(substr($elements[0], $pos + 1));

            for ($i = 1; $i < count($elements); $i++) {
                if (false === strpos($elements[$i], '=')) {
                    $elName  = trim($elements[$i]);
                    $elValue = null;
                } else {
                    list ($elName, $elValue) = array_map('trim', explode('=', $elements[$i]));
                }

                $elName = strtolower($elName);

                if ($elName == 'secure') {
                    $cookie['secure'] = true;
                } elseif ($elName == 'expires') {
                    $cookie['expires'] = str_replace('"', '', $elValue);
                } elseif ($elName == 'path' || $elName == 'domain') {
                    $cookie[$elName] = urldecode($elValue);
                } else {
                    $cookie[$elName] = $elValue;
                }
            }
        }
        return $cookie;
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
<?php
class PEAR2_HTTP_Request_Adapter_Phpsocket_Socket {
        public $lineLength = 2048;
        private $_handle;

        public function __construct($handle) {
                $this->_handle = $handle;
        }

        public function readLine() {
                $line = '';
                while(!$this->eof()) {
                        $line .= @fgets($this->_handle, $this->lineLength);
                        if (substr($line, -1) == "\n") {
                                return rtrim($line, "\r\n");
                        }
                }
                return false;
        }

        public function read($size) {
                if ($this->eof()) {
                        return false;
                }
                return @fread($this->_handle,$size);
        }

        public function write($payload) {
                return fwrite($this->_handle,$payload,strlen($payload));
        }

        public function eof() {
                return feof($this->_handle);
        }
}

/**
 * A class which represents an Http Reponse
 * Handles parsing cookies and headers
 *
 * Based on PEAR HTTP_Response
 *
 * @version $Revision: 1.52 $
 */
class PEAR2_HTTP_Request_Adapter_Phpsocket extends PEAR2_HTTP_Request_Adapter {

    
    /**
     * Used by _readChunked(): remaining length of the current chunk
     * @var string
     */
    private $_chunkLength = 0;

    /**
     * Bytes left to read from message-body
     * @var null|int
     */
    private $_toRead = null;

    /**
     * Raw Response to be parsed
     */
    private $_stream;

    public function sendRequest() {
        $payload = $this->_buildHeaders($this->uri->path,$this->uri->host,$this->headers,strlen($this->body));
        $payload .= $this->body;
        $this->body = '';

        $errno    = 0;
        $errstr   = '';
        $handle   = @fsockopen($this->uri->host, $this->uri->port, $errno, $errstr, 30);

        if (!is_resource($handle)) {
            throw new PEAR2_HTTP_Request_Exception("Couldn't connection to host using Phpsocket Adapter, fsockopen errors($errstr,$errno)");
        }
        stream_set_timeout($handle,10);

        $this->_stream = new PEAR2_HTTP_Request_Adapter_Phpsocket_Socket($handle);

        $this->_stream->write($payload);

        $this->parse();

        $details['code'] = $this->code;
        $details['httpVersion'] = $this->httpVersion;


        $response = new PEAR2_HTTP_Request_Response(
            $details,$this->body,new PEAR2_HTTP_Request_Headers($this->headers),$this->cookies);
        return $response;
    }

    /**
     * Parse a HTTP response
     * 
     * This extracts response code, headers, cookies and decodes body if it 
     * was encoded in some way
     *
     * @access public
     * @param  bool      Whether to store response body in object property, set
     *                   this to false if downloading a LARGE file and using a Listener.
     *                   This is assumed to be true if body is gzip-encoded.
     * @param  bool      Whether the response can actually have a message-body.
     *                   Will be set to false for HEAD requests.
     * @throws Exception
     * @return boolean     true on success
     */
    public function parse($saveBody = true, $canHaveBody = true)
    {
        do {
            $line = $this->_stream->readLine();
            $code = $this->parseResponseCode($line);
            $this->httpVersion = 'HTTP/' . $code['httpVersion'];
            $this->code     = $code['code'];

            while ('' !== ($header = $this->_stream->readLine())) {
                $this->processHeader($header);
            }
        } while ($this->code == 100);

        // RFC 2616, section 4.4:
        // 1. Any response message which "MUST NOT" include a message-body ... 
        // is always terminated by the first empty line after the header fields 
        // 3. ... If a message is received with both a
        // Transfer-Encoding header field and a Content-Length header field,
        // the latter MUST be ignored.
        $canHaveBody = $canHaveBody && $this->code >= 200 && 
                       $this->code != 204 && $this->code != 304;

        // If response body is present, read it and decode
        $chunked = isset($this->headers['transfer-encoding']) && ('chunked' == $this->headers['transfer-encoding']);
        $gzipped = isset($this->headers['content-encoding']) && ('gzip' == $this->headers['content-encoding']);
        $hasBody = false;
        if ($canHaveBody && ($chunked || !isset($this->headers['content-length']) || 
                0 != $this->headers['content-length']))
        {
            if ($chunked || !isset($this->headers['content-length'])) {
                $this->_toRead = null;
            } else {
                $this->_toRead = $this->headers['content-length'];
            }
            while (!$this->_stream->eof() && (is_null($this->_toRead) || $this->_toRead > 0)) {
                if ($chunked) {
                    $data = $this->_readChunked();
                } elseif (is_null($this->_toRead)) {
                    $data = $this->_stream->read(4096);
                } else {
                    $data = $this->_stream->read(min(4096, $this->_toRead));
                    $this->_toRead -= strlen($data);
                }
                if ($data == '') {
                    break;
                } else {
                    $hasBody = true;
                    if ($saveBody || $gzipped) {
                        $this->body .= $data;
                    }
                }
            }
        }

        if ($hasBody) {
            // Uncompress the body if needed
            if ($gzipped) {
                $body = $this->_decodeGzip($this->body);
                if (PEAR::isError($body)) {
                    return $body;
                }
                $this->body = $body;
            }
        }
        return true;
    }

   /**
    * Read a part of response body encoded with chunked Transfer-Encoding
    * 
    * @access private
    * @return string
    */
    private function _readChunked()
    {
        // at start of the next chunk?
        if (0 == $this->_chunkLength) {
            $line = $this->_stream->readLine();
            if (preg_match('/^([0-9a-f]+)/i', $line, $matches)) {
                $this->_chunkLength = hexdec($matches[1]); 
                // Chunk with zero length indicates the end
                if (0 == $this->_chunkLength) {
                    $this->_stream->readLine(); // make this an eof()
                    return '';
                }
            } else {
                return '';
            }
        }
        $data = $this->_stream->read($this->_chunkLength);
        $this->_chunkLength -= strlen($data);
        if (0 == $this->_chunkLength) {
            $this->_stream->readLine(); // Trailing CRLF
        }
        return $data;
    }

   /**
    * Decodes the message-body encoded by gzip
    *
    * The real decoding work is done by gzinflate() built-in function, this
    * method only parses the header and checks data for compliance with
    * RFC 1952  
    *
    * @access   private
    * @param    string  gzip-encoded data
    * @return   string  decoded data
    */
    private function _decodeGzip($data)
    {
        $length = strlen($data);
        // If it doesn't look like gzip-encoded data, don't bother
        if ($length < 18 || strcmp(substr($data, 0, 2), "\x1f\x8b")) {
            return $data;
        }
        $method = ord(substr($data, 2, 1));
        if ($method != 8) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): unknown compression method');
        }
        
        $flags = ord(substr($data, 3, 1));

        if ($flags & 224) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): reserved bits are set');
        }

        // header is 10 bytes minimum. may be longer, though.
        $headerLength = 10;
        // extra fields, need to skip 'em
        if ($flags & 4) {
            if ($length - $headerLength - 2 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            
            $extraLength = unpack('v', substr($data, 10, 2));
            if ($length - $headerLength - 2 - $extraLength[1] < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }

            $headerLength += $extraLength[1] + 2;
        }
        // file name, need to skip that
        if ($flags & 8) {
            if ($length - $headerLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $filenameLength = strpos(substr($data, $headerLength), chr(0));
            if (false === $filenameLength || $length - $headerLength - $filenameLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $headerLength += $filenameLength + 1;
        }
        // comment, need to skip that also
        if ($flags & 16) {
            if ($length - $headerLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $commentLength = strpos(substr($data, $headerLength), chr(0));
            if (false === $commentLength || $length - $headerLength - $commentLength - 1 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $headerLength += $commentLength + 1;
        }
        // have a CRC for header. let's check
        if ($flags & 1) {
            if ($length - $headerLength - 2 < 8) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data too short');
            }
            $crcReal   = 0xffff & crc32(substr($data, 0, $headerLength));
            $crcStored = unpack('v', substr($data, $headerLength, 2));
            if ($crcReal != $crcStored[1]) {
                throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): header CRC check failed');
            }
            $headerLength += 2;
        }
        // unpacked data CRC and size at the end of encoded data
        $tmp = unpack('V2', substr($data, -8));
        $dataCrc  = $tmp[1];
        $dataSize = $tmp[2];

        // finally, call the gzinflate() function
        $unpacked = @gzinflate(substr($data, $headerLength, -8), $dataSize);
        if (false === $unpacked) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): gzinflate() call failed');
        } elseif ($dataSize != strlen($unpacked)) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data size check failed');
        } elseif ($dataCrc != crc32($unpacked)) {
            throw new PEAR2_HTTP_Request_Exception('_decodeGzip(): data CRC check failed');
        }
        return $unpacked;
    }

    private function _buildHeaders($path, $host, $headers,$bodySize) {
        $httpRequest  = "$this->verb $path $this->httpVersion\r\n";
        $httpRequest .= "Host: $host\r\n";
        foreach($headers as $key => $value) {
            $httpRequest .= "$key: $value\r\n";
        }
        if ($bodySize > 0) {
            $httpRequest .= "Content-Length:".$bodySize."\r\n";
        }
        $httpRequest .= "\r\n";

        return $httpRequest;
    }
} // End class PEAR2_HTTP_Response
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php
/**
 * driver that uses php http:// stream to do requests
 *
 * Loosely Based on PEAR HTTP_Response
 *
 * @version $Revision: 1.52 $
 */
class PEAR2_HTTP_Request_Adapter_PhpStream extends PEAR2_HTTP_Request_Adapter
{
    private $_phpErrorStr;

    /**
     * Throws exception if allow_url_fopen is off
     */
    public function __construct()
    {
        if (ini_get('allow_url_fopen') == false) {
            throw new PEAR2_HTTP_Request_Exception(
                'allow_url_fopen is off, the http:// stream wrapper will not function'
            );
        }
    }


    /**
     * Send the request
     *
     * This function sends the actual request to the
     * remote/local webserver using php streams.
     */
    public function sendRequest()
    {

        $proxyurl = '';
        if (!is_null($this->proxy)) {
            $proxyurl = $this->proxy->url;
        }
        // create context with proper junk
        $ctx = stream_context_create(
            array(
                $this->uri->protocol => array(
                    'method' => $this->verb,
                    'content' => $this->body,
                    'header' => $this->buildHeaderString(),
                    'proxy'  => $proxyurl,
                )
            )
        );

        set_error_handler(array($this,'_errorHandler'));
        $fp = fopen($this->uri->url, 'rb', false, $ctx);
        if (!is_resource($fp)) {
            // php sucks
            if (strpos($this->_phpErrorStr, 'HTTP/1.1 304')) {
                restore_error_handler();
                $details = $this->uri->toArray();

                $details['code'] = '304';
                $details['httpVersion'] = '1.1';

                return new PEAR2_HTTP_Request_Response($details,'',array(),array());
            }
            restore_error_handler();
            throw new PEAR2_HTTP_Request_Exception('Url ' . $this->uri->url . ' could not be opened (PhpStream Adapter ('.$this->_phpErrorStr.'))');
        } else {
            restore_error_handler();
        }

        stream_set_timeout($fp, $this->requestTimeout);
        $body = stream_get_contents($fp);

        if ($body === false) {
            throw new PEAR2_HTTP_Request_Exception(
                'Url ' . $this->uri->url . ' did not return a response'
            );
        }

        $meta = stream_get_meta_data($fp);
        fclose($fp);

        $headers = $meta['wrapper_data'];

        $details = $this->uri->toArray();

        $tmp = $this->parseResponseCode($headers[0]);
        $details['code'] = $tmp['code'];
        $details['httpVersion'] = $tmp['httpVersion'];

        $cookies = array();
        $this->headers = $this->cookies = array();

        foreach($headers as $line) {
            $this->processHeader($line);
        }

        return new PEAR2_HTTP_Request_Response(
            $details,$body,new PEAR2_HTTP_Request_Headers($this->headers),$this->cookies);
    }

    /**
     * Build header String
     *
     * This method builds the header string
     * to be passed to the request.
     *
     * @return string $out  The headers
     */
    private function buildHeaderString()
    {
        $out = '';
        foreach($this->headers as $header => $value) {
            $out .= "$header: $value\r\n";
        }
        return $out;
    }

    /**
     * This has to be public to be used as a callback but its actually private
     */
    public function _errorHandler($errno,$errstr) {
        $this->_phpErrorStr = $errstr;
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php
class PEAR2_HTTP_Request_Exception extends PEAR2_Exception {
}
<?php

/**
 * A container for HTTP request headers provides case insensitive access
 *
 * Array style access and object style access is provided
 *
 * Lazy processing of case insensitive access is provided so we don't strtolower the keys
 * until the headers are actually used
 *
 * @todo decide if this should be pulled out of the package and provided as a generic class
 */
class PEAR2_HTTP_Request_Headers implements Iterator, ArrayAccess, Countable {

	const ORIGINAL_CASE = 'fields';
	const LOWER_CASE = 'lowerCase';
	const CAMEL_CASE = 'camelCase';

	public $iterationStyle = self::LOWER_CASE;

	protected $fields = array();
	protected $camelCase = null;
	protected $lowerCase = null;

	/**
	 * Takes the headers to provide access too
	 */
	public function __construct($fields) {
		$this->fields = $fields;
	}

	/**
	 * Magic getter for object access
	 */
	public function __get($key) {
		if (is_null($this->camelCase)) {
			$this->camelCaseFields();
		}

		if (isset($this->camelCase[$key])) {
			return $this->camelCase[$key];
		}
		return null;
	}

	/**
	 * Magic setter for object access
	 *
	 * @todo set $this->fields and $this->lowerCase
	 */
	public function __set($key,$value) {
		$this->camelCase[$key] = $value;
	}

	/**
	 * Magic isset for object access
	 */
	public function __isset($key) {
		if (is_null($this->camelCase)) {
			$this->camelCaseFields();
		}
		return isset($this->camelCase[$key]);
	}

	/**
	 * Magic unset for object access
	 */
	public function __unset($key) {
		if (is_null($this->camelCase)) {
			$this->camelCaseFields();
		}
		unset($this->camelCase[$key]);
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetExists($key) {
		if (is_null($this->lowerCase)) {
			$this->lowerCaseFields();
		}
		$key = strtolower($key);
		return isset($this->lowerCase[$key]);
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetGet($key) {
		if (is_null($this->lowerCase)) {
			$this->lowerCaseFields();
		}
		$key = strtolower($key);
		if (isset($this->lowerCase[$key])) {
			return $this->lowerCase[$key];
		}
		return null;
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetSet($key,$value) {
		$key = strtolower($key);

		$this->lowerCase[$key] = $value;
	}

	/**
	 * ArrayAccess Implementation
	 */
	public function offsetUnset($key) {
		if (is_null($this->lowerCase)) {
			$this->lowerCaseFields();
		}
		$key = strtolower($key);
		unset($this->lowerCase[$key]);
	}

	/**
	 * Return the number of headers
	 * Countable interface implmentation
	 */
	public function count() {
		return count($this->fields);
	}

	/**
	 * Iterator Implmentation
	 */
	public function current() {
		return current($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function key() {
		return key($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function next() {
		return next($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function rewind() {
		if (is_null($this->{$this->iterationStyle})) {
			$m = $this->iterationStyle."Fields";
			$this->$m();
		}
		reset($this->{$this->iterationStyle});
	}

	/**
	 * Iterator Implmentation
	 */
	public function valid() {
		return (boolean) current($this->{$this->iterationStyle});
	}

	/**
	 * Make all keys lower case
	 */
	protected function lowerCaseFields() {
		$fields = array();
		foreach($this->fields as $k => $v) {
			$fields[strtolower($k)] = $v;
		}
		$this->lowerCase = $fields;
	}

	/**
	 * Make all keys camel case, removing dashes
	 */
	protected function camelCaseFields() {
		$fields = array();
		foreach($this->fields as $k => $v) {
			$pieces = explode('-',$k);
			$pieces = array_map('ucfirst',$pieces);
			$fields[implode('',$pieces)] = $v;
		}
		$this->camelCase = $fields;
	}
}
<?php
/**
 * A class which represents an HTTP Reponse
 *
 */
class PEAR2_HTTP_Request_Response
{
    /**
     * HTTP Return code
     * @var string
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
     */
    public $code = 100;

    /**
     * Response headers
     * @var array
     */
    public $headers;

    /**
     * Cookies set in response
     * @var array
     */
    public $cookies;

    /**
     * Response body
     * @var string
     */
    public $body = '';

    /**
     * Constructor
     *
     *
     * @see $this->body
     * @see $this->headers
     * @see $this->cookies
     */
    public function __construct($details, $body, $headers, $cookies)
    {
        foreach($details as $name => $value) {
            $this->$name = $value;
        }

        $this->body    = $body;
        $this->headers = $headers;
        $this->cookies = $cookies;
    }

    /**
     * Return the body of the response
     */
    public function __toString() {
        return $this->body;
    }
}
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
?>
<?php

/**
 * Simple class for parsing url/uris
 *
 * Basically compatiable with Net_URL2 propery names but not methods
 */
class PEAR2_HTTP_Request_Uri {

	protected $pieces = array();
	protected $map = array(
			'url' => 'uri',
			'querystring' => 'query',
			'anchor' => 'fragment',
			'protocol' => 'scheme',
			);
	protected $schemes = array(
			'http' => 80,
			'https'=> 443,
		);

	public function __construct($uri) {
		$this->pieces = parse_url($uri);
		$this->pieces['uri'] = $uri;
		if (!isset($this->pieces['port'])) {
			if (isset($this->schemes[$this->pieces['scheme']])) {
				$this->pieces['port'] = $this->schemes[$this->pieces['scheme']];
			}
			else {
				$this->pieces['port'] = 80;
			}
		}
	}

	public function __get($key) {
		if (isset($this->map[$key])) {
			$key = $this->map[$key];
		}
		if (isset($this->pieces[$key])) {
			return $this->pieces[$key];
		}
		return null;
	}

	public function toArray() {
		return $this->pieces;
	}
}
<?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>pear.php.net</name>
 <suggestedalias>pear</suggestedalias>
 <summary>PHP Extension and Application Repository</summary>
 <servers>
  <primary>
   <rest>

    <baseurl type="REST1.0">http://pear.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://pear.php.net/rest/</baseurl>
    <baseurl type="REST1.2">http://pear.php.net/rest/</baseurl>
    <baseurl type="REST1.3">http://pear.php.net/rest/</baseurl>
   </rest>
  </primary>
  <mirror host="us.pear.php.net">

   <rest>
    <baseurl type="REST1.0">http://us.pear.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://us.pear.php.net/rest/</baseurl>
    <baseurl type="REST1.2">http://us.pear.php.net/rest/</baseurl>
    <baseurl type="REST1.3">http://us.pear.php.net/rest/</baseurl>
   </rest>
  </mirror>

  <mirror host="de.pear.php.net" ssl="yes" port="3452">
   <rest>
    <baseurl type="REST1.0">https://de.pear.php.net:3452/rest/</baseurl>
    <baseurl type="REST1.1">https://de.pear.php.net:3452/rest/</baseurl>
    <baseurl type="REST1.2">https://de.pear.php.net:3452/rest/</baseurl>
    <baseurl type="REST1.3">https://de.pear.php.net:3452/rest/</baseurl>
   </rest>

  </mirror>
 </servers>
</channel><?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>pear.php.net</name>
 <suggestedalias>pear</suggestedalias>
 <summary>PHP Extension and Application Repository</summary>
 <servers>
  <primary>
   <rest>

    <baseurl type="REST1.0">http://pear.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://pear.php.net/rest/</baseurl>
    <baseurl type="REST1.2">http://pear.php.net/rest/</baseurl>
    <baseurl type="REST1.3">http://pear.php.net/rest/</baseurl>
   </rest>
  </primary>
  <mirror host="us.pear.php.net">

   <rest>
    <baseurl type="REST1.0">http://us.pear.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://us.pear.php.net/rest/</baseurl>
    <baseurl type="REST1.2">http://us.pear.php.net/rest/</baseurl>
    <baseurl type="REST1.3">http://us.pear.php.net/rest/</baseurl>
   </rest>
  </mirror>

  <mirror host="de.pear.php.net" ssl="yes" port="3452">
   <rest>
    <baseurl type="REST1.0">https://de.pear.php.net:3452/rest/</baseurl>
    <baseurl type="REST1.1">https://de.pear.php.net:3452/rest/</baseurl>
    <baseurl type="REST1.2">https://de.pear.php.net:3452/rest/</baseurl>
    <baseurl type="REST1.3">https://de.pear.php.net:3452/rest/</baseurl>
   </rest>

  </mirror>
 </servers>
</channel><?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>pear2.php.net</name>
 <suggestedalias>pear2</suggestedalias>
 <summary>PEAR packages for PHP 5.3+ installed by Pyrus</summary>
 <servers>
  <primary>
   <rest>

    <baseurl type="REST1.0">http://pear2.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://pear2.php.net/rest/</baseurl>
    <baseurl type="REST1.2">http://pear2.php.net/rest/</baseurl>
    <baseurl type="REST1.3">http://pear2.php.net/rest/</baseurl>
   </rest>
  </primary>
 </servers>
</channel><?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>pear2.php.net</name>
 <suggestedalias>pear2</suggestedalias>
 <summary>PEAR packages for PHP 5.3+ installed by Pyrus</summary>
 <servers>
  <primary>
   <rest>

    <baseurl type="REST1.0">http://pear2.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://pear2.php.net/rest/</baseurl>
    <baseurl type="REST1.2">http://pear2.php.net/rest/</baseurl>
    <baseurl type="REST1.3">http://pear2.php.net/rest/</baseurl>
   </rest>
  </primary>
 </servers>
</channel><?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>pecl.php.net</name>
 <suggestedalias>pecl</suggestedalias>
 <summary>PHP Extension Community Library</summary>
 <validatepackage version="1.0">PEAR_Validator_PECL</validatepackage>
 <servers>
  <primary>

   <xmlrpc>
    <function version="1.0">logintest</function>
    <function version="1.0">package.listLatestReleases</function>
    <function version="1.0">package.listAll</function>
    <function version="1.0">package.info</function>
    <function version="1.0">package.getDownloadURL</function>

    <function version="1.0">package.getDepDownloadURL</function>
    <function version="1.0">package.search</function>
    <function version="1.0">channel.listAll</function>
   </xmlrpc>
   <rest>
    <baseurl type="REST1.0">http://pecl.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://pecl.php.net/rest/</baseurl>

   </rest>
  </primary>
 </servers>
</channel><?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>pecl.php.net</name>
 <suggestedalias>pecl</suggestedalias>
 <summary>PHP Extension Community Library</summary>
 <validatepackage version="1.0">PEAR_Validator_PECL</validatepackage>
 <servers>
  <primary>

   <xmlrpc>
    <function version="1.0">logintest</function>
    <function version="1.0">package.listLatestReleases</function>
    <function version="1.0">package.listAll</function>
    <function version="1.0">package.info</function>
    <function version="1.0">package.getDownloadURL</function>

    <function version="1.0">package.getDepDownloadURL</function>
    <function version="1.0">package.search</function>
    <function version="1.0">channel.listAll</function>
   </xmlrpc>
   <rest>
    <baseurl type="REST1.0">http://pecl.php.net/rest/</baseurl>
    <baseurl type="REST1.1">http://pecl.php.net/rest/</baseurl>

   </rest>
  </primary>
 </servers>
</channel><?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>__uri</name>
 <suggestedalias>__uri</suggestedalias>
 <summary>Pseudo-channel for static packages</summary>
 <servers>
  <primary>
   <xmlrpc>
    <function version="1.0">****</function>
   </xmlrpc>
  </primary>
 </servers>
</channel><?xml version="1.0" encoding="ISO-8859-1"?>
<channel version="1.0" xmlns="http://pear.php.net/channel-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd">
 <name>__uri</name>
 <suggestedalias>__uri</suggestedalias>
 <summary>Pseudo-channel for static packages</summary>
 <servers>
  <primary>
   <xmlrpc>
    <function version="1.0">****</function>
   </xmlrpc>
  </primary>
 </servers>
</channel><?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ch="http://pear.php.net/channel-1.0" targetNamespace="http://pear.php.net/channel-1.0" elementFormDefault="qualified">
 <xs:complexType name="function">
  <xs:simpleContent>
   <xs:extension base="xs:string">
    <xs:attribute name="version" use="required">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:pattern value="[0-9]+\.[0-9]+"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:attribute>
   </xs:extension>
  </xs:simpleContent>
 </xs:complexType>
 <xs:complexType name="functions">
  <xs:sequence>
   <xs:element name="function" type="ch:function" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType>
 <xs:complexType name="serverinternals">
  <xs:sequence>
   <xs:element name="xmlrpc" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
   <xs:element name="rest" minOccurs="0">
    <xs:complexType>
     <xs:sequence>
      <xs:element name="baseurl" maxOccurs="unbounded">
       <xs:complexType>
        <xs:simpleContent>
         <xs:extension base="xs:string">
          <xs:attribute name="type" type="xs:string" use="required"/>
         </xs:extension>
        </xs:simpleContent>
       </xs:complexType>
      </xs:element>
     </xs:sequence>
    </xs:complexType>
   </xs:element>
   <xs:element name="soap" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
  </xs:sequence>
  <xs:attribute name="port" type="xs:int" default="80"/>
  <xs:attribute name="ssl">
   <xs:simpleType>
    <xs:restriction base="xs:string">
     <xs:enumeration value="yes"/>
    </xs:restriction>
   </xs:simpleType>
  </xs:attribute>
 </xs:complexType>
 <xs:complexType name="mirrorinternals">
  <xs:sequence>
   <xs:element name="xmlrpc" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
   <xs:element name="rest" minOccurs="0">
    <xs:complexType>
     <xs:sequence>
      <xs:element name="baseurl" maxOccurs="unbounded">
       <xs:complexType>
        <xs:simpleContent>
         <xs:extension base="xs:string">
          <xs:attribute name="type" type="xs:string" use="required"/>
         </xs:extension>
        </xs:simpleContent>
       </xs:complexType>
      </xs:element>
     </xs:sequence>
    </xs:complexType>
   </xs:element>
   <xs:element name="soap" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
  </xs:sequence>
  <xs:attribute name="port" type="xs:int" default="80"/>
  <xs:attribute name="host" use="required"/>
  <xs:attribute name="ssl">
   <xs:simpleType>
    <xs:restriction base="xs:string">
     <xs:enumeration value="yes"/>
    </xs:restriction>
   </xs:simpleType>
  </xs:attribute>
 </xs:complexType>
 <xs:complexType name="server">
  <xs:sequence>
   <xs:element name="primary">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:serverinternals"/>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
   <xs:element name="mirror" type="ch:mirrorinternals" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType>
 <xs:complexType name="validatepackage">
  <xs:simpleContent>
   <xs:extension base="xs:string">
    <xs:attribute name="version"/>
   </xs:extension>
  </xs:simpleContent>
 </xs:complexType>
 <xs:simpleType name="channelname">
  <xs:restriction base="xs:string">
   <xs:pattern value="[A-Za-z][a-zA-Z0-9_.]+|__uri"/>
  </xs:restriction>
 </xs:simpleType>
 <xs:element name="channel">
  <xs:complexType>
   <xs:sequence>
     <xs:element name="name" type="ch:channelname"/>
    <xs:choice>
     <xs:sequence minOccurs="1" maxOccurs="1">
      <xs:element name="suggestedalias" type="ch:channelname"/>
      <xs:element name="summary" type="xs:string"/>
     </xs:sequence>
     <xs:sequence minOccurs="1" maxOccurs="1">
      <xs:element name="summary" type="xs:string"/>
      <xs:element name="suggestedalias" minOccurs="0" type="ch:channelname"/>
     </xs:sequence>
    </xs:choice>
    <xs:element name="validatepackage" minOccurs="0">
     <xs:complexType>
      <xs:simpleContent>
       <xs:restriction base="ch:validatepackage">
        <xs:pattern value="[A-Za-z][a-zA-Z0-9_]+"/>
       </xs:restriction>
      </xs:simpleContent>
     </xs:complexType>
    </xs:element>
    <xs:element name="servers" type="ch:server"/>
   </xs:sequence>
   <xs:attribute name="version" use="required">
    <xs:simpleType>
     <xs:restriction base="xs:string">
      <xs:pattern value="[0-9]+\.[0-9]+"/>
     </xs:restriction>
    </xs:simpleType>
   </xs:attribute>
  </xs:complexType>
 </xs:element>
</xs:schema>
<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ch="http://pear.php.net/channel-1.0" targetNamespace="http://pear.php.net/channel-1.0" elementFormDefault="qualified">
 <xs:complexType name="function">
  <xs:simpleContent>
   <xs:extension base="xs:string">
    <xs:attribute name="version" use="required">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:pattern value="[0-9]+\.[0-9]+"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:attribute>
   </xs:extension>
  </xs:simpleContent>
 </xs:complexType>
 <xs:complexType name="functions">
  <xs:sequence>
   <xs:element name="function" type="ch:function" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType>
 <xs:complexType name="serverinternals">
  <xs:sequence>
   <xs:element name="xmlrpc" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
   <xs:element name="rest" minOccurs="0">
    <xs:complexType>
     <xs:sequence>
      <xs:element name="baseurl" maxOccurs="unbounded">
       <xs:complexType>
        <xs:simpleContent>
         <xs:extension base="xs:string">
          <xs:attribute name="type" type="xs:string" use="required"/>
         </xs:extension>
        </xs:simpleContent>
       </xs:complexType>
      </xs:element>
     </xs:sequence>
    </xs:complexType>
   </xs:element>
   <xs:element name="soap" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
  </xs:sequence>
  <xs:attribute name="port" type="xs:int" default="80"/>
  <xs:attribute name="ssl">
   <xs:simpleType>
    <xs:restriction base="xs:string">
     <xs:enumeration value="yes"/>
    </xs:restriction>
   </xs:simpleType>
  </xs:attribute>
 </xs:complexType>
 <xs:complexType name="mirrorinternals">
  <xs:sequence>
   <xs:element name="xmlrpc" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
   <xs:element name="rest" minOccurs="0">
    <xs:complexType>
     <xs:sequence>
      <xs:element name="baseurl" maxOccurs="unbounded">
       <xs:complexType>
        <xs:simpleContent>
         <xs:extension base="xs:string">
          <xs:attribute name="type" type="xs:string" use="required"/>
         </xs:extension>
        </xs:simpleContent>
       </xs:complexType>
      </xs:element>
     </xs:sequence>
    </xs:complexType>
   </xs:element>
   <xs:element name="soap" minOccurs="0">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:functions">
       <xs:attribute name="path" type="xs:string"/>
      </xs:extension>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
  </xs:sequence>
  <xs:attribute name="port" type="xs:int" default="80"/>
  <xs:attribute name="host" use="required"/>
  <xs:attribute name="ssl">
   <xs:simpleType>
    <xs:restriction base="xs:string">
     <xs:enumeration value="yes"/>
    </xs:restriction>
   </xs:simpleType>
  </xs:attribute>
 </xs:complexType>
 <xs:complexType name="server">
  <xs:sequence>
   <xs:element name="primary">
    <xs:complexType>
     <xs:complexContent>
      <xs:extension base="ch:serverinternals"/>
     </xs:complexContent>
    </xs:complexType>
   </xs:element>
   <xs:element name="mirror" type="ch:mirrorinternals" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType>
 <xs:complexType name="validatepackage">
  <xs:simpleContent>
   <xs:extension base="xs:string">
    <xs:attribute name="version"/>
   </xs:extension>
  </xs:simpleContent>
 </xs:complexType>
 <xs:simpleType name="channelname">
  <xs:restriction base="xs:string">
   <xs:pattern value="[A-Za-z][a-zA-Z0-9_.]+|__uri"/>
  </xs:restriction>
 </xs:simpleType>
 <xs:element name="channel">
  <xs:complexType>
   <xs:sequence>
     <xs:element name="name" type="ch:channelname"/>
    <xs:choice>
     <xs:sequence minOccurs="1" maxOccurs="1">
      <xs:element name="suggestedalias" type="ch:channelname"/>
      <xs:element name="summary" type="xs:string"/>
     </xs:sequence>
     <xs:sequence minOccurs="1" maxOccurs="1">
      <xs:element name="summary" type="xs:string"/>
      <xs:element name="suggestedalias" minOccurs="0" type="ch:channelname"/>
     </xs:sequence>
    </xs:choice>
    <xs:element name="validatepackage" minOccurs="0">
     <xs:complexType>
      <xs:simpleContent>
       <xs:restriction base="ch:validatepackage">
        <xs:pattern value="[A-Za-z][a-zA-Z0-9_]+"/>
       </xs:restriction>
      </xs:simpleContent>
     </xs:complexType>
    </xs:element>
    <xs:element name="servers" type="ch:server"/>
   </xs:sequence>
   <xs:attribute name="version" use="required">
    <xs:simpleType>
     <xs:restriction base="xs:string">
      <xs:pattern value="[0-9]+\.[0-9]+"/>
     </xs:restriction>
    </xs:simpleType>
   </xs:attribute>
  </xs:complexType>
 </xs:element>
</xs:schema>
<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSpy v2005 rel. 3 U (http://www.altova.com) by Gregory Beaver (The Chiara String Quartet) -->
<!-- edited with XMLSPY v2004 rel. 4 U (http://www.xmlspy.com) by Greg Beaver (The Chiara String Quartet) -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://pear.php.net/dtd/package-2.0" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" targetNamespace="http://pear.php.net/dtd/package-2.0" elementFormDefault="qualified" attributeFormDefault="unqualified" xml:lang="EN">
 <xs:element name="package">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:choice>
     <xs:element ref="channel"/>
     <xs:element ref="uri"/>
    </xs:choice>
    <xs:element ref="extends" minOccurs="0"/>
    <xs:element ref="summary"/>
    <xs:element ref="description"/>
    <xs:element ref="lead" maxOccurs="unbounded"/>
    <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="contributor" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="helper" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="date"/>
    <xs:element ref="time" minOccurs="0"/>
    <xs:element ref="version"/>
    <xs:element ref="stability"/>
    <xs:element ref="license"/>
    <xs:element ref="notes"/>
    <xs:element ref="contents"/>
    <xs:element ref="compatible" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="dependencies"/>
    <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usesrole" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usestask" minOccurs="0" maxOccurs="unbounded"/>
    <xs:choice minOccurs="0">
     <xs:sequence>
      <xs:element ref="srcpackage"/>
      <xs:element ref="srcchannel"/>
     </xs:sequence>
     <xs:element name="srcuri" type="xs:anyURI">
      <xs:annotation>
       <xs:documentation>uri of the package that contains the source of this extension</xs:documentation>
      </xs:annotation>
     </xs:element>
    </xs:choice>
    <xs:choice>
     <xs:element ref="phprelease" maxOccurs="unbounded"/>
     <xs:element ref="extsrcrelease" maxOccurs="unbounded"/>
     <xs:element ref="extbinrelease" maxOccurs="unbounded"/>
     <xs:element ref="bundle"/>
    </xs:choice>
    <xs:element ref="changelog" minOccurs="0"/>
   </xs:sequence>
   <xs:attribute name="version" type="xs:string" fixed="2.0"/>
   <xs:attribute name="packagerversion" type="version"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="name" type="xs:string">
  <xs:annotation>
   <xs:documentation>this is ignored if the release type is bundle</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="summary" type="xs:string"/>
 <xs:element name="description" type="xs:string"/>
 <xs:element name="lead">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="developer">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="contributor">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="helper">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="date" type="xs:date"/>
 <xs:element name="version">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" type="version"/>
    <xs:element name="api" type="version"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="license">
  <xs:complexType>
   <xs:simpleContent>
    <xs:extension base="xs:string">
     <xs:attribute name="uri" type="xs:anyURI"/>
     <xs:attribute name="filesource" type="xs:string"/>
    </xs:extension>
   </xs:simpleContent>
  </xs:complexType>
 </xs:element>
 <xs:element name="stability">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="snapshot"/>
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
    <xs:element name="api">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="notes" type="xs:string"/>
 <xs:element name="contents">
  <xs:complexType>
   <xs:choice>
    <xs:element ref="dir" maxOccurs="unbounded"/>
    <xs:element ref="bundledpackage" maxOccurs="unbounded"/>
   </xs:choice>
  </xs:complexType>
 </xs:element>
 <xs:element name="dir">
  <xs:complexType>
   <xs:choice>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="dir" maxOccurs="unbounded"/>
     <xs:element ref="file" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="file" maxOccurs="unbounded"/>
     <xs:element ref="dir" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
   </xs:choice>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="name" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="file">
  <xs:complexType>
   <xs:choice>
    <xs:any namespace="http://pear.php.net/dtd/tasks-1.0" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
   </xs:choice>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="role" type="xs:string" use="required"/>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="md5sum" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="install">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="as" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="ignore">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="phprelease">
  <xs:annotation>
   <xs:documentation>for php script releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extsrcrelease">
  <xs:annotation>
   <xs:documentation>for extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="configureoption" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element name="binarypackage" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extbinrelease">
  <xs:annotation>
   <xs:documentation>for compiled extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="bundle">
  <xs:annotation>
   <xs:documentation>for bundling several releases together in one release</xs:documentation>
  </xs:annotation>
  <xs:complexType/>
 </xs:element>
 <xs:element name="filelist">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="install" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="ignore" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="dependencies">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="required"/>
    <xs:element ref="optional" minOccurs="0"/>
    <xs:element ref="group" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="nodefault">
  <xs:annotation>
   <xs:documentation>tells the installer not to install the default dependency group</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="required">
  <xs:annotation>
   <xs:documentation>absolute required dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php"/>
    <xs:element ref="pearinstaller"/>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="arch" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="group">
  <xs:annotation>
   <xs:documentation>all other optional dependency groups</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="hint" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="optional">
  <xs:annotation>
   <xs:documentation>simple optional dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="changelog">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" minOccurs="1" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="lead" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element name="version">
        <xs:complexType>
         <xs:sequence>
          <xs:element name="release" type="xs:string"/>
          <xs:element name="api" type="xs:string"/>
         </xs:sequence>
        </xs:complexType>
       </xs:element>
       <xs:element ref="stability"/>
       <xs:element ref="date"/>
       <xs:element ref="license"/>
       <xs:element ref="notes"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:simpleType name="version">
  <xs:annotation>
   <xs:documentation>version string regex</xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="[0-9]+(\.[0-9]+)*([a-zA-Z]+[0-9]*)?"/>
  </xs:restriction>
 </xs:simpleType>
 <xs:element name="extension">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="min" minOccurs="0"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="pearinstaller">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="php">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="installconditions">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php" minOccurs="0"/>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0"/>
    <xs:element ref="arch" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="exclude" type="version"/>
 <xs:element name="configureoption">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="default" type="xs:string"/>
   <xs:attribute name="prompt" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="arch">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="pattern"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extends" type="xs:string"/>
 <xs:element name="time" type="xs:time"/>
 <xs:element name="compatible">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="name"/>
    <xs:element name="channel"/>
    <xs:element ref="min"/>
    <xs:element ref="max"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="min" type="version"/>
 <xs:element name="max" type="version"/>
 <xs:element name="user" type="xs:string"/>
 <xs:element name="email" type="xs:string"/>
 <xs:element name="active">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:enumeration value="yes"/>
    <xs:enumeration value="no"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="recommended" type="version"/>
 <xs:element name="channel">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:pattern value="[A-Za-z][a-zA-Z0-9_.]+"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="uri" type="xs:anyURI"/>
 <xs:element name="pattern" type="xs:string"/>
 <xs:element name="conflicts"/>
 <xs:element name="os">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="srcpackage" type="xs:string">
  <xs:annotation>
   <xs:documentation>name of the package that contains the source of this extension (can be the same if the source and binaries are in the same package)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="srcchannel" type="xs:string"/>
 <xs:element name="bundledpackage" type="xs:string"/>
 <xs:element name="filename" type="xs:string"/>
 <xs:element name="providesextension" type="xs:string">
  <xs:annotation>
   <xs:documentation>if a package can provide one or more compatible extensions (dblib/sybase/mssql for instance)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="usesrole">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="role"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="usestask">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="task"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="role" type="xs:string"/>
 <xs:element name="task" type="xs:string"/>
</xs:schema>
<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSpy v2005 rel. 3 U (http://www.altova.com) by Gregory Beaver (The Chiara String Quartet) -->
<!-- edited with XMLSPY v2004 rel. 4 U (http://www.xmlspy.com) by Greg Beaver (The Chiara String Quartet) -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://pear.php.net/dtd/package-2.0" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" targetNamespace="http://pear.php.net/dtd/package-2.0" elementFormDefault="qualified" attributeFormDefault="unqualified" xml:lang="EN">
 <xs:element name="package">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:choice>
     <xs:element ref="channel"/>
     <xs:element ref="uri"/>
    </xs:choice>
    <xs:element ref="extends" minOccurs="0"/>
    <xs:element ref="summary"/>
    <xs:element ref="description"/>
    <xs:element ref="lead" maxOccurs="unbounded"/>
    <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="contributor" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="helper" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="date"/>
    <xs:element ref="time" minOccurs="0"/>
    <xs:element ref="version"/>
    <xs:element ref="stability"/>
    <xs:element ref="license"/>
    <xs:element ref="notes"/>
    <xs:element ref="contents"/>
    <xs:element ref="compatible" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="dependencies"/>
    <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usesrole" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usestask" minOccurs="0" maxOccurs="unbounded"/>
    <xs:choice minOccurs="0">
     <xs:sequence>
      <xs:element ref="srcpackage"/>
      <xs:element ref="srcchannel"/>
     </xs:sequence>
     <xs:element name="srcuri" type="xs:anyURI">
      <xs:annotation>
       <xs:documentation>uri of the package that contains the source of this extension</xs:documentation>
      </xs:annotation>
     </xs:element>
    </xs:choice>
    <xs:choice>
     <xs:element ref="phprelease" maxOccurs="unbounded"/>
     <xs:element ref="extsrcrelease" maxOccurs="unbounded"/>
     <xs:element ref="extbinrelease" maxOccurs="unbounded"/>
     <xs:element ref="bundle"/>
    </xs:choice>
    <xs:element ref="changelog" minOccurs="0"/>
   </xs:sequence>
   <xs:attribute name="version" type="xs:string" fixed="2.0"/>
   <xs:attribute name="packagerversion" type="version"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="name" type="xs:string">
  <xs:annotation>
   <xs:documentation>this is ignored if the release type is bundle</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="summary" type="xs:string"/>
 <xs:element name="description" type="xs:string"/>
 <xs:element name="lead">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="developer">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="contributor">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="helper">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="date" type="xs:date"/>
 <xs:element name="version">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" type="version"/>
    <xs:element name="api" type="version"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="license">
  <xs:complexType>
   <xs:simpleContent>
    <xs:extension base="xs:string">
     <xs:attribute name="uri" type="xs:anyURI"/>
     <xs:attribute name="filesource" type="xs:string"/>
    </xs:extension>
   </xs:simpleContent>
  </xs:complexType>
 </xs:element>
 <xs:element name="stability">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="snapshot"/>
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
    <xs:element name="api">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="notes" type="xs:string"/>
 <xs:element name="contents">
  <xs:complexType>
   <xs:choice>
    <xs:element ref="dir" maxOccurs="unbounded"/>
    <xs:element ref="bundledpackage" maxOccurs="unbounded"/>
   </xs:choice>
  </xs:complexType>
 </xs:element>
 <xs:element name="dir">
  <xs:complexType>
   <xs:choice>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="dir" maxOccurs="unbounded"/>
     <xs:element ref="file" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="file" maxOccurs="unbounded"/>
     <xs:element ref="dir" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
   </xs:choice>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="name" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="file">
  <xs:complexType>
   <xs:choice>
    <xs:any namespace="http://pear.php.net/dtd/tasks-1.0" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
   </xs:choice>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="role" type="xs:string" use="required"/>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="md5sum" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="install">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="as" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="ignore">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="phprelease">
  <xs:annotation>
   <xs:documentation>for php script releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extsrcrelease">
  <xs:annotation>
   <xs:documentation>for extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="configureoption" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element name="binarypackage" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extbinrelease">
  <xs:annotation>
   <xs:documentation>for compiled extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="bundle">
  <xs:annotation>
   <xs:documentation>for bundling several releases together in one release</xs:documentation>
  </xs:annotation>
  <xs:complexType/>
 </xs:element>
 <xs:element name="filelist">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="install" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="ignore" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="dependencies">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="required"/>
    <xs:element ref="optional" minOccurs="0"/>
    <xs:element ref="group" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="nodefault">
  <xs:annotation>
   <xs:documentation>tells the installer not to install the default dependency group</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="required">
  <xs:annotation>
   <xs:documentation>absolute required dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php"/>
    <xs:element ref="pearinstaller"/>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="arch" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="group">
  <xs:annotation>
   <xs:documentation>all other optional dependency groups</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="hint" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="optional">
  <xs:annotation>
   <xs:documentation>simple optional dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="changelog">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" minOccurs="1" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="lead" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element name="version">
        <xs:complexType>
         <xs:sequence>
          <xs:element name="release" type="xs:string"/>
          <xs:element name="api" type="xs:string"/>
         </xs:sequence>
        </xs:complexType>
       </xs:element>
       <xs:element ref="stability"/>
       <xs:element ref="date"/>
       <xs:element ref="license"/>
       <xs:element ref="notes"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:simpleType name="version">
  <xs:annotation>
   <xs:documentation>version string regex</xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="[0-9]+(\.[0-9]+)*([a-zA-Z]+[0-9]*)?"/>
  </xs:restriction>
 </xs:simpleType>
 <xs:element name="extension">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="min" minOccurs="0"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="pearinstaller">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="php">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="installconditions">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php" minOccurs="0"/>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0"/>
    <xs:element ref="arch" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="exclude" type="version"/>
 <xs:element name="configureoption">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="default" type="xs:string"/>
   <xs:attribute name="prompt" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="arch">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="pattern"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extends" type="xs:string"/>
 <xs:element name="time" type="xs:time"/>
 <xs:element name="compatible">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="name"/>
    <xs:element name="channel"/>
    <xs:element ref="min"/>
    <xs:element ref="max"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="min" type="version"/>
 <xs:element name="max" type="version"/>
 <xs:element name="user" type="xs:string"/>
 <xs:element name="email" type="xs:string"/>
 <xs:element name="active">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:enumeration value="yes"/>
    <xs:enumeration value="no"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="recommended" type="version"/>
 <xs:element name="channel">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:pattern value="[A-Za-z][a-zA-Z0-9_.]+"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="uri" type="xs:anyURI"/>
 <xs:element name="pattern" type="xs:string"/>
 <xs:element name="conflicts"/>
 <xs:element name="os">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="srcpackage" type="xs:string">
  <xs:annotation>
   <xs:documentation>name of the package that contains the source of this extension (can be the same if the source and binaries are in the same package)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="srcchannel" type="xs:string"/>
 <xs:element name="bundledpackage" type="xs:string"/>
 <xs:element name="filename" type="xs:string"/>
 <xs:element name="providesextension" type="xs:string">
  <xs:annotation>
   <xs:documentation>if a package can provide one or more compatible extensions (dblib/sybase/mssql for instance)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="usesrole">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="role"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="usestask">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="task"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="role" type="xs:string"/>
 <xs:element name="task" type="xs:string"/>
</xs:schema>
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://pear.php.net/dtd/package-2.1" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" targetNamespace="http://pear.php.net/dtd/package-2.1" elementFormDefault="qualified" attributeFormDefault="unqualified" xml:lang="EN">
 <xs:element name="package">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:choice>
     <xs:element ref="channel"/>
     <xs:element ref="uri"/>
    </xs:choice>
    <xs:element ref="extends" minOccurs="0"/>
    <xs:element ref="summary"/>
    <xs:element ref="description"/>
    <xs:element ref="lead" maxOccurs="unbounded"/>
    <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="contributor" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="helper" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="date"/>
    <xs:element ref="time" minOccurs="0"/>
    <xs:element ref="version"/>
    <xs:element ref="stability"/>
    <xs:element ref="license"/>
    <xs:element ref="notes"/>
    <xs:element ref="contents"/>
    <xs:element ref="compatible" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="dependencies"/>
    <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usesrole" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usestask" minOccurs="0" maxOccurs="unbounded"/>
    <xs:choice minOccurs="0">
     <xs:sequence>
      <xs:element ref="srcpackage"/>
      <xs:element ref="srcchannel"/>
     </xs:sequence>
     <xs:element name="srcuri" type="xs:anyURI">
      <xs:annotation>
       <xs:documentation>uri of the package that contains the source of this extension</xs:documentation>
      </xs:annotation>
     </xs:element>
    </xs:choice>
    <xs:choice>
     <xs:element ref="phprelease" maxOccurs="unbounded"/>
     <xs:element ref="extsrcrelease" maxOccurs="unbounded"/>
     <xs:element ref="extbinrelease" maxOccurs="unbounded"/>
     <xs:element ref="bundle"/>
     <xs:element ref="zendextsrcrelease" maxOccurs="unbounded"/>
     <xs:element ref="zendextbinrelease" maxOccurs="unbounded"/>
    </xs:choice>
    <xs:element ref="changelog" minOccurs="0"/>
   </xs:sequence>
   <xs:attribute name="version" type="xs:string" fixed="2.1"/>
   <xs:attribute name="packagerversion" type="version"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="name" type="xs:string">
  <xs:annotation>
   <xs:documentation>this is ignored if the release type is bundle</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="summary" type="xs:string"/>
 <xs:element name="description" type="xs:string"/>
 <xs:element name="lead">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="developer">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="contributor">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="helper">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="date" type="xs:date"/>
 <xs:element name="version">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" type="version"/>
    <xs:element name="api" type="version"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="license">
  <xs:complexType>
   <xs:simpleContent>
    <xs:extension base="xs:string">
     <xs:attribute name="uri" type="xs:anyURI"/>
     <xs:attribute name="filesource" type="xs:string"/>
    </xs:extension>
   </xs:simpleContent>
  </xs:complexType>
 </xs:element>
 <xs:element name="stability">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="snapshot"/>
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
    <xs:element name="api">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="notes" type="xs:string"/>
 <xs:element name="contents">
  <xs:complexType>
   <xs:choice>
    <xs:element ref="dir" maxOccurs="unbounded"/>
    <xs:element ref="bundledpackage" maxOccurs="unbounded"/>
   </xs:choice>
  </xs:complexType>
 </xs:element>
 <xs:element name="dir">
  <xs:complexType>
   <xs:choice>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="dir" maxOccurs="unbounded"/>
     <xs:element ref="file" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="file" maxOccurs="unbounded"/>
     <xs:element ref="dir" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
   </xs:choice>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="name" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="file">
  <xs:complexType>
   <xs:choice>
    <xs:any namespace="http://pear.php.net/dtd/tasks-1.0" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
   </xs:choice>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="role" type="xs:string" use="required"/>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="md5sum" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="install">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="as" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="ignore">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="phprelease">
  <xs:annotation>
   <xs:documentation>for php script releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extsrcrelease">
  <xs:annotation>
   <xs:documentation>for extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="configureoption" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element name="binarypackage" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="zendextsrcrelease">
  <xs:annotation>
   <xs:documentation>for zend extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="configureoption" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element name="binarypackage" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extbinrelease">
  <xs:annotation>
   <xs:documentation>for compiled extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="zendextbinrelease">
  <xs:annotation>
   <xs:documentation>for compiled zend extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="bundle">
  <xs:annotation>
   <xs:documentation>for bundling several releases together in one release</xs:documentation>
  </xs:annotation>
  <xs:complexType/>
 </xs:element>
 <xs:element name="filelist">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="install" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="ignore" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="dependencies">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="required"/>
    <xs:element ref="optional" minOccurs="0"/>
    <xs:element ref="group" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="nodefault">
  <xs:annotation>
   <xs:documentation>tells the installer not to install the default dependency group</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="required">
  <xs:annotation>
   <xs:documentation>absolute required dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php"/>
    <xs:element ref="pearinstaller"/>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="arch" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="group">
  <xs:annotation>
   <xs:documentation>all other optional dependency groups</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="hint" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="optional">
  <xs:annotation>
   <xs:documentation>simple optional dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="changelog">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" minOccurs="1" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="lead" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element name="version">
        <xs:complexType>
         <xs:sequence>
          <xs:element name="release" type="xs:string"/>
          <xs:element name="api" type="xs:string"/>
         </xs:sequence>
        </xs:complexType>
       </xs:element>
       <xs:element ref="stability"/>
       <xs:element ref="date"/>
       <xs:element ref="license"/>
       <xs:element ref="notes"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:simpleType name="version">
  <xs:annotation>
   <xs:documentation>version string regex</xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="[0-9]+(\.[0-9]+)*([a-zA-Z]+[0-9]*)?"/>
  </xs:restriction>
 </xs:simpleType>
 <xs:element name="extension">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="min" minOccurs="0"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="pearinstaller">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="php">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="installconditions">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php" minOccurs="0"/>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0"/>
    <xs:element ref="arch" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="exclude" type="version"/>
 <xs:element name="configureoption">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="default" type="xs:string"/>
   <xs:attribute name="prompt" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="arch">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="pattern"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extends" type="xs:string"/>
 <xs:element name="time" type="xs:time"/>
 <xs:element name="compatible">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="name"/>
    <xs:element name="channel"/>
    <xs:element ref="min"/>
    <xs:element ref="max"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="min" type="version"/>
 <xs:element name="max" type="version"/>
 <xs:element name="user" type="xs:string"/>
 <xs:element name="email" type="xs:string"/>
 <xs:element name="active">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:enumeration value="yes"/>
    <xs:enumeration value="no"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="recommended" type="version"/>
 <xs:element name="channel">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:pattern value="[A-Za-z][a-zA-Z0-9_.]+"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="uri" type="xs:anyURI"/>
 <xs:element name="pattern" type="xs:string"/>
 <xs:element name="conflicts"/>
 <xs:element name="os">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="srcpackage" type="xs:string">
  <xs:annotation>
   <xs:documentation>name of the package that contains the source of this extension (can be the same if the source and binaries are in the same package)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="srcchannel" type="xs:string"/>
 <xs:element name="bundledpackage" type="xs:string"/>
 <xs:element name="filename" type="xs:string"/>
 <xs:element name="providesextension" type="xs:string">
  <xs:annotation>
   <xs:documentation>if a package can provide one or more compatible extensions (dblib/sybase/mssql for instance)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="usesrole">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="role"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="usestask">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="task"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="role" type="xs:string"/>
 <xs:element name="task" type="xs:string"/>
</xs:schema>
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://pear.php.net/dtd/package-2.1" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" targetNamespace="http://pear.php.net/dtd/package-2.1" elementFormDefault="qualified" attributeFormDefault="unqualified" xml:lang="EN">
 <xs:element name="package">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:choice>
     <xs:element ref="channel"/>
     <xs:element ref="uri"/>
    </xs:choice>
    <xs:element ref="extends" minOccurs="0"/>
    <xs:element ref="summary"/>
    <xs:element ref="description"/>
    <xs:element ref="lead" maxOccurs="unbounded"/>
    <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="contributor" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="helper" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="date"/>
    <xs:element ref="time" minOccurs="0"/>
    <xs:element ref="version"/>
    <xs:element ref="stability"/>
    <xs:element ref="license"/>
    <xs:element ref="notes"/>
    <xs:element ref="contents"/>
    <xs:element ref="compatible" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="dependencies"/>
    <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usesrole" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="usestask" minOccurs="0" maxOccurs="unbounded"/>
    <xs:choice minOccurs="0">
     <xs:sequence>
      <xs:element ref="srcpackage"/>
      <xs:element ref="srcchannel"/>
     </xs:sequence>
     <xs:element name="srcuri" type="xs:anyURI">
      <xs:annotation>
       <xs:documentation>uri of the package that contains the source of this extension</xs:documentation>
      </xs:annotation>
     </xs:element>
    </xs:choice>
    <xs:choice>
     <xs:element ref="phprelease" maxOccurs="unbounded"/>
     <xs:element ref="extsrcrelease" maxOccurs="unbounded"/>
     <xs:element ref="extbinrelease" maxOccurs="unbounded"/>
     <xs:element ref="bundle"/>
     <xs:element ref="zendextsrcrelease" maxOccurs="unbounded"/>
     <xs:element ref="zendextbinrelease" maxOccurs="unbounded"/>
    </xs:choice>
    <xs:element ref="changelog" minOccurs="0"/>
   </xs:sequence>
   <xs:attribute name="version" type="xs:string" fixed="2.1"/>
   <xs:attribute name="packagerversion" type="version"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="name" type="xs:string">
  <xs:annotation>
   <xs:documentation>this is ignored if the release type is bundle</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="summary" type="xs:string"/>
 <xs:element name="description" type="xs:string"/>
 <xs:element name="lead">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="developer">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="contributor">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="helper">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="user"/>
    <xs:element ref="email"/>
    <xs:element ref="active"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="date" type="xs:date"/>
 <xs:element name="version">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" type="version"/>
    <xs:element name="api" type="version"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="license">
  <xs:complexType>
   <xs:simpleContent>
    <xs:extension base="xs:string">
     <xs:attribute name="uri" type="xs:anyURI"/>
     <xs:attribute name="filesource" type="xs:string"/>
    </xs:extension>
   </xs:simpleContent>
  </xs:complexType>
 </xs:element>
 <xs:element name="stability">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="snapshot"/>
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
    <xs:element name="api">
     <xs:simpleType>
      <xs:restriction base="xs:string">
       <xs:enumeration value="devel"/>
       <xs:enumeration value="alpha"/>
       <xs:enumeration value="beta"/>
       <xs:enumeration value="stable"/>
      </xs:restriction>
     </xs:simpleType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="notes" type="xs:string"/>
 <xs:element name="contents">
  <xs:complexType>
   <xs:choice>
    <xs:element ref="dir" maxOccurs="unbounded"/>
    <xs:element ref="bundledpackage" maxOccurs="unbounded"/>
   </xs:choice>
  </xs:complexType>
 </xs:element>
 <xs:element name="dir">
  <xs:complexType>
   <xs:choice>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="dir" maxOccurs="unbounded"/>
     <xs:element ref="file" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:sequence maxOccurs="unbounded">
     <xs:element ref="file" maxOccurs="unbounded"/>
     <xs:element ref="dir" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
   </xs:choice>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="name" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="file">
  <xs:complexType>
   <xs:choice>
    <xs:any namespace="http://pear.php.net/dtd/tasks-1.0" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
   </xs:choice>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="role" type="xs:string" use="required"/>
   <xs:attribute name="baseinstalldir" type="xs:string"/>
   <xs:attribute name="md5sum" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="install">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="as" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="ignore">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="phprelease">
  <xs:annotation>
   <xs:documentation>for php script releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extsrcrelease">
  <xs:annotation>
   <xs:documentation>for extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="configureoption" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element name="binarypackage" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="zendextsrcrelease">
  <xs:annotation>
   <xs:documentation>for zend extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="configureoption" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element name="binarypackage" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extbinrelease">
  <xs:annotation>
   <xs:documentation>for compiled extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="zendextbinrelease">
  <xs:annotation>
   <xs:documentation>for compiled zend extension source releases</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="installconditions" minOccurs="0"/>
    <xs:element ref="filelist" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="bundle">
  <xs:annotation>
   <xs:documentation>for bundling several releases together in one release</xs:documentation>
  </xs:annotation>
  <xs:complexType/>
 </xs:element>
 <xs:element name="filelist">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="install" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="ignore" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="dependencies">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="required"/>
    <xs:element ref="optional" minOccurs="0"/>
    <xs:element ref="group" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="nodefault">
  <xs:annotation>
   <xs:documentation>tells the installer not to install the default dependency group</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="required">
  <xs:annotation>
   <xs:documentation>absolute required dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php"/>
    <xs:element ref="pearinstaller"/>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="arch" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="group">
  <xs:annotation>
   <xs:documentation>all other optional dependency groups</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="conflicts" minOccurs="0"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="hint" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="optional">
  <xs:annotation>
   <xs:documentation>simple optional dependencies</xs:documentation>
  </xs:annotation>
  <xs:complexType>
   <xs:sequence>
    <xs:element name="package" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element name="subpackage" minOccurs="0" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="name"/>
       <xs:choice>
        <xs:sequence>
         <xs:element ref="channel"/>
         <xs:element ref="min" minOccurs="0"/>
         <xs:element ref="max" minOccurs="0"/>
         <xs:element ref="recommended" minOccurs="0"/>
         <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element ref="nodefault" minOccurs="0"/>
        </xs:sequence>
        <xs:element ref="uri"/>
       </xs:choice>
       <xs:element ref="providesextension" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="changelog">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="release" minOccurs="1" maxOccurs="unbounded">
     <xs:complexType>
      <xs:sequence>
       <xs:element ref="lead" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element ref="developer" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element name="version">
        <xs:complexType>
         <xs:sequence>
          <xs:element name="release" type="xs:string"/>
          <xs:element name="api" type="xs:string"/>
         </xs:sequence>
        </xs:complexType>
       </xs:element>
       <xs:element ref="stability"/>
       <xs:element ref="date"/>
       <xs:element ref="license"/>
       <xs:element ref="notes"/>
      </xs:sequence>
     </xs:complexType>
    </xs:element>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:simpleType name="version">
  <xs:annotation>
   <xs:documentation>version string regex</xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="[0-9]+(\.[0-9]+)*([a-zA-Z]+[0-9]*)?"/>
  </xs:restriction>
 </xs:simpleType>
 <xs:element name="extension">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="min" minOccurs="0"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="pearinstaller">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="recommended" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="php">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="min"/>
    <xs:element ref="max" minOccurs="0"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="installconditions">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="php" minOccurs="0"/>
    <xs:element ref="extension" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="os" minOccurs="0"/>
    <xs:element ref="arch" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="exclude" type="version"/>
 <xs:element name="configureoption">
  <xs:complexType>
   <xs:attribute name="name" type="xs:string" use="required"/>
   <xs:attribute name="default" type="xs:string"/>
   <xs:attribute name="prompt" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
 <xs:element name="arch">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="pattern"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="extends" type="xs:string"/>
 <xs:element name="time" type="xs:time"/>
 <xs:element name="compatible">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="name"/>
    <xs:element name="channel"/>
    <xs:element ref="min"/>
    <xs:element ref="max"/>
    <xs:element ref="exclude" minOccurs="0" maxOccurs="unbounded"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="min" type="version"/>
 <xs:element name="max" type="version"/>
 <xs:element name="user" type="xs:string"/>
 <xs:element name="email" type="xs:string"/>
 <xs:element name="active">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:enumeration value="yes"/>
    <xs:enumeration value="no"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="recommended" type="version"/>
 <xs:element name="channel">
  <xs:simpleType>
   <xs:restriction base="xs:string">
    <xs:pattern value="[A-Za-z][a-zA-Z0-9_.]+"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:element>
 <xs:element name="uri" type="xs:anyURI"/>
 <xs:element name="pattern" type="xs:string"/>
 <xs:element name="conflicts"/>
 <xs:element name="os">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="name"/>
    <xs:element ref="conflicts" minOccurs="0"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="srcpackage" type="xs:string">
  <xs:annotation>
   <xs:documentation>name of the package that contains the source of this extension (can be the same if the source and binaries are in the same package)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="srcchannel" type="xs:string"/>
 <xs:element name="bundledpackage" type="xs:string"/>
 <xs:element name="filename" type="xs:string"/>
 <xs:element name="providesextension" type="xs:string">
  <xs:annotation>
   <xs:documentation>if a package can provide one or more compatible extensions (dblib/sybase/mssql for instance)</xs:documentation>
  </xs:annotation>
 </xs:element>
 <xs:element name="usesrole">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="role"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="usestask">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="task"/>
    <xs:choice>
     <xs:sequence>
      <xs:element name="package" type="xs:string"/>
      <xs:element ref="channel"/>
     </xs:sequence>
     <xs:element ref="uri"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
 <xs:element name="role" type="xs:string"/>
 <xs:element name="task" type="xs:string"/>
</xs:schema>
<?php
/**
 * PEAR2_Pyrus_AtomicFileTransaction_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for atomic file transaction mechanism
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_AtomicFileTransaction_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Channel_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for channels
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Channel_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Channel_IMirror
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for channel mirrors
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_Channel_IMirror
{
    public function getChannel();
}<?php
/**
 * PEAR2_Pyrus_Channel_Remotepackage
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Remote REST iteration handler
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Channel_Remotepackage extends PEAR2_Pyrus_PackageFile_v2 implements ArrayAccess, Iterator
{
    protected $parent;
    protected $rest;
    protected $releaseList;
    protected $remotedeps;
    protected $remoteAbridgedInfo;
    protected $versionSet = false;
    protected $minimumStability;
    protected $explicitVersion;
    /**
     * Flag used to determine whether this package has been tested for upgradeability
     */
    protected $isUpgradeable = null;

    function __construct(PEAR2_Pyrus_IChannelFile $channelinfo, $releases = null)
    {
        $this->parent = $channelinfo;
        if (!isset($this->parent->protocols->rest['REST1.0'])) {
            throw new PEAR2_Pyrus_Channel_Exception('Cannot access remote packages without REST1.0 protocol');
        }
        // instruct parent::__set() to call $this->setRawVersion() when setting rawversion
        $this->rawMap['rawversion'] = array('setRawVersion');
        $this->rest = new PEAR2_Pyrus_REST;
        $this->releaseList = $releases;
        $this->minimumStability = PEAR2_Pyrus_Config::current()->preferred_state;
        $this->explicitVersion = false;
    }

    /**
     * Sets the minimum stability allowed.
     *
     * This is set by a call to a package such as "pyrus install Pname-stable"
     * or "pyrus install Pname-beta"
     *
     * The stability is only changed if it is less stable than preferred_state.
     * @param string
     */
    function setExplicitState($stability)
    {
        $states = PEAR2_Pyrus_Installer::betterStates($this->minimumStability);
        $newstates = PEAR2_Pyrus_Installer::betterStates($stability);
        if (count($newstates) > count($states)) {
            $this->minimumStability = $stability;
        }
    }

    function setExplicitVersion($version)
    {
        $this->explicitVersion = $version;
    }

    function setUpgradeable()
    {
        $this->isUpgradeable = true;
    }

    function isUpgradeable()
    {
        return $this->isUpgradeable;
    }

    function setRawVersion($var, $value)
    {
        if (isset($this->parent->protocols->rest['REST1.3'])) {
            $a = $this->remoteAbridgedInfo = $this->rest->retrieveCacheFirst(
                                                        $this->parent->protocols->rest['REST1.3']->baseurl .
                                                        'r/' . strtolower($this->name) . '/v2.' . $value['release'] . '.xml');
            $this->packageInfo['version']['api'] = $a['a'];
        } else {
            $a = $this->remoteAbridgedInfo = $this->rest->retrieveCacheFirst(
                                                        $this->parent->protocols->rest['REST1.0']->baseurl .
                                                        'r/' . strtolower($this->name) . '/v2.' . $value['release'] . '.xml');
        }
        $this->packageInfo['version'] = $value;
        $this->stability['release'] = $a['st'];
        $this->license['name'] = $a['l'];
        $this->summary = $a['s'];
        $this->description = $a['d'];
        list($this->date, $this->time) = explode(' ', $a['da']);
        $this->notes = $a['n'];
        $this->versionSet = true;
    }

    function download()
    {
        if (!$this->versionSet) {
            // this happens when doing a simple download outside of an install
            $this->rewind();
            $ok = PEAR2_Pyrus_Installer::betterStates($this->minimumStability, true);
            foreach ($this->releaseList as $versioninfo) {
                if (isset($versioninfo['m'])) {
                    // minimum PHP version required
                    if (version_compare($versioninfo['m'], $this->getPHPVersion(), '>=')) {
                        continue;
                    }
                }

                if (!in_array($versioninfo['s'], $ok) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                    // release is not stable enough
                    continue;
                }
                $this->version['release'] = $versioninfo['v'];
                break;
            }
        }
        $url = $this->remoteAbridgedInfo['g'];
        // first try to download .phar, then .tgz, then .tar, then .zip
        $errs = new PEAR2_MultiErrors;
        try {
            return new PEAR2_Pyrus_Package_Remote($url . '.phar');
        } catch (Exception $e) {
            $errs->E_ERROR[] = $e;
        }
    
        try {
            return new PEAR2_Pyrus_Package_Remote($url . '.tgz');
        } catch (Exception $e) {
            $errs->E_ERROR[] = $e;
        }

        try {
            return new PEAR2_Pyrus_Package_Remote($url . '.tar');
        } catch (Exception $e) {
            $errs->E_ERROR[] = $e;
        }

        try {
            return new PEAR2_Pyrus_Package_Remote($url . '.zip');
        } catch (Exception $e) {
            $errs->E_ERROR[] = $e;
            throw new PEAR2_Pyrus_Package_Exception(
                'Could not download abstract package ' .
                $this->channel . '/' .
                $this->name, $errs);
        }
    }

    function offsetGet($var)
    {
        $lowerpackage = strtolower($var);
        try {
            $info = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                    'p/' . $lowerpackage . '/info.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Channel_Exception('package ' . $var . ' does not exist', $e);
        }
        if (is_string($this->releaseList)) {
            $ok = PEAR2_Pyrus_Installer::betterStates($this->releaseList, true);
            if (isset($this->parent->protocols->rest['REST1.3'])) {
                $rinfo = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.3']->baseurl .
                                                        'r/' . $lowerpackage . '/allreleases2.xml');
            } else {
                $rinfo = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                        'r/' . $lowerpackage . '/allreleases.xml');
            }
            if (!isset($rinfo['r'][0])) {
                $rinfo['r'] = array($rinfo['r']);
            }
            $releases = array();
            foreach ($rinfo['r'] as $release) {
                if (!in_array($release['s'], $ok)) {
                    continue;
                }
                if (!isset($release['m'])) {
                    $release['m'] = '5.2.0';
                }
                $releases[] = $release;
            }
            $this->releaseList = $releases;
        }
        $pxml = clone $this;
        $pxml->channel = $info['c'];
        $pxml->name = $info['n'];
        $pxml->license = $info['l'];
        $pxml->summary = $info['s'];
        $pxml->description = $info['d'];
        return $pxml;
    }

    function offsetSet($var, $value)
    {
        throw new PEAR2_Pyrus_Channel_Exception('remote channel info is read-only');
    }

    function offsetUnset($var)
    {
        throw new PEAR2_Pyrus_Channel_Exception('remote channel info is read-only');
    }

    /**
     * This is very expensive, use sparingly if at all
     */
    function offsetExists($var)
    {
        try {
            $info = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                    'p/' . strtolower($var) . '/info.xml');
        } catch (Exception $e) {
            return false;
        }
        return true;
    }

    function valid()
    {
        return current($this->releaseList);
    }

    function current()
    {
        $info = current($this->releaseList);
        if (!isset($info['m'])) {
            $info['m'] = '5.2.0'; // guess something lower than us
        }
        // setting this allows us to retrieve information specific to this
        // version
        $this->version['release'] = $info['v'];
        return array('stability' => $info['s'], 'minimumphp' => $info['m']);
    }

    function key()
    {
        $info = current($this->releaseList);
        return $info['v'];
    }

    function next()
    {
        return next($this->releaseList);
    }

    function rewind()
    {
        if ($this->releaseList) {
            return reset($this->releaseList);
        }
        if (!$this->name) {
            throw new PEAR2_Pyrus_Channel_Exception('Cannot iterate without first choosing a remote package');
        }
        if (isset($this->parent->protocols->rest['REST1.3'])) {
            $info = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.3']->baseurl .
                                                    'r/' . strtolower($this->name) . '/allreleases2.xml');
        } else {
            $info = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                    'r/' . strtolower($this->name) . '/allreleases.xml');
        }
        $this->releaseList = $info['r'];
        if (!isset($this->releaseList[0])) {
            $this->releaseList = array($this->releaseList);
        }
    }

    function getDependencies()
    {
        // dynamically retrieve the dependencies from the remote server when requested
        $deps = unserialize($this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                    'r/' . strtolower($this->name) . '/deps.' .
                                                    $this->version['release'] . '.txt'));
        if ($deps) {
            $this->packageInfo['dependencies'] = $deps;
        }
        return parent::getDependencies();
    }

    function getMaintainer()
    {
        if (isset($this->parent->protocols->rest['REST1.2'])) {
            $maintainers = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.2']->baseurl .
                                                    'p/' . strtolower($this->name) . '/maintainers2.xml');
            $maintainers = $maintainers['m'];
            if (!isset($maintainers[0])) {
                $maintainers = array($maintainers);
            }
            $info = array('lead' => array(), 'developer' => array(), 'contributor' => array(), 'helper' => array());
            foreach ($maintainers as $maintainer) {
                $minfo = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                    'm/' . $maintainer['h'] . '/info.xml');
                $info[$maintainer['r']][] = array('name' => $minfo['n'],
                                                  'user' => $maintainer['h'],
                                                  'email' => '*hidden*',
                                                  'active' => 'yes');
            }
        } else {
            $maintainers = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                    'p/' . strtolower($this->name) . '/maintainers.xml');
            $maintainers = $maintainers['m'];
            if (!isset($maintainers[0])) {
                $maintainers = array($maintainers);
            }
            $info = array('lead' => array(), 'developer' => array(), 'contributor' => array(), 'helper' => array());
            foreach ($maintainers as $maintainer) {
                $minfo = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                    'm/' . $maintainer['h'] . '/info.xml');
                $info['lead'][] = array('name' => $minfo['n'],
                                        'user' => $maintainer['h'],
                                        'email' => '*hidden*',
                                        'active' => 'yes');
            }
        }
        foreach ($info as $role => $peoples) {
            foreach ($peoples as $dev) {
                $this->packageInfo[$role][] = $dev;
            }
        }
        return parent::getMaintainer();
    }

    /**
     * For unit testing purposes
     */
    function getPHPVersion()
    {
        return phpversion();
    }
    /**
     * Figure out which version is best, and use this, or error out if none work
     * @param PEAR2_Pyrus_PackageFile_v2_Dependencies_Package $compositeDep
     *        the composite of all dependencies on this package, as calculated
     *        by {@link PEAR2_Pyrus_Package_Dependency::getCompositeDependency()}
     */
    function figureOutBestVersion(PEAR2_Pyrus_PackageFile_v2_Dependencies_Package $compositeDep)
    {
        // set up release list if not done yet
        $this->rewind();
        $ok = PEAR2_Pyrus_Installer::betterStates($this->minimumStability, true);
        $v = $this->explicitVersion;
        $n = $this->channel . '/' . $this->name;
        $failIfExplicit = function() use ($v, $n) {
            if ($v && $versioninfo['v'] == $v) {
                throw new PEAR2_Pyrus_Channel_Exception($n .
                                                        ' Cannot be installed, it does not satisfy ' .
                                                        'all dependencies');
            }
        };
        foreach ($this->releaseList as $versioninfo) {
            if (isset($versioninfo['m'])) {
                // minimum PHP version required
                if (version_compare($versioninfo['m'], $this->getPHPVersion(), '>=')) {
                    $failIfExplicit();
                    continue;
                }
            }
            // now check for versions satisfying the dependency
            if (isset($compositeDep->min)) {
                if (version_compare($versioninfo['v'], $compositeDep->min, '<')) {
                    $failIfExplicit();
                    continue;
                }
            }
            if (isset($compositeDep->exclude)) {
                foreach ($compositeDep->exclude as $exclude) {
                    if ($versioninfo['v'] == $exclude) {
                        $failIfExplicit();
                        continue 2;
                    }
                }
            }
            if (isset($compositeDep->max)) {
                if (version_compare($versioninfo['v'], $compositeDep->max, '>')) {
                    $failIfExplicit();
                    continue;
                }
            }
            if (isset($compositeDep->recommended)) {
                if ($versioninfo['v'] == $compositeDep->recommended) {
                    // we're done.  That was easy.
                    $this->version['release'] = $versioninfo['v'];
                    return;
                }
                continue;
            }

            if (!in_array($versioninfo['s'], $ok) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                // release is not stable enough
                continue;
            }
            if ($this->explicitVersion && $versioninfo['v'] != $this->explicitVersion) {
                continue;
            }
            // found one
            if ($this->versionSet && $versioninfo['v'] != $this->version['release']) {
                // inform the installer we need to reset dependencies
                $this->version['release'] = $versioninfo['v'];
                return true;
            }
            $this->version['release'] = $versioninfo['v'];
            return;
        }
        throw new PEAR2_Pyrus_Channel_Exception('Unable to locate a package release for ' .
                                                $this->channel . '/' . $this->name .
                                                ' that can satisfy all dependencies');
    }
}<?php
/**
 * PEAR2_Pyrus_Channel_Remotepackages
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Remote REST iteration handler for package listing
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Channel_Remotepackages implements ArrayAccess, Iterator
{
    protected $parent;
    public $stability = null;
    protected $rest;
    protected $packageList;

    function __construct(PEAR2_Pyrus_IChannel $channelinfo)
    {
        $this->parent = $channelinfo;
        if (!isset($this->parent->protocols->rest['REST1.0'])) {
            throw new PEAR2_Pyrus_Channel_Exception('Cannot access remote packages without REST1.0 protocol');
        }
        $this->rest = new PEAR2_Pyrus_REST;
    }

    function offsetGet($var)
    {
        if ($var !== 'devel' && $var !== 'alpha' && $var !== 'beta' && $var !== 'stable') {
            throw new PEAR2_Pyrus_Channel_Exception('Invalid stability requested, must be one of ' .
                                                    'devel, alpha, beta, stable');
        }
        $a = clone $this;
        $a->stability = $var;
        return $a;
    }

    function offsetSet($var, $value)
    {
        throw new PEAR2_Pyrus_Channel_Exception('remote channel info is read-only');
    }

    function offsetUnset($var)
    {
        throw new PEAR2_Pyrus_Channel_Exception('remote channel info is read-only');
    }

    function offsetExists($var)
    {
        // implement this
    }

    function valid()
    {
        return current($this->packageList);
    }

    function current()
    {
        if ($this->stability) {
            $info = current($this->packageList);
            $lowerpackage = $info[0];
            $releases = $info[1];
        } else {
            $lowerpackage = current($this->packageList);
        }
        $info = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                'p/' . $lowerpackage . '/info.xml');
        if (isset($releases)) {
            $pxml = new PEAR2_Pyrus_Channel_Remotepackage($this->parent, $releases);
        } else {
            $pxml = new PEAR2_Pyrus_Channel_Remotepackage($this->parent);
        }
        $pxml->channel = $info['c'];
        $pxml->name = $info['n'];
        $pxml->license = $info['l'];
        $pxml->summary = $info['s'];
        $pxml->description = $info['d'];
        return $pxml;
    }

    function getPackage($package)
    {
        $lowerpackage = strtolower($package);
        if (isset($this->parent->protocols->rest['REST1.3'])) {
            $info = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.3']->baseurl .
                                                    'r/' . $lowerpackage . '/allreleases2.xml');
        } else {
            $info = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                    'r/' . $lowerpackage . '/allreleases.xml');
        }
        if (!isset($info['r'][0])) {
            $info['r'] = array($info['r']);
        }
        // filter the package list for packages of this stability or better
        $ok = PEAR2_Pyrus_Installer::betterStates($this->stability, true);
        $releases = array();
        foreach ($info['r'] as $release) {
            if (!in_array($release['s'], $ok)) {
                continue;
            }
            if (!isset($release['m'])) {
                $release['m'] = '5.2.0';
            }
            $releases[] = $release;
        }
        $info = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                'p/' . $lowerpackage . '/info.xml');
        $pxml = new PEAR2_Pyrus_Channel_Remotepackage($this->parent, $releases);
        $pxml->channel = $info['c'];
        $pxml->name = $info['n'];
        $pxml->license = $info['l'];
        $pxml->summary = $info['s'];
        $pxml->description = $info['d'];
        return $pxml;
    }

    function key()
    {
        return key($this->packageList);
    }

    function next()
    {
        return next($this->packageList);
    }

    function rewind()
    {
        $this->packageList = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                             'p/packages.xml');
        $this->packageList = $this->packageList['p'];
        if (!is_array($this->packageList)) {
            $this->packageList = array($this->packageList);
        }
        if (isset($this->stability)) {
            // filter the package list for packages of this stability or better
            $ok = PEAR2_Pyrus_Installer::betterStates($this->stability, true);
            $filtered = array();
            foreach ($this->packageList as $lowerpackage) {
                if (isset($this->parent->protocols->rest['REST1.3'])) {
                    $info = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.3']->baseurl .
                                                            'r/' . $lowerpackage . '/allreleases2.xml');
                } else {
                    $info = $this->rest->retrieveCacheFirst($this->parent->protocols->rest['REST1.0']->baseurl .
                                                            'r/' . $lowerpackage . '/allreleases.xml');
                }
                if (!isset($info['r'][0])) {
                    $info['r'] = array($info['r']);
                }
                $releases = array();
                foreach ($info['r'] as $release) {
                    if (!in_array($release['s'], $ok)) {
                        continue;
                    }
                    if (!isset($release['m'])) {
                        $release['m'] = '5.2.0';
                    }
                    $releases[] = $release;
                }
                if (!count($releases)) {
                    continue;
                }
                $filtered[] = array($lowerpackage, $releases);
            }
            $this->packageList = $filtered;
        }
    }
}<?php

class PEAR2_Pyrus_ChannelFile_Parser_v1 extends PEAR2_Pyrus_XMLParser
{
    
    /**
     * @param string
     * @param string file name of the channel.xml
     *
     * @return PEAR2_Pyrus_ChannelFile_v1
     */
    function parse($data, $file = false, $class = 'PEAR2_Pyrus_ChannelFile_v1')
    {
        $ret = new $class();
        if (!$ret instanceof PEAR2_Pyrus_ChannelFile_v1) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Class ' . $class .
                ' passed to parse() must be a child class of PEAR2_Pyrus_ChannelFile_v1');
        }
        $schema = PEAR2_Pyrus::getDataPath() . '/channel-1.0.xsd';
        // for running out of svn
        if (!file_exists($schema)) {
            $schema = dirname(dirname(dirname(dirname(dirname(__FILE__))))) . '/data/channel-1.0.xsd';
        }
        try {
            $ret->fromArray(parent::parseString($data, $schema));
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Invalid channel.xml', null, $e);
        }
        return $ret;
    }
}<?php
class PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols_REST implements ArrayAccess, Countable, Iterator
{
    protected $info;
    protected $parent;
    protected $index;
    
    function __construct($info, $parent, $index = null)
    {
        if (isset($info['baseurl']) && !isset($info['baseurl'][0])) {
            $info['baseurl'] = array($info['baseurl']);
        }
        $this->info = $info;
        $this->parent = $parent;
        $this->index = $index;
    }

    function current()
    {
        $info = current($this->info['baseurl']);
        if ($info['_content'][strlen($info['_content'])-1] != '/') {
            return $info['_content'] . '/';
        }
        return $info['_content'];
    }

    function rewind()
    {
        reset($this->info['baseurl']);
    }

    function key()
    {
        return $this->info['baseurl'][key($this->info['baseurl'])]['attribs']['type'];
    }

    function next()
    {
        return next($this->info['baseurl']);
    }

    function valid()
    {
        if (!isset($this->info['baseurl'])) {
            return false;
        }
        return current($this->info['baseurl']);
    }

    function count()
    {
        if (!isset($this->info['baseurl'])) {
            return 0;
        }
        return count($this->info['baseurl']);
    }
    
    function __get($var)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Cannot use -> to access '
                    . 'REST protocols, use []');
        }
        if ($var === 'baseurl') {
            return $this->info['_content'];
        }
        throw new PEAR2_Pyrus_ChannelFile_Exception('Unknown variable ' . $var);
    }

    function __set($var, $value)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Cannot use -> to access '
                    . 'REST protocols, use []');
        }
        if ($var === 'baseurl') {
            $this->info['_content'] = $value;
            return $this->save();
        }
        throw new PEAR2_Pyrus_ChannelFile_Exception('Unknown variable ' . $var);
    }
    
    function offsetGet($protocol)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Cannot use [] to access '
                    . 'baseurl, use ->');
        }
        if (!isset($this->info['baseurl'])) {
            return new PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols_REST(
                array('attribs' => array('type' => $protocol), '_content' => null),
                $this, 0);
        }
        foreach ($this->info['baseurl'] as $baseurl) {
            if (strtolower($baseurl['attribs']['type']) == strtolower($protocol)) {
                $ret = new PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols_REST(
                    $baseurl, $this, $protocol
                );
                return $ret;
            }
        }
        return new PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols_REST(
            array('attribs' => array('type' => $protocol), '_content' => null),
            $this, count($this->info['baseurl']));
    }
    
    function offsetSet($protocol, $value)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Cannot use [] to access '
                    . 'baseurl, use ->');
        }
        if (!($value instanceof self)) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Can only set REST protocol ' .
                        ' to a PEAR2_Pyrus_ChannelFile_v1_Servers_Protocol_REST object');
        }
        if (!isset($this->info['baseurl'])) {
            $this->info['baseurl'] = $value->getInfo();
            return $this->save();
        }
        foreach ($this->info['baseurl'] as $i => $baseurl) {
            if (strtolower($baseurl['attribs']['type']) == strtolower($protocol)) {
                $this->info['baseurl'][$i] = $value->getInfo();
                return $this->save();
            }
        }
        $this->info['baseurl'][] = $value->getInfo();
        return $this->save();
    }
    
    function offsetExists($protocol)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Cannot use [] to access '
                    . 'baseurl, use ->');
        }
        foreach ($this->info['baseurl'] as $baseurl) {
            if (strtolower($baseurl['attribs']['type']) == strtolower($protocol)) {
                return true;
            }
        }
        return false;
    }
    
    function offsetUnset($protocol)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Cannot use [] to access '
                    . 'baseurl, use ->');
        }
        foreach ($this->info['baseurl'] as $i => $baseurl) {
            if (strtolower($baseurl['attribs']['type']) == strtolower($protocol)) {
                unset($this->info['baseurl'][$i]);
                $this->info['baseurl'] = array_values($this->info['baseurl']);
                return $this->save();
            }
        }
    }

    function getInfo()
    {
        return $this->info;
    }

    function save()
    {
        if ($this->parent instanceof self) {
            $this->parent[$this->info['attribs']['type']] = $this;
            return $this->parent->save();
        }
        $info = $this->info;
        if (isset($info['baseurl']) && count($info['baseurl']) == 1) {
            $info['baseurl'] = $info['baseurl'][0];
        }
        $this->parent->rawrest = $info;
    }
}
?><?php

class PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols
{
    protected $_info;
    
    protected $parent;
    
    function __construct($info, $parent)
    {
        $this->_info =  $info;
        $this->parent = $parent;
    }
    
    function __get($var)
    {
        switch($var){
            case 'rest':
            case 'soap':
            case 'xmlrpc':
                $method = 'get' . $var;
                return $this->{$method}();
            default:
                throw new PEAR2_Pyrus_ChannelFile_Exception('Unknown protocol: ' . $var);
        }
    }

    function __set($var, $value)
    {
        switch($var){
            case 'rest':
            case 'soap':
            case 'xmlrpc':
                $method = 'set' . $var;
                return $this->{$method}($value);
            default:
                throw new PEAR2_Pyrus_ChannelFile_Exception('Unknown protocol: ' . $var);
        }
    }

    function setREST($value)
    {
        if ($value === null) {
            $this->parent->rest = null;
            return;
        }
        if (!($value instanceof PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols_REST)) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Can only set REST to ' .
                        'PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols_REST object');
        }
        $info = $value->getInfo();
        if (!count($info)) {
            $this->parent->rest = null;
        } else {
            $this->parent->rest = $info;
        }
    }

    function getREST()
    {
        if (isset($this->_info['rest'])) {
            $info = $this->_info['rest'];
        } else {
            $info = array();
        }
        return new PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols_REST($info, $this->parent);
    }
}

?><?php
/**
 * PEAR2_Pyrus_ChannelFile_v1_Mirror
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class for a PEAR2 channel mirror
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelFile_v1_Mirror extends PEAR2_Pyrus_ChannelFile_v1 implements PEAR2_Pyrus_Channel_IMirror
{
    
    /**
     * Mapping of __get variables to method handlers
     * @var array
     */
    protected $getMap = array(
        'ssl' => 'getSSL',
        'port' => 'getPort',
        'server' => 'getChannel',
        'alias' => 'getAlias',
        'name' => 'getName',
        'channel' => 'getChannel',
        'mirror' => 'getServers',
        'mirrors' => 'getServers',
        'protocols' => 'getProtocols'
    );

    private $_info;
    
    /**
     * Parent channel object
     *
     * @var PEAR2_Pyrus_Channel
     */
    protected $parentChannel;
    protected $parent;
    protected $index;

    function __construct($mirrorarray, $parent, $parentchannel, $index)
    {
        $this->_info = $mirrorarray;
        $this->parent = $parent;
        $this->parentChannel = $parentchannel;
        $this->index = $index;
    }

    function getChannel()
    {
        return $this->parentChannel->name;
    }

    /**
     * @return string|false
     */
    function getName()
    {
        if (isset($this->_info['attribs']['host'])) {
            return $this->_info['attribs']['host'];
        }

        return false;
    }

    /**
     * @return int|80 port number to connect to
     */
    function getPort()
    {
        if (isset($this->_info['attribs']['port'])) {
            return (int)$this->_info['attribs']['port'];
        }

        if ($this->getSSL()) {
            return 443;
        }

        return 80;
    }

    /**
     * @return bool Determines whether secure sockets layer (SSL) is used to connect to this channel
     */
    function getSSL()
    {
        if (isset($this->_info['attribs']['ssl'])) {
            return true;
        }

        return false;
    }
    
    /**
     * Returns the protocols supported by the primary server for this channel
     * 
     * @return PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols
     */
    function getProtocols()
    {
        return new PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols($this->_info, $this);
    }

    /**
     * Determines whether a channel supports Representational State Transfer (REST) protocols
     * for retrieving channel information
     * @return bool
     */
    function supportsREST()
    {
        return isset($this->_info['rest']);
    }

    function setREST($rest)
    {
        if ($rest === null) {
            if (isset($this->_info['rest'])) {
                unset($this->_info['rest']);
            }
            return;
        }
        $this->_info['rest'] = $rest;
        $this->save();
    }

    function setName($name)
    {
        if (empty($name)) {
            throw new PEAR2_Pyrus_Channel_Exception('Mirror server must be non-empty');
        }
        if (!$this->validChannelServer($name)) {
            throw new PEAR2_Pyrus_Channel_Exception('Mirror server "' . $name .
                '" for channel "' . $this->getChannel() . '" is not a valid channel server');
        }
        $this->_info['attribs']['host'] = $name;
        $this->save();
    }

    function setPort($port)
    {
        $this->_info['attribs']['port'] = $port;
        $this->save();
    }

    function setSSL($ssl = true)
    {
        if (!$ssl) {
            if (isset($this->_info['attribs']['ssl'])) {
                unset($this->_info['attribs']['ssl']);
            }
        } else {
            $this->_info['attribs']['ssl'] = 'yes';
        }
        $this->save();
    }

    /**
     * Empty all REST definitions
     */
    function resetREST()
    {
        if (isset($this->_info['rest'])) {
            unset($this->_info['rest']);
        }
        $this->save();
    }

    function getInfo()
    {
        return $this->_info;
    }

    function save()
    {
        $this->parent->setMirror($this->index, $this->_info);
        $this->parent->save();
    }
}<?php
class PEAR2_Pyrus_ChannelFile_v1_Servers implements ArrayAccess, Countable, Iterator
{
    /**
     * @var PEAR2_Pyrus_ChannelFile_v1
     */
    protected $parent;
    
    protected $info = array();
    
    protected $type = 'primary';
    
    function __construct($info, PEAR2_Pyrus_ChannelFile_v1 $parent)
    {
        if (isset($info['mirror']) && !isset($info['mirror'][0])) {
            $info['mirror'] = array($info['mirror']);
        }
        $this->info = $info;
        $this->parent = $parent;
    }

    function current()
    {
        $info = current($this->info['mirror']);
        return new PEAR2_Pyrus_ChannelFile_v1_Mirror($info, $this, $this->parent, key($this->info['mirror']));
    }

    function rewind()
    {
        if (!isset($this->info['mirror'])) {
            return;
        }
        reset($this->info['mirror']);
    }

    function key()
    {
        return key($this->info['mirror']);
    }

    function next()
    {
        return next($this->info['mirror']);
    }

    function valid()
    {
        if (!isset($this->info['mirror'])) {
            return false;
        }
        return current($this->info['mirror']);
    }
        

    function count()
    {
        if (!isset($this->info['mirror'])) {
            return 0;
        }
        return count($this->info['mirror']);
    }

    function offsetExists($mirror)
    {
        foreach ($this->info as $type=>$details) {
            if ($type == 'mirror'
                && isset($details[0])
                && $details[0]['attribs']['host'] == $mirror) {
                return true;
            }
        }
        return false;
    }
    
    function offsetUnset($mirror)
    {
        if (!isset($this->info['mirror'])) {
            return;
        }
        foreach ($this->info['mirror'] as $i => $details) {
            if (isset($details['attribs']) && isset($details['attribs']['host']) &&
                    $details['attribs']['host'] == $mirror) {
                unset($this->info['mirror'][$i]);
                $this->info['mirror'] = array_values($this->info['mirror']);
                return $this->save();
            }
        }
    }
    
    function offsetGet($mirror)
    {
        if (!isset($this->info['mirror'])) {
            return new PEAR2_Pyrus_ChannelFile_v1_Mirror(array('attribs' => array('host' => $mirror)), $this, $this->parent, 0);
        }
        foreach ($this->info['mirror'] as $i => $details) {
            if (isset($details['attribs']) && isset($details['attribs']['host']) &&
                $details['attribs']['host'] == $mirror) {
                return new PEAR2_Pyrus_ChannelFile_v1_Mirror($details, $this, $this->parent, $i);
            }
        }
        
        return new PEAR2_Pyrus_ChannelFile_v1_Mirror(array('attribs' => array('host' => $mirror)), $this, $this->parent, count($this->info['mirror']));
    }
    
    function offsetSet($mirror, $value)
    {
        if ($value === null) {
            return $this->offsetUnset($mirror);
        }
        if (!($value instanceof PEAR2_Pyrus_ChannelFile_v1_Mirror)) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Can only set mirror to a ' .
                        'PEAR2_Pyrus_ChannelFile_v1_Mirror object');
        }
        $info = $value->getInfo();
        if ($mirror != $value->server) {
            $info['attribs']['host'] = $mirror;
        }
        foreach ($this->info['mirror'] as $i => $details) {
            if (isset($details['attribs']) && isset($details['attribs']['host']) &&
                $details['attribs']['host'] == $mirror) {
                $this->setMirror($i, $info);
                return $this->save();
            }
        }
        $this->setMirror(count($this->info['mirror']), $info);
        $this->save();
    }

    function setMirror($index, $info)
    {
        $this->info['mirror'][$index] = $info;
    }

    function save()
    {
        $info = $this->info;
        if (!$info['mirror']) {
            return $this->parent->rawmirrors = null;
        }
        if (count($info['mirror']) === 1) {
            return $this->parent->rawmirrors = $info['mirror'][0];
        }
        $this->parent->rawmirrors = $info['mirror'];
    }
}<?php
class PEAR2_Pyrus_ChannelFile_Exception extends Exception {}<?php
/**
 * PEAR2_Pyrus_ChannelFile_v1
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for a PEAR channel.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelFile_v1 extends PEAR2_Pyrus_ChannelFile implements PEAR2_Pyrus_IChannelFile
{
    /**
     * Supported channel.xml versions, for parsing
     * @var array
     */
    protected $supportedVersions = array('1.0');

    /**
     * Parsed channel information
     * @var array
     */
    protected $channelInfo = array(
        'attribs' => array(
            'version' => '1.0',
            'xmlns' => 'http://pear.php.net/channel-1.0',
        ),
    );

    public $rootAttributes = array(
            'version' => '1.0',
            'xmlns' => 'http://pear.php.net/channel-1.0',
            'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
            'xsi:schemaLocation' => 'http://pear.php.net/channel-1.0 
http://pear.php.net/dtd/channel-1.0.xsd'
        );

    private $_xml;
    
    /**
     * Mapping of __get variables to method handlers
     * @var array
     */
    protected $getMap = array(
        'ssl' => 'getSSL',
        'port' => 'getPort',
        'suggestedalias' => 'getSuggestedAlias',
        'alias' => 'getAlias',
        'name' => 'getName',
        'mirror' => 'getServers',
        'mirrors' => 'getServers',
        'protocols' => 'getProtocols'
    );
    
    protected $setMap = array(
        'name' => 'setName',
        'ssl' => 'setSSL',
        'summary' => 'setSummary',
        'alias' => 'setAlias',
        'localalias' => 'setLocalAlias',
        'port' => 'setPort',
        'rawrest' => 'setREST',
        'rawmirrors' => 'setMirrors',
    );

    function __construct(array $data = null)
    {
        if (null !== $data) {
            $this->fromArray($data);
        }
    }
    
    
    /**
     * Directly set the channel info.
     *
     * @param array $data The xml parsed data
     */
    function fromArray($data)
    {
        if (isset($data['channel'])) {
            $this->channelInfo = $data['channel'];
        } else {
            $this->channelInfo = $data;
        }
        // Reset root attributes.
        $this->channelInfo['attribs'] = $this->rootAttributes;
    }

    /**
     * Validate the xml against the channel schema.
     *
     */
    function validate()
    {
        if (!isset($this->_xml)) {
            $this->__toString();
        }
        $a = new PEAR2_Pyrus_XMLParser;
        $schema = PEAR2_Pyrus::getDataPath() . '/channel-1.0.xsd';
        // for running out of svn
        if (!file_exists($schema)) {
            $schema = dirname(dirname(dirname(dirname(__FILE__)))) . '/data/channel-1.0.xsd';
        }
        try {
            $a->parseString($this->_xml, $schema);
            return true;
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Channel_Exception('Invalid channel.xml', $e);
        }
    }

    /**
     * Returns the raw xml for the channel file.
     *
     * @return string
     */
    function __toString()
    {
        return $this->_xml = (string) new PEAR2_Pyrus_XMLWriter(array('channel'=>$this->channelInfo));
    }

    /**
     * @return string|false
     */
    protected function getName()
    {
        if (isset($this->channelInfo['name'])) {
            return $this->channelInfo['name'];
        }

        return false;
    }

    /**
     * @return int|80 port number to connect to
     */
    protected function getPort()
    {
        if (isset($this->channelInfo['servers']['primary']['attribs']['port'])) {
            return (int)$this->channelInfo['servers']['primary']['attribs']['port'];
        }

        if ($this->getSSL()) {
            return 443;
        }

        return 80;
    }

    /**
     * @return bool Determines whether secure sockets layer (SSL) is used to connect to this channel
     */
    protected function getSSL()
    {
        if (isset($this->channelInfo['servers']['primary']['attribs']['ssl'])) {
            return true;
        }

        return false;
    }

    function __get($var)
    {
        if (isset($this->getMap[$var])) {
            return $this->{$this->getMap[$var]}($var);
        }
        if ($var == 'remotepackages') {
            return new PEAR2_Pyrus_Channel_Remotepackages($this);
        } elseif ($var == 'remotepackage') {
            return new PEAR2_Pyrus_Channel_Remotepackage($this, false);
        }
        if (!isset($this->channelInfo[$var])) {
            return null;
        }
        return $this->channelInfo[$var];
    }

    /**
     * Returns the protocols supported by the primary server for this channel
     *
     * @return PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols
     */
    protected function getProtocols()
    {
        if (isset($this->channelInfo['name']) && $this->channelInfo['name'] == '__uri') {
            throw new PEAR2_Pyrus_Channel_Exception('__uri pseudo-channel has no protocols');
        }
        if (!isset($this->channelInfo['servers']) || !isset($this->channelInfo['servers']['primary'])) {
            return new PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols(array(), $this);
        }
        return new PEAR2_Pyrus_ChannelFile_v1_Servers_Protocols($this->channelInfo['servers']['primary'], $this);
    }
    
    protected function getServers()
    {
        if ($this->channelInfo['name'] == '__uri') {
            throw new PEAR2_Pyrus_Channel_Exception('__uri pseudo-channel cannot have mirrors');
        }
        if (isset($this->channelInfo['servers'])) {
            $servers = $this->channelInfo['servers'];
        } else {
            $servers = array();
        }
        return new PEAR2_Pyrus_ChannelFile_v1_Servers($servers, $this);
    }
    
    /**
     * Determines whether a channel supports Representational State Transfer (REST) protocols
     * for retrieving channel information
     *
     * @return bool
     */
    function supportsREST()
    {
        return isset($this->channelInfo['servers']['primary']['rest']);
    }

    function __set($var, $value)
    {
        if (isset($this->setMap[$var])) {
            return $this->{$this->setMap[$var]}($value);
        }
        if (method_exists($this, "set$var")) {
            $sv = "set$var";
            $this->$sv($value);
        }
    }

    /**
     * Empty all REST definitions
     */
    function resetREST()
    {
        if (isset($this->channelInfo['servers']['primary']['rest'])) {
            unset($this->channelInfo['servers']['primary']['rest']);
        }
    }

    /**
     * @param string
     * @return string|false
     * @error PEAR_CHANNELFILE_ERROR_NO_NAME
     * @error PEAR_CHANNELFILE_ERROR_INVALID_NAME
     */
    protected function setName($name)
    {
        if (empty($name)) {
            throw new PEAR2_Pyrus_Channel_Exception('Primary server must be non-empty');
        }
        if (!$this->validChannelServer($name)) {
            throw new PEAR2_Pyrus_Channel_Exception('Primary server "' . $name .
                '" is not a valid channel server');
        }
        $this->channelInfo['name'] = $name;
    }

    /**
     * Test whether a string contains a valid channel server.
     * @param string $ver the package version to test
     * @return bool
     */
    static function validChannelServer($server)
    {
        if ($server == '__uri') {
            return true;
        }

        $regex = '/^[a-z0-9\-]+(?:\.[a-z0-9\-]+)*(\/[a-z0-9\-]+)*\\z/i';
        return (bool) preg_match($regex, $server);
    }

    /**
     * Set the socket number (port) that is used to connect to this channel
     * @param integer
     */
    protected function setPort($port)
    {
        if (isset($this->channelInfo['servers']) &&
              isset($this->channelInfo['servers']['primary']) &&
              !isset($this->channelInfo['servers']['primary']['attribs'])) {
            $this->channelInfo['servers']['primary'] =
                array_merge(array('attribs' => array('port' => $port)),
                            $this->channelInfo['servers']['primary']);
        } else {
            $this->channelInfo['servers']['primary']['attribs']['port'] = $port;
        }
    }

    /**
     * Set the socket number (port) that is used to connect to this channel
     * @param bool Determines whether to turn on SSL support or turn it off
     */
    protected function setSSL($ssl = true)
    {
        if ($ssl) {
        if (isset($this->channelInfo['servers']) &&
              isset($this->channelInfo['servers']['primary']) &&
              !isset($this->channelInfo['servers']['primary']['attribs'])) {
                $this->channelInfo['servers']['primary'] =
                    array_merge(array('attribs' => array('ssl' => 'yes')),
                                $this->channelInfo['servers']['primary']);
            } else {
                $this->channelInfo['servers']['primary']['attribs']['ssl'] = 'yes';
            }
        } elseif (isset($this->channelInfo['servers']['primary']['attribs']['ssl'])) {
            unset($this->channelInfo['servers']['primary']['attribs']['ssl']);
        }
    }

    /**
     * @param string
     * @return boolean success
     * @error PEAR_CHANNELFILE_ERROR_NO_SUMMARY
     * @warning PEAR_CHANNELFILE_ERROR_MULTILINE_SUMMARY
     */
    protected function setSummary($summary)
    {
        if (empty($summary)) {
            throw new PEAR2_Pyrus_Channel_Exception('Channel summary cannot be empty');
        } elseif (strpos(trim($summary), "\n") !== false) {
            // not sure what to do about this yet
            $this->_validateWarning(PEAR_CHANNELFILE_ERROR_MULTILINE_SUMMARY,
                array('summary' => $summary));
        }
        $this->channelInfo['summary'] = $summary;
        return true;
    }

    protected function setLocalAlias($alias)
    {
        return $this->setAlias($alias, true);
    }

    /**
     * @param string
     * @param boolean determines whether the alias is in channel.xml or local
     * @return boolean success
     */
    protected function setAlias($alias, $local = false)
    {
        if (!$this->validChannelServer($alias)) {
            throw new PEAR2_Pyrus_Channel_Exception('Alias "' . $alias . '" is not a valid channel alias');
        }

        $a = $local ? 'localalias' : 'suggestedalias';
        $this->channelInfo[$a] = $alias;
        return true;
    }

    protected function getSuggestedAlias()
    {
        if (isset($this->channelInfo['suggestedalias'])) {
            return $this->channelInfo['suggestedalias'];
        }

        return '';
    }

    /**
     * @return string
     */
    protected function getAlias()
    {
        if (isset($this->channelInfo['localalias'])) {
            return $this->channelInfo['localalias'];
        }

        if (isset($this->channelInfo['suggestedalias'])) {
            return $this->channelInfo['suggestedalias'];
        }

        if (isset($this->channelInfo['name'])) {
            return $this->channelInfo['name'];
        }

        return '';
    }

    /**
     * Set the package validation object if it differs from PEAR's default
     * The class must be includeable via changing _ in the classname to path separator,
     * but no checking of this is made.
     * @param string|false pass in false to reset to the default packagename regex
     * @return boolean success
     */
    function setValidationPackage($validateclass, $version)
    {
        if (empty($validateclass)) {
            unset($this->channelInfo['validatepackage']);
        }
        $this->channelInfo['validatepackage'] = array('_content' => $validateclass);
        $this->channelInfo['validatepackage']['attribs'] = array('version' => $version);
    }

    protected function setREST($rest)
    {
        if ($rest === null) {
            $this->resetREST();
            return;
        }
        $this->channelInfo['servers']['primary']['rest'] = $rest;
    }

    protected function setMirrors($mirrors)
    {
        if ($mirrors === null) {
            if (isset($this->channelInfo['servers']['mirror'])) {
                unset($this->channelInfo['servers']['mirror']);
            }
            return;
        }
        $this->channelInfo['servers']['mirror'] = $mirrors;
    }

    /**
     * Retrieve the name of the validation package for this channel
     * @return string|false
     */
    function getValidationPackage()
    {
        if (!isset($this->channelInfo['validatepackage'])) {
            return array('attribs' => array('version' => 'default'),
                '_content' => 'PEAR2_Pyrus_Validate');
        }

        $info = $this->channelInfo['validatepackage'];
        if (!is_array($info)) {
            $info = array('attribs' => array('version' => 'default'), '_content' => $info);
        }
        return $info;
    }

    function getArray()
    {
        return $this->channelInfo;
    }

    /**
     * Retrieve the object that can be used for custom validation
     * @param string|false the name of the package to validate.  If the package is
     *                     the channel validation package, PEAR_Validate is returned
     * @return PEAR2_Pyrus_Validate|false false is returned if the validation package
     *         cannot be located
     */
    function getValidationObject($package = false)
    {
        if (isset($this->channelInfo['validatepackage'])) {
            if ($package == $this->channelInfo['validatepackage']['_content']) {
                // channel validation packages are always validated by PEAR2_Pyrus_Validate
                $val = new PEAR2_Pyrus_Validate;
                return $val;
            }

            $vclass = str_replace('.', '_', $this->channelInfo['validatepackage']['_content']);
            $vclass = str_replace('PEAR_', 'PEAR2_Pyrus_', $vclass);
            if (!class_exists(str_replace('.', '_',
                  $vclass), true)) {
                throw new PEAR2_Pyrus_ChannelFile_Exception(
                    'Validation object ' . $this->channelInfo['validatepackage']['_content'] .
                    ' cannot be instantiated');
            }

            $val = new $vclass;
        } else {
            $val = new PEAR2_Pyrus_Validate;
        }
        return $val;
    }

    /**
     * This function is used by the channel updater and retrieves a value set by
     * the registry, or the current time if it has not been set
     * @return string
     */
    function lastModified()
    {
        if (isset($this->channelInfo['_lastmodified'])) {
            return $this->channelInfo['_lastmodified'];
        }

        return time();
    }

    function toChannelFile()
    {
        return $this;
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Mirror_Sqlite3
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Represents a mirror within a Sqlite3 channel registry.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Mirror_Sqlite3 extends PEAR2_Pyrus_ChannelRegistry_Channel_Sqlite3 implements PEAR2_Pyrus_Channel_IMirror
{
    private $_channel;
    private $_parent;

    function __construct(SQLite3 $db, $mirror, PEAR2_Pyrus_IChannel $parent)
    {
        if ($parent->name == '__uri') {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('__uri channel cannot have mirrors');
        }

        $this->_channel = $parent->name;
        parent::__construct($db, $this->_channel);
        $this->mirror = $mirror;
        $this->_parent = $parent;
    }

    function getChannel()
    {
        return $this->_channel;
    }

    function toChannelObject()
    {
        return $parent;
    }

    /**
     * @return string|false
     */
    function getName()
    {
        return $this->mirror;
    }
}<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Mirror_Xml
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * A class for handling mirrors within an xml based channel registry.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Mirror_Xml extends PEAR2_Pyrus_Channel_Mirror
{
    private $_parent;
    function __construct(&$mirrorarray, PEAR2_Pyrus_IChannel $parent,
                         PEAR2_Pyrus_ChannelRegistry $reg)
    {
        parent::__construct($mirrorarray, $parent);
        $this->_parent = $reg;
    }

    public function toChannelObject()
    {
        $chan = new PEAR2_Pyrus_Channel(new PEAR2_Pyrus_ChannelFile((string) $this->parentChannel, true));
        return $chan;
    }

    public function resetREST()
    {
        parent::resetREST();
        $this->_parent->update($this->parentChannel);
    }

    public function setName($name)
    {
        parent::setName($name);
        $this->_parent->update($this->parentChannel);
    }

    public function setPort($port)
    {
        parent::setPort($port);
        $this->_parent->update($this->parentChannel);
    }

    public function setSSL($ssl = true)
    {
        parent::setSSL($ssl);
        $this->_parent->update($this->parentChannel);
    }

    public function setPath($protocol, $path)
    {
        parent::setPath($protocol, $path);
        $this->_parent->update($this->parentChannel);
    }

    public function addFunction($type, $version, $name)
    {
        parent::addFunction($type, $version, $name);
        $this->_parent->update($this->parentChannel);
    }

    public function setBaseUrl($resourceType, $url)
    {
        parent::setBaseURL($resourceType, $url);
        $this->_parent->update($this->parentChannel);
    }
}<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Base
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Pyrus managed channel registries
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
abstract class PEAR2_Pyrus_ChannelRegistry_Base
    implements PEAR2_Pyrus_IChannelRegistry, Iterator
{
    protected $path;
    protected $readonly;
    
    /**
     * Parse a package name, or validate a parsed package name array
     * @param string string of format
     *               [channel://][channame/]pname[-version|-state][/group=groupname]
     *               [http|https]://uri
     *
     * @return array
     */
    public function parseName($param, $defaultchannel = 'pear2.php.net')
    {
        $saveparam = $param;
        $components = @parse_url((string) $param);
        if (isset($components['scheme'])) {
            if ($components['scheme'] == 'http' || $components['scheme'] == 'https') {
                // uri package
                $param = array('uri' => $param, 'channel' => '__uri');
                return $param;
            } elseif($components['scheme'] != 'channel') {
                throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): only channel:// uris may ' .
                    'be downloaded, not "' . $param . '"', 'scheme');
            }
        }
        if (!isset($components['path'])) {
            throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): array $param ' .
                'must contain a valid package name in "' . $param . '"', 'path');
        }
        if (isset($components['host'])) {
            // remove the leading "/"
            $components['path'] = substr($components['path'], 1);
        }
        if (!isset($components['scheme'])) {
            if (strpos($components['path'], '/') !== false) {
                if ($components['path']{0} == '/') {
                    throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parsePackageName(): this is not ' .
                        'a package name, it begins with "/" in "' . $param . '"', 'invalid');
                }
                $parts = explode('/', $components['path']);
                $components['host'] = array_shift($parts);
                if (count($parts) > 1) {
                    $components['path'] = array_pop($parts);
                    $components['host'] .= '/' . implode('/', $parts);
                } else {
                    $components['path'] = implode('/', $parts);
                }
            } else {
                $components['host'] = $defaultchannel;
            }
        } else {
            if (strpos($components['path'], '/')) {
                $parts = explode('/', $components['path']);
                $components['path'] = array_pop($parts);
                $components['host'] .= '/' . implode('/', $parts);
            }
        }

        $param = array(
            'package' => $components['path']
            );
        if (isset($components['host'])) {
            $param['channel'] = $components['host'];
        }
        if (isset($components['fragment'])) {
            $param['group'] = $components['fragment'];
        }
        if (isset($components['user'])) {
            $param['user'] = $components['user'];
        }
        if (isset($components['pass'])) {
            $param['pass'] = $components['pass'];
        }
        if (isset($components['query'])) {
            parse_str($components['query'], $param['opts']);
        }
        // check for extension
        $pathinfo = pathinfo($param['package']);
        if (isset($pathinfo['extension']) &&
              in_array(strtolower($pathinfo['extension']), array('tgz', 'tar', 'zip', 'tbz', 'phar'))) {
            $param['extension'] = $pathinfo['extension'];
            $param['package'] = substr($pathinfo['basename'], 0,
                strlen($pathinfo['basename']) - strlen($pathinfo['extension']) - 1);
        }
        // check for version
        if (strpos($param['package'], '-')) {
            $test = explode('-', $param['package']);
            if (count($test) != 2) {
                throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parseName(): only one version/state ' .
                    'delimiter "-" is allowed in "' . $saveparam . '"', 'invalid');
            }
            list($param['package'], $param['version']) = $test;
        }
        // validation
        $info = $this->exists($param['channel'], false);
        if (!$info) {
            throw new PEAR2_Pyrus_ChannelRegistry_ParseException('unknown channel "' . $param['channel'] .
                '" in "' . $saveparam . '"', 'channel', $param);
        }
        try {
            $chan = $this->get($param['channel'], false);
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_ChannelRegistry_ParseException("Exception: corrupt registry, could not " .
                "retrieve channel " . $param['channel'] . " information", 'other', $e);
        }
        $param['channel'] = $chan->name;
        $validate = $chan->getValidationObject(false);
        $vpackage = $chan->getValidationPackage();
        // validate package name
        if (!$validate->validPackageName($param['package'], $vpackage['_content'])) {
            throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parseName(): invalid package name "' .
                $param['package'] . '" in "' . $saveparam . '"', 'package');
        }
        if (isset($param['group'])) {
            if (!PEAR2_Pyrus_Validate::validGroupName($param['group'])) {
                throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parseName(): dependency group "' . $param['group'] .
                    '" is not a valid group name in "' . $saveparam . '"', 'group');
            }
        }
        if (isset($param['version'])) {
            // check whether version is actually a state
            if (in_array(strtolower($param['version']), $validate->getValidStates())) {
                $param['state'] = strtolower($param['version']);
                unset($param['version']);
            } else {
                if (!$validate->validVersion($param['version'])) {
                    throw new PEAR2_Pyrus_ChannelRegistry_ParseException('parseName(): "' . $param['version'] .
                        '" is neither a valid version nor a valid state in "' .
                        $saveparam . '"', 'version/state');
                }
            }
        }
        return $param;
    }

    /**
     * @param array
     * @return string
     */
    function parsedNameToString($parsed, $brief = false)
    {
        if (is_string($parsed)) {
            return $parsed;
        }
        if (is_object($parsed)) {
            $p = $parsed;
            $parsed = array(
                'package' => $p->getPackage(),
                'channel' => $p->getChannel(),
                'version' => $p->getVersion(),
            );
        }
        if (isset($parsed['uri'])) {
            return $parsed['uri'];
        }
        if ($brief) {
            if ($channel = $this->getAlias($parsed['channel'])) {
                return $channel . '/' . $parsed['package'];
            }
        }
        $upass = '';
        if (isset($parsed['user'])) {
            $upass = $parsed['user'];
            if (isset($parsed['pass'])) {
                $upass .= ':' . $parsed['pass'];
            }
            $upass = "$upass@";
        }
        $ret = 'channel://' . $upass . $parsed['channel'] . '/' . $parsed['package'];
        if (isset($parsed['version']) || isset($parsed['state'])) {
            $ver = isset($parsed['version']) ? $parsed['version'] : '';
            $ver .= isset($parsed['state']) ? $parsed['state'] : '';
            $ret .= '-' . $ver;
        }
        if (isset($parsed['extension'])) {
            $ret .= '.' . $parsed['extension'];
        }
        if (isset($parsed['opts'])) {
            $ret .= '?';
            foreach ($parsed['opts'] as $name => $value) {
                $parsed['opts'][$name] = "$name=$value";
            }
            $ret .= implode('&', $parsed['opts']);
        }
        if (isset($parsed['group'])) {
            $ret .= '#' . $parsed['group'];
        }
        return $ret;
    }

    function current()
    {
        if (!isset($this->channelList)) {
            $this->rewind();
        }
        return $this->get(current($this->channelList));
    }

    function key()
    {
        return key($this->channelList);
    }

    function valid()
    {
        if (!isset($this->channelList)) {
            $this->rewind();
        }
        return current($this->channelList);
    }

    function next()
    {
        return next($this->channelList);
    }

    function rewind()
    {
        $this->channelList = $this->listChannels();
    }

    public function getPearChannel()
    {
        return $this->getDefaultChannel('pear.php.net');
    }

    public function getPear2Channel()
    {
        return $this->getDefaultChannel('pear2.php.net');
    }

    public function getPeclChannel()
    {
        return $this->getDefaultChannel('pecl.php.net');
    }

    public function getUriChannel()
    {
        return $this->getDefaultChannel('__uri');
    }
    
    protected function getDefaultChannel($channel)
    {
        $xml = PEAR2_Pyrus::getDataPath() . '/default_channels/' . $channel . '.xml';
        if (!file_exists($xml)) {
            $xml = dirname(dirname(dirname(__DIR__))).'/data/default_channels/' . $channel . '.xml';
        }
        return new PEAR2_Pyrus_Channel(new PEAR2_Pyrus_ChannelFile($xml));
    }

    /**
     * Set up default channels, for uninitialized channel registries
     */
    protected function initDefaultChannels()
    {
        $pear = $this->getPearChannel();
        $pear2 = $this->getPear2Channel();
        $pecl = $this->getPeclChannel();
        $__uri = $this->getUriChannel();
        $this->add($pear);
        $this->add($pear2);
        $this->add($pecl);
        $this->add($__uri);
    }

    public function getPath()
    {
        return $this->path;
    }

    /**
     * @param string
     * @return int
     */
    function packageCount($channel)
    {
        return count($this->getRegistry()->listPackages($channel));
    }

    /**
     * @return PEAR2_Pyrus_IRegistry
     */
    function getRegistry()
    {
        $class = str_replace('Channel', '', get_class($this));
        $ret = new $class($this->path, $this->readonly);
        return $ret;
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Channel
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/PEAR2/Pyrus/
 */

/**
 * A class that represents individual channels within a channel registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/PEAR2/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Channel extends PEAR2_Pyrus_ChannelFile_v1 implements PEAR2_Pyrus_IChannel
{
    private $_parent;
    function __construct(PEAR2_Pyrus_IChannelRegistry $parent, $data)
    {
        $this->_parent = $parent;
        parent::__construct($data);
    }

    function __get($var)
    {
        if ($var == 'remotepackages') {
            return new PEAR2_Pyrus_Channel_Remotepackages($this);
        } elseif ($var == 'remotepackage') {
            return new PEAR2_Pyrus_Channel_Remotepackage($this, false);
        }
        return parent::__get($var);
    }

    function __set($var, $value)
    {
        parent::__set($var, $value);
        $this->_parent->update($this);
    }

    function toChannelFile()
    {
        $ret = new PEAR2_Pyrus_ChannelFile_v1;
        $ret->fromArray($this->getArray());
        return $ret;
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Exceptions with a Pyrus channel registry.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Exception extends PEAR2_Exception
{
}<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_ParseException
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Exceptions when parsing channel registry.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_ParseException extends PEAR2_Exception
{
    public $why;
    public $params;

    function __construct($message, $why, $params = array())
    {
        $this->why = $why;
        $this->params = $params;
        parent::__construct($message);
    }
}<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Pear1
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Gregory Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/PEAR2/Pyrus
 */

/**
 * This is the central registry, that is used for all installer options,
 * stored in .reg files for PEAR 1 compatibility
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Gregory Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/PEAR2/Pyrus
 */
class PEAR2_Pyrus_ChannelRegistry_Pear1 extends PEAR2_Pyrus_ChannelRegistry_Base
{
    private $_channelPath;
    private $_aliasPath;
    function __construct($path, $readonly = false)
    {
        $this->readonly = $readonly;
        if (!file_exists($path . '/.registry') && basename($path) !== 'php') {
            $path = $path . DIRECTORY_SEPARATOR . 'php';
        }
        $this->path = $path;
        $this->_channelPath = $this->path . DIRECTORY_SEPARATOR . '.channels';
        $this->_aliasPath = $this->_channelPath . DIRECTORY_SEPARATOR . '.alias';
        if (!file_exists($this->_channelPath) || !is_dir($this->_channelPath)) {
            if ($readonly) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot initialize ' .
                    'PEAR1 channel registry, directory does not exist and registry is read-only');
            }
            if (!@mkdir($this->_channelPath, 0755, true)) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot initialize ' .
                    'PEAR1 channel registry, channel directory could not be initialized');
            }
        }

        if (!file_exists($this->_aliasPath) || !is_dir($this->_aliasPath)) {
            if ($readonly) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot initialize ' .
                    'PEAR1 channel registry, aliasdirectory does not exist and registry is read-only');
            }
            if (!@mkdir($this->_aliasPath, 0755, true)) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot initialize ' .
                    'PEAR1 channel registry, channel aliasdirectory could not be initialized');
            }
        }
        if (!$this->readonly) {
            if (!$this->exists('pear.php.net')) {
                $this->initDefaultChannels();
            }
        }
    }

    private function _channelFileName($channel, $noaliases = false)
    {
        if (!$noaliases) {
            $c = $this->_channelAliasFileName($channel);
            if (file_exists($c)) {
                $channel = implode('', file($c));
            }
        }
        return $this->_channelPath . DIRECTORY_SEPARATOR . str_replace('/', '_',
            strtolower($channel)) . '.reg';
    }

    private function _channelAliasFileName($alias)
    {
        return $this->_channelPath . DIRECTORY_SEPARATOR . '.alias' .
              DIRECTORY_SEPARATOR . str_replace('/', '_', strtolower($alias)) . '.txt';
    }

    private function _channelFromAlias($alias)
    {
        $file = $this->_channelAliasFileName($alias);
        if (file_exists($file)) {
            return file_get_contents($file);
        }
        return $alias;
    }

    public function add(PEAR2_Pyrus_IChannel $channel, $update = false, $lastmodified = false)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel, registry is read-only');
        }
        if (!is_writeable($this->_channelPath)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel ' .
                $channel->name . ', channel registry path is not writeable');
        }
        $channel->validate();
        if ($this->exists($channel->name)) {
            if (!$update) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel ' .
                    $channel->name . ', channel already exists, use update to change');
            }
            $checker = $this->get($channel->name);
            if ($channel->alias != $checker->alias) {
                if (file_exists($this->_channelAliasFileName($checker->alias))) {
                    @unlink($this->_channelAliasFileName($checker->alias));
                }
            }
        } elseif ($update) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' .
                $channel->name . ' is unknown');
        }
        if ($channel->alias != $channel->name) {
            if (file_exists($this->_channelAliasFileName($channel->alias)) &&
                  $this->_channelFromAlias($channel->alias) != $channel->name) {
                $channel->alias = $channel->name;
            }
            $fp = @fopen($this->_channelAliasFileName($channel->alias), 'w');
            if (!$fp) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add/update channel ' .
                    $channel->name . ', unable to open PEAR1 alias file');
            }
            fwrite($fp, $channel->name);
            fclose($fp);
        }
        $fp = @fopen($this->_channelFileName($channel->name), 'wb');
        if (!$fp) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add/update channel ' .
                $channel->name . ', unable to open PEAR1 channel registry file');
        }
        $info = (string) $channel;
        $parser = new PEAR2_Pyrus_XMLParser;
        $info = $parser->parseString($info);
        $info = $info['channel'];
        if ($lastmodified) {
            $info['_lastmodified'] = $lastmodified;
        } else {
            $info['_lastmodified'] = date('r');
        }
        fwrite($fp, serialize($info));
        fclose($fp);
        return true;
    }

    public function update(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot update channel, registry is read-only');
        }
        return $this->add($channel, true);
    }

    public function delete(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel, registry is read-only');
        }
        $name = $channel->name;
        if ($name == 'pear.php.net' || $name == 'pear2.php.net' || $name == 'pecl.php.net' || $name == '__uri') {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete default channel ' .
                $channel->name);
        }
        if (!$this->exists($name)) {
            return true;
        }

        if ($this->packageCount($name)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel ' .
                $name . ', packages are installed');
        }
        @unlink($this->_channelFileName($name));
        @unlink($this->_channelAliasFileName($channel->alias));
    }

    public function get($channel, $strict = true)
    {
        if (!$this->exists($channel, $strict)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Channel ' . $channel .
                ' does not exist');
        }
        $cont = file_get_contents($this->_channelFileName($channel, $strict));
        $a = @unserialize($cont);
        if (!$a || !is_array($a)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Channel ' . $channel .
                ' PEAR1 registry file is corrupt');
        }
        try {
            $chan = new PEAR2_Pyrus_ChannelRegistry_Channel($this, $a);
            return $chan;
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Channel ' . $channel .
                ' PEAR1 registry file is invalid channel information', $e);
        }
    }

    public function exists($channel, $strict = true)
    {
        $chan = $this->_channelFileName($channel);
        if (file_exists($chan)) {
            return true;
        }
        return false;
    }

    function listChannels()
    {
        $ret = array();
        foreach (new RegexIterator(new DirectoryIterator($this->_channelPath),
                                '/^(.+?)\.reg/', RegexIterator::GET_MATCH) as $file) {
            $ret[] = $this->get(str_replace('_', '/', $file[1]))->name;
        }
        return $ret;
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Sqlite3
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * An implementation of a Pyrus channel registry using Sqlite3 as the storage
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Sqlite3 extends PEAR2_Pyrus_ChannelRegistry_Base
{
    /**
     * The database resource
     *
     * @var SQLite3
     */
    static protected $databases = array();

    /**
     * Initialize the registry
     *
     * @param unknown_type $path
     */
    function __construct($path, $readonly = false)
    {
        $this->readonly = $readonly;
        if ($path && $path != ':memory:') {
            if (dirname($path . '.pear2registry') != $path) {
                $path = $path . DIRECTORY_SEPARATOR . '.pear2registry';
            }
        }
        $this->path = $path;
        $this->_init($path, $readonly);
    }

    private function _init($path, $readonly)
    {
        if (isset(self::$databases[$path]) && self::$databases[$path]) {
            return;
        }

        if (!$path) {
            $path = ':memory:';
        } elseif (!file_exists(dirname($path))) {
            if ($readonly) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot create SQLite3 channel registry, registry is read-only');
            }
            @mkdir(dirname($path), 0755, true);
        }

        if ($readonly && !file_exists($path)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot create SQLite3 channel registry, registry is read-only');
        }

        self::$databases[$path] = new SQLite3($path);
        // hopefully this works
        if (self::$databases[$path]->lastErrorCode()) {
            $temp = self::$databases[$path];
            unset(self::$databases[$path]);
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot open SQLite3 channel registry: ' . $temp->lastErrorMsg());
        }

        $sql = 'SELECT version FROM pearregistryversion';
        if (@self::$databases[$path]->querySingle($sql) == '1.0.0') {
            $sql = 'SELECT COUNT(*) FROM channels';
            if (!self::$databases[$path]->querySingle($sql)) {
                if ($readonly) {
                    throw new PEAR2_Pyrus_Registry_Exception('Cannot create SQLite3 channel registry, registry is read-only');
                }
                $this->initDefaultChannels();
                return;
            }
            return;
        }

        if ($readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot create SQLite3 channel registry, registry is read-only');
        }

        $a = new PEAR2_Pyrus_Registry_Sqlite3_Creator;
        $a->create(self::$databases[$path]);
        $this->initDefaultChannels();
    }

    function exists($channel, $strict = true)
    {
        if (!isset(self::$databases[$this->path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite3 channel registry for ' . $this->path);
        }

        $sql = 'SELECT channel FROM channels WHERE alias = "' . self::$databases[$this->path]->escapeString($channel) . '"';
        if (!$strict && $a = self::$databases[$this->path]->querySingle($sql)) {
            return true;
        }

        $sql = 'SELECT channel FROM channels WHERE channel = "' . self::$databases[$this->path]->escapeString($channel) . '"';
        if ($a = self::$databases[$this->path]->querySingle($sql)) {
            return true;
        }

        return false;
    }

    function add(PEAR2_Pyrus_IChannel $channel, $update = false, $lastmodified = false)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel, registry is read-only');
        }

        if (!isset(self::$databases[$this->path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite3 channel registry for ' . $this->path);
        }

        self::$databases[$this->path]->exec('BEGIN');
        $sql = 'SELECT channel FROM channels WHERE channel = "' . self::$databases[$this->path]->escapeString($channel->name) . '"';
        if (self::$databases[$this->path]->querySingle($sql)) {
            if (!$update) {
                self::$databases[$this->path]->exec('ROLLBACK');
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' .
                    $channel->name . ' has already been discovered');
            }
            $this->delete($channel, true);
        } elseif ($update) {
            self::$databases[$this->path]->exec('ROLLBACK');
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' .
                $channel->name . ' is unknown');
        }

        $validate = $channel->getValidationPackage();

        $sql = '
            INSERT INTO channels
            (channel, summary, suggestedalias, alias, validatepackageversion,
            validatepackage, lastmodified)
            VALUES(
                :name, :summary, :suggestedalias,
                :alias, :version, :package, :lastmodified
            )';

        $stmt = self::$databases[$this->path]->prepare($sql);

        $stmt->bindValue(':name',           $cn = $channel->name);
        $stmt->bindValue(':summary',        $channel->summary);
        $stmt->bindValue(':suggestedalias', $channel->suggestedalias);
        $stmt->bindValue(':alias',          $channel->alias);
        $stmt->bindValue(':version',        $validate['attribs']['version']);
        $stmt->bindValue(':package',        $validate['_content']);
        $stmt->bindValue(':lastmodified',   $channel->lastModified());

        if (!$stmt->execute()) {
            self::$databases[$this->path]->exec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Error: channel ' . $channel->name .
                ' could not be added to the SQLite3 registry');
        }
        $stmt->close();

        $sql = '
            INSERT INTO channel_servers
            (channel, server, ssl, port)
            VALUES(
                :channel, :server, :ssl, :port
            )';
        $stmt = self::$databases[$this->path]->prepare($sql);

        $stmt->bindValue(':channel', $cn);
        $stmt->bindValue(':server',  $cn);
        $stmt->bindValue(':ssl',     $channel->ssl, SQLITE3_INTEGER);
        $stmt->bindValue(':port',    $channel->port, SQLITE3_INTEGER);

        if (!$stmt->execute()) {
            self::$databases[$this->path]->exec('ROLLBACK');
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' . $channel->name .
                ' could not be added to the SQLite3 registry');
        }
        $stmt->close();

        if ($channel->name == '__uri') {
            // __uri pseudo-channel has no protocols or mirrors
            self::$databases[$this->path]->exec('COMMIT');
            return;
        }

        foreach ($channel->protocols->rest as $type => $baseurl) {
            $sql = '
                INSERT INTO channel_server_rest
                (channel, server, baseurl, type)
                VALUES(
                    :channel, :server, :func, :attrib
                )';

            $stmt = self::$databases[$this->path]->prepare($sql);

            $stmt->bindValue(':channel', $cn);
            $stmt->bindValue(':server',  $cn);
            $stmt->bindValue(':func',    $baseurl);
            $stmt->bindValue(':attrib',  $type);

            if (!$stmt->execute()) {
                self::$databases[$this->path]->exec('ROLLBACK');
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' . $channel->name .
                    ' could not be added to the SQLite3 registry');
            }
            $stmt->close();
        }

        $sql = '
            INSERT INTO channel_servers
            (channel, server, ssl, port)
            VALUES(
                :channel, :server, :ssl, :port
            )';
        $stmt = self::$databases[$this->path]->prepare($sql);
        foreach ($channel->mirrors as $mirror) {

            $ssl = 0;
            if ($mirror->ssl) {
                $ssl = 1;
            }

            $stmt->bindValue(':channel', $cn);
            $stmt->bindValue(':server',  $mn = $mirror->name);
            $stmt->bindValue(':ssl',     $ssl, SQLITE3_INTEGER);
            $stmt->bindValue(':port',    $mirror->port, SQLITE3_INTEGER);

            if (!$stmt->execute()) {
                self::$databases[$this->path]->exec('ROLLBACK');
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' . $channel->name .
                    ' could not be added to the registry');
            }

            $sql = '
                INSERT INTO channel_server_rest
                (channel, server, baseurl, type)
                VALUES(
                    :channel, :server, :func, :attrib
                )';

            $stmt1 = self::$databases[$this->path]->prepare($sql);
            foreach ($mirror->protocols->rest as $type => $baseurl) {

                $stmt1->bindValue(':channel', $cn);
                $stmt1->bindValue(':server',  $mn);
                $stmt1->bindValue(':func',    $baseurl);
                $stmt1->bindValue(':attrib',  $type);

                if (!$stmt1->execute()) {
                    self::$databases[$this->path]->exec('ROLLBACK');
                    throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' . $channel->name .
                        ' could not be added to the SQLite3 registry');
                }
            }
        }
        self::$databases[$this->path]->exec('COMMIT');
    }

    function update(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot update channel, registry is read-only');
        }

        return $this->add($channel, true);
    }

    function get($channel, $strict = true)
    {
        if (!isset(self::$databases[$this->path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite3 channel registry for ' . $this->path);
        }

        if (!$this->exists($channel, $strict)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unknown channel: ' . $channel);
        }

        $chan = $this->getChannelObject($this->channelFromAlias($channel));
        return new PEAR2_Pyrus_ChannelRegistry_Channel($this, $chan->getArray());
    }

    function channelFromAlias($alias)
    {
        $sql = 'SELECT channel FROM channels WHERE alias = "' .
            self::$databases[$this->path]->escapeString($alias) . '"';
        if ($chan = self::$databases[$this->path]->querySingle($sql)) {
            return $chan;
        }
        $sql = 'SELECT channel FROM channels WHERE channel = "' .
            self::$databases[$this->path]->escapeString($alias) . '"';
        if ($chan = self::$databases[$this->path]->querySingle($sql)) {
            return $chan;
        }
        throw new PEAR2_Pyrus_ChannelFile_Exception('Unknown channel/alias: ' . $alias);
    }

    /**
     * @param string
     */
    protected function getChannelObject($channel)
    {
        $channel = $this->channelFromAlias($channel);
        $sql = 'SELECT * FROM channels WHERE channel = "' .
            self::$databases[$this->path]->escapeString($channel) . '"';

        $result = self::$databases[$this->path]->query($sql);
        if (!$result) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Failed to query channels table');
        }

        while ($res = $result->fetchArray(SQLITE3_ASSOC)) {
            break;
        }
        $ret = new PEAR2_Pyrus_ChannelFile_v1;
        $ret->name = $channel;
        $ret->suggestedalias = $res['suggestedalias'];
        if ($res['alias']) {
            $ret->alias = $res['alias'];
        }
        $ret->summary = $res['summary'];
        $ret->setValidationPackage($res['validatepackage'], $res['validatepackageversion']);
        $ret->lastModified = $res['lastmodified'];

        $sql = 'SELECT channel, server, ssl, port FROM channel_servers
            WHERE channel = "' .
            self::$databases[$this->path]->escapeString($channel) . '"';
        $result = self::$databases[$this->path]->query($sql);
        if (!$result) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Failed to query mirrors table');
        }

        while ($res = $result->fetchArray(SQLITE3_ASSOC)) {
            if ($res['server'] == $res['channel']) {
                $ret->port = $res['port'];
                $ret->ssl = $res['ssl'];
            } else {
                $ret->mirrors[$res['server']]->ssl = $res['ssl'];
                $ret->mirrors[$res['server']]->port = $res['port'];
            }
        }

        $sql = 'SELECT channel, server, baseurl, type FROM channel_server_rest
            WHERE channel= "' .
            self::$databases[$this->path]->escapeString($channel) . '"';
        $result = self::$databases[$this->path]->query($sql);
        if (!$result) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Failed to query rest table');
        }

        while ($res = $result->fetchArray(SQLITE3_ASSOC)) {
            if ($res['server'] == $res['channel']) {
                $ret->protocols->rest[$res['type']]->baseurl = $res['baseurl'];
            } else {
                $ret->mirrors[$res['server']]->protocols->rest[$res['type']]->baseurl = $res['baseurl'];
            }
        }
        return $ret;
    }

    function delete(PEAR2_Pyrus_IChannel $channel, $inupdate = false)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel, registry is read-only');
        }

        if (!isset(self::$databases[$this->path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite3 channel registry for ' . $this->path);
        }

        $name = $channel->name;
        if ($name == 'pear.php.net' || $name == 'pear2.php.net' || $name == 'pecl.php.net' || $name == '__uri') {
            if (!$inupdate) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete default channel ' .
                    $channel->name);
            }
        }

        $sql = 'SELECT count(*) FROM packages WHERE channel = "' .
            self::$databases[$this->path]->escapeString($channel->name) . '"';
        if (self::$databases[$this->path]->querySingle($sql)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel ' .
                $channel->name . ', packages are installed');
        }


        $sql = 'DELETE FROM channels WHERE channel = "' .
            self::$databases[$this->path]->escapeString($channel->name) . '"';
        if (!@self::$databases[$this->path]->exec($sql)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot delete channel ' .
                $channel->name . ': ' . self::$databases[$this->path]->lastErrorMsg());
        }
    }

    public function listChannels()
    {
        if (!isset(self::$databases[$this->path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception(
                'Error: no existing SQLite3 channel registry for ' . $this->path);
        }

        $ret = array();
        $sql = 'SELECT channel FROM channels ORDER BY channel';
        $res = self::$databases[$this->path]->query($sql);
        while ($chan = $res->fetchArray(SQLITE_ASSOC)) {
            $ret[] = $chan['channel'];
        }

        return $ret;
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry_Xml
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * An implementation of a Pyrus channel registry within XML files.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry_Xml extends PEAR2_Pyrus_ChannelRegistry_Base
{
    protected $channelpath;
    /**
     * Initialize the registry
     *
     * @param string $path
     */
    function __construct($path, $readonly = false)
    {
        $this->readonly = $readonly;
        $this->path = $path;
        $this->channelpath = $path . DIRECTORY_SEPARATOR . '.xmlregistry' . DIRECTORY_SEPARATOR .
            'channels'; 
        if (!$this->readonly) {
            if (!$this->exists('pear.php.net')) {
                $this->initDefaultChannels();
            }
        }
    }

    /**
     * Convert a name into a path-friendly name
     *
     * @param string $name
     */
    private function _mung($name)
    {
        return str_replace(array('/', '\\'), array('##', '###'), $name);
    }

    private function _unmung($name)
    {
        return str_replace(array('##', '###'), array('/', '\\'), $name);
    }

    /**
     * Get the filename to store a channel
     *
     * @param PEAR2_Pyrus_IChannel|string $channel Channel to save
     *
     * @return string
     */
    protected function getChannelFile($channel)
    {
        if ($channel instanceof PEAR2_Pyrus_IChannel) {
            $channel = $channel->name;
        }

        return $this->channelpath . DIRECTORY_SEPARATOR . 'channel-' .
            $this->_mung($channel) . '.xml';
    }

    /**
     * Get the filename for a channel alias.
     *
     * @param string $alias Alias to save
     *
     * @return string
     */
    protected function getAliasFile($alias)
    {
        return $this->channelpath . DIRECTORY_SEPARATOR . 'channelalias-' .
            $this->_mung($alias) . '.txt';
    }

    function channelFromAlias($alias)
    {
        if (file_exists($this->getAliasFile($alias))) {
            return file_get_contents($this->getAliasFile($alias));
        }
        return $alias;
    }

    /**
     * Check if the channel has been discovered.
     *
     * @param string $channel Name of the channel
     * @param bool   $strict  Allow aliases or not
     *
     * @return bool
     */
    function exists($channel, $strict = true)
    {
        if (file_exists($this->getChannelFile($channel))) {
            return true;
        }

        if ($strict) {
            return false;
        }

        return file_exists($this->getAliasFile($channel));
    }

    function add(PEAR2_Pyrus_IChannel $channel, $update = false, $lastmodified = false)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel, registry is read-only');
        }

        $file = $this->getChannelFile($channel);
        if (@file_exists($file)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' .
                $channel->alias . ' has already been discovered');
        }
        if (!@is_dir(dirname($file))) {
            mkdir(dirname($file), 0755, true);
        }

        file_put_contents($file, (string) $channel);
        $alias = $channel->alias;
        file_put_contents($this->getAliasFile($alias), $channel->name);
    }

    function update(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot update channel, registry is read-only');
        }

        $file = $this->getChannelFile($channel);
        if (!@file_exists($file)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: channel ' .
                $channel->name . ' is unknown');
        }

        file_put_contents($file, (string) $channel);
        $alias = $channel->alias;
        file_put_contents($this->getAliasFile($alias), $channel->name);
    }

    function delete(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel, registry is read-only');
        }

        $name = $channel->name;
        if ($name == 'pear.php.net' || $name == 'pear2.php.net' || $name == 'pecl.php.net' || $name == '__uri') {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete default channel ' .
                $channel->name);
        }

        if ($this->packageCount($name)) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel ' .
                $name . ', packages are installed');
        }

        @unlink($this->getChannelFile($channel));
        @unlink($this->getAliasFile($channel->alias));
    }

    function get($channel, $strict = true)
    {
        if ($this->exists($channel, $strict)) {
            $channel = $this->channelFromAlias($channel);
            $chan = new PEAR2_Pyrus_ChannelFile($this->getChannelFile($channel));
            return new PEAR2_Pyrus_ChannelRegistry_Channel($this, $chan->getArray());
        }

        throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unknown channel: ' . $channel);
    }

    /**
     * List all discovered channels
     *
     * @return array
     */
    function listChannels()
    {
        $ret = array();
        foreach (new RegexIterator(new DirectoryIterator($this->channelpath),
                                '/channel-(.+?)\.xml/', RegexIterator::GET_MATCH) as $file) {
            $ret[] = $this->get($this->_unmung($file[1]))->name;
        }

        return $ret;
    }
}
<?php
/**
 * PEAR2_Pyrus_Config_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus configuration
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Config_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Config
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Pyrus's master configuration manager
 *
 * Unlike PEAR version 1.x, the new Pyrus configuration manager is tightly bound
 * to include_path, and will search through include_path for system configuration
 * Pyrus installations.
 *
 * The User configuration file will be looked for in these locations:
 *
 * Unix:
 *
 * - home directory
 * - current directory
 *
 * Windows:
 *
 * - local settings directory on windows for the current user.
 *   This is looked up directly in the windows registry using COM
 * - current directory
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Config_Snapshot extends PEAR2_Pyrus_Config
{
    /**
     * parse a configuration for a PEAR2 installation
     *
     * @param string $pearDirectory This can be either a single path, or a
     *                              PATH_SEPARATOR-separated list of directories
     * @param string $userfile
     */
    public function __construct($snapshot, PEAR2_Pyrus_Config $config = null)
    {
        self::constructDefaults();
        if (!$config) {
            $config = PEAR2_Pyrus_Config::current();
        }
        $this->loadConfigFile($config->path, $snapshot);
        $this->pearDir = $config->path;
    }

    /**
     * Extract configuration from system + user configuration files
     *
     * Configuration is stored in XML format, in two locations.
     *
     * The system configuration contains all of the important directory
     * configuration variables like data_dir, and the location of php.ini and
     * the php executable php.exe or php.  This configuration is tightly bound
     * to the repository, and cannot be moved.  As such, php_dir is auto-defined
     * as dirname(/path/to/pear/.config), or /path/to/pear.
     *
     * Only 1 user configuration file is allowed, and contains user-specific
     * settings, including the locations where to download package releases
     * and where to cache files downloaded from the internet.  If false is passed
     * in, PEAR2_Pyrus_Config will attempt to guess at the config file location as
     * documented in the class docblock {@link PEAR2_Pyrus_Config}.
     * @param string $pearDirectory
     * @param string|false $userfile
     */
    protected function loadConfigFile($pearDirectory, $snapshot = null)
    {
        if (!file_exists($pearDirectory . DIRECTORY_SEPARATOR . '.configsnapshots')) {
            // no configurations - this may be an extracted-from-disk install.
            // in this case, we use the defaults, as this is intended
            return;
        }
        $snapshotdir = $pearDirectory . DIRECTORY_SEPARATOR . '.configsnapshots';
        $snapshotfile = $snapshotdir . DIRECTORY_SEPARATOR . $snapshot;
        if (!file_exists($snapshotfile)) {
            if (preg_match('/^\\d{4}\\-\\d{2}\\-\\d{2} \\d{2}:\\d{2}:\\d{2}$/', $snapshot)) {
                // passed a date, locate a matching snapshot
                $us = new DateTime($snapshot);
                $dir = new RegexIterator(
                    new RecursiveDirectoryIterator($snapshotdir), '/configsnapshot\\-\\d{4}\\-\\d{2}\\-\\d{2} \\d{2}:\\d{2}:\\d{2}.xml/',
                    RegexIterator::MATCH,
                    RegexIterator::USE_KEY);
                foreach ($dir as $match) {
                    $matches[] = $match;
                }
                usort($matches, array($this, 'datediff'));
                unset($match);
                foreach ($matches as $match) {
                    $match = substr($match->getFileName(), strlen('configsnapshot-'));
                    $match = str_replace('.xml', '', $match);
                    $diff = $us->diff(new DateTime($match))->format("%r%s");
                    if (!$diff) {
                        // found a snapshot match
                        break;
                    }
                    if (!isset($last)) {
                        if ($diff > 0) {
                            // oldest snapshot is newer than us, resort to default config
                            return parent::loadConfigFile($pearDirectory);
                        }
                        $last = $match;
                        continue;
                    }

                    if ($diff < 0) {
                        $last = $match;
                        continue;
                    }
                    // the current snapshot is newer than our install
                    // the last snapshot was the one we used
                    $match = $last;
                    break;
                }
                if (!isset($match)) {
                    // no config snapshots
                    return parent::loadConfigFile($pearDirectory);
                }
                $snapshotfile = $snapshotdir . DIRECTORY_SEPARATOR . 'configsnapshot-' .
                    $match . '.xml';
            }
            if (!file_exists($snapshotfile)) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot retrieve non-existent config ' .
                                                   'snapshot ' . $snapshot);
            }
        }

        PEAR2_Pyrus_Log::log(5, 'Loading configuration snapshot ' .
                             $snapshotfile . ' for ' . $pearDirectory);
        try {
            $this->helperLoadConfigFile($pearDirectory, $snapshotfile, 'snapshot');
        } catch (Exception $e) {
            // no config snapshots found, so simply load the existing config
            return parent::loadConfigFile($pearDirectory);
        }
    }

    function datediff($a, $b)
    {
        $us = new DateTime($a);
        $diff = $us->diff(new DateTime($match))->format("%r%s");
        if (!$diff) return 0;
        if ($diff > 0) return 1;
        return -1;
    }

    /**
     * Save both the user configuration file and the system file
     *
     * If the userfile is not passed in, it is saved in the default
     * location which is either in ~/.pear/pearconfig.xml or on Windows
     * in the Documents and Settings directory
     * @param string $userfile path to alternate user configuration file
     */
    function saveConfig($userfile = false)
    {
    }

    /**
     * Save a snapshot of the current config, and return the file name
     *
     * If the latest snapshot is the same as the existing configuration,
     * simply return the filename
     * @return string basename of the snapshot file of the current configuration
     */
    static public function configSnapshot()
    {
    }
}
<?php
/**
 * PEAR2_Pyrus_Dependency_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for dependencies
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Dependency_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Dependency_Validator, advanced dependency validation
 *
 * PHP versions 4 and 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Dependency check for PEAR2 packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Dependency_Validator
{
    /**
     * @var PEAR2_MultiErrors
     */
    protected $errs;
    /**
     * One of the PEAR2_Pyrus_Validate::* states
     * @see PEAR2_Pyrus_Validate::NORMAL
     * @var integer
     */
    var $_state;
    /**
     * @var PEAR2_Pyrus_OSGuess
     */
    var $_os;
    /**
     * Package to validate
     * @var PEAR2_Pyrus_Package
     */
    var $_currentPackage;
    /**
     * @param PEAR2_Pyrus_Package
     * @param int installation state (one of PEAR2_Pyrus_Validate::*)
     * @param PEAR2_MultiErrors
     */
    function __construct($package, $state = PEAR2_Pyrus_Validate::INSTALLING,
                         PEAR2_MultiErrors $errs)
    {
        $this->_state = $state;
        $this->_currentPackage = $package;
        $this->errs = $errs;
    }

    function _getExtraString($dep)
    {
        $extra = ' (';
        if ($dep->type != 'extension' && isset($dep->uri)) {
            return '';
        }
        if (isset($dep->recommended)) {
            $extra .= 'recommended version ' . $dep->recommended;
        } else {
            if (isset($dep->min)) {
                $extra .= 'version >= ' . $dep->min;
            }
            if (isset($dep->max)) {
                if ($extra != ' (') {
                    $extra .= ', ';
                }
                $extra .= 'version <= ' . $dep->max;
            }
            if (isset($dep->exclude)) {
                if (!is_array($dep->exclude)) {
                    $dep->exclude = array($dep->exclude);
                }
                if ($extra != ' (') {
                    $extra .= ', ';
                }
                $extra .= 'excluded versions: ';
                foreach ($dep->exclude as $i => $exclude) {
                    if ($i) {
                        $extra .= ', ';
                    }
                    $extra .= $exclude;
                }
            }
        }
        $extra .= ')';
        if ($extra == ' ()') {
            $extra = '';
        }
        return $extra;
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function getPHP_OS()
    {
        return PHP_OS;
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function getsysname()
    {
        $this->_os = new PEAR2_Pyrus_OSGuess;
        return $this->_os->getSysname();
    }

    /**
     * Specify a dependency on an OS.  Use arch for detailed os/processor information
     *
     * There are two generic OS dependencies that will be the most common, unix and windows.
     * Other options are linux, freebsd, darwin (OS X), sunos, irix, hpux, aix
     */
    function validateOsDependency(PEAR2_Pyrus_PackageFile_v2_Dependencies_Dep $dep)
    {
        if ($this->_state != PEAR2_Pyrus_Validate::INSTALLING &&
              $this->_state != PEAR2_Pyrus_Validate::DOWNLOADING) {
            return true;
        }
        if ($dep->name == '*') {
            return true; // no one will do conflicts with *, so assume no conflicts
        }
        switch (strtolower($dep->name)) {
            case 'windows' :
                if ($dep->conflicts) {
                    if (strtolower(substr($this->getPHP_OS(), 0, 3)) == 'win') {
                        if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) &&
                              !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                            return $this->raiseError("Cannot install %s on Windows");
                        } else {
                            return $this->warning("warning: Cannot install %s on Windows");
                        }
                    }
                } else {
                    if (strtolower(substr($this->getPHP_OS(), 0, 3)) != 'win') {
                        if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) &&
                              !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                            return $this->raiseError("Can only install %s on Windows");
                        } else {
                            return $this->warning("warning: Can only install %s on Windows");
                        }
                    }
                }
            break;
            case 'unix' :
                $unices = array('linux', 'freebsd', 'darwin', 'sunos', 'irix', 'hpux', 'aix');
                if ($dep->conflicts) {
                    if (in_array(strtolower($this->getSysname()), $unices)) {
                        if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) &&
                              !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                            return $this->raiseError("Cannot install %s on any Unix system");
                        } else {
                            return $this->warning(
                                "warning: Cannot install %s on any Unix system");
                        }
                    }
                } else {
                    if (!in_array(strtolower($this->getSysname()), $unices)) {
                        if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) &&
                              !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                            return $this->raiseError("Can only install %s on a Unix system");
                        } else {
                            return $this->warning(
                                "warning: Can only install %s on a Unix system");
                        }
                    }
                }
            break;
            default :
                if ($dep->conflicts) {
                    if (strtolower($dep->name) == strtolower($this->getSysname())) {
                        if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) &&
                              !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                            return $this->raiseError('Cannot install %s on ' . $dep->name .
                                ' operating system');
                        } else {
                            return $this->warning('warning: Cannot install %s on ' .
                                $dep->name . ' operating system');
                        }
                    }
                } else {
                    if (strtolower($dep->name) != strtolower($this->getSysname())) {
                        if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) &&
                              !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                            return $this->raiseError('Cannot install %s on ' .
                                $this->getSysname() .
                                ' operating system, can only install on ' . $dep->name);
                        } else {
                            return $this->warning('warning: Cannot install %s on ' .
                                $this->getSysname() .
                                ' operating system, can only install on ' . $dep->name);
                        }
                    }
                }
        }
        return true;
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function matchSignature($pattern)
    {
        $this->_os = new PEAR2_Pyrus_OSGuess;
        return $this->_os->matchSignature($pattern);
    }

    /**
     * Specify a complex dependency on an OS/processor/kernel version,
     * Use OS for simple operating system dependency.
     *
     * This is the only dependency that accepts an eregable pattern.  The pattern
     * will be matched against the php_uname() output parsed by OS_Guess
     */
    function validateArchDependency($dep)
    {
        if ($this->_state != PEAR2_Pyrus_Validate::INSTALLING) {
            return true;
        }
        if ($this->matchSignature($dep->pattern)) {
            if ($dep->conflicts) {
                if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                    return $this->raiseError('%s Architecture dependency failed, cannot match "' .
                        $dep->pattern . '"');
                }
                return $this->warning('warning: %s Architecture dependency failed, ' .
                    'cannot match "' . $dep->pattern . '"');
            }
            return true;
        } else {
            if ($dep->conflicts) {
                return true;
            }
            if (!isset(PEAR2_Pyrus_Installer::$options['nodeps'])
                && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                return $this->raiseError('%s Architecture dependency failed, does not ' .
                    'match "' . $dep->pattern . '"');
            }
            return $this->warning('warning: %s Architecture dependency failed, does ' .
                'not match "' . $dep->pattern . '"');
        }
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function extension_loaded($name)
    {
        return extension_loaded($name);
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function phpversion($name = null)
    {
        if ($name !== null) {
            return phpversion($name);
        } else {
            return phpversion();
        }
    }

    function validateExtensionDependency(PEAR2_Pyrus_PackageFile_v2_Dependencies_Package $dep)
    {
        if ($this->_state != PEAR2_Pyrus_Validate::INSTALLING &&
              $this->_state != PEAR2_Pyrus_Validate::DOWNLOADING) {
            return true;
        }
        $required = $dep->deptype == 'required';
        $loaded = $this->extension_loaded($dep->name);
        $extra = $this->_getExtraString($dep);
        if (!isset($dep->min) && !isset($dep->max) &&
              !isset($dep->recommended) && !isset($dep->exclude)) {
            if ($loaded) {
                if ($dep->conflicts) {
                    if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                        return $this->raiseError('%s conflicts with PHP extension "' .
                            $dep->name . '"' . $extra);
                    } else {
                        return $this->warning('warning: %s conflicts with PHP extension "' .
                            $dep->name . '"' . $extra);
                    }
                }
                return true;
            } else {
                if ($dep->conflicts) {
                    return true;
                }
                if ($required) {
                    if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                        return $this->raiseError('%s requires PHP extension "' .
                            $dep->name . '"' . $extra);
                    } else {
                        return $this->warning('warning: %s requires PHP extension "' .
                            $dep->name . '"' . $extra);
                    }
                } else {
                    return $this->warning('%s can optionally use PHP extension "' .
                        $dep->name . '"' . $extra);
                }
            }
        }
        if (!$loaded) {
            if ($dep->conflicts) {
                return true;
            }
            if (!$required) {
                return $this->warning('%s can optionally use PHP extension "' .
                    $dep->name . '"' . $extra);
            } else {
                if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                    return $this->raiseError('%s requires PHP extension "' . $dep->name .
                        '"' . $extra);
                }
                    return $this->warning('warning: %s requires PHP extension "' . $dep->name .
                        '"' . $extra);
            }
        }
        $version = (string) $this->phpversion($dep->name);
        if (empty($version)) {
            $version = '0';
        }
        $fail = false;
        if (isset($dep->min)) {
            if (!version_compare($version, $dep->min, '>=')) {
                $fail = true;
            }
        }
        if (isset($dep->max)) {
            if (!version_compare($version, $dep->max, '<=')) {
                $fail = true;
            }
        }
        if ($fail && !$dep->conflicts) {
            if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                return $this->raiseError('%s requires PHP extension "' . $dep->name .
                    '"' . $extra . ', installed version is ' . $version);
            } else {
                return $this->warning('warning: %s requires PHP extension "' . $dep->name .
                    '"' . $extra . ', installed version is ' . $version);
            }
        } elseif (!isset($dep->exclude) && (isset($dep->min) || isset($dep->max)) && !$fail && $dep->conflicts) {
            if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                return $this->raiseError('%s conflicts with PHP extension "' .
                    $dep->name . '"' . $extra . ', installed version is ' . $version);
            } else {
                return $this->warning('warning: %s conflicts with PHP extension "' .
                    $dep->name . '"' . $extra . ', installed version is ' . $version);
            }
        }
        if (isset($dep->exclude)) {
            // exclude ordinarily tells the installer "install anything but these versions"
            // when paired with conflicts, it becomes "install only these versions"
            $conflicts = $dep->conflicts;
            foreach ($dep->exclude as $exclude) {
                if (version_compare($version, $exclude, '==')) {
                    if ($conflicts) {
                        $fail = false;
                        break;
                    }
                    goto conflict_error;
                } else {
                    if ($conflicts) {
                        $fail = true;
                    }
                }
            }
        }
        if ($fail) {
conflict_error:
            if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                return $this->raiseError('%s is not compatible with version ' . $version . ' of PHP extension "' .
                    $dep->name . '", installed version is ' . $version);
            } else {
                return $this->warning('warning: %s is not compatible with version ' . $version . ' of PHP extension "' .
                    $dep->name . '", installed version is ' . $version);
            }
        }
        if (isset($dep->recommended)) {
            if (version_compare($version, $dep->recommended, '==')) {
                return true;
            } else {
                if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                    return $this->raiseError('%s dependency: PHP extension ' . $dep->name .
                        ' version "' . $version . '"' .
                        ' is not the recommended version "' . $dep->recommended .
                        '", but may be compatible, use --force to install');
                } else {
                    return $this->warning('warning: %s dependency: PHP extension ' .
                        $dep->name . ' version "' . $version . '"' .
                        ' is not the recommended version "' . $dep->recommended . '"');
                }
            }
        }
        return true;
    }

    function validatePhpDependency(PEAR2_Pyrus_PackageFile_v2_Dependencies_Dep $dep)
    {
        if ($this->_state != PEAR2_Pyrus_Validate::INSTALLING &&
              $this->_state != PEAR2_Pyrus_Validate::DOWNLOADING) {
            return true;
        }
        $version = $this->phpversion();
        $extra = $this->_getExtraString($dep);
        if (isset($dep->min)) {
            if (!version_compare($version, $dep->min, '>=')) {
                if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                    return $this->raiseError('%s requires PHP' .
                        $extra . ', installed version is ' . $version);
                } else {
                    return $this->warning('warning: %s requires PHP' .
                        $extra . ', installed version is ' . $version);
                }
            }
        }
        if (isset($dep->max)) {
            if (!version_compare($version, $dep->max, '<=')) {
                if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                    return $this->raiseError('%s requires PHP' .
                        $extra . ', installed version is ' . $version);
                } else {
                    return $this->warning('warning: %s requires PHP' .
                        $extra . ', installed version is ' . $version);
                }
            }
        }
        if (isset($dep->exclude)) {
            foreach ($dep->exclude as $exclude) {
                if (version_compare($version, $exclude, '==')) {
                    if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) &&
                          !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                        return $this->raiseError('%s is not compatible with PHP version ' .
                            $exclude);
                    } else {
                        return $this->warning(
                            'warning: %s is not compatible with PHP version ' .
                            $exclude);
                    }
                }
            }
        }
        return true;
    }

    /**
     * This makes unit-testing a heck of a lot easier
     */
    function getPEARVersion()
    {
        return '@PACKAGE_VERSION@' === '@'.'PACKAGE_VERSION@' ? '2.0.0' : '@PACKAGE_VERSION@';
    }

    function validatePearinstallerDependency(PEAR2_Pyrus_PackageFile_v2_Dependencies_Dep $dep)
    {
        $pearversion = $this->getPEARVersion();
        $extra = $this->_getExtraString($dep);
        if (version_compare($pearversion, $dep->min, '<')) {
            if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                return $this->raiseError('%s requires PEAR Installer' . $extra .
                    ', installed version is ' . $pearversion);
            } else {
                return $this->warning('warning: %s requires PEAR Installer' . $extra .
                    ', installed version is ' . $pearversion);
            }
        }
        if (isset($dep->max)) {
            if (version_compare($pearversion, $dep->max, '>')) {
                if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                    return $this->raiseError('%s requires PEAR Installer' . $extra .
                        ', installed version is ' . $pearversion);
                } else {
                    return $this->warning('warning: %s requires PEAR Installer' . $extra .
                        ', installed version is ' . $pearversion);
                }
            }
        }
        if (isset($dep->exclude)) {
            foreach ($dep->exclude as $exclude) {
                if (version_compare($exclude, $pearversion, '==')) {
                    if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                        return $this->raiseError('%s is not compatible with PEAR Installer ' .
                            'version ' . $exclude);
                    } else {
                        return $this->warning('warning: %s is not compatible with PEAR ' .
                            'Installer version ' . $exclude);
                    }
                }
            }
        }
        return true;
    }

    function validateSubpackageDependency(PEAR2_Pyrus_PackageFile_v2_Dependencies_Package $dep, $params)
    {
        return $this->validatePackageDependency($dep, $params);
    }

    /**
     * @param array dependency information (2.0 format)
     * @param boolean whether this is a required dependency
     * @param array a list of downloaded packages to be installed, if any
     */
    function validatePackageDependency(PEAR2_Pyrus_PackageFile_v2_Dependencies_Package $dep, $params)
    {
        if ($this->_state != PEAR2_Pyrus_Validate::INSTALLING &&
              $this->_state != PEAR2_Pyrus_Validate::DOWNLOADING) {
            return true;
        }
        $required = $dep->deptype == 'required';
        if (isset($dep->providesextension)) {
            if ($this->extension_loaded($dep->providesextension)) {
                $req = $required ? 'required' : 'optional';
                $info = $dep->getInfo();
                $info['name'] = $info['providesextension'];
                $subdep = new PEAR2_Pyrus_PackageFile_v2_Dependencies_Package(
                    $req, 'extension', null, $info, 0);
                $ret = $this->validateExtensionDependency($subdep);
                if ($ret === true) {
                    return true;
                }
            }
        }
        if ($this->_state == PEAR2_Pyrus_Validate::INSTALLING) {
            return $this->_validatePackageInstall($dep);
        }
        if ($this->_state == PEAR2_Pyrus_Validate::DOWNLOADING) {
            return $this->_validatePackageDownload($dep, $params);
        }
    }

    function _validatePackageDownload(PEAR2_Pyrus_PackageFile_v2_Dependencies_Package $dep, $params)
    {
        $required = $dep->deptype === 'required';
        $depname = PEAR2_Pyrus_Config::parsedPackageNameToString(array('package' => $dep->name,
                                                                       'channel' => $dep->channel), true);
        $found = false;
        foreach ($params as $param) {
            if ($param->name == $dep->name && $param->channel == $dep->channel) {
                $found = true;
                break;
            }
        }
        if ($found) {
            $version = $param->version['release'];
            $installed = false;
            $downloaded = true;
        } else {
            if (PEAR2_Pyrus_Config::current()->registry->exists($dep->name, $dep->channel)) {
                $installed = true;
                $downloaded = false;
                $version = PEAR2_Pyrus_Config::current()->registry->info($dep->name,
                    $dep->channel, 'version');
            } else {
                $version = 'not installed or downloaded';
                $installed = false;
                $downloaded = false;
            }
        }
        $extra = $this->_getExtraString($dep);
        if (!isset($dep->min) && !isset($dep->max) &&
              !isset($dep->recommended) && !isset($dep->exclude)) {
            if ($installed || $downloaded) {
                $installed = $installed ? 'installed' : 'downloaded';
                if ($dep->conflicts) {
                    $rest = ", $installed version is " . $version;
                    if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                        return $this->raiseError('%s conflicts with package "' . $depname . '"' .
                            $extra . $rest);
                    } else {
                        return $this->warning('warning: %s conflicts with package "' . $depname . '"' .
                            $extra . $rest);
                    }
                }
                return true;
            } else {
                if ($dep->conflicts) {
                    return true;
                }
                if ($required) {
                    if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                        return $this->raiseError('%s requires package "' . $depname . '"' .
                            $extra);
                    } else {
                        return $this->warning('warning: %s requires package "' . $depname . '"' .
                            $extra);
                    }
                } else {
                    return $this->warning('%s can optionally use package "' . $depname . '"' .
                        $extra);
                }
            }
        }
        if (!$installed && !$downloaded) {
            if ($dep->conflicts) {
                return true;
            }
            if ($required) {
                if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                    return $this->raiseError('%s requires package "' . $depname . '"' .
                        $extra);
                } else {
                    return $this->warning('warning: %s requires package "' . $depname . '"' .
                        $extra);
                }
            } else {
                return $this->warning('%s can optionally use package "' . $depname . '"' .
                    $extra);
            }
        }
        $fail = false;
        if (isset($dep->min)) {
            if (version_compare($version, $dep->min, '<')) {
                $fail = true;
            }
        }
        if (isset($dep->max)) {
            if (version_compare($version, $dep->max, '>')) {
                $fail = true;
            }
        }
        if ($fail && !$dep->conflicts) {
            $installed = $installed ? 'installed' : 'downloaded';
            $dep = PEAR2_Pyrus_Config::parsedPackageNameToString(array('package' => $dep->name,
                                                                       'channel' => $dep->channel), true);
            if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                return $this->raiseError('%s requires package "' . $depname . '"' .
                    $extra . ", $installed version is " . $version);
            } else {
                return $this->warning('warning: %s requires package "' . $depname . '"' .
                    $extra . ", $installed version is " . $version);
            }
        } elseif (!isset($dep->exclude) && (isset($dep->min) || isset($dep->max)) && !$fail &&
              $dep->conflicts) {
            $installed = $installed ? 'installed' : 'downloaded';
            if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                return $this->raiseError('%s conflicts with package "' .
                    $depname . '"' . $extra . ', ' . $installed . ' version is ' . $version);
            } else {
                return $this->warning('warning: %s conflicts with package "' .
                    $depname . '"' . $extra . ', ' . $installed . ' version is ' . $version);
            }
        }
        if (isset($dep->exclude)) {
            // exclude ordinarily tells the installer "install anything but these versions"
            // when paired with conflicts, it becomes "install only these versions"
            $conflicts = $dep->conflicts;
            foreach ($dep->exclude as $exclude) {
                if (version_compare($version, $exclude, '==')) {
                    if ($conflicts) {
                        $fail = false;
                        break;
                    }
                    goto conflict_error;
                } else {
                    if ($conflicts) {
                        $fail = true;
                    }
                }
            }
        } elseif ($dep->conflicts) {
            return true;
        }
        if ($fail) {
conflict_error:
            $installed = $installed ? 'installed' : 'downloaded';
            if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                return $this->raiseError('%s is not compatible with version ' . $version . ' of package "' .
                    $depname . '", ' . $installed . ' version is ' . $version);
            } else {
                return $this->warning('warning: %s is not compatible with version ' . $version . ' of package "' .
                    $depname . '", ' . $installed . ' version is ' . $version);
            }
        }
        if (isset($dep->recommended)) {
            if (version_compare($version, $dep->recommended, '==')) {
                return true;
            } else {
                if (!$found && $installed) {
                    $param = PEAR2_Pyrus_Config::current()->registry->package[$dep->channel . '/' . $dep->name];
                }
                if ($param) {
                    $found = false;
                    foreach ($params as $parent) {
                        if ($parent->name == $this->_currentPackage['package'] &&
                              $parent->channel == $this->_currentPackage['channel']) {
                            $found = true;
                            break;
                        }
                    }
                    if ($found) {
                        if ($param->isCompatible($parent)) {
                            return true;
                        }
                    }
                }
                $installed = $installed ? 'installed' : 'downloaded';
                if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force']) &&
                      !isset(PEAR2_Pyrus_Installer::$options['loose'])) {
                    return $this->raiseError('%s dependency package "' . $depname .
                        '" ' . $installed . ' version ' . $version .
                        ' is not the recommended version ' . $dep->recommended .
                        ', but may be compatible, use --force to install');
                } else {
                    return $this->warning('warning: %s dependency package "' . $depname .
                        '" ' . $installed . ' version ' . $version .
                        ' is not the recommended version ' . $dep->recommended);
                }
            }
        }
        return true;
    }

    function _validatePackageInstall($dep)
    {
        return $this->_validatePackageDownload($dep, array());
    }

    function validatePackageUninstall($dep, $param)
    {
        if ($dep->conflicts) {
            return true; // uninstall OK - these packages conflict (probably installed with --force)
        }
        $required = $dep->deptype == 'required';
        $depname = PEAR2_Pyrus_Config::parsedPackageNameToString(array('package' => $dep->name,
                                                                       'channel' => $dep->channel), true);
        $extra = $this->_getExtraString($dep);
        if (!isset($dep->min) && !isset($dep->max) && !isset($dep->exclude)) {
            if ($required) {
                if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                    return $this->raiseError('"' . $depname . '" is required by ' .
                        'installed package %s' . $extra);
                } else {
                    return $this->warning('warning: "' . $depname . '" is required by ' .
                        'installed package %s' . $extra);
                }
            } else {
                return $this->warning('"' . $depname . '" can be optionally used by ' .
                        'installed package %s' . $extra);
            }
        }
        $version = $param->version['release'];
        $fail = false;
        if (isset($dep->min)) {
            if (version_compare($version, $dep->min, '>=')) {
                $fail = true;
            } else {
                goto nofail;
            }
        }
        if (isset($dep->max)) {
            if (version_compare($version, $dep->max, '<=')) {
                $fail = true;
            }
        }
nofail:
        if (isset($dep->exclude)) {
            $fail = true;
            foreach ($dep->exclude as $exclude) {
                if (version_compare($version, $exclude, '==')) {
                    // rare case - we conflict with the installed package,
                    // so uninstalling is just fine
                    $fail = false;
                    break;
                }
            }
        }
        if ($fail) {
            if ($required) {
                if (!isset(PEAR2_Pyrus_Installer::$options['nodeps']) && !isset(PEAR2_Pyrus_Installer::$options['force'])) {
                    return $this->raiseError($depname . $extra . ' is required by installed package' .
                        ' "%s"');
                } else {
                    return $this->warning('warning: ' . $depname . $extra .
                        ' is required by installed package "%s"');
                }
            } else {
                return $this->warning($depname . $extra . ' can be optionally used by installed package' .
                        ' "%s"');
            }
        }
        return true;
    }

    /**
     * validate a downloaded package against installed packages
     *
     * @param $pkg downloaded package package.xml object
     * @param array $params full list of packages to install
     * @return bool
     */
    function validateDownloadedPackage(PEAR2_Pyrus_IPackageFile $pkg, $params = array())
    {
        $me = $pkg->channel . '/' . $pkg->name;
        $reg = PEAR2_Pyrus_Config::current()->registry;
        $deppackages = $reg->getDependentPackages($pkg);
        $fail = false;
        if ($deppackages) {
            $actual = array();
            // first, remove packages that will be installed
            foreach ($deppackages as $package) {
                foreach ($params as $packd) {
                    if (strtolower($packd->name) == strtolower($package->name) &&
                          $packd->channel == $package->channel) {
                        PEAR2_Pyrus_Log::log(3, 'skipping installed package check of "' .
                                    PEAR2_Pyrus_Config::parsedPackageNameToString(
                                        array('channel' => $package->channel, 'package' => $package->name),
                                        true) .
                                    '", version "' . $packd->version['release'] . '" will be ' .
                                    'downloaded and installed');
                        continue 2;
                    }
                }
                $actual[] = $package;
            }
            foreach ($actual as $package) {
                $checker = new PEAR2_Pyrus_Dependency_Validator(
                    array('channel' => $package->channel, 'package' => $package->name),
                    $this->_state, $this->errs);
                foreach ($params as $packd) {
                    $deps = $package->dependencies['required']->package;
                    if (isset($deps[$me])) {
                        $ret = $checker->_validatePackageDownload($deps[$me], array($pkg, $package));
                    }
                    $deps = $package->dependencies['required']->subpackage;
                    if (isset($deps[$me])) {
                        $ret = $checker->_validatePackageDownload($deps[$me], array($pkg));
                    }
                    $deps = $package->dependencies['optional']->package;
                    if (isset($deps[$me])) {
                        $ret = $checker->_validatePackageDownload($deps[$me], array($pkg, $package));
                    }
                    $deps = $package->dependencies['optional']->subpackage;
                    if (isset($deps[$me])) {
                        $ret = $checker->_validatePackageDownload($deps[$me], array($pkg));
                    }
                }
            }
        }
        if (count($this->errs->E_ERROR)) {
            return $this->raiseError(
                '%s cannot be installed, conflicts with installed packages');
        }
        return true;
    }

    function raiseError($msg)
    {
        if (isset(PEAR2_Pyrus_Installer::$options['ignore-errors'])) {
            return $this->warning($msg);
        }
        $this->errs->E_ERROR[] = new PEAR2_Pyrus_Dependency_Exception(sprintf($msg, PEAR2_Pyrus_Config::parsedPackageNameToString(
            $this->_currentPackage, true)));
        return false;
    }

    function warning($msg)
    {
        $this->errs->E_WARNING[] = new PEAR2_Pyrus_Dependency_Exception(sprintf($msg, PEAR2_Pyrus_Config::parsedPackageNameToString(
            $this->_currentPackage, true)));
        return true;
    }
}
?>
<?php
/**
 * PEAR2_Pyrus_DirectedGraph_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for directedgraph
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_DirectedGraph_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_DirectedGraph_Vertex
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class to represent vertices within the dependency directed graph.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_DirectedGraph_Vertex implements ArrayAccess, Countable, Iterator
{
    const WHITE = PEAR2_Pyrus_DirectedGraph::WHITE;
    const GRAY = PEAR2_Pyrus_DirectedGraph::GRAY;
    const BLACK = PEAR2_Pyrus_DirectedGraph::BLACK;
    protected $color = self::WHITE;
    public $data;
    protected $connections = array();

    /**
     * Encapsulate data within a directed graph vertex
     *
     * @param object $data
     */
    function __construct($data)
    {
        if (!is_object($data)) {
            throw new PEAR2_Pyrus_DirectedGraph_Exception('data must be an object, was ' .
                gettype($data));
        }

        $this->data = $data;
    }

    /**
     * Connect to another vertex
     *
     * @param PEAR2_Pyrus_DirectedGraph_Vertex $to
     */
    function connect(PEAR2_Pyrus_DirectedGraph_Vertex $to)
    {
        $this->connections[spl_object_hash($to)] = $to;
    }

    /**
     * Set the color of a visited node
     *
     * WHITE = unvisited, GRAY = visited, BLACK = finished
     *
     * @param self::WHITE|self::GRAY|self::BLACK|null $color if null, return the current color
     * @return int
     */
    function color($color = null)
    {
        if ($color === null) {
            return $this->color;
        }

        $this->color = $color;
    }

    function count()
    {
        $count = count($this->connections);
        foreach ($this->connections as $node) {
            if ($node->color() != self::WHITE) {
                --$count;
            }
        }

        return $count;
    }

    function offsetGet($var)
    {
        return $this->connections[$var];
    }

    function offsetSet($var, $value)
    {
        if ($value instanceof PEAR2_Pyrus_DirectedGraph_Vertex) {
            $this->connect($value);
        }
    }

    function offsetExists($var)
    {
        return isset($this->connections[$var]);
    }

    function offsetUnset($var)
    {
        unset($this->connections[$var]);
    }

    function current()
    {
        return current($this->connections);
    }

    function next()
    {
        return next($this->connections);
    }

    function key()
    {
        return key($this->connections);
    }

    function valid()
    {
        return current($this->connections);
    }

    function rewind()
    {
        reset($this->connections);
    }
}<?php
/**
 * Base class for all installation roles.
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for all installation roles.
 *
 * This class allows extensibility of file roles.  Packages with complex
 * customization can now provide custom file roles along with the possibility of
 * adding configuration values to match.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Common
{
    /**
     * @var PEAR_Config
     * @access protected
     */
    protected $config;

    /**
     * @param PEAR2_Pyrus_Config
     */
    function __construct(PEAR2_Pyrus_Config $config)
    {
        $this->config = $config;
    }

    /**
     * Retrieve configuration information about a file role from its XML info
     *
     * @param string $role Role Classname, as in "PEAR2_Pyrus_Installer_Role_Data"
     * @return array
     */
    static function getInfo($role)
    {
        return PEAR2_Pyrus_Installer_Role::getInfo($role);
    }

    /**
     * Retrieve the location a packaged file should be placed in a package
     *
     * @param PEAR2_Pyrus_Package $pkg
     * @param array $atts
     * @return string
     */
    function getPackagingLocation(PEAR2_Pyrus_IPackageFile $pkg, $atts)
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        $role = str_replace('pear2_pyrus_installer_role_', '',
                strtolower(get_class($this)));

        $file = $atts['name'];
        // strip role from file path
        // so src/Path/To/File.php becomes Path/To/File.php,
        // data/package.xsd becomes package.xsd
        $newpath = $file;
        if ($role === 'php') {
            if (strpos($newpath, 'src') === 0) {
                $newpath = substr($newpath, 4);
            }
        } elseif (strpos($newpath, $role) === 0) {
            $newpath = substr($newpath, strlen($role) + 1);
        }
        if ($newpath === false) {
            $newpath = $file;
        }

        if ($newpath) {
            if ($newpath[0] == '/') {
                $newpath = substr($newpath, 1);
            }
            $file = $newpath;
        }

        if ($roleInfo['honorsbaseinstall']) {
            $dest_dir = $role;
            if (array_key_exists('baseinstalldir', $atts)) {
                if ($atts['baseinstalldir'] != '/') {
                    $dest_dir .= '/' . $atts['baseinstalldir'];
                }

                if (strlen($atts['baseinstalldir'])) {
                    $dest_dir .= '/';
                }
            } else {
                $dest_dir .= '/';
            }
        } elseif ($roleInfo['unusualbaseinstall']) {
            $dest_dir = $role . '/' . $pkg->channel . '/' . $pkg->name . '/';
            if (array_key_exists('baseinstalldir', $atts)) {
                if (strlen($atts['baseinstalldir']) && $atts['baseinstalldir'] != '/') {
                    $dest_dir .= $atts['baseinstalldir'];
                    if (strlen($atts['baseinstalldir'])) {
                        $dest_dir .= '/';
                    }
                }
            } else {
                if (dirname($file) != '.') {
                    $dest_dir .= dirname($file) . '/';
                }
            }
        } else {
            $dest_dir = $role . '/' . $pkg->channel . '/' . $pkg->name . '/';
        }

        return $dest_dir . $file;
    }

    function getRelativeLocation(PEAR2_Pyrus_IPackageFile $pkg, PEAR2_Pyrus_PackageFile_v2Iterator_FileTag $file,
                                 $retDir = false)
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        if (!$roleInfo['locationconfig']) {
            return false;
        }

        if ($roleInfo['honorsbaseinstall']) {
            $dest_dir = $save_destdir = '';
            if ($file->baseinstalldir) {
                $dest_dir .= $file->baseinstalldir;
            }
        } elseif ($roleInfo['unusualbaseinstall']) {
        	if (!$pkg->isNewPackage()) {
        		// Place files using the old doc dir structure
        		$dest_dir = $save_destdir = $pkg->name;
        	} else {
	            $dest_dir = $save_destdir =
	                $pkg->channel . DIRECTORY_SEPARATOR . $pkg->name;
        	}
            if ($file->baseinstalldir) {
                $dest_dir .= DIRECTORY_SEPARATOR . $file->baseinstalldir;
            }
        } else {
            $dest_dir = $save_destdir =
                $pkg->channel . DIRECTORY_SEPARATOR . $pkg->name;
        }

        if (dirname($file->name) != '.' && empty($file['install-as'])) {
            $newpath = dirname($file->name);
            if ($pkg->isNewPackage()) {
                // strip role from file path
                // so php/Path/To/File.php becomes Path/To/File.php,
                // data/package.xsd becomes package.xsd
                $r = strtolower(str_replace('PEAR2_Pyrus_Installer_Role_', '',
                      get_class($this)));
                if ($r === 'php') {
                    if (strpos($newpath, 'src') === 0) {
                        $newpath = substr($newpath, 4);
                        if ($newpath === false) {
                            $newpath = '';
                        }
                    }
                }
                if (strpos($newpath, $r) === 0) {
                    $newpath = substr($newpath, strlen($r) + 1);
                    if ($newpath === false) {
                        $newpath = '';
                    }
                }
            }
            if ($dest_dir && $newpath) {
                $dest_dir .= DIRECTORY_SEPARATOR;
            }
            $dest_dir .= $newpath;
        }

        if ($dest_dir) {
            $dest_dir .= DIRECTORY_SEPARATOR;
        }
        $dest_file = $dest_dir;
        if (empty($file['install-as'])) {
            $dest_file .= basename($file->name);
        } else {
            $dest_file .= $file['install-as'];
        }
        if ($retDir) {
            // Clean up the DIRECTORY_SEPARATOR mess
            $ds2 = DIRECTORY_SEPARATOR . DIRECTORY_SEPARATOR;

            list($dest_dir, $dest_file) = preg_replace(array('!\\\\+!', '!/!', "!$ds2+!"),
                                                        array(DIRECTORY_SEPARATOR, DIRECTORY_SEPARATOR,
                                                              DIRECTORY_SEPARATOR),
                                                        array($dest_dir, $dest_file));
            return array($dest_dir, $dest_file);
        }
        return $dest_file;
    }

    /**
     * Get the name of the configuration variable that specifies the location of this file
     * @return string|false
     */
    function getLocationConfig()
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        return $roleInfo['locationconfig'];
    }

    /**
     * Do any unusual setup here
     * @param PEAR_Installer
     * @param PEAR_PackageFile_v2
     * @param array file attributes
     * @param string file name
     */
    function setup($installer, $pkg, $atts, $file)
    {
    }

    function isExecutable()
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        return $roleInfo['executable'];
    }

    function isInstallable()
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role_Common::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        return $roleInfo['installable'];
    }

    function isExtension()
    {
        $roleInfo = PEAR2_Pyrus_Installer_Role::getInfo('PEAR2_Pyrus_Installer_Role_' .
            ucfirst(str_replace('pear2_pyrus_installer_role_', '', strtolower(get_class($this)))));
        return $roleInfo['phpextension'];
    }
}<?php
/**
 * PEAR2_Pyrus_Installer_Role_Data
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Data role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Data extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>data_dir</locationconfig>
 <honorsbaseinstall />
 <unusualbaseinstall>1</unusualbaseinstall>
 <phpfile />
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Doc
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Doc role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Doc extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>doc_dir</locationconfig>
 <honorsbaseinstall />
 <unusualbaseinstall>1</unusualbaseinstall>
 <phpfile />
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Exception
 * 
 * PHP version 5
 * 
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for roles
 * 
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Installer_Role_Ext
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Ext role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Ext extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>ext_dir</locationconfig>
 <honorsbaseinstall>1</honorsbaseinstall>
 <unusualbaseinstall />
 <phpfile />
 <executable />
 <phpextension>1</phpextension>
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Php
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * php role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Php extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>php_dir</locationconfig>
 <honorsbaseinstall>1</honorsbaseinstall>
 <unusualbaseinstall />
 <phpfile>1</phpfile>
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Script
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Script role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Script extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>bin_dir</locationconfig>
 <honorsbaseinstall>1</honorsbaseinstall>
 <unusualbaseinstall />
 <phpfile />
 <executable>1</executable>
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Src
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Src role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Src extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>extsrc</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <installable>1</installable>
 <locationconfig>src_dir</locationconfig>
 <honorsbaseinstall />
 <unusualbaseinstall>1</unusualbaseinstall>
 <phpfile />
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Test
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Test role
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Test extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>test_dir</locationconfig>
 <honorsbaseinstall />
 <unusualbaseinstall>1</unusualbaseinstall>
 <phpfile />
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Role_Www
 * 
 * PHP version 5
 * 
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * www role
 * 
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role_Www extends PEAR2_Pyrus_Installer_Role_Common {}
?><role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>www_dir</locationconfig>
 <honorsbaseinstall />
 <unusualbaseinstall>1</unusualbaseinstall>
 <phpfile />
 <executable />
 <phpextension />
 <config_vars />
</role><?php
/**
 * PEAR2_Pyrus_Installer_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus installer
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Installer_Role
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for installation roles for files.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer_Role
{
    static private $_roles;

    public static function getRelativeInstallLocation(PEAR2_Pyrus_PackageFile_v2Iterator_FileTag $file)
    {
        
    }
    /**
     * Set up any additional configuration variables that file roles require
     *
     * Never call this directly, it is called by the PEAR_Config constructor
     * @param PEAR2_Pyrus_Config
     * @access private
     * @static
     */
    public static function initializeConfig(PEAR2_Pyrus_Config $config)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }

        foreach (self::$_roles as $class => $info) {
            if (!$info['config_vars']) {
                continue;
            }

            $config->addConfigValue($info['config_vars']);
        }
    }

    /**
     * @param string package type
     * @param string role name
     * @static
     */
    static function factory($packagetype, $role)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }

        if (!in_array($role, self::getValidRoles($packagetype))) {
            throw new PEAR2_Pyrus_Installer_Exception('Invalid role ' . $role .
                                                      'requested for package type ' . $packagetype);
        }

        $a = 'PEAR2_Pyrus_Installer_Role_' . ucfirst($role);
        return new $a(PEAR2_Pyrus_Config::current());
    }

    /**
     * Get a list of file roles that are valid for the particular release type.
     *
     * For instance, src files serve no purpose in regular php releases.
     * @param string
     * @param bool clear cache
     * @return array
     * @static
     */
    static function getValidRoles($release, $clear = false)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }

        static $ret = array();
        if ($clear) {
            $ret = array();
        }

        if (isset($ret[$release])) {
            return $ret[$release];
        }

        $ret[$release] = array();
        foreach (self::$_roles as $role => $okreleases) {
            if (in_array($release, $okreleases['releasetypes'])) {
                $ret[$release][] = strtolower(str_replace('PEAR2_Pyrus_Installer_Role_', '', $role));
            }
        }

        return $ret[$release];
    }

    /**
     * Get a list of roles that require their files to be installed
     *
     * Most roles must be installed, but src and package roles, for instance
     * are pseudo-roles.  src files are compiled into a new extension.  Package
     * roles are actually fully bundled releases of a package
     * @param bool clear cache
     * @return array
     * @static
     */
    static function getInstallableRoles($clear = false)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }

        static $ret;
        if ($clear) {
            unset($ret);
        }

        if (!isset($ret)) {
            $ret = array();
            foreach (self::$_roles as $role => $okreleases) {
                if ($okreleases['installable']) {
                    $ret[] = strtolower(str_replace('PEAR2_Pyrus_Installer_Role_', '', $role));
                }
            }
        }

        return $ret;
    }

    /**
     * Return an array of roles that are affected by the baseinstalldir attribute
     *
     * Most roles ignore this attribute, and instead install directly into:
     * PackageName/filepath
     * so a tests file tests/file.phpt is installed into PackageName/tests/filepath.php
     * @param bool clear cache
     * @return array
     * @static
     */
    static function getBaseinstallRoles($clear = false)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }

        static $ret;
        if ($clear) {
            unset($ret);
        }

        if (!isset($ret)) {
            $ret = array();
            foreach (self::$_roles as $role => $okreleases) {
                if ($okreleases['honorsbaseinstall']) {
                    $ret[] = strtolower(str_replace('PEAR2_Pyrus_Installer_Role_', '', $role));
                }
            }
        }

        return $ret;
    }

    /**
     * Return an array of file roles that should be analyzed for PHP content at package time,
     * like the "php" role.
     * @param bool clear cache
     * @return array
     * @static
     */
    static function getPhpRoles($clear = false)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }

        static $ret;
        if ($clear) {
            unset($ret);
        }

        if (!isset($ret)) {
            $ret = array();
            foreach (self::$_roles as $role => $okreleases) {
                if ($okreleases['phpfile']) {
                    $ret[] = strtolower(str_replace('PEAR2_Pyrus_Installer_Role_', '', $role));
                }
            }
        }

        return $ret;
    }

    /**
     * Scan through the Command directory looking for classes
     * and see what commands they implement.
     * @param string which directory to look for classes, defaults to
     *               the Installer/Roles subdirectory of
     *               the directory from where this file (__FILE__) is
     *               included.
     *
     * @return bool TRUE on success, a PEAR error on failure
     * @access public
     * @static
     */
    static function registerRoles($dir = null)
    {
        self::$_roles = array();
        $parser = new PEAR2_Pyrus_XMLParser;
        if ($dir === null) {
            $dir = dirname(__FILE__) . '/Role';
        }

        if (!file_exists($dir) || !is_dir($dir)) {
            throw new PEAR2_Pyrus_Installer_Role_Exception("registerRoles: opendir($dir) failed");
        }

        $dp = @opendir($dir);
        if (empty($dp)) {
            throw new PEAR2_Pyrus_Installer_Role_Exception("registerRoles: opendir($dir) failed");
        }

        while ($entry = readdir($dp)) {
            if ($entry{0} == '.' || substr($entry, -4) != '.xml') {
                continue;
            }

            $class = "PEAR2_Pyrus_Installer_Role_".substr($entry, 0, -4);
            // List of roles
            if (!isset(self::$_roles[$class])) {
                $file = "$dir/$entry";
                $data = $parser->parse($file);
                $data = $data['role'];
                if (!is_array($data['releasetypes'])) {
                    $data['releasetypes'] = array($data['releasetypes']);
                }
                self::$_roles[$class] = $data;
            }
        }

        closedir($dp);
        $roles = self::$_roles;
        ksort($roles);
        self::$_roles = $roles;
        self::getBaseinstallRoles(true);
        self::getInstallableRoles(true);
        self::getPhpRoles(true);
        self::getValidRoles('****', true);
        return true;
    }

    /**
     * Retrieve configuration information about a file role from its XML info
     *
     * @param string $role Role Classname, as in "PEAR2_Pyrus_Installer_Role_Data"
     * @return array
     */
    static function getInfo($role)
    {
        if (!isset(self::$_roles)) {
            self::registerRoles();
        }

        if (empty(self::$_roles[$role])) {
            throw new PEAR2_Pyrus_Installer_Role_Exception('Unknown Role class: "' . $role . '"');
        }

        return self::$_roles[$role];
    }
}<?php
/**
 * PEAR2_Pyrus_Package_Creator_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for package creator
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Creator_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Package_Creator_TaskIterator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class which iterates over all the tasks to perform for package creation.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Creator_TaskIterator extends FilterIterator
{
    private $_inner;
    private $_parent;
    private $_tasksNs;
    private $_installphase;
    protected $lastversion;

    function __construct(array $arr, PEAR2_Pyrus_IPackage $parent, $phase, $lastversion = null)
    {
        $this->_parent = $parent;
        $this->_tasksNs = $this->_parent->getTasksNs();
        $this->_installphase = $phase;
        $this->lastversion = $lastversion;
        parent::__construct($this->_inner = new ArrayIterator($arr));
    }

    function accept()
    {
        if (!$this->_inner->valid()) {
            return false;
        }

        if ($this->_inner->key() == 'attribs') {
            return false;
        }

        $key = parent::key();
        if (strpos($key, $this->_tasksNs . ':') !== 0) {
            return false;
        }

        $task = str_replace(array($this->_tasksNs . ':', '-'), array('', ' '), parent::key());
        $task = str_replace(' ', '/', ucwords($task));
        $task = str_replace('/', '_', $task);
        $task = 'PEAR2_Pyrus_Task_' . $task;

        if (0 == $task::PHASE & $this->_installphase) {
            // skip tasks that won't run in this installphase
            return false;
        }

        if ($this->_installphase == PEAR2_Pyrus_Task_Common::INSTALL && $this->_parent->isPreProcessed()) {
            $info = $this->current();
            if ($info->isPreProcessed()) {
                // some tasks are pre-processed at package-time
                return false;
            }
        }
        return true;
    }

    function key()
    {
        return str_replace($this->_tasksNs . ':', '', parent::key());
    }

    function current()
    {
        $xml = parent::current();
        if (isset($xml[0])) {
            $tasks = array();
            $task = str_replace(array($this->_tasksNs . ':', '-'), array('', ' '), parent::key());
            $task = str_replace(' ', '/', ucwords($task));
            $task = str_replace('/', '_', $task);
            $task = 'PEAR2_Pyrus_Task_' . $task;
            foreach ($xml as $info) {
                $attribs = array();
                if (isset($xml['attribs'])) {
                    $attribs = $xml['attribs'];
                }
                $tasks[] = new $task($this->_parent, $this->_installphase, $info, $attribs, $this->lastversion);
            }
            // use proxy for multiple tasks
            return new PEAR2_Pyrus_Task_MultipleProxy($this->_parent, $tasks, $this->_inner['attribs'], $this->key());
        }
        $attribs = array();
        if (isset($xml['attribs'])) {
            $attribs = $xml['attribs'];
        }
        $task = str_replace(array($this->_tasksNs . ':', '-'), array('', ' '), parent::key());
        $task = str_replace(' ', '/', ucwords($task));
        $task = str_replace('/', '_', $task);
        $task = 'PEAR2_Pyrus_Task_' . $task;
        return new $task($this->_parent, $this->_installphase, $xml, $attribs, $this->lastversion);
    }
}<?php
/**
 * PEAR2_Pyrus_Package_Phar_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Phar packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Phar_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Package_Tar_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Tar packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Tar_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Package_Zip_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Zip packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Zip_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Package_Base
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for representing a package in Pyrus
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
abstract class PEAR2_Pyrus_Package_Base implements PEAR2_Pyrus_IPackage
{
    protected $packagefile;
    /**
     * The original source of this package
     *
     * This is a chain documenting the steps it took to get this
     * package instantiated, for instance Tar->Abstract
     * @var PEAR2_Pyrus_IPackage
     */
    protected $from;

    function __construct(PEAR2_Pyrus_PackageFile $packagefile, $parent = null)
    {
        $this->packagefile = $packagefile;
        $this->from = $parent;
    }

    function isStatic()
    {
        return true;
    }

    /**
     * Used to determine whether a package is designed for Pyrus, or for the PEAR installer
     *
     * @return bool
     */
    function isNewPackage()
    {
        return version_compare($this->dependencies['required']->pearinstaller->min,
                               '2.0.0a1', '>=');
    }

    function isUpgradeable()
    {
        if (!isset(PEAR2_Pyrus_Installer::$options['upgrade'])) {
            // we don't attempt to upgrade a dep unless we're upgrading
            return false;
        }
        $reg = PEAR2_Pyrus_Config::current()->registry;
        $version = $reg->info($this->name, $info->channel, 'version');
        if (version_compare($this->version, $version, '<=')) {
            return false;
        }
        return true;
    }

    /**
     * This test tells the installer whether to run any package-info
     * replacement tasks.
     *
     * The XML package has not had any package-info transformations.  Packages
     * in tar/zip/phar format have had package-info replacements.
     * @return bool if false, the installer will run all packag-einfo replacements
     */
    function isPreProcessed()
    {
        return true;
    }

    function setFrom(PEAR2_Pyrus_IPackage $from)
    {
        $this->from = $from;
    }

    function getFrom()
    {
        if ($this->from) {
            return $this->from->getFrom();
        }

        return $this;
    }

    /**
     * Sort files/directories for removal
     *
     * Files are always removed first, followed by directories in
     * path order
     * @param unknown_type $a
     * @param unknown_type $b
     * @return unknown
     */
    static function sortstuff($a, $b)
    {
        // files can be removed in any order
        if (is_file($a) && is_file($b)) return 0;
        if (is_dir($a) && is_file($b)) return 1;
        if (is_dir($b) && is_file($a)) return -1;
        $countslasha = substr_count($a, DIRECTORY_SEPARATOR);
        $countslashb = substr_count($b, DIRECTORY_SEPARATOR);
        if ($countslasha > $countslashb) return -1;
        if ($countslashb > $countslasha) return 1;
        // if not subdirectories, tehy can be removed in any order
        return 0;
    }

    /**
     * Create vertices/edges of a directed graph for dependencies of this package
     *
     * Iterate over dependencies and create edges from this package to those it
     * depends upon
     * @param PEAR2_Pyrus_DirectedGraph $graph
     * @param array $packages channel/package indexed array of PEAR2_Pyrus_Package objects
     */
    function makeConnections(PEAR2_Pyrus_DirectedGraph $graph, array $packages)
    {
        $graph->add($this->getFrom());
        foreach (array('required', 'optional') as $required) {
            foreach (array('package', 'subpackage') as $package) {
                foreach ($this->dependencies[$required]->$package as $d) {
                    if ($d->conflicts) {
                        continue;
                    }

                    if (isset($packages[$d->channel . '/' . $d->name])) {
                        $graph->connect($this, $packages[$d->channel . '/' . $d->name]);
                    }
                }
            }
        }

        foreach ($this->dependencies['group'] as $group) {
            foreach (array('package', 'subpackage') as $package) {
                foreach ($group->$package as $d) {
                    if ($d->conflicts) {
                        continue;
                    }

                    if (isset($packages[$d->channel . '/' . $d->name])) {
                        $graph->connect($this, $packages[$d->channel . '/' . $d->name]);
                    }
                }
            }
        }
    }

    function offsetExists($offset)
    {
        return $this->packagefile->info->hasFile($offset);
    }

    function offsetGet($offset)
    {
        if (strpos($offset, 'contents://') === 0) {
            return $this->getFileContents(substr($offset, 11));
        }

        return $this->packagefile->info->getFile($offset);
    }

    function offsetSet($offset, $value)
    {
        return;
    }

    function offsetUnset($offset)
    {
        return;
    }

    function getPackageFile()
    {
        return $this->packagefile;
    }

    function __call($func, $args)
    {
        // delegate to the internal object
        return call_user_func_array(array($this->packagefile->info, $func), $args);
    }

    function __get($var)
    {
        return $this->packagefile->info->$var;
    }

    function __set($var, $value)
    {
        return $this->packagefile->info->$var = $value;
    }

    function getValidator()
    {
        return $this->packagefile->info->getValidator();
    }

    function toArray($forpackaging = false)
    {
        return $this->packagefile->info->toArray($forpackaging);
    }

    function __toString()
    {
        return $this->packagefile->__toString();
    }

    function validate($state = PEAR2_Pyrus_Validate::NORMAL)
    {
        $validator = $this->packagefile->getValidator();
        if (!$validator->validate($this, $state)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml', $validator->getErrors());
        }
    }

    function getPackageFileObject()
    {
        return $this->packagefile;
    }

    function getFileContents($file, $asstream = false)
    {
        if (!isset($this[$file])) {
            throw new PEAR2_Pyrus_Package_Exception('file ' . $file . ' is not in this package');
        }
        if ($asstream) {
            $fp = fopen($this->getFilePath($file), 'rb');
            return $fp;
        } else {
            $ret = file_get_contents($this->getFilePath($file));
            if (!$ret) {
                $ret = '';
            }
            return $ret;
        }
    }
}
<?php
/**
 * PEAR2_Pyrus_Package_Creator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Create packages using provided renderers.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Creator
{
    const VERSION = '@PACKAGE_VERSION@';
    private $_creators;
    private $_handles = array();
    /**
     * Begin package creation
     *
     * @param array|PEAR2_Pyrus_Package_ICreator $creators
     */
    function __construct($creators, $pear2ExceptionPath = false, $pear2AutoloadPath = false,
                         $pear2MultiErrorsPath = false)
    {
        if (!$pear2ExceptionPath) {
            if (!($pear2Exception = @fopen('PEAR2/Exception.php', 'r', true))) {
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/Exception.php, please' .
                    ' pass in the path to the constructor');
            }
        } else {
            if ($a = realpath($pear2ExceptionPath)) {
                $pear2ExceptionPath = $a;
            }
            if (dirname($pear2ExceptionPath) == dirname($pear2ExceptionPath . 'test')) {
                $pear2ExceptionPath .= '/';
            }
            if (!($pear2Exception = @fopen($pear2ExceptionPath . 'Exception.php', 'r'))) {
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/Exception.php' .
                    ' in ' . $pear2ExceptionPath);
            }
        }

        if (!$pear2AutoloadPath) {
            if (!($pear2Autoload = @fopen('PEAR2/Autoload.php', 'r', true))) {
                fclose($pear2Exception);
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/Autoload.php, please' .
                    ' pass in the path to the constructor');
            }
        } else {
            if ($a = realpath($pear2AutoloadPath)) {
                $pear2AutoloadPath = $a;
            }
            if (dirname($pear2AutoloadPath) == dirname($pear2AutoloadPath . 'test')) {
                $pear2AutoloadPath .= '/';
            }
            if (!($pear2Autoload = @fopen($pear2AutoloadPath . 'Autoload.php', 'r'))) {
                fclose($pear2Exception);
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/Autoload.php' .
                    ' in ' . $pear2AutoloadPath);
            }
        }

        if (!$pear2MultiErrorsPath) {
            if (!($pear2MultiErrors = @fopen('PEAR2/MultiErrors.php', 'r', true))) {
                fclose($pear2Exception);
                fclose($pear2Autoload);
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/MultiErrors.php, please' .
                    ' pass in the path to the constructor');
            }

            if (!($pear2MultiErrorsException = @fopen('PEAR2/MultiErrors/Exception.php', 'r', true))) {
                fclose($pear2Exception);
                fclose($pear2Autoload);
                fclose($pear2MultiErrors);
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/MultiErrors/Exception.php, please' .
                    ' pass in the path to the constructor');
            }
        } else {
            if ($a = realpath($pear2MultiErrorsPath)) {
                $pear2MultiErrorsPath = $a;
            }
            if (dirname($pear2MultiErrorsPath) == dirname($pear2MultiErrorsPath . 'test')) {
                $pear2MultiErrorsPath .= '/';
            }

            if (!($pear2MultiErrors = @fopen($pear2MultiErrorsPath . 'MultiErrors.php', 'r'))) {
                fclose($pear2Exception);
                fclose($pear2Autoload);
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/MultiErrors.php' .
                    ' in ' . $pear2MultiErrorsPath . 'MultiErrors.php');
            }

            if (!($pear2MultiErrorsException = @fopen($pear2MultiErrorsPath . 'MultiErrors/Exception.php', 'r'))) {
                fclose($pear2Exception);
                fclose($pear2Autoload);
                fclose($pear2MultiErrors);
                throw new PEAR2_Pyrus_Package_Exception('Cannot locate PEAR2/MultiErrors/Exception.php' .
                    ' in ' . $pear2MultiErrorsPath . 'MultiErrors/Exception.php');
            }
        }

        $this->_handles['php/PEAR2/Autoload.php'] = $pear2Autoload;
        $this->_handles['php/PEAR2/MultiErrors.php'] = $pear2MultiErrors;
        $this->_handles['php/PEAR2/MultiErrors/Exception.php'] = $pear2MultiErrorsException;
        $this->_handles['php/PEAR2/Exception.php'] = $pear2Exception;
        if ($creators instanceof PEAR2_Pyrus_Package_ICreator) {
            $this->_creators = array($creators);
        } elseif (is_array($creators)) {
            foreach ($creators as $creator) {
                if ($creator instanceof PEAR2_Pyrus_Package_ICreator) {
                    continue;
                }

                throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid ' .
                    'PEAR2 package creator passed into PEAR2_Pyrus_Package_Creator');
            }
            $this->_creators = $creators;
        } else {
            throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid ' .
                'PEAR2 package creator passed into PEAR2_Pyrus_Package_Creator');
        }
    }

    /**
     * Render packages from the creators passed into the constructor.
     *
     * This will take any package source and an array mapping internal
     * path => file name and create new packages in the formats requested.
     *
     * All files in package.xml will have the string @PACKAGE_VERSION@
     * automatically replaced with the current package's version
     * @param PEAR2_Pyrus_Package $package
     * @param array $extrafiles
     */
    function render(PEAR2_Pyrus_Package $package, array $extrafiles = array())
    {
        foreach ($this->_creators as $creator) {
            $creator->init();
        }

        $packagexml = '.xmlregistry/packages/' .
            str_replace('/', '!', $package->channel) . '/' . $package->name . '/' .
            $package->version['release'] . '-package.xml';
        if (self::VERSION === '@' . 'PACKAGE_VERSION@') {
            // we're running straight from SVN, so pretend to be 2.0.0
            $package->packagerversion = '2.0.0';
        } else {
            $package->packagerversion = self::VERSION;
        }

        // get packaging package.xml
        $packageingstr = (string) new PEAR2_Pyrus_XMLWriter($package->toArray(true));
        foreach ($this->_creators as $creator) {
            $creator->addFile($packagexml, $packageingstr);
        }
        $packagingloc = PEAR2_Pyrus_Config::current()->temp_dir . DIRECTORY_SEPARATOR . 'pyrpackage';
        if (file_exists($packagingloc)) {
            foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($packagingloc,
                        RecursiveDirectoryIterator::SKIP_DOTS), RecursiveIteratorIterator::CHILD_FIRST) as $file) {
                if (is_dir($file)) {
                    rmdir($file);
                } elseif (is_file($file)) {
                    unlink($file);
                }
            }
        } else {
            mkdir($packagingloc, 0777, true);
        }

        // $packageat is the relative path within the archive
        // $info is an array of format:
        // array('attribs' => array('name' => ...)[, 'tasks:blah' ...])
        $alreadyPackaged = array();
        $globalreplace = array('attribs' =>
                    array('from' => '@' . 'PACKAGE_VERSION@',
                          'to' => 'version',
                          'type' => 'package-info'));
        foreach ($package->packagingcontents as $packageat => $info) {
            $packageat = str_replace('\\', '/', $packageat);
            $packageat = str_replace('//', '/', $packageat);
            if ($packageat[0] === '/' ||
                  (strlen($packageat) > 2 && ($packageat[1] === ':' && $packageat[2] == '/'))) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid path, cannot' .
                    ' save a root path ' . $packageat);
            }

            if (preg_match('@^\.\.?/|/\.\.?\\z|/\.\./@', $packageat)) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid path, cannot' .
                    ' use directory reference . or .. ' . $packageat);
            }

            $alreadyPackaged[$packageat] = true;
            $contents = $package->getFileContents($info['attribs']['name'], true);
            if (!file_exists(dirname($packagingloc . DIRECTORY_SEPARATOR . $packageat))) {
                mkdir(dirname($packagingloc . DIRECTORY_SEPARATOR . $packageat), 0777, true);
            }
            $fp = fopen($packagingloc . DIRECTORY_SEPARATOR . $packageat, 'wb+');
            ftruncate($fp, 0);
            stream_copy_to_stream($contents, $fp);
            fclose($contents);
            rewind($fp);
            if ($info['attribs']['role'] == 'php') {
                if (isset($info['tasks:replace'])) {
                    if (isset($info['tasks:replace'][0])) {
                        $info['tasks:replace'][] = $globalreplace;
                    } else {
                        $info['tasks:replace'] = array($info['tasks:replace'], $globalreplace);
                    }
                } else {
                    $info['tasks:replace'] = $globalreplace;
                }
            }

            if (isset(PEAR2_Pyrus_Config::current()->registry->package[$package->channel . '/' . $package->name])) {
                $version = PEAR2_Pyrus_Config::current()->registry->info($package->name, $package->channel, 'version');
            } else {
                $version = null;
            }
            foreach (new PEAR2_Pyrus_Package_Creator_TaskIterator($info, $package,
                                                                  PEAR2_Pyrus_Task_Common::PACKAGE,
                                                                  $version) as $task) {
                // do pre-processing of file contents
                try {
                    $task->startSession($fp, $packageat);
                } catch (Exception $e) {
                    // TODO: handle exceptions
                }
            }
            fclose($fp);
        }

        foreach ($this->_creators as $creator) {
            $creator->addDir($packagingloc);
        }

        $creator->mkdir('php/PEAR2');
        foreach ($this->_handles as $path => $stream) {
            if (isset($alreadyPackaged[$path])) {
                continue; // we're packaging this package
            }

            foreach ($this->_creators as $creator) {
                $creator->addFile($path, $stream);
            }

            fclose($stream);
        }

        foreach ($this->_creators as $creator) {
            if (isset($alreadyPackaged['php/PEAR2/MultiErrors/Exception.php'])) {
                continue; // we're packaging MultiErrors package
            }

            $creator->mkdir('php/PEAR2/MultiErrors');
            $creator->addFile('php/PEAR2/MultiErrors/Exception.php',
                "<?php\nclass PEAR2_MultiErrors_Exception extends PEAR2_Exception {}");
        }

        foreach ($extrafiles as $path => $filename) {
            $path = str_replace('\\', '/', $path);
            $path = str_replace('//', '/', $path);
            if ($path[0] === '/' ||
                  (strlen($path) > 2 && ($path[1] === ':' && $path[2] == '/'))) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid path, cannot' .
                    ' save a root path ' . $path);
            }

            if (preg_match('@^\.\.?/|/\.\.?\\z|/\.\./@', $path)) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Invalid path, cannot' .
                    ' use directory reference . or .. ' . $path);
            }

            if (isset($alreadyPackaged[$path])) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Path ' . $path .
                    'has already been added, and cannot be overwritten');
            }

            $alreadyPackaged[$path] = true;
            if (!@file_exists($filename) || !($fp = @fopen($filename, 'rb'))) {
                throw new PEAR2_Pyrus_Package_Creator_Exception('Extra file ' .
                    $filename . ' does not exist or cannot be read');
            }

            foreach ($this->_creators as $creator) {
                $creator->mkdir(dirname($path));
                $creator->addFile($path, $fp);
            }

            fclose($fp);
        }

        foreach ($this->_creators as $creator) {
            $creator->close();
        }
        foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($packagingloc,
                    RecursiveDirectoryIterator::SKIP_DOTS), RecursiveIteratorIterator::CHILD_FIRST) as $file) {
            if (is_dir($file)) {
                rmdir($file);
            } elseif (is_file($file)) {
                unlink($file);
            }
        }
        rmdir($packagingloc);
    }
}<?php
/**
 * PEAR2_Pyrus_Package_Dependency
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class represents a package dependency.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Dependency extends PEAR2_Pyrus_Package_Remote
{
    /**
     * A map of package name => packages that depend on this package =>
     * actual dependency
     */
    static protected $dependencyTree = array();
    
    /**
     * A map of package => packages it depends upon
     */
    static protected $packageDepTree = array();

    static function getPHPVersion()
    {
        return phpversion();
    }

    /**
     * Check to see if any packages in the list of packages to be installed
     * satisfy this dependency, and return one if found, otherwise
     * instantiate a new dependency package object
     * @return PEAR2_Pyrus_IPackage
     */
    static function retrieve($installerclass, array $toBeInstalled,
                             PEAR2_Pyrus_PackageFile_v2_Dependencies_Package $info,
                             PEAR2_Pyrus_Package $parentPackage)
    {
        $reg = PEAR2_Pyrus_Config::current()->registry;
        static::processDependencies($info, $parentPackage);
        // first check to see if the dependency is installed
        $canupgrade = false;
        if (isset($reg->package[$info->channel . '/' . $info->name])) {
            if (!isset(PEAR2_Pyrus_Installer::$options['upgrade'])) {
                // we don't attempt to upgrade a dep unless we're upgrading
                return;
            }
            $version = $reg->info($info->name, $info->channel, 'version');
            $stability = $reg->info($info->name, $info->channel, 'state');
            if ($parentPackage->isRemote() && $parentPackage->getExplicitState()) {
                $installedstability = PEAR2_Pyrus_Installer::betterStates($stability);
                $parentstability = PEAR2_Pyrus_Installer::betterStates($parentPackage->getExplicitState());
                if (count($parentstability) > count($installedstability)) {
                    $stability = $parentPackage->getExplicitState();
                }
            } else {
                $installedstability = PEAR2_Pyrus_Installer::betterStates($stability);
                $prefstability = PEAR2_Pyrus_Installer::betterStates(PEAR2_Pyrus_Config::current()->preferred_state);
                if (count($prefstability) > count($installedstability)) {
                    $stability = PEAR2_Pyrus_Config::current()->preferred_state;
                }
            }
            // see if there are new versions in our stability or better
            $remote = new PEAR2_Pyrus_Channel_Remotepackage(PEAR2_Pyrus_Config::current()
                                                            ->channelregistry[$info->channel], $stability);
            $found = false;
            foreach ($remote[$info->name] as $remoteversion => $rinfo) {
                if (version_compare($remoteversion, $version, '<=')) {
                    continue;
                }
                if (version_compare($rinfo['minimumphp'], static::getPHPversion(), '>')) {
                    continue;
                }
                // found one, so upgrade is possible if dependencies pass
                $found = true;
                break;
            }
            // the installed package version satisfies this dependency, don't do anything
            if (!$found) {
                return;
            }
            $canupgrade = true;
        }
        if (isset($toBeInstalled[$info->channel . '/' . $info->name])) {
            $ret = $toBeInstalled[$info->channel . '/' . $info->name];
            if ($parentPackage->isRemote() && $parentPackage->getExplicitState()
                && $ret->isRemote() && !$ret->getExplicitState()) {
                $ret->setExplicitState($parentPackage->getExplicitState());
            }
            if ($ret->isRemote() && $canupgrade) {
                $ret->setUpgradeable();
            }
            return $installerclass::prepare($ret);
        }
        if (isset($info->uri)) {
            $ret = new PEAR2_Pyrus_Package_Remote($info->uri);
            // set up the basics
            $ret->name = $info->name;
            $ret->uri = $info->uri;
            return $installerclass::prepare($ret);
        }
        if ($parentPackage->isRemote() && $parentPackage->getExplicitState()) {
            // pass the same explicit state to the child dependency
            $ret = new PEAR2_Pyrus_Package_Remote($info->channel . '/' . $info->name . '-' .
                                                  $parentPackage->getExplicitState());
            if ($canupgrade) {
                $ret->setUpgradeable();
            }
            return $installerclass::prepare($ret);
        }
        $ret = new PEAR2_Pyrus_Package_Remote($info->channel . '/' . $info->name);
        if ($canupgrade) {
            $ret->setUpgradeable();
        }
        return $installerclass::prepare($ret);
    }

    /**
     * Create a tree mapping packages to those that depend on them
     *
     * This is used to determine which versions of a package satisfy
     * all package dependencies.  A composite dependency is calculated
     * from all of them, and this also allows removing a package from the
     * calculation
     */
    static protected function processDependencies($info, $parentPackage)
    {
        static::$dependencyTree[$info->channel . '/' . $info->name]
                               [$parentPackage->channel . '/' . $parentPackage->name] = $info;
        static::$packageDepTree[$parentPackage->channel . '/' . $parentPackage->name]
            [$info->channel . '/' . $info->name] = 1;
    }

    /**
     * @return array A list of packages to be removed from the to-be-installed list
     */
    static function removePackage(PEAR2_Pyrus_Package $info)
    {
        if (!isset(static::$packageDepTree[$info->channel . '/' . $info->name])) {
            return array();
        }
        $ret = array();
        foreach (static::$packageDepTree[$info->channel . '/' . $info->name] as $package => $unused) {
            unset(static::$dependencyTree[$package][$info->channel . '/' . $info->name]);
            if (!count(static::$dependencyTree[$package])) {
                $ret[] = $package;
                unset(static::$dependencyTree[$package]);
            }
        }
        unset(static::$packageDepTree[$info->channel . '/' . $info->name]);
        return $ret;
    }

    /**
     * Return a composite dependency on the package, as defined by combining
     * all dependencies on this package into one.
     *
     * As an example, for these dependencies:
     *
     * <pre>
     * P1 version >= 1.2.0
     * P1 version <= 3.0.0, != 2.3.2
     * P1 version >= 1.1.0, != 1.2.0
     * </pre>
     *
     * The composite dependency is
     *
     * <pre>
     * P1 version >= 1.2.0, <= 3.0.0, != 2.3.2, 1.2.0
     * </pre>
     */
    static function getCompositeDependency(PEAR2_Pyrus_Package $info)
    {
        if (!isset(static::$dependencyTree[$info->channel . '/' . $info->name])) {
            return new PEAR2_Pyrus_PackageFile_v2_Dependencies_Package(
                'required', 'package', null, array('name' => $info->name, 'channel' => $info->channel, 'uri' => null,
                                            'min' => null, 'max' => null,
                                            'recommended' => null, 'exclude' => null,
                                            'providesextension' => null, 'conflicts' => null), 0);
        }
        $compdep = array('name' => $info->name, 'channel' => $info->channel, 'uri' => null,
                                            'min' => null, 'max' => null,
                                            'recommended' => null, 'exclude' => null,
                                            'providesextension' => null, 'conflicts' => null);
        $initial = true;
        $recommended = null;
        $min = null;
        $max = null;
        foreach (static::$dependencyTree[$info->channel . '/' . $info->name] as $deppackage => $actualdep) {
            if ($initial) {
                if ($actualdep->min) {
                    $compdep['min'] = $actualdep->min;
                    $min = $deppackage;
                }
                if ($actualdep->max) {
                    $compdep['max'] = $actualdep->max;
                    $max = $deppackage;
                }
                if ($actualdep->recommended) {
                    $compdep['recommended'] = $actualdep->recommended;
                    $recommended = $deppackage;
                }
                $compdep['exclude'] = $actualdep->exclude;
                $initial = false;
                continue;
            }
            if (isset($compdep['recommended']) && isset($actualdep->recommended)
                && $actualdep->recommended != $compdep['recommended']) {
                throw new PEAR2_Pyrus_Package_Exception('Cannot install ' . $info->channel . '/' .
                    $info->name . ', two dependencies conflict (different recommended values for ' .
                    $deppackage . ' and ' . $recommended . ')');
            }
            if ($compdep['max'] && $actualdep->min && version_compare($actualdep->min, $compdep['max'], '>')) {
                throw new PEAR2_Pyrus_Package_Exception('Cannot install ' . $info->channel . '/' .
                    $info->name . ', two dependencies conflict (' .
                    $deppackage . ' min is > ' . $max . ' max)');
            }
            if ($compdep['min'] && $actualdep->max && version_compare($actualdep->max, $compdep['min'], '<')) {
                throw new PEAR2_Pyrus_Package_Exception('Cannot install ' . $info->channel . '/' .
                    $info->name . ', two dependencies conflict (' .
                    $deppackage . ' max is < ' . $min . ' min)');
            }
            if ($actualdep->min) {
                if ($compdep['min']) {
                    if (version_compare($actualdep->min, $compdep['min'], '>')) {
                        $compdep['min'] = $actualdep->min;
                        $min = $deppackage;
                    }
                } else {
                    $compdep['min'] = $actualdep->min;
                    $min = $deppackage;
                }
            }
            if ($actualdep->max) {
                if ($compdep['max']) {
                    if (version_compare($actualdep->max, $compdep['max'], '<')) {
                        $compdep['max'] = $actualdep->max;
                        $max = $deppackage;
                    }
                } else {
                    $compdep['max'] = $actualdep->max;
                    $max = $deppackage;
                }
            }
            if ($actualdep->recommended) {
                $compdep['recommended'] = $actualdep->recommended;
                $recommended = $deppackage;
            }
            if ($actualdep->exclude) {
                if (!$compdep['exclude']) {
                    $compdep['exclude'] = array();
                    foreach ($actualdep->exclude as $exclude) {
                        $compdep['exclude'][] = $exclude;
                    }
                    continue;
                }
                foreach ($actualdep->exclude as $exclude) {
                    if (in_array($exclude, $compdep['exclude'])) {
                        continue;
                    }
                    $compdep['exclude'][] = $exclude;
                }
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Dependencies_Package(
            'required', 'package', null, $compdep, 0);
    }
}<?php
/**
 * PEAR2_Pyrus_Package_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_Package_ICreator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for a Package creator.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_Package_ICreator
{
    /**
     * save a file inside this package
     * @param string relative path within the package
     * @param string|resource file contents or open file handle
     */
    function addFile($path, $filename);
    /**
     * Add everything within a directory and all subdirectories
     * @param string path to the directory to add
     */
    function addDir($path);
    /**
     * Initialize the package creator
     */
    function init();
    /**
     * Create an internal directory, creating parent directories as needed
     * @param string $dir
     */
    function mkdir($dir);
    /**
     * Finish saving the package
     */
    function close();
}<?php
/**
 * PEAR2_Pyrus_Package_InstalledException
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for installed packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_InstalledException extends PEAR2_Pyrus_Package_Exception {}<?php
/**
 * PEAR2_Pyrus_Package_Phar
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/PEAR2/Pyrus/
 */

/**
 * Class for phar packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/PEAR2/Pyrus/
 */
class PEAR2_Pyrus_Package_Phar extends PEAR2_Pyrus_Package_Base
{
    private $_packagename;
    static private $_tempfiles = array();
    private $_tmpdir;
    private $_BCpackage = false;

    /**
     * @param string $package path to package file
     */
    function __construct($package, PEAR2_Pyrus_Package $parent)
    {
        $package = realpath($package);
        if (!$package) {
            throw new PEAR2_Pyrus_Package_Phar_Exception(
                'Phar package ' . $package . ' does not exist');
        }

        if (!class_exists('Phar')) {
            throw new PEAR2_Pyrus_Package_Phar_Exception(
                'Phar extension is not available');
        }

        $this->_packagename = $package;
        try {
            if (Phar::isValidPharFilename($package, 1)) {
                $phar = new Phar($package, RecursiveDirectoryIterator::KEY_AS_FILENAME);
                $pxml = $phar->getMetaData();
            } else {
                $phar = new PharData($package, RecursiveDirectoryIterator::KEY_AS_FILENAME);
                $pxml = false;
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Package_Phar_Exception('Could not open Phar archive ' .
                $package, $e);
        }

        $package = str_replace('\\', '/', $package);
        try {
            if ($pxml === false) {
                foreach (new RecursiveIteratorIterator($phar,
                            RecursiveIteratorIterator::LEAVES_ONLY) as $file) {
                    $filename = $file->getFileName();
                    // default to new package.xml, but search for old one
                    // also
                    if (preg_match('@^(.+)\-package.xml$@', $filename)) {
                        $pxml = $file->getPathName();
                        break;
                    } elseif ($filename == 'package2.xml') {
                        $this->_BCpackage = true;
                        $pxml = $file->getPathName();
                    } elseif ($pxml === false && $filename == 'package.xml') {
                        $this->_BCpackage = true;
                        $pxml = $file->getPathName();
                    }
                }
            }
            if ($pxml === false) {
                throw new PEAR2_Pyrus_Package_Phar_Exception('No package.xml in archive');
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Package_Phar_Exception('Could not extract Phar archive ' .
                $package, $e);
        }

        parent::__construct(new PEAR2_Pyrus_PackageFile($pxml,
                                                       'PEAR2_Pyrus_PackageFile_v2'),
                            $parent);
    }

    function getTarballPath()
    {
        return $this->_packagename;
    }

    function copyTo($where)
    {
        copy($this->_packagename, $where . DIRECTORY_SEPARATOR . basename($this->_packagename));
        $this->_packagename = $where . DIRECTORY_SEPARATOR . basename($this->_packagename);
    }

    function isNewPackage()
    {
        return !$this->_BCpackage;
    }

    function __get($var)
    {
        if ($var === 'archivefile') {
            return $this->_packagename;
        }

        return parent::__get($var);
    }

    function getFilePath($file)
    {
        if (!isset($this->packagefile->info->files[$file])) {
            throw new PEAR2_Pyrus_Package_Exception('file ' . $file . ' is not in package.xml');
        }
        
        $phar_file = 'phar://' . str_replace('\\', '/', $this->_packagename) . '/' . $file;
        if (!file_exists($phar_file)) {
            $phar_file = 'phar://' . str_replace('\\', '/', $this->_packagename) . '/' .
                    $this->packagefile->info->name . '-' .
                    $this->packagefile->info->version['release'] . '/' .
                    $file;
        
        }
        return $phar_file;
    }
}
<?php
/**
 * PEAR2_Pyrus_Package_Remote
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class representing a remote package
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Remote extends PEAR2_Pyrus_Package
{
    private $_info;
    protected $parsedname;
    protected $explicitState = false;
    protected $explicitVersion;
    protected $explicitGroup;
    protected $type;
    protected $isUpgradeable = null;
    /**
     * For easy unit testing
     */
    static public $downloadClass = 'PEAR2_HTTP_Request';
    /**
     * @param string $package path to package file
     */
    function __construct($package, PEAR2_Pyrus_Package $parent = null)
    {
        $this->_info = $package;
        if (!is_array($package) &&
              (preg_match('#^(http[s]?|ftp[s]?)://#', $package))) {
            $this->internal = $this->fromUrl($package);
        } else {
            $this->internal = $this->fromString($package);
        }
        $this->from = $parent;
    }

    function isStatic()
    {
        if ($this->type == 'url') {
            return true;
        }
        return $this->explicitVersion;
    }

    function getExplicitState()
    {
        return $this->explicitState;
    }

    function setUpgradeable()
    {
        $this->isUpgradeable = true;
    }

    function isUpgradeable()
    {
        if ($this->isUpgradeable === null) {
            // we are not a dependency, so figure out a version that could work
            if (!isset(PEAR2_Pyrus_Installer::$options['upgrade'])) {
                // we don't attempt to upgrade a dep unless we're upgrading
                return;
            }
            $reg = PEAR2_Pyrus_Config::current()->registry;
            $version = $reg->info($this->name, $this->channel, 'version');
            $stability = $reg->info($this->name, $this->channel, 'state');
            if ($this->explicitState) {
                $stability = $this->explicitState;
            } else {
                $installedstability = PEAR2_Pyrus_Installer::betterStates($stability);
                $preferred = PEAR2_Pyrus_Installer::betterStates($pref =PEAR2_Pyrus_Config::current()->preferred_state);
                if (count($preferred) < count($installedstability)) {
                    $stability = $pref;
                }
            }
            // see if there are new versions in our stability or better
            $remote = new PEAR2_Pyrus_Channel_Remotepackage(PEAR2_Pyrus_Config::current()
                                                            ->channelregistry[$this->channel], $stability);
            $found = false;
            foreach ($remote[$this->name] as $remoteversion => $rinfo) {
                if (version_compare($remoteversion, $version, '<=')) {
                    continue;
                }
                if (version_compare($rinfo['minimumphp'], phpversion(), '>')) {
                    continue;
                }
                // found one, so upgrade is possible if dependencies pass
                $found = true;
                break;
            }
            // the installed package version satisfies this dependency, don't do anything
            if (!$found) {
                $this->isUpgradeable = false;
            } else {
                $this->isUpgradeable = true;
            }
        }
        return $this->isUpgradeable;
    }

    /**
     * Convert this remote packagefile into a local .tar, .tgz or .phar
     *
     * @return PEAR2_Pyrus_Package_Base
     */
    function download()
    {
        if ($this->type === 'url') {
            return $this->internal;
        }

        $internal = $this->internal->download();
        if ($internal->name != $this->name) {
            throw new PEAR2_Pyrus_Package_Exception('Invalid package downloaded, package name changed from ' .
                                                    $this->name . ' to ' . $internal->name);
        }
        if ($internal->channel != $this->channel) {
            throw new PEAR2_Pyrus_Package_Exception('SECURITY ERROR: package is claiming to be from ' .
                                                    'channel ' . $internal->channel . ', but we are ' .
                                                    'channel ' . $this->name);
        }
        $internal->setFrom($this->internal);
        $this->internal = $internal;
        return $this->internal;
    }

    function copyTo($where)
    {
        $old = PEAR2_Pyrus_Config::current()->download_dir;
        PEAR2_Pyrus_Config::current()->download_dir = $where;
        $this->download();
        PEAR2_Pyrus_Config::current()->download_dir = $old;
        return;
    }

    protected function fromUrl($param, $saveparam = '')
    {
        $this->type = 'url';
        $dir = PEAR2_Pyrus_Config::current()->download_dir;
        try {
            $download = static::$downloadClass;
            $http = new $download($param);
            $response = $http->sendRequest();
            $name = 'unknown.tgz';
            if ($response->code != '200') {
                throw new PEAR2_Pyrus_Package_Exception('Download failed, received ' . $response->code);
            }

            if (isset($response->headers['content-disposition'])) {
                if (preg_match('/filename="(.+)"/', $response->headers['content-disposition'], $match)) {
                    $name = $match[1];
                }
            }

            if (!@file_exists($dir)) {
                mkdir($dir, 0755, true);
            }

            file_put_contents($dir . DIRECTORY_SEPARATOR . $name, $response->body);

            // whew, download worked!
            $a = new PEAR2_Pyrus_Package($dir . DIRECTORY_SEPARATOR . $name);
            return $a->getInternalPackage();
        } catch (Exception $e) {
            if (!empty($saveparam)) {
                $saveparam = ", cannot download \"$saveparam\"";
            }
            throw new PEAR2_Pyrus_Package_Exception('Could not download from "' . $param .
                '"' . $saveparam, $e);
        }
    }

    /**
     *
     * @param string|array pass in an array of format
     *                     array(
     *                      'package' => 'pname',
     *                     ['channel' => 'channame',]
     *                     ['version' => 'version',]
     *                     ['state' => 'state',])
     *                     or a string of format [channame/]pname[-version|-state]
     */
    protected function fromString($param)
    {
        try {
            $pname = PEAR2_Pyrus_Config::parsePackageName($param, true);
        } catch (PEAR2_Pyrus_ChannelRegistry_ParseException $e) {
            if ($e->why !== 'channel') {
                throw new PEAR2_Pyrus_Package_Exception(
                    'invalid package name/package file "' . $param . '"', $e);
            }

            if (PEAR2_Pyrus_Config::current()->auto_discover) {
                try {
                    try {
                        $chan = new PEAR2_Pyrus_Channel(
                                    new PEAR2_Pyrus_ChannelFile('https://' . $e->params['channel'] . '/channel.xml',
                                                                false, true));
                    } catch (\Exception $e) {
                        $chan = new PEAR2_Pyrus_Channel(
                                    new PEAR2_Pyrus_ChannelFile('http://' . $e->params['channel'] . '/channel.xml',
                                                                false, true));
                    }
                } catch (\Exception $e) {
                    throw new PEAR2_Pyrus_Package_Exception(
                        'Cannot auto-discover channel ' . $e->params['channel'], $e);
                }
                PEAR2_Pyrus_Config::current()->channelregistry[] = $chan;
                try {
                    PEAR2_Pyrus_Config::parsePackageName($param,
                            PEAR2_Pyrus_Config::current()->default_channel);
                } catch (\Exception $e) {
                    throw new PEAR2_Pyrus_Package_Exception(
                        'invalid package name/package file "' . $param . '"', $e);
                }
            } else {
                PEAR2_Pyrus_Log::log(0, 'Channel "' . $param['channel'] .
                    '" is not initialized, use ' .
                    '"pyrus channel-discover ' . $param['channel'] . '" to initialize' .
                    'or pyrus set auto_discover 1');
            }
        }

        $this->parsedname    = $pname;
        $this->explicitVersion = isset($pname['version']) ? $pname['version'] : false;
        $this->explicitState = isset($pname['state']) ? $pname['state'] : false;
        $this->explicitGroup = isset($pname['group']) ? true            : false;

        $reg = PEAR2_Pyrus_Config::current()->registry;
        $version = $reg->info($pname['package'], $pname['channel'], 'version');
        $stability = $reg->info($pname['package'], $pname['channel'], 'state');

        if (!isset(PEAR2_Pyrus_Installer::$options['force']) &&
              !isset(PEAR2_Pyrus_Installer::$options['downloadonly']) &&
              $version && $this->explicitVersion &&
              !isset($pname['group'])) {
            if (version_compare($version, $pname['version'], '>=')) {
                throw new PEAR2_Pyrus_Package_InstalledException(
                    PEAR2_Pyrus_Config::parsedPackageNameToString($parr, true) .
                    ' is already installed and is newer than detected ' .
                    'release version ' . $pname['version']);
            }
        }
        if (!$this->explicitVersion && $stability) {
            // if installed, use stability of the installed package,
            // but only if it is less restrictive than preferred_state.
            // This allows automatic upgrade to a newer beta for 1 package
            // even if preferred_state is stable, for instance.
            $states = PEAR2_Pyrus_Installer::betterStates(PEAR2_Pyrus_Config::current()->preferred_state);
            $newstates = PEAR2_Pyrus_Installer::betterStates($stability);
            if (count($newstates) > count($states)) {
                $this->explicitState = $stability;
            }
        }

        $this->type = 'abstract';
        $ret = $this->getRemotePackage($pname);
        if ($this->explicitVersion) {
            $ret->setExplicitVersion($this->explicitVersion);
            $ret->version['release'] = $this->explicitVersion;
        }
        if ($this->explicitState) {
            $ret->setExplicitState($this->explicitState);
        }
        return $ret;
    }

    /**
     * @param array output of {@link parsePackageName()}
     * @return PEAR2_Pyrus_Channel_RemotePackage
     * @access private
     */
    function getRemotePackage($parr)
    {
        // getDownloadURL returns an array.  On error, it only contains information
        // on the latest release as array(version, info).  On success it contains
        // array(version, info, download url string)
        $state = isset($parr['state']) ? $parr['state'] :  PEAR2_Pyrus_Config::current()->preferred_state;
        if (!isset(PEAR2_Pyrus_Config::current()->channelregistry[$parr['channel']])) {
            throw new PEAR2_Pyrus_Package_Exception(
                'Unknown remote channel: ' . $parr['channel']);
        }

        try {
            $chan = PEAR2_Pyrus_Config::current()->channelregistry[$parr['channel']];
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Package_Exception('Cannot retrieve download information ' .
                'for remote abstract package ' . $parr['channel'] . '/' . $parr['package'], $e);
        }

        $p_mirror = PEAR2_Pyrus_Config::current()->preferred_mirror;
        $mirror   = isset($chan->mirrors[$p_mirror]) ? $chan->mirrors[$p_mirror] : $chan;
        return $mirror->remotepackage[$parr['package']];
    }
}<?php
/**
 * PEAR2_Pyrus_Package_Tar
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class for handling a tar package
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Tar extends PEAR2_Pyrus_Package_Base
{
    private $_fp;
    private $_packagename;
    private $_internalFileLength;
    private $_footerLength;
    private $_tmpdir;
    private $_BCpackage;
    static private $_tempfiles = array();

    /**
     * @param string $package path to package file
     */
    function __construct($package, PEAR2_Pyrus_Package $parent)
    {
        $this->_packagename = $package;
        $info = pathinfo($package);
        $streamfilters = stream_get_filters();
        $this->_fp = fopen($package, 'rb');
        switch ($info['extension']) {
            case 'tgz' :
                if ($this->_fp) {
                    fclose($this->_fp);
                    if (!function_exists('gzopen')) {
                        throw new PEAR2_Pyrus_Package_Tar_Exception('Cannot extract package '.
                            $package . ', PHP must have the zlib extension enabled --with-zlib.');
                    } else {
                        $this->_fp = gzopen($package, 'rb');
                    }
                }
                break;
            case 'tbz' :
                if (!in_array('bzip2.*', $streamfilters)) {
                    throw new PEAR2_Pyrus_Package_Tar_Exception('Cannot open package' .
                        $package . ', bzip2 decompression is not available');
                }
                stream_filter_append($this->_fp, 'bzip2.decompress');
        }

        if (!$this->_fp) {
            throw new PEAR2_Pyrus_Package_Tar_Exception('Cannot open package ' . $package);
        }

        $packagexml = $this->_extract();
        parent::__construct(new PEAR2_Pyrus_PackageFile($packagexml), $parent);
    }

    function __destruct()
    {
        usort(self::$_tempfiles, array('PEAR2_Pyrus_Package_Base', 'sortstuff'));
        foreach (self::$_tempfiles as $fileOrDir) {
            if (!file_exists($fileOrDir)) {
                continue;
            }

            if (is_file($fileOrDir)) {
                unlink($fileOrDir);
            } elseif (is_dir($fileOrDir)) {
                rmdir($fileOrDir);
            }
        }
    }

    function isNewPackage()
    {
        return !$this->_BCpackage;
    }

    private static function _addTempFile($file)
    {
        self::$_tempfiles[] = $file;
    }

    private static function _addTempDirectory($dir)
    {
        do {
            self::$_tempfiles[] = $dir;
            $dir = dirname($dir);
        } while (!file_exists($dir));
    }

    function getTarballPath()
    {
        return $this->_packagename;
    }

    function copyTo($where)
    {
        copy($this->_packagename, $where . DIRECTORY_SEPARATOR . basename($this->_packagename));
        $this->_packagename = $where . DIRECTORY_SEPARATOR . basename($this->_packagename);
    }

    function __get($var)
    {
        if ($var === 'archivefile') {
            return $this->_packagename;
        }
        return parent::__get($var);
    }

    function getFilePath($file)
    {
        if (!isset($this->packagefile->info->files[$file])) {
            throw new PEAR2_Pyrus_Package_Exception('file ' . $file . ' is not in package.xml');
        }

        $extract = '';
        if ($this->_BCpackage) {
            // old fashioned PEAR 1.x packages put everything in Package-Version/
            // directory
            $extract = $this->packagefile->info->name . '-' .
                $this->packagefile->info->version['release'];
        }

        $extract = $this->_tmpdir . $extract . DIRECTORY_SEPARATOR . $file;
        $extract = str_replace('\\', '/', $extract);
        $extract = str_replace('//', '/', $extract);
        $extract = str_replace('/', DIRECTORY_SEPARATOR, $extract);
        return $extract;
    }

    private function _processHeader($rawHeader)
    {
        if (strlen($rawHeader) < 512 || $rawHeader == pack("a512", "")) {
            throw new PEAR2_Pyrus_Package_Tar_Exception(
                'Error: "' . $this->_packagename . '" has corrupted tar header');
        }

        $header = unpack(
            "a100filename/a8mode/a8uid/a8gid/a12size/a12mtime/".
            "a8checksum/a1type/a100linkname/a6magic/a2version/".
            "a32uname/a32gname/a8devmajor/a8devminor/a155path",
            $rawHeader);
        $this->_internalFileLength = octdec($header['size']);
        if ($this->_internalFileLength % 512 == 0) {
            $this->_footerLength = 0;
        } else {
            $this->_footerLength = 512 - $this->_internalFileLength % 512;
        }
        return $header;
    }

    private function _readHeader($rawHeader)
    {
        if (!strlen($rawHeader)) {
            $this->_internalFileLength = $this->_footerLength = 0;
            return true;
        }

        if (strlen($rawHeader) != 512) {
            throw new PEAR2_Pyrus_Package_Tar_Exception(
                'Invalid block size : ' . strlen($rawHeader));
        }
        $header = $this->_processHeader($rawHeader);
        if ($header['type'] == 'L') {
            // filenames longer than 100 characters
            // borrowed from Archive_Tar written by Vincent Blavet
            $longFilename = '';
            $n = floor($header['size'] / 512);
            for ($i=0; $i < $n; $i++) {
                $content = fread($this->_fp, 512);
                $longFilename .= $content;
            }
            if (($header['size'] % 512) != 0) {
                $content = fread($this->_fp, 512);
                $longFilename .= $content;
            }
            // ----- Read the next header
            $newHeader = fread($this->_fp, 512);
            $header = $this->_processHeader($newHeader);
            $header['filename'] = trim($longFilename);
            $rawHeader = $newHeader;
        }
        if ($this->_maliciousFilename($header['filename'])) {
            throw new PEAR2_Pyrus_Package_Tar_Exception('Malicious .tar detected, file "' .
                $header['filename'] .
                '" will not install in desired directory tree');
        }

        $checksum = 256; // 8 * ord(' ');
        $c1 = str_split($rawHeader);
        $checkheader = array_merge(array_slice($c1, 0, 148), array_slice($c1, 156));
        if (!function_exists('_pear2tarchecksum')) {
            function _pear2tarchecksum($a, $b) {return $a + ord($b);}
        }
        $checksum += array_reduce($checkheader, '_pear2tarchecksum');

        // ----- Extract the checksum
        $header['checksum'] = octdec(trim($header['checksum']));
        if ($header['checksum'] != $checksum) {
            $header['filename'] = '';

            // ----- Look for last block (empty block)
            if (($checksum == 256) && ($header['checksum'] == 0)) {
                return true;
            }

            throw new PEAR2_Pyrus_Package_Tar_Exception(
                'Invalid checksum for header of file "' . $header['filename'] .
                '" : ' . $checksum . ' calculated, ' .
                $header['checksum'] . ' expected');
        }

        $header['filename'] = trim($header['filename']);
        $header['mode'] = octdec(trim($header['mode']));
        $header['uid'] = octdec(trim($header['uid']));
        $header['gid'] = octdec(trim($header['gid']));
        $header['size'] = octdec(trim($header['size']));
        $header['mtime'] = octdec(trim($header['mtime']));
        if ($header['type'] == '5') {
            $header['size'] = 0;
        }
        $header['linkname'] = trim($header['linkname']);
        return $header;
    }

    /**
     * Detect and report a malicious file name
     *
     * @param string $file
     * @return bool
     * @access private
     */
    private function _maliciousFilename($file)
    {
        if (strpos($file, '/../') !== false) {
            return true;
        }
        if (strpos($file, '../') === 0) {
            return true;
        }
        return false;
    }

    /**
     * Extract the archive so we can work with the contents
     *
     */
    private function _extract()
    {
        $packagexml = false;
        $where = (string) PEAR2_Pyrus_Config::current()->temp_dir;
        $where = str_replace('\\', '/', $where);
        $where = str_replace('//', '/', $where);
        $where = str_replace('/', DIRECTORY_SEPARATOR, $where);
        if (!file_exists($where)) {
            mkdir($where, 0777, true);
        }

        $where = realpath($where);
        if (dirname($where . 'a') != $where) {
            $where .= DIRECTORY_SEPARATOR;
        }

        $this->_tmpdir = $where;
        do {
            $header = fread($this->_fp, 512);
            if ($header == pack('a512', '')) {
                // end of archive
                break;
            }

            $header = $this->_readHeader($header);
            $extract = $where . $header['filename'];
            $extract = str_replace('\\', '/', $extract);
            $extract = str_replace('//', '/', $extract);
            $extract = str_replace('/', DIRECTORY_SEPARATOR, $extract);
            self::_addTempFile($extract);
            if (!file_exists(dirname($extract))) {
                self::_addTempDirectory(dirname($extract));
                mkdir(dirname($extract), 0777, true);
            }

            $fp = fopen($extract, 'wb');
            $amount = stream_copy_to_stream($this->_fp, $fp, $this->_internalFileLength);
            if ($amount != $this->_internalFileLength) {
                throw new PEAR2_Pyrus_Package_Tar_Exception(
                    'Unable to fully extract ' . $header['filename'] . ' from ' .
                    $this->_packagename);
            }

            if ($this->_footerLength) {
                fseek($this->_fp, $this->_footerLength, SEEK_CUR);
            }

            if (!$packagexml) {
                if (preg_match('/^package\-.+\-\\d+(?:\.\d+)*(?:[a-zA-Z]+\d*)?.xml$/',
                      $header['filename'])) {
                    $this->_BCpackage = false;
                    $packagexml = $where . $header['filename'];
                } elseif ($header['filename'] == 'package2.xml') {
                    $this->_BCpackage = true;
                    $packagexml = $where . $header['filename'];
                } elseif ($header['filename'] == 'package.xml') {
                    $this->_BCpackage = true;
                    $packagexml = $where . $header['filename'];
                }
            }
        } while ($this->_internalFileLength);

        fclose($fp);
        fclose($this->_fp);
        if (!$packagexml) {
            throw new PEAR2_Pyrus_Package_Tar_Exception('Archive ' . $this->_packagename .
                ' does not contain a package.xml file');
        }

        return $packagexml;
    }
}
<?php
/**
 * PEAR2_Pyrus_Package_Xml
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Package represented just by the package.xml file
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Xml extends PEAR2_Pyrus_Package_Base
{
    private $_file;
    function __construct($package, PEAR2_Pyrus_Package $parent, PEAR2_Pyrus_PackageFile $info = null)
    {
        $this->_file = $package;
        if ($info === null) {
            $info = new PEAR2_Pyrus_PackageFile($package);
        }
        parent::__construct($info, $parent);
    }

    /**
     * This test tells the installer whether to run any package-info
     * replacement tasks.
     *
     * The XML package has not had any package-info transformations.  Packages
     * in tar/zip/phar format have had package-info replacements.
     * @return bool if false, the installer will run all packag-einfo replacements
     */
    function isPreProcessed()
    {
        return false;
    }

    function copyTo($where)
    {
        throw new PEAR2_Pyrus_Package_Exception('download/copy not supported for extracted packages');
    }

    function getFilePath($file)
    {
        return dirname($this->_file) . DIRECTORY_SEPARATOR . $file;
    }
}
<?php
/**
 * PEAR2_Pyrus_Package_Zip
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class representing a Zip package
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package_Zip extends PEAR2_Pyrus_Package_Base
{
    private $_packagename;
    static private $_tempfiles = array();
    private $_tmpdir;

    /**
     * @param string $package path to package file
     */
    function __construct($package, PEAR2_Pyrus_Package $parent)
    {
        if (!class_exists('ZIPArchive')) {
            throw new PEAR2_Pyrus_Package_Zip_Exception(
                'Zip extension is not available');
        }

        $this->_packagename = $package;
        $zip = new ZIPArchive;
        if (true !== ($zip->open($package))) {
            throw new PEAR2_Pyrus_Package_Zip_Exception('Could not open ZIP archive ' .
                $package);
        }

        if (false !== ($pxml = $zip->getNameIndex(0))) {
            if (!preg_match('/^package\-.+\-\\d+(?:\.\d+)*(?:[a-zA-Z]+\d*)?.xml$/',
                      $pxml)) {
                throw new PEAR2_Pyrus_Package_Zip_Exception('First file in ZIP archive ' .
                    'is not package.xml, cannot process');
            }
        }

        $where = (string) PEAR2_Pyrus_Config::current()->temp_dir;
        $where = str_replace('\\', '/', $where);
        $where = str_replace('//', '/', $where);
        $where = str_replace('/', DIRECTORY_SEPARATOR, $where);
        if (!file_exists($where)) {
            mkdir($where, 0777, true);
        }

        $where = realpath($where);
        if (dirname($where . 'a') != $where) {
            $where .= DIRECTORY_SEPARATOR;
        }

        $this->_tmpdir = $where;
        $zip->extractTo($where);
        parent::__construct(new PEAR2_Pyrus_PackageFile($where . DIRECTORY_SEPARATOR . $pxml),
            $parent);
    }

    function __destruct()
    {
        usort(self::$_tempfiles, array('PEAR2_Pyrus_Package_Base', 'sortstuff'));
        foreach (self::$_tempfiles as $fileOrDir) {
            if (!file_exists($fileOrDir)) {
                continue;
            }

            if (is_file($fileOrDir)) {
                unlink($fileOrDir);
            } elseif (is_dir($fileOrDir)) {
                rmdir($fileOrDir);
            }
        }
    }

    private static function _addTempFile($file)
    {
        self::$_tempfiles[] = $file;
    }

    private static function _addTempDirectory($dir)
    {
        do {
            self::$_tempfiles[] = $dir;
            $dir = dirname($dir);
        } while (!file_exists($dir));
    }

    function __get($var)
    {
        if ($var === 'archivefile') {
            return $this->_packagename;
        }

        return parent::__get($var);
    }

    function getFilePath($file)
    {
        if (!isset($this->packagefile->info->files[$file])) {
            throw new PEAR2_Pyrus_Package_Exception('file ' . $file . ' is not in package.xml');
        }

        $extract = $this->_tmpdir . DIRECTORY_SEPARATOR . $file;
        $extract = str_replace('\\', '/', $extract);
        $extract = str_replace('//', '/', $extract);
        $extract = str_replace('/', DIRECTORY_SEPARATOR, $extract);
        return $extract;
    }
}
<?php
/**
 * package.xml parsing class, package.xml version 2.0
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Parser for package.xml version 2.0
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_Parser_v2 extends PEAR2_Pyrus_XMLParser
{
    private $_inContents = false;
    private $_path = '';
    private $_files = array();
    /**
     * Mapping of directories within package.xml and their baseinstalldir settings
     * @var array
     */
    private $_baseinstalldirs = array();
    private $_lastDepth = 0;
    private $_lastFileDepth = 0;
    private $_inFile = 0;
    private $_curFile;
    /**
     * Unindent given string
     *
     * @param string $str The string that has to be unindented.
     * @return string
     * @access private
     */
    function _unIndent($str)
    {
        // remove leading newlines
        $str = preg_replace('/^[\r\n]+/', '', $str);
        // find whitespace at the beginning of the first line
        $indent_len = strspn($str, " \t");
        $indent = substr($str, 0, $indent_len);
        $data = '';
        // remove the same amount of whitespace from following lines
        foreach (explode("\n", $str) as $line) {
            if (substr($line, 0, $indent_len) == $indent) {
                $data .= substr($line, $indent_len) . "\n";
            }
        }
        return $data;
    }

    /**
     * post-process data
     *
     * @param string $data
     * @param string $element element name
     */
    function postProcess($data, $element)
    {
        if ($element == 'notes') {
            return trim($this->_unIndent($data));
        }
        return trim($data);
    }

    /**
     * @param string
     * @param string file name of the package.xml
     * @param string|false name of the archive this package.xml came from, if any
     * @param string class name to instantiate and return.  This must be PEAR_PackageFile_v2 or
     *               a subclass
     * @return PEAR2_Pyrus_PackageFile_v2
     */
    function parse($data, $file = false, $class = 'PEAR2_Pyrus_PackageFile_v2', $state = PEAR2_Pyrus_Validate::NORMAL)
    {
        $this->_inContents = false;
        $this->_path = '';
        $this->_files = array();
        $this->_lastDepth = $this->_lastFileDepth = 0;
        $this->_inFile = 0;
        $ret = new $class;
        if (!$ret instanceof PEAR2_Pyrus_PackageFile_v2) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Class ' . $class .
                ' passed to parse() must be a child class of PEAR2_Pyrus_PackageFile_v2');
        }

        if (preg_match('/<package[^>]+version="2.1"/', $data)) {
            $schema = PEAR2_Pyrus::getDataPath() . '/package-2.1.xsd';
            // for running out of cvs
            if (!file_exists($schema)) {
                $schema = dirname(dirname(dirname(dirname(dirname(__FILE__))))) . '/data/package-2.1.xsd';
            }
        } elseif (preg_match('/<package[^>]+version="2.0"/', $data)) {
            $schema = PEAR2_Pyrus::getDataPath() . '/package-2.0.xsd';
            // for running out of cvs
            if (!file_exists($schema)) {
                $schema = dirname(dirname(dirname(dirname(dirname(__FILE__))))) . '/data/package-2.0.xsd';
            }
        } else {
            throw new PEAR2_Pyrus_PackageFile_Exception('Cannot process package.xml version 1.0');
        }
        try {
            $ret->fromArray(parent::parseString($data, $schema));
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml', $e);
        }
        $ret->setFileList($this->_files);
        $ret->setBaseInstallDirs($this->_baseinstalldirs);
        $ret->setPackagefile($file);
        return $ret;
    }

    /**
     * Merge a tag into the array
     * @see PEAR2_Pyrus_XMLParser::mergeTag()
     *
     * @param array  $arr     The array representation of the XML
     * @param string $tag     The tag name
     * @param array  $attribs Associative array of attributes for this tag
     * @param string $name    The tag name
     * @param int    $depth   The current depth within the XML document
     *
     * @return array
     */
    protected function mergeTag($arr, $tag, $attribs, $name, $depth)
    {
        $arr = parent::mergeTag($arr, $tag, $attribs, $name, $depth);
        if ($this->_inContents) {
            if ($this->_inFile) {
                if ($depth < $this->_inFile) {
                    $this->_inFile = 0;
                }
            }
            if ($name === 'dir') {
                while ($this->_lastDepth >= $depth) {
                    $this->_path = dirname($this->_path);
                    if ($this->_path == '.') {
                        $this->_path = '';
                    } else {
                        $this->_path .= '/';
                    }
                    $this->_lastDepth--;
                }
                $this->_lastDepth = $depth;
                $this->_lastFileDepth = $depth + 1;
                $origpath = $path = $attribs['name'];
                if ($path === '/') {
                    $path = '';
                } else {
                    $path .= '/';
                }
                $this->_path .= $path;
                if (isset($attribs['baseinstalldir'])) {
                    $this->_baseinstalldirs[$origpath] = $attribs['baseinstalldir'];
                } else {
                    if (isset($this->_baseinstalldirs[dirname($path)])) {
                        $this->_baseinstalldirs[$origpath] = $this->_baseinstalldirs[dirname($path)];
                    }
                }
            } elseif ($name === 'file') {
                while ($this->_lastFileDepth > $depth) {
                    $this->_path = dirname($this->_path);
                    if ($this->_path == '.') {
                        $this->_path = '';
                    } else {
                        $this->_path .= '/';
                    }
                    $this->_lastFileDepth--;
                    $this->_lastDepth--;
                }
                $path = $this->_path . $attribs['name'];
                if (isset($arr['file'][0])) {
                    $newarr = $arr['file'][count($arr['file']) - 1];
                } else {
                    $newarr = $arr['file'];
                }
                $newarr['attribs']['name'] =
                    $path;
                $this->_files[$path] = $newarr;
                $this->_curFile = $path;
                $this->_inFile = $depth;
            } elseif ($this->_inFile) {
                // add tasks
                $this->_files[$this->_curFile][$name] = $arr[$name];
            }
        } elseif ($name === 'contents') {
            $this->_inContents = true;
        }
        return $arr;
    }
}
?>
<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Compatible_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for compatiblility exceptions in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Compatible_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Files_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for file exceptions in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception extends PEAR2_Exception {}<?php
class PEAR2_Pyrus_PackageFile_v2_Dependencies_Dep implements ArrayAccess, Iterator
{
    protected $parent;
    protected $info;
    protected $type;
    function __construct($parent, array $info, $type)
    {
        $this->parent = $parent;
        $this->info = $info;
        $this->type = $type;
    }

    function current()
    {
        return current($this->info);
    }

    function rewind()
    {
        if (count($this->info) && !isset($this->info[0])) {
            $this->info = array($this->info);
        }
        reset($this->info);
    }

    function key()
    {
        return key($this->info);
    }

    function next()
    {
        return next($this->info);
    }

    function valid()
    {
        return current($this->info);
    }
    function __call($var, $args)
    {
        if ($this->type == 'os' || $this->type == 'arch') {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Unknown method ' . $var . ' called');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Unknown variable ' . $var . '(), must be one of ' .
                            implode(', ', array_keys($this->info)));
        }
        if ($args[0] === null) {
            $this->info[$var] = null;
            $this->save();
            return $this;
        }
        if ($var == 'exclude') {
            if (!isset($this->info[$var])) {
                $this->info[$var] = $args;
            } else {
                if (!is_array($this->info[$var])) {
                    $this->info[$var] = array($this->info[$var]);
                }
                $this->info[$var] = array_merge($this->info[$var], $args);
            }
        } else {
            $this->info[$var] = $args[0];
        }
        $this->save();
        return $this;
    }

    function __get($var)
    {
        if (!isset($this->info[$var])) {
            return null;
        }
        if ($var == 'exclude') {
            $ret = $this->info['exclude'];
            if (!is_array($ret)) {
                return array($ret);
            }
        }
        return $this->info[$var];
    }

    function __set($var, $value)
    {
        $this->__call($var, array($value));
    }

    function __isset($var)
    {
        return isset($this->info[$var]);
    }

    function locateDep($name)
    {
        if (count($this->info) && !isset($this->info[0])) {
            $this->info = array($this->info);
        }
        foreach ($this->info as $i => $dep)
        {
            $pattern = ($this->type == 'os') ? 'name' : 'pattern';
            if (isset($dep[$pattern]) && $dep[$pattern] == $name) {
                return $i;
            }
        }
        return false;
    }

    function offsetGet($var)
    {
        $i = $this->locateDep($var);
        if (false === $i) {
            return null;
        }
        return !isset($this->info[$i]['conflicts']);
    }

    function offsetSet($var, $value)
    {
        $i = $this->locateDep($var);
        if (false === $i) {
            $i = count($this->info);
            $pattern = ($this->type == 'os') ? 'name' : 'pattern';
            $this->info[] = array($pattern => $var);
        }
        if ($value) {
            if (isset($this->info[$i]['conflicts'])) {
                unset($this->info[$i]['conflicts']);
            }
        } else {
            $this->info[$i]['conflicts'] = '';
        }
        $this->save();
    }

    function offsetExists($var)
    {
        return false !== $this->locateDep($var);
    }

    function offsetUnset($var)
    {
        $i = $this->locateDep($var);
        if ($i === false) {
            return;
        }
        unset($this->info[$i]);
        $this->info = array_values($this->info);
        $this->save();
    }

    function getInfo()
    {
        return $this->info;
    }

    function save()
    {
        $info = $this->info;
        if ($this->type === 'php' || $this->type === 'pearinstaller') {
            foreach ($info as $key => $val) {
                if ($key === 'exclude' && is_array($val) && count($val) == 1) {
                    $info[$key] = $val[0];
                }
            }
        } else {
            if (count($info) == 1) {
                $info = $info[0];
            }
        }
        $this->parent->setInfo($this->type, $info);
        $this->parent->save();
    }
}
?><?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for dependency exceptions in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception extends PEAR2_Exception {}<?php
class PEAR2_Pyrus_PackageFile_v2_Dependencies_Group implements Iterator
{
    protected $parent;
    protected $info = array();
    protected $index = null;

    function __construct($parent, $info, $index = null)
    {
        $this->parent = $parent;
        $this->info = $info;
        $this->index = $index;
    }

    function locateGroup($name)
    {
        if (count($this->info) && !isset($this->info[0])) {
            $this->info = array($this->info);
        }
        foreach ($this->info as $i => $group)
        {
            if (isset($group['attribs']) && isset($group['attribs']['name']) && $group['attribs']['name'] == $name) {
                return $i;
            }
        }
        return false;
    }

    function current()
    {
        $i = key($this->info);
        return new PEAR2_Pyrus_PackageFile_v2_Dependencies_Group($this, $this->info[$i], $i);
    }

    function rewind()
    {
        if (count($this->info) && !isset($this->info[0])) {
            $this->info = array($this->info);
        }
        reset($this->info);
    }

    function key()
    {
        $i = key($this->info);
        return $this->info[$i]['attribs']['name'];
    }

    function next()
    {
        return next($this->info);
    }

    function valid()
    {
        return current($this->info);
    }

    function __get($group)
    {
        if (isset($this->index)) {
            if ($group == 'hint') {
                if (!isset($this->info['attribs']['hint'])) {
                    return null;
                }
                return $this->info['attribs']['hint'];
            }
            if ($group == 'name') {
                if (!isset($this->info['attribs']['name'])) {
                    return null;
                }
                return $this->info['attribs']['name'];
            }
            $var = $group;
            if (!isset($this->info[$var])) {
                switch ($var) {
                    case 'package' :
                    case 'subpackage' :
                    case 'extension' :
                        $this->info[$var] = array();
                        break;
                    default :
                        throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                                        'Only package, subpackage, and ' .
                                        'extension dependencies are supported in dependency groups, asked for ' .
                                        $var);
                }
            } else {
                switch ($var) {
                    case 'package' :
                    case 'subpackage' :
                    case 'extension' :
                        if (count($this->info[$var]) && !isset($this->info[$var][0])) {
                            $this->info[$var] = array($this->info[$var]);
                        }
                        break;
                }
            }
            return new PEAR2_Pyrus_PackageFile_v2_Dependencies_Package('group', $var, $this, $this->info[$var]);
        }
        $i = $this->locateGroup($group);
        if (false === $i) {
            $i = count($this->info);
            $this->info[] = array('attribs' => array('hint' => null, 'name' => $group));
        }
        return new PEAR2_Pyrus_PackageFile_v2_Dependencies_Group($this, $this->info[$i], $i);
    }

    function __set($group, $value)
    {
        if (isset($this->index)) {
            if ($group == 'hint') {
                if ($value === null) {
                    if (!isset($this->info['attribs']) || !isset($this->info['attribs']['hint'])) {
                        return;
                    }
                    unset($this->info['attribs']['hint']);
                    $this->save();
                    return;
                }
                if (!is_string($value)) {
                    throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('hint must be a string, was ' . gettype($value));
                }
                if (!isset($this->info['attribs'])) {
                    $this->info['attribs'] = array();
                }
                $this->info['attribs']['hint'] = $value;
                $this->save();
                return;
            }
            $info = array();
            switch ($group) {
                case 'package' :
                case 'subpackage' :
                case 'extension' :
                    if ($value === null) {
                        unset($this->info[$group]);
                        $this->save();
                        return;
                    }
                    if (!($value instanceof PEAR2_Pyrus_PackageFile_v2_Dependencies_Package)) {
                        throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                            'Can only set ' . $group . ' to PEAR2_Pyrus_PackageFile_v2_Dependencies_Package object'
                        );
                    }
                    $this->info[$group] = $value->getInfo();
                    $this->save();
                    break;
                default :
                    throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                                    'Only package, subpackage, and ' .
                                    'extension dependencies are supported in dependency groups, asked for ' .
                                    $group);
            }
        }
    }

    function __isset($group)
    {
        if (isset($this->index)) {
            if ($group == 'hint') {
                return isset($this->info['attribs']['hint']);
            }
            return isset($this->info[$group]) && !empty($this->info[$group]);
        }
        return false !== $this->locateGroup($group);
    }

    function __unset($group)
    {
        if (isset($this->index)) {
            if ($group == 'hint') {
                $this->info['attribs']['hint'] = null;
                $this->save();
                return;
            }
            unset($this->info[$group]);
            $this->save();
            return;
        }
        $i = $this->locateGroup($group);
        if ($i !== false) {
            unset($this->info[$i]);
            $this->save();
        }
    }

    function getInfo()
    {
        return $this->info;
    }

    function setInfo($index, $info)
    {
        $this->info[$index] = $info;
    }

    function save()
    {
        if ($this->parent instanceof self) {
            $this->parent->setInfo($this->index, $this->info);
        } else {
            $info = $this->info;
            if (count($info) == 1) {
                $info = $info[0];
            }
            $this->parent->setInfo('group', $info);
        }
        $this->parent->save();
    }
}
?><?php
/**
 * This class is used for package, subpackage, and extension deps
 */
class PEAR2_Pyrus_PackageFile_v2_Dependencies_Package implements ArrayAccess, Iterator
{
    protected $info;
    protected $index = null;
    protected $parent;
    protected $type;
    protected $deptype;

    function __construct($deptype, $type, $parent, array $info, $index = null)
    {
        $this->parent = $parent;
        $this->info = $info;
        $this->index = $index;
        $this->type = $type;
        $this->deptype = $deptype;
    }

    function current()
    {
        $i = key($this->info);
        switch ($this->type) {
            case 'package' :
            case 'subpackage' :
                $keys = array('name' => null, 'channel' => null, 'uri' => null,
                                            'min' => null, 'max' => null,
                                            'recommended' => null, 'exclude' => null,
                                            'providesextension' => null, 'conflicts' => null);
                if ($this->deptype != 'required') {
                    unset($keys['conflicts']);
                }
                break;
            case 'extension' :
                $keys = array('name' => null, 'min' => null, 'max' => null,
                                            'recommended' => null, 'exclude' => null, 'conflicts' => null);
                if ($this->deptype != 'required') {
                    unset($keys['conflicts']);
                }
                break;
        }
        foreach ($keys as $key => $null) {
            if (!array_key_exists($key, $this->info[$i])) {
                $this->info[$i][$key] = null;
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Dependencies_Package($this->deptype, $this->type, $this, $this->info[$i], $i);
    }

    function rewind()
    {
        reset($this->info);
    }

    function key()
    {
        $i = key($this->info);
        if ($this->type == 'extension') {
            return $this->info[$i]['name'];
        }
        $channel = isset($this->info[$i]['channel']) ? $this->info[$i]['channel'] : '__uri';
        return $channel . '/' . $this->info[$i]['name'];
    }

    function next()
    {
        return next($this->info);
    }

    function valid()
    {
        return current($this->info);
    }

    function locateDep($name)
    {
        if ($this->type == 'extension') {
            foreach ($this->info as $i => $dep)
            {
                if (isset($dep['name']) && $dep['name'] == $name) {
                    return $i;
                }
            }
            return false;
        }
        $stuff = explode('/', $name);
        $name = array_pop($stuff);
        $channel = implode('/', $stuff);
        foreach ($this->info as $i => $dep)
        {
            if ($channel == '__uri') {
                if (isset($dep['name']) && $dep['name'] == $name && isset($dep['uri'])) {
                    return $i;
                }
                continue;
            }
            if (isset($dep['name']) && $dep['name'] == $name
                && isset($dep['channel']) && $dep['channel'] == $channel) {
                return $i;
            }
        }
        return false;
    }

    function offsetGet($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Use -> operator to access dependency properties');
        }
        $i = $this->locateDep($var);
        if (false === $i) {
            $i = count($this->info);
            switch ($this->type) {
                case 'package' :
                case 'subpackage' :
                    if (!strpos($var, '/')) {
                        throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Cannot access "' . $var .
                            '", must use "channel/package" to specify a package dependency to access');
                    }
                    $stuff = explode('/', $var);
                    $name = array_pop($stuff);
                    $channel = implode('/', $stuff);
                    if ($channel === '__uri') {
                        // use fake uri, user must set it
                        $this->info[$i] = array('name' => $name, 'channel' => null, 'uri' => '__uri',
                                                    'min' => null, 'max' => null,
                                                    'recommended' => null, 'exclude' => null,
                                                    'providesextension' => null, 'conflicts' => null);
                    } else {
                        $this->info[$i] = array('name' => $name, 'channel' => $channel, 'uri' => null,
                                                    'min' => null, 'max' => null,
                                                    'recommended' => null, 'exclude' => null,
                                                    'providesextension' => null, 'conflicts' => null);
                    }
                    if ($this->deptype != 'required') {
                        unset($this->info[$i]['conflicts']);
                    }
                    break;
                case 'extension' :
                    $this->info[$i] = array('name' => $var, 'min' => null, 'max' => null,
                                                'recommended' => null, 'exclude' => null, 'conflicts' => null);
                    if ($this->deptype != 'required') {
                        unset($this->info[$i]['conflicts']);
                    }
                    break;
            }
        } else {
            switch ($this->type) {
                case 'package' :
                case 'subpackage' :
                    $keys = array('name' => $var, 'channel' => null, 'uri' => null,
                                                'min' => null, 'max' => null,
                                                'recommended' => null, 'exclude' => null,
                                                'providesextension' => null, 'conflicts' => null);
                    if ($this->deptype != 'required') {
                        unset($keys['conflicts']);
                    }
                    break;
                case 'extension' :
                    $keys = array('name' => $var, 'min' => null, 'max' => null,
                                                'recommended' => null, 'exclude' => null, 'conflicts' => null);
                    if ($this->deptype != 'required') {
                        unset($keys['conflicts']);
                    }
                    break;
            }
            foreach ($keys as $key => $null) {
                if (!array_key_exists($key, $this->info[$i])) {
                    $this->info[$i][$key] = null;
                }
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Dependencies_Package($this->deptype, $this->type, $this, $this->info[$i], $i);
    }

    function offsetSet($var, $value)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Use -> operator to access dependency properties');
        }
        if (!($value instanceof self)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Can only set $pf->dependencies[\'' .
                $this->deptype . '\']->' . $this->type . '[\'' . $var .
                '\'] to PEAR2_Pyrus_PackageFile_v2_Dependencies_Package object');
        }
        if ($this->type !== $value->type) {
            if (!(($this->type === 'package' && $value->type === 'subpackage') ||
                ($this->type === 'subpackage' && $value->type === 'package'))) {
                throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Cannot set ' . $this->type .
                    ' dependency to ' . $value->type . ' dependency');
            }
        }
        if ($var === null) {
            if ($this->type === 'extension') {
                $var = $value->name;
            } else {
                $var = $value->channel . '/' . $value->name;
            }
        }
        if ($this->type !== 'extension' && !strpos($var, '/')) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Cannot set "' . $var .
                '", must use "channel/package" to specify a package dependency to set');
        }
        if ($this->type === 'extension') {
            if ($value->name != $var) {
                throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Cannot set ' .
                    $var . ' to ' .
                    $value->name .
                    ', use $pf->dependencies[\'' .
                    $this->deptype . '\']->extension[] to set a new value');
            }
        } else {
            $stuff = explode('/', $var);
            $name = array_pop($stuff);
            $channel = implode('/', $stuff);
            if ($value->name != $name || $value->channel != $channel) {
                throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Cannot set ' .
                    $channel . '/' . $name . ' to ' .
                    $value->channel . '/' . $value->name .
                    ', use $pf->dependencies[\'' .
                    $this->deptype . '\']->' . $this->type . '[] to set a new value');
            }
        }
        if (false === ($i = $this->locateDep($var))) {
            $i = count($this->info);
        }
        $this->info[$i] = $value->getInfo();
        $this->save();
    }

    function offsetExists($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Use -> operator to access dependency properties');
        }
        $i = $this->locateDep($var);
        return $i !== false;
    }

    function offsetUnset($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Use -> operator to access dependency properties');
        }
        $i = $this->locateDep($var);
        if ($i === false) {
            return;
        }
        unset($this->info[$i]);
        $this->info = array_values($this->info);
        $this->save();
    }

    function __get($var)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Use [] operator to access ' . $this->type .
                                                                        's');
        }
        if ($var == 'conflicts') {
            return isset($this->info[$var]);
        }
        if ($var === 'deptype') {
            return $this->deptype;
        }
        if ($var === 'type') {
            return $this->type;
        }
        if ($var === 'channel' && isset($this->info['uri'])) {
            return '__uri';
        }
        if (!isset($this->info[$var])) {
            return null;
        }
        if ($var === 'exclude') {
            $ret = $this->info['exclude'];
            if (!is_array($ret)) {
                return array($ret);
            }
        }
        return $this->info[$var];
    }

    function __isset($var)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Use [] operator to access ' . $this->type .
                                                                        's');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', array_keys($this->info))
            );
        }
        return isset($this->info[$var]);
    }

    function __unset($var)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Use [] operator to access ' . $this->type .
                                                                        's');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', array_keys($this->info))
            );
        }
        $this->info[$var] = null;
    }

    function __set($var, $value)
    {
        return $this->__call($var, array($value));
    }

    function __call($var, $args)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Use [] operator to access ' . $this->type .
                                                                        's');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', array_keys($this->info))
            );
        }
        if (count($args) && $args[0] !== null && $var === 'channel' && isset($this->info['uri'])) {
            $this->info['uri'] = null;
            $this->info['channel'] = $args[0];
            $this->save();
            return;
        }
        if (count($args) && $args[0] !== null && $var === 'uri' && isset($this->info['channel'])) {
            $this->info['channel'] = null;
            $this->info['uri'] = $args[0];
            $this->save();
            return;
        }
        if ($var === 'name' || $var === 'channel') {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                'Cannot change dependency name, use unset() to remove the old dependency'
            );
        }
        if ($var == 'conflicts') {
            if (count($args)) {
                if ($args[0]) {
                    $this->info['conflicts'] = '';
                } else {
                    $this->info['conflicts'] = null;
                }
            } else {
                $this->info['conflicts'] = '';
            }
            $this->save();
            return $this;
        }
        if (!count($args) || $args[0] === null) {
            $this->info[$var] = null;
            $this->save();
            return $this;
        }
        if ($var == 'exclude') {
            if (!isset($this->info[$var])) {
                $this->info[$var] = $args;
            } else {
                if (!is_array($this->info[$var])) {
                    $this->info[$var] = array($this->info[$var]);
                }
                $this->info[$var] = array_merge($this->info[$var], $args);
            }
        } else {
            $this->info[$var] = $args[0];
        }
        $this->save();
        return $this;
    }

    function getInfo()
    {
        return $this->info;
    }

    function setInfo($index, $info)
    {
        foreach ($info as $key => $null) {
            if ($null === null) {
                unset($info[$key]);
                continue;
            }
            if (is_array($null) && count($null) == 1) {
                $info[$key] = $null[0];
            }
        }
        $this->info[$index] = $info;
    }

    function save()
    {
        if ($this->parent instanceof self) {
            $this->parent->setInfo($this->index, $this->info);
        } else {
            $info = $this->info;
            if (count($info) == 1) {
                $info = $info[0];
            }
            $this->parent->setInfo($this->type, $info);
        }
        $this->parent->save();
    }
}
?><?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Developer_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for developer exceptions in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Developer_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Files_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for file exceptions in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Files_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Files_File
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class for manipulating a filelist's file contents
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Files_File extends ArrayObject
{
    protected $pkg;
    protected $parent;
    protected $tasksNs;

    function __construct(PEAR2_Pyrus_PackageFile_v2_Files $parent, PEAR2_Pyrus_PackageFile_v2 $ultraparent, array $info)
    {
        $this->parent = $parent;
        $this->pkg = $ultraparent;
        $this->tasksNs = $ultraparent->getTasksNs() . ':';
        parent::__construct($info);
    }

    function __get($var)
    {
        $task = str_replace('-', ' ', $var);
        $task = str_replace(' ', '/', ucwords($task));
        $task = str_replace('/', '_', $task);
        $c = 'PEAR2_Pyrus_Task_' . $task;
        if (isset($this[$this->tasksNs . $var])) {
            $inf = $this[$this->tasksNs . $var];
            if (isset($inf[0])) {
                $ret = array();
                foreach ($inf as $info) {
                    $ret[] = new $c($this->pkg, PEAR2_Pyrus_Validate::NORMAL, $info, $this['attribs'], null);
                }
                goto return_multi;
            } else {
                $c = 'PEAR2_Pyrus_Task_' . str_replace('-', '_', $var);
                $ret = array(new $c($this->pkg, PEAR2_Pyrus_Validate::NORMAL, $inf, $this['attribs'], null));
                goto return_multi;
            }
        }
        $ret = array();
return_multi:
        return new PEAR2_Pyrus_Task_MultipleProxy($this->pkg, $ret, $this['attribs'], $var);
    }

    function __set($var, $value)
    {
        if (!($value instanceof PEAR2_Pyrus_Task_Common) && !($value instanceof PEAR2_Pyrus_Task_MultipleProxy)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Can only change tasks via __set() to an instance ' .
                                                        'of PEAR2_Pyrus_Task_Common');
        }
        $this[$this->tasksNs . $var] = $value->getInfo();
        $this->pkg->setFilelistFile($this['attribs']['name'], $this->getArrayCopy());
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_License_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for exceptions when handling package license.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_License_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Release_BinaryPackage
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Represents a binarypackage tag in an extsrcrelease or zendextsrcrelease tag
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Release_BinaryPackage implements ArrayAccess, Iterator, Countable
{
    protected $info;
    protected $parent;

    /**
     * @param array The content of this element.  All allowed indices should be initialized to null
     */
    function __construct($parent, $info)
    {
        $this->parent = $parent;
        $this->info = array_flip(array_values($info));
    }

    function count()
    {
        return count($this->info);
    }

    function current()
    {
        return key($this->info);
    }

    function next()
    {
        return next($this->info);
    }

    function rewind()
    {
        reset($this->info);
    }

    function valid()
    {
        return key($this->info);
    }

    function key()
    {
        return key($this->info);
    }

    function offsetUnset($var)
    {
        unset($this->info[$var]);
        $this->save();
    }

    function offsetGet($var)
    {
        if (!isset($this->info[$var])) {
            return null;
        }
        return $var;
    }

    function offsetSet($var, $value)
    {
        if (!is_string($value)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Can only set binarypackage to string');
        }
        $this->info[$value] = 1;
        $this->save();
    }

    function offsetExists($var)
    {
        return isset($this->info[$var]);
    }

    function getInfo()
    {
        $ret = array_keys($this->info);
        if (count($ret) == 1) {
            return $ret[0];
        }
        return $ret;
    }

    function save()
    {
        $info = array_keys($this->info);
        $this->parent->setBinaryPackage($this->getInfo());
        $this->parent->save();
    }
}<?php
class PEAR2_Pyrus_PackageFile_v2_Release_ConfigureOption implements ArrayAccess, Iterator, Countable
{
    protected $parent;
    protected $info;
    protected $index;
    function __construct($parent, array $info, $index = null)
    {
        $this->parent = $parent;
        $this->info = $info;
        $this->index = $index;
    }

    function current()
    {
        $info = current($this->info);
        foreach (array('name', 'default', 'prompt') as $key) {
            if (!array_key_exists($key, $info)) {
                $info[$key] = null;
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Release_ConfigureOption($this, $info, key($this->info));
    }

    function count()
    {
        return count($this->info);
    }

    function rewind()
    {
        reset($this->info);
    }

    function key()
    {
        $info = current($this->info);
        return $info['name'];
    }

    function next()
    {
        return next($this->info);
    }

    function valid()
    {
        return current($this->info);
    }

    function locateConfigureOption($name)
    {
        foreach ($this->info as $i => $dep)
        {
            if (isset($dep['name']) && $dep['name'] == $name) {
                return $i;
            }
        }
        return false;
    }

    function offsetGet($var)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'use -> operator to access properties of a configureoption');
        }
        $i = $this->locateConfigureOption($var);
        if (false === $i) {
            $i = count($this->info);
            $info = array('name' => $var, 'default' => null, 'prompt' => null);
        } else {
            $info = $this->info[$i];
            foreach (array('name', 'default', 'prompt') as $key) {
                if (!array_key_exists($key, $this->info[$i])) {
                    $info[$key] = null;
                }
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Release_ConfigureOption($this, $info, $i);
    }

    function offsetSet($var, $value)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'use -> operator to access properties of a configureoption');
        }
        if (!($value instanceof PEAR2_Pyrus_PackageFile_v2_Release_ConfigureOption)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'Can only set configureoption to a PEAR2_Pyrus_PackageFile_v2_Release_ConfigureOption object');
        }
        if ($var !== null && $var !== $value->name) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'use [] or [\'' . $value->name . '\'] to set this configureoption');
        }
        $i = $this->locateConfigureOption($var);
        if (false === $i) {
            $i = count($this->info);
        }
        $this->info[$i] = array('name' => $value->name,
                                'default' => $value->default,
                                'prompt' => $value->prompt);
        $this->save();
    }

    function offsetExists($var)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'use -> operator to access properties of a configureoption');
        }
        $i = $this->locateConfigureOption($var);
        return $i !== false;
    }

    function offsetUnset($var)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'use -> operator to access properties of a configureoption');
        }
        $i = $this->locateConfigureOption($var);
        if ($i === false) {
            return;
        }
        unset($this->info[$i]);
        $this->info = array_values($this->info);
        $this->save();
    }

    function __unset($var)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'use [] operator to access configureoptions');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'Unknown variable ' . $var . ', must be one of ' .
                implode(', ', array_keys($this->info))
            );
        }
        $this->info[$var] = null;
        $this->save();
    }

    function __isset($var)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'use [] operator to access configureoptions');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'Unknown variable ' . $var . ', must be one of ' .
                implode(', ', array_keys($this->info))
            );
        }
        return isset($this->info[$var]);
    }

    function __set($var, $value)
    {
        return $this->__call($var, array($value));
    }

    function __call($var, $args)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'use [] operator to access configureoptions');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Unknown variable ' . $var . ', must be one of ' .
                            implode(', ', array_keys($this->info)));
        }
        if ($args[0] === null) {
            $this->info[$var] = null;
            $this->save();
            return $this;
        }
        $this->info[$var] = $args[0];
        $this->save();
        return $this;
    }

    function __get($var)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                'use [] operator to access configureoptions');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Unknown variable ' . $var . ', must be one of ' .
                            implode(', ', array_keys($this->info)));
        }
        if (!isset($this->info[$var])) {
            return null;
        }
        return $this->info[$var];
    }

    function getInfo()
    {
        return $this->info;
    }

    function setInfo($info, $index)
    {
        foreach (array_keys($info) as $key) {
            if ($info[$key] === null) {
                unset($info[$key]);
            }
        }
        $this->info[$index] = $info;
    }

    function save()
    {
        if ($this->parent instanceof self) {
            $this->parent->setInfo($this->info, $this->index);
            $this->parent->save();
            return;
        }
        $info = $this->info;
        if (count($info) == 1) {
            $info = $info[0];
        }
        $this->parent->setConfigureOption($info);
        $this->parent->save();
    }
}
?><?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Release_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for release info in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Release_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Releaseinstallcondition
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Manage a release's installation conditions in package.xml
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Release_InstallCondition implements ArrayAccess
{
    protected $parent;
    protected $index = null;
    protected $installcondition;
    protected $info = array();
    function __construct($parent, array $info, $condition = null, $index = null)
    {
        $this->parent = $parent;
        $this->info = $info;
        if ($condition !== null) {
            $this->installcondition = $condition;
        }
        if ($index !== null) {
            $this->index = $index;
        }
    }

    function getInfo()
    {
        return $this->info;
    }

    function __get($var)
    {
        if ($var === 'installcondition') {
            return isset($this->installcondition) ? $this->installcondition : false;
        }
        if (isset($this->info[$var])) {
            if ($var === 'conflicts') {
                return $this->info[$var] !== null;
            }
            return $this->info[$var];
        }
        if ($var === 'conflicts') {
            return false;
        }
        return null;
    }

    function __call($var, $args)
    {
        if (!isset($this->installcondition)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Cannot set variables for unknown install condition');
        }
        if (array_key_exists($var, $this->info)) {
            if (!count($args) && $var == 'conflicts') {
                $args = array('');
            }
            $this->info[$var] = $args[0];
            $this->save();
        }
        return $this;
    }

    function offsetGet($var)
    {
        if (isset($this->installcondition) && !isset($this->index) && $this->installcondition == 'extension') {
            if (!is_string($var)) {
                throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Access extension installconditions by name, not number');
            }
            if (false === ($i = $this->locateExtension($var))) {
                $i = count($this->info);
                $this->info[$i] =
                    array('name' => $var, 'min' => null, 'max' => null, 'exclude' => null, 'conflicts' => null);
            } else {
                foreach (array('name' => null, 'min' => null, 'max' => null, 'exclude' => null, 'conflicts' => null) as $key => $val) {
                    if (!array_key_exists($key, $this->info[$i])) {
                        $this->info[$i][$key] = null;
                    }
                }
            }
            return new PEAR2_Pyrus_PackageFile_v2_Release_InstallCondition($this,
                       $this->info[$i], 'extension', $i);
        }
        if (!is_string($var)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Cannot access numeric index');
        }
        $var = strtolower($var);
        switch ($var) {
            case 'php' :
                if (!isset($this->info[$var])) {
                    $this->info[$var] = array('min' => null, 'max' => null, 'exclude' => null);
                } else {
                    foreach (array('min' => null, 'max' => null, 'exclude' => null) as $key => $val) {
                        if (!array_key_exists($key, $this->info[$var])) {
                            $this->info[$var][$key] = null;
                        }
                    }
                }
                break;
            case 'os' :
                if (!isset($this->info[$var])) {
                    $this->info[$var] = array('name' => null, 'conflicts' => null);
                } else {
                    settype($this->info[$var], 'array');
                    foreach (array('name' => null, 'conflicts' => null) as $key => $val) {
                        if (!array_key_exists($key, $this->info[$var])) {
                            $this->info[$var][$key] = null;
                        }
                    }
                }
                break;
            case 'arch' :
                if (!isset($this->info[$var])) {
                    $this->info[$var] = array('pattern' => null, 'conflicts' => null);
                } else {
                    foreach (array('pattern' => null, 'conflicts' => null) as $key => $val) {
                        if (!array_key_exists($key, $this->info[$var])) {
                            $this->info[$var][$key] = null;
                        }
                    }
                }
                break;
            case 'extension' :
                if (!isset($this->info[$var])) {
                    $this->info[$var] = array();
                } else {
                    if (!isset($this->info['extension'][0])) {
                        $this->info['extension'] = array($this->info['extension']);
                    }
                    foreach (array('name' => null, 'min' => null, 'max' => null, 'exclude' => null, 'conflicts' => null) as $key => $val) {
                        foreach ($this->info['extension'] as $index => $ext) {
                            if (!array_key_exists($key, $ext)) {
                                $this->info['extension'][$index][$key] = null;
                            }
                        }
                    }
                }
                break;
            default :
                throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Cannot access unknown install condition ' . $var);
        }
        return new PEAR2_Pyrus_PackageFile_v2_Release_InstallCondition($this, $this->info[$var],
                   $var);
    }

    protected function locateExtension($ext)
    {
        foreach ($this->info as $i => $test) {
            if (!isset($test['name'])) {
                continue;
            }
            if ($test['name'] === $ext) {
                return $i;
            }
        }
        return false;
    }

    function offsetSet($var, $value)
    {
        $info = array();
        if (isset($this->installcondition) && $this->installcondition == 'extension') {
            if (!($value instanceof PEAR2_Pyrus_PackageFile_v2_Release_InstallCondition)) {
                throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Cannot set extension to anything but a' .
                            ' PEAR2_Pyrus_PackageFile_v2_Release_InstallCondition object');
            }
        } else {
            switch ($var) {
                case 'php' :
                    if (is_string($value)) {
                        $info['min'] = $value;
                    }
                    break;
                case 'arch' :
                    if (is_string($value)) {
                        $info['pattern'] = $value;
                    }
                    break;
                case 'os' :
                    if (is_string($value)) {
                        $info['name'] = $value;
                    }
                    break;
                case 'extension' :
                    throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Set extension install condition by name');
                default :
                    throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Unknown install condition ' .
                        $var);
            }
        }
        if ($value instanceof PEAR2_Pyrus_PackageFile_v2_Release_InstallCondition && $value->installcondition) {
            if (!isset($this->installcondition) || $this->installcondition != 'extension') {
                if ($value->installcondition != $var) {
                    throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Cannot set ' . $var .
                                ' to another install condition (' . $value->installcondition . ')');
                }
                if (!isset($this->info[$var])) {
                    switch ($var) {
                        case 'php' :
                            $this->info[$var] = array('min' => null, 'max' => null, 'exclude' => null);
                            break;
                        case 'os' :
                            $this->info[$var] = array('name' => null, 'conflicts' => null);
                            break;
                        case 'arch' :
                            $this->info[$var] = array('pattern' => null, 'conflicts' => null);
                            break;
                    }
                }
                foreach ($this->info[$var] as $n => $unused) {
                    $this->info[$var][$n] = $value->$n;
                }
            } else {
                if ($value->installcondition != 'extension') {
                    throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Cannot set extension ' . $var .
                                ' to another install condition (' . $value->installcondition . ')');
                }
                $ext = $this->locateExtension($var);
                if (!$ext) {
                    $ext = count($this->info);
                    $this->info[$ext] = array('name' => $var, 'min' => null, 'max' => null, 'exclude' => null, 'conflicts' => null);
                }
                foreach (array('min' => null, 'max' => null, 'exclude' => null, 'conflicts' => null) as $n => $unused) {
                    if ($n == 'conflicts') {
                        if ($value->conflicts) {
                            $this->info[$ext]['conflicts'] = '';
                        } else {
                            $this->info[$ext]['conflicts'] = null;
                        }
                        continue;
                    }
                    $this->info[$ext][$n] = $value->$n;
                }
            }
        } else {
            foreach ($info as $key => $val) {
                $this->info[$var][$key] = $val;
            }
        }
        $this->save();
    }

    function offsetExists($var)
    {
        if ($this->installcondition == 'extension' && !isset($this->index)) {
            return ($this->locateExtension($var) !== false);
        }
        return isset($this->info[$var]);
    }

    function offsetUnset($var)
    {
        if ($this->installcondition == 'extension' && !isset($this->index)) {
            if (($i = $this->locateExtension($var)) !== false) {
                unset($this->info[$i]);
            }
            return;
        }
        unset($this->info[$var]);
        $this->save();
    }

    function setInstallCondition($obj, $type, $index = null)
    {
        if (!$this->parent) {
            return;
        }
        if ($index !== null) {
            $this->info[$index] = $obj->getInfo();
            return $this->parent->setInstallCondition($this, $type);
        }
        if (isset($this->index)) {
            $this->parent->setInstallCondition($this, $type, $this->index);
        } else {
            if (!isset($this->info[$type])) {
                $this->info[$type] = array();
            }
            $this->info[$type] = $obj->getInfo();
            $this->parent->setInstallCondition($this);
        }
    }

    function save()
    {
        if (!$this->parent) {
            return;
        }
        if (isset($this->installcondition)) {
            $this->parent->setInstallCondition($this, $this->installcondition, $this->index);
        } else {
            $this->parent->setInstallCondition($this);
        }
    }
}

?><?php
/**
 * PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for compatiblility exceptions in a package file.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_BundledPackage
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Represents bundled packages in a package.xml bundle package type
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_BundledPackage implements ArrayAccess, Countable, Iterator
{
    protected $info;
    protected $parent;

    /**
     * @param array The content of this element.  All allowed indices should be initialized to null
     */
    function __construct($parent, $info)
    {
        $this->parent = $parent;
        if (is_string($info)) {
            $info = array($info);
        }
        $this->info = $info;
    }

    function count()
    {
        return count($this->info);
    }

    function current()
    {
        return current($this->info);
    }

    function next()
    {
        next($this->info);
    }

    function key()
    {
        return current($this->info);
    }

    function valid()
    {
        return current($this->info);
    }

    function rewind()
    {
        reset($this->info);
    }

    function locatePackage($package)
    {
        foreach ($this->info as $i => $bundle) {
            if ($bundle === $package) {
                return $i;
            }
        }
        return false;
    }

    function offsetUnset($var)
    {
        $i = $this->locatePackage($var);
        if ($i === false) {
            return;
        }
        unset($this->info[$i]); 
        $this->save();
    }

    function offsetGet($var)
    {
        $i = $this->locatePackage($var);
        if ($i === false) {
            return false;
        }
        return $var;
    }

    function offsetSet($var, $value)
    {
        if (!is_string($value)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Can only set bundledpackage to string');
        }
        // $var is ignored
        $i = $this->locatePackage($value);
        if ($i === false) {
            $i = count($this->info);
        }
        $this->info[$i] = $value;
        $this->save();
    }

    function offsetExists($var)
    {
        $i = $this->locatePackage($var);
        return $i !== false;
    }

    function getInfo()
    {
        return $this->info;
    }

    function save()
    {
        $info = $this->info;
        if (count($info) == 1) {
            $info = $info[0];
        }
        $this->parent->rawcontents = array('bundledpackage' => $info);
    }
}<?php
/**
 * Manage compatible packages with this one
 *
 * To be used like:
 * <code>
 * // add a new compatible declaration or replace an existing one
 * $pf->compatible['pear.php.net/Archive_Tar']
 *         ->min('1.2')
 *         ->max('1.3.0')
 *         ->exclude('1.2.1', '1.2.2');
 * // remove a compatibility declaration
 * unset($pf->compatible['pear.php.net/Archive_Tar']);
 * // test for existence of compatible declaration
 * isset($pf->compatible['pear.php.net/Archive_Tar']);
 * // display info:
 * echo $pf->compatible['pear.php.net/Archive_Tar']->min;
 * foreach ($pf->compatible as $package => $info) {
 *     echo $info->min;
 *     echo $info->max;
 *     if (isset($info->exclude)) {
 *         foreach ($info->exclude as $version) {
 *             echo $version;
 *         }
 *     }
 * }
 * </code>
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Compatible implements ArrayAccess, Iterator, Countable
{
    protected $info;
    protected $index = null;
    protected $parent;

    function __construct($parent, array $info, $index = null)
    {
        $this->parent = $parent;
        if (!($parent instanceof self) && !isset($info[0]) && count($info)) {
            $info = array($info);
        }
        $this->info = $info;
        $this->index = $index;
    }

    function count()
    {
        return count($this->info);
    }

    function current()
    {
        $i = key($this->info);
        return new PEAR2_Pyrus_PackageFile_v2_Compatible($this, $this->info[$i], $i);
    }

    function rewind()
    {
        reset($this->info);
    }

    function key()
    {
        $i = key($this->info);
        return $this->info[$i]['channel'] . '/' . $this->info[$i]['name'];
    }

    function next()
    {
        return next($this->info);
    }

    function valid()
    {
        return current($this->info);
    }

    function locateCompatible($name)
    {
        $stuff = explode('/', $name);
        $name = array_pop($stuff);
        $channel = implode('/', $stuff);
        foreach ($this->info as $i => $compat)
        {
            if (isset($compat['name']) && $compat['name'] == $name
                && isset($compat['channel']) && $compat['channel'] == $channel) {
                return $i;
            }
        }
        return false;
    }

    function offsetGet($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception('Use -> operator to access compatible package properties');
        }
        $i = $this->locateCompatible($var);
        if (false === $i) {
            $i = count($this->info);
            if (!strpos($var, '/')) {
                throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception('Cannot access "' . $var .
                    '", must use "channel/package" to specify a compatible package to access');
            }
            $stuff = explode('/', $var);
            $name = array_pop($stuff);
            $channel = implode('/', $stuff);
            $this->info[$i] = array('name' => $name, 'channel' => $channel,
                                        'min' => null, 'max' => null,
                                        'exclude' => null);
        } else {
            foreach (array('name', 'channel', 'min', 'max', 'exclude') as $key) {
                if (!array_key_exists($key, $this->info[$i])) {
                    $this->info[$i][$key] = null;
                }
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Compatible($this, $this->info[$i], $i);
    }

    function offsetSet($var, $value)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception('Use -> operator to access compatible package properties');
        }
        if (!($value instanceof self)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception('Can only set $pf->compatible[\'' .
                $var . '\'] to PEAR2_Pyrus_PackageFile_v2_Compatible object');
        }
        if ($var === null) {
            $var = $value->channel . '/' . $value->name;
        }
        if (!strpos($var, '/')) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception('Cannot set "' . $var .
                '", must use "channel/package" to specify a compatible package to set');
        }
        $stuff = explode('/', $var);
        $name = array_pop($stuff);
        $channel = implode('/', $stuff);
        if ($value->name != $name || $value->channel != $channel) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception('Cannot set ' .
                $channel . '/' . $name . ' to ' .
                $value->channel . '/' . $value->name .
                ', use $pf->compatible[] to set a new value');
        }
        if (false === ($i = $this->locateCompatible($var))) {
            $i = count($this->info);
        }
        $this->info[$i] = $value->getInfo();
        $this->save();
    }

    function offsetExists($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception('Use -> operator to access compatible package properties');
        }
        $i = $this->locateCompatible($var);
        return $i !== false;
    }

    function offsetUnset($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception('Use -> operator to access compatible package properties');
        }
        $i = $this->locateCompatible($var);
        if ($i === false) {
            return;
        }
        unset($this->info[$i]);
        $this->info = array_values($this->info);
        $this->save();
    }

    function __isset($var)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception('Use [] operator to access compatible packages');
        }
        if (!isset($this->info[$var])) {
            return null;
        }
        return isset($this->info[$var]);
    }

    function __get($var)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception('Use [] operator to access compatible packages');
        }
        if (!isset($this->info[$var])) {
            return null;
        }
        if ($var === 'exclude') {
            $ret = $this->info['exclude'];
            if (!is_array($ret)) {
                return array($ret);
            }
        }
        return $this->info[$var];
    }

    function __set($var, $value)
    {
        return $this->__call($var, array($value));
    }

    function __call($var, $args)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception('Use [] operator to access compatible packages');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', array_keys($this->info))
            );
        }
        if ($var === 'name' || $var === 'channel') {
            throw new PEAR2_Pyrus_PackageFile_v2_Compatible_Exception(
                'Cannot change compatible package name, use unset() to remove the old compatible package'
            );
        }
        if (!count($args) || $args[0] === null) {
            unset($this->info[$var]);
            $this->save();
            return $this;
        }
        if ($var == 'exclude') {
            if (!isset($this->info[$var])) {
                $this->info[$var] = $args;
            } else {
                $this->info[$var] = array_merge($this->info[$var], $args);
            }
        } else {
            $this->info[$var] = $args[0];
        }
        $this->save();
        return $this;
    }

    function getInfo()
    {
        return $this->info;
    }

    function setInfo($index, $info)
    {
        foreach ($info as $key => $null) {
            if ($null === null) {
                unset($info[$key]);
            }
        }
        $this->info[$index] = $info;
    }

    function save()
    {
        if ($this->parent instanceof self) {
            $this->parent->setInfo($this->index, $this->info);
            $this->parent->save();
        } else {
            $info = $this->info;
            if (count($info) == 1) {
                $info = $info[0];
            }
            $this->parent->rawcompatible = $info;
        }
    }
}
?><?php
class PEAR2_Pyrus_PackageFile_v2_Configureoption implements ArrayAccess, Iterator, Countable
{
    protected $parent;
    protected $info;
    protected $index;
    function __construct($parent, array $info, $index = null)
    {
        $this->parent = $parent;
        $this->info = $info;
        $this->index = $index;
    }

    function current()
    {
        $info = current($this->info);
        foreach (array('name', 'default', 'prompt') as $key) {
            if (!array_key_exists($key, $info)) {
                $info[$key] = null;
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Configureoption($this, $info, key($this->info));
    }

    function count()
    {
        return count($this->info);
    }

    function rewind()
    {
        reset($this->info);
    }

    function key()
    {
        $info = current($this->info);
        return $info['name'];
    }

    function next()
    {
        return next($this->info);
    }

    function valid()
    {
        return current($this->info);
    }

    function locateConfigureOption($name)
    {
        foreach ($this->info as $i => $dep)
        {
            if (isset($dep['name']) && $dep['name'] == $name) {
                return $i;
            }
        }
        return false;
    }

    function offsetGet($var)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception(
                'use -> operator to access properties of a configureoption');
        }
        $i = $this->locateConfigureOption($var);
        if (false === $i) {
            $i = count($this->info);
            $info = array('name' => $var, 'default' => null, 'prompt' => null);
        } else {
            $info = $this->info[$i];
            foreach (array('name', 'default', 'prompt') as $key) {
                if (!array_key_exists($key, $this->info[$i])) {
                    $info[$key] = null;
                }
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Configureoption($this, $info, $i);
    }

    function offsetSet($var, $value)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception(
                'use -> operator to access properties of a configureoption');
        }
        if (!($value instanceof PEAR2_Pyrus_PackageFile_v2_Configureoption)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception(
                'Can only set configureoption to a PEAR2_Pyrus_PackageFile_v2_Configureoption object');
        }
        $i = $this->locateConfigureOption($var);
        if (false === $i) {
            $i = count($this->info);
        }
        $this->info[$i] = array('name' => $var,
                                'default' => $value->default,
                                'prompt' => $value->prompt);
        $this->save();
    }

    function offsetExists($var)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception(
                'use -> operator to access properties of a configureoption');
        }
        $i = $this->locateConfigureOption($var);
        return $i !== false;
    }

    function offsetUnset($var)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception(
                'use -> operator to access properties of a configureoption');
        }
        $i = $this->locateConfigureOption($var);
        if ($i === false) {
            return;
        }
        unset($this->info[$i]);
        $this->info = array_values($this->info);
        $this->save();
    }

    function __unset($var)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception(
                'use [] operator to access configureoption' . 's');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception(
                'Unknown variable ' . $var . ' requested, should be one of ' .
                implode(', ', array_keys($this->info))
            );
        }
        $this->info[$var] = null;
        $this->save();
    }

    function __isset($var)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception(
                'use [] operator to access configureoption' . 's');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception(
                'Unknown variable ' . $var . ' requested, should be one of ' .
                implode(', ', array_keys($this->info))
            );
        }
        return isset($this->info[$var]);
    }

    function __set($var, $value)
    {
        return $this->__call($var, array($value));
    }

    function __call($var, $args)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception(
                'use [] operator to access configureoptions');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception('Unknown variable ' . $var .
                                                                           ', must be one of ' .
                            implode(', ', array_keys($this->info)));
        }
        if ($args[0] === null) {
            $this->info[$var] = null;
            $this->save();
            return $this;
        }
        $this->info[$var] = $args[0];
        $this->save();
        return $this;
    }

    function __get($var)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception(
                'use [] operator to access configureoptions');
        }
        if ($var === 'type') {
            return 'configureoption';
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Configureoption_Exception('Unknown variable ' . $var .
                                                                           ', must be one of ' .
                            implode(', ', array_keys($this->info)));
        }
        if (!isset($this->info[$var])) {
            return null;
        }
        return $this->info[$var];
    }

    function getInfo()
    {
        return $this->info;
    }

    function setInfo($info, $index)
    {
        foreach (array_keys($info) as $key) {
            if ($info[$key] === null) {
                unset($info[$key]);
            }
        }
        $this->info[$index] = $info;
    }

    function save()
    {
        if ($this->parent instanceof self) {
            $this->parent->setInfo($this->info, $this->index);
            $this->parent->save();
            return;
        }
        $info = $this->info;
        if (count($info) == 1) {
            $info = $info[0];
        }
        $this->parent->rawconfigureoption = $info;
    }
}
?><?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Dependencies
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Manage dependencies
 *
 * To be used like:
 * <code>
 * // reset deps
 * $reg->dependencies = null;
 * // for PHP dep
 * // defaults to min
 * $reg->dependencies['required']->php = '5.3.0';
 * $reg->dependencies['required']->php->min('5.3.1')->max('7.0.0')->exclude('6.1.2');
 * 
 * $reg->dependencies['required']->php = null;
 * 
 * $reg->dependencies['required']->php->exclude('6.1.2')->exclude('6.1.3');
 * $reg->dependencies['required']->php->exclude(null);
 * 
 * // for PEAR Installer dep
 * // defaults to min
 * $reg->dependencies['required']->pearinstaller = '2.0.0';
 * $reg->dependencies['required']->pearinstaller->min('2.0.1')->max('3.0.0');
 * 
 * // for required/optional package deps or subpackage deps
 * $reg->dependencies->required->package['channel/PackageName']->min('1.1.0')->max('1.2.0')->recommended('1.1.1')
 *     ->exclude('1.1.0a1')->exclude('1.1.0a2');
 * $reg->dependencies['optional']->package['channel/PackageName']->min('1.1.0')->max('1.2.0')->recommended('1.1.1')
 *     ->exclude('1.1.0a1')->exclude('1.1.0a2');
 * 
 * $reg->dependencies->required->subpackage['channel/subpackageName']->min('1.1.0')->max('1.2.0')->recommended('1.1.1')
 *     ->exclude('1.1.0a1')->exclude('1.1.0a2');
 * $reg->dependencies->optional->subpackage['channel/subpackageName']->min('1.1.0')->max('1.2.0')->recommended('1.1.1')
 *     ->exclude('1.1.0a1')->exclude('1.1.0a2');
 * 
 * // for conflicting package dep
 * $reg->dependencies['required']->subpackage['channel/PackageName']->conflicts();
 * $reg->dependencies['required']->subpackage['channel/PackageName']->conflicts(false);
 * 
 * // for PECL extension deps (optional or required same as packages)
 * $reg->dependencies['required']->package['channel/PackageName']->providesextension('packagename');
 * 
 * // for extension deps (required or optional same as packages)
 * $reg->dependencies['required']->extension['extname']->min('1.0.0')->max('1.2.0')->recommended('1.1.1');
 * 
 * // for regular arch deps
 * $reg->dependencies['required']->arch['i386'] = true; // only works on i386
 * 
 * // for conflicting arch deps
 * $reg->dependencies['required']->arch['*(ix|ux)'] = false; // doesn't work on unix/linux
 * 
 * // for regular OS deps
 * $reg->dependencies['required']->os['windows'] = true; // only works on windows
 * 
 * // for conflicting OS deps
 * $reg->dependencies['required']->os['freebsd'] = false; // doesn't work on FreeBSD
 * 
 * // dependency group setup
 * $group = $reg->dependencies['group']->groupname;
 * $group->hint = 'Install optional stuff as a group';
 * 
 * $group->package['channel/PackageName1']->save();
 * $group->package['channel/PackageName2']->min('1.2.0');
 * $group->subpackage['channel/PackageName3']->min('1.3.0');
 * 
 * $group->extension['extension']->save();
 * </code>
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Dependencies implements ArrayAccess
{
    protected $parent;
    protected $info = array();
    protected $deptype = null;

    function __construct($parent, $info, $deptype = null)
    {
        $this->parent = $parent;
        $this->info = $info;
        $this->deptype = $deptype;
    }

    function __get($var)
    {
        if ($this->deptype === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                'Cannot retrieve dependency type, choose $pf->dependencies[\'required\']->' .
                $var . ' or $pf->dependencies[\'optional\']->' . $var);
        }
        if (!isset($this->info[$var])) {
            switch ($var) {
                case 'arch' :
                case 'os' :
                    if ($this->deptype === 'optional' || $this->deptype === 'group') {
                        throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                                $var . ' dependency is not supported as an optional dependency');
                    }
                    if (!isset($this->info[$var])) {
                        $this->info[$var] = array();
                    }
                    break;
                case 'php' :
                    $this->info[$var] = array('min' => null, 'max' => null, 'exclude' => null);
                    break;
                case 'pearinstaller' :
                    $this->info[$var] = array('min' => null, 'max' => null, 'exclude' => null, 'recommended' => null);
                    break;
                case 'package' :
                case 'subpackage' :
                case 'extension' :
                    $this->info[$var] = array();
                    return new PEAR2_Pyrus_PackageFile_v2_Dependencies_Package($this->deptype, $var, $this, $this->info[$var]);
                default :
                    throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Unknown dependency type: '.
                        $var);
            }
        } else {
            if (!is_array($this->info[$var])) {
                $this->info[$var] = array($this->info[$var]);
            }
            $keys = array();
            switch ($var) {
                case 'php' :
                    $keys = array('min' => null, 'max' => null, 'exclude' => null);
                    break;
                case 'pearinstaller' :
                    $keys = array('min' => null, 'max' => null, 'exclude' => null, 'recommended' => null);
                    break;
                case 'package' :
                case 'subpackage' :
                case 'extension' :
                    if (count($this->info[$var]) && !isset($this->info[$var][0])) {
                        $this->info[$var] = array($this->info[$var]);
                    }
                    return new PEAR2_Pyrus_PackageFile_v2_Dependencies_Package($this->deptype, $var, $this, $this->info[$var]);
            }
            foreach ($keys as $key => $null) {
                if (!array_key_exists($key, $this->info[$var])) {
                    $this->info[$var][$key] = $null;
                }
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Dependencies_Dep($this, $this->info[$var], $var);
    }

    function __set($var, $value)
    {
        if ($this->deptype === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                'Cannot set dependency type, choose $pf->dependencies[\'required\']->' .
                $var . ' or $pf->dependencies[\'optional\']->' . $var);
        }
        if ($value === null) {
            unset($this->info[$var]);
            $this->save();
            return;
        }
        $info = array();
        switch ($var) {
            case 'php' :
                if (is_string($value)) {
                    $info['min'] = $value;
                }
                break;
            case 'pearinstaller' :
                if (is_string($value)) {
                    $info['min'] = $value;
                }
                break;
            case 'arch' :
            case 'os' :
                if ($this->deptype === 'optional' || $this->deptype === 'group') {
                    throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                            $var . ' dependency is not supported as an optional dependency');
                }
                if (!($value instanceof PEAR2_Pyrus_PackageFile_v2_Dependencies_Dep)) {
                    throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                        'Can only set ' . $var . ' to PEAR2_Pyrus_PackageFile_v2_Dependencies_Dep object'
                    );
                }
                $this->info[$var] = $value->getInfo();
                $this->save();
                return;
            case 'package' :
            case 'subpackage' :
            case 'extension' :
                if (!($value instanceof PEAR2_Pyrus_PackageFile_v2_Dependencies_Package)) {
                    throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception(
                        'Can only set ' . $var . ' to PEAR2_Pyrus_PackageFile_v2_Dependencies_Package object'
                    );
                }
                $this->info[$var] = $value->getInfo();
                $this->save();
                return;
            default :
                throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Unknown dependency type: ' . $var);
        }
        $this->info[$var] = $info;
        $this->save();
    }

    function __isset($var)
    {
        if ($this->deptype === null) {
            return false;
        }
        return isset($this->info[$var]) && !empty($this->info[$var]);
    }

    function offsetGet($var)
    {
        if ($this->deptype !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Cannot access ' .
                                    '$pf->dependencies[\'' . $this->deptype . '\'][\'' . $var . '\']');
        }
        if ($var === 'required' || $var === 'optional') {
            if (!isset($this->info[$var]) || !is_array($this->info[$var])) {
                $this->info[$var] = array();
            }
            return new PEAR2_Pyrus_PackageFile_v2_Dependencies($this, $this->info[$var], $var);
        }
        if ($var === 'group') {
            if (!isset($this->info[$var]) || !is_array($this->info[$var])) {
                $this->info[$var] = array();
            }
            return new PEAR2_Pyrus_PackageFile_v2_Dependencies_Group($this, $this->info['group']);
        }
    }

    function offsetSet($var, $value)
    {
        if ($this->deptype !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Cannot set ' .
                                    '$pf->dependencies[\'' . $this->deptype . '\'][\'' . $var . '\']');
        }
        if ($var === 'group') {
            if (!($value instanceof PEAR2_Pyrus_PackageFile_v2_Dependencies_Group)) {
                throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Cannot set group to anything' .
                            ' but a PEAR2_Pyrus_PackageFile_v2_Dependencies_Group object');
            }
            $this->info['group'] = $value->getInfo();
            $this->save();
            return;
        }
        if ($var === 'required' || $var === 'optional') {
            if (!($value instanceof PEAR2_Pyrus_PackageFile_v2_Dependencies)) {
                throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Cannot set ' . $var . ' to anything' .
                            ' but a PEAR2_Pyrus_PackageFile_v2_Dependencies object');
            }
            $this->info[$var] = $value->getInfo();
            $this->save();
            return;
        }
        throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Only required, optional, or group indices' .
                        ' are supported, was passed ' . $var);
    }

    function offsetExists($var)
    {
        return isset($this->info[$var]) && !empty($this->info[$var]);
    }

    function offsetUnset($var)
    {
        unset($this->info[$var]);
        $this->save();
    }

    function setInfo($deptype, $info)
    {
        foreach ($info as $key => $null) {
            if ($null === null) {
                unset($info[$key]);
            }
        }
        if (!count($info)) {
            unset($this->info[$deptype]);
            return;
        }
        $this->info[$deptype] = $info;
    }

    function getInfo()
    {
        return $this->info;
    }

    function save()
    {
        if ($this->deptype !== null) {
            $this->parent->setInfo($this->deptype, $this->info);
            return $this->parent->save();
        }
        $this->parent->rawdependencies = $this->info;
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Developer
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Manage an individual maintainer in package.xml
 *
 * To be used like:
 *
 * <code>
 * // add developer
 * $pf->maintainer['cellog']
 *    ->name('Greg Beaver')
 *    ->role('lead')
 *    ->email('cellog@php.net')
 *    ->active('yes');
 * echo $pf->maintainer['cellog']->name;
 * isset($pf->maintainer['cellog']); // test for maintainer in package.xml
 * unset($pf->maintainer['cellog']); // remove from package.xml
 * </code>
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Developer implements ArrayAccess, Iterator
{
    protected $parent;
    protected $role;
    protected $index;
    protected $info;
    private $_curRole;

    function __construct($parent, $info, $role = null, $index = null)
    {
        $this->parent = $parent;
        $this->info = $info;
        $this->role = $role;
        $this->index = $index;
    }

    function current()
    {
        $info = current($this->info[current($this->_curRole)]);
        foreach(array('name', 'user', 'email', 'active') as $key) {
            if (!array_key_exists($key, $info)) {
                $info[$key] = null;
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Developer($this, $info, current($this->_curRole),
                                                        key($this->info[current($this->_curRole)]));
    }

    function key()
    {
        return key($this->info[current($this->_curRole)]);
    }

    function next()
    {
        $a = next($this->info[current($this->_curRole)]);
        while (!current($this->info[current($this->_curRole)])) {
            next($this->_curRole);
            if (!current($this->_curRole)) {
                return false;
            }
            reset($this->info[current($this->_curRole)]);
            if (count($this->info[current($this->_curRole)])) {
                return true;
            }
        }
        return $a;
    }

    function rewind()
    {
        $this->_curRole = array_keys($this->info);
        reset($this->info[current($this->_curRole)]);
    }

    function valid()
    {
        while (current($this->_curRole) && !current($this->info[current($this->_curRole)])) {
            next($this->_curRole);
            if (!current($this->_curRole)) {
                return false;
            }
            reset($this->info[current($this->_curRole)]);
            if (count($this->info[current($this->_curRole)])) {
                return true;
            }
        }
        return current($this->_curRole);
    }

    /**
     * Search for a maintainer, find them and return the maintainer role
     *
     * @param string $handle
     * @return array|false the role (lead, developer, contributor, helper)/index
     */
    function locateMaintainerRole($handle)
    {
        foreach ($this->info as $role => $devs) {
            foreach ($devs as $i => $developer) {
                if ($developer['user'] == $handle) {
                    return array($role, $i);
                }
            }
        }
        return false;
    }

    function __get($var)
    {
        if (!isset($this->info['user']) || !is_string($this->info['user'])) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Cannot access developer info for unknown developer');
        }
        if ($var === 'role') {
            return $this->role;
        }
        if (!isset($this->info[$var])) {
            if (!array_key_exists($var, $this->info)) {
                $keys = $this->info;
                unset($keys['user']);
                $keys = array_keys($keys);
                throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                    'Unknown variable ' . $var . ', should be one of ' . implode(', ', $keys));
            }
            return null;
        }
        return $this->info[$var];
    }

    function __call($var, $args)
    {
        if (!isset($this->info['user']) || !is_string($this->info['user'])) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Cannot set developer info for unknown developer');
        }
        if ($var == 'role') {
            $oldrole = $this->role;
            $this->role = $args[0];
            $this->save($oldrole);
            return $this;
        }
        if (!array_key_exists($var, $this->info) || $var == 'user') {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Cannot set unknown value ' . $var);
        }
        if (count($args) != 1) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Can only set ' . $var . ' to 1 value');
        }
        if (!is_string($args[0])) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Invalid value for ' . $var . ', must be a string');
        }
        $this->info[$var] = $args[0];
        $this->save($this->role);
        return $this;
    }

    function offsetGet($var)
    {
        if (isset($this->info['user']) && is_string($this->info['user'])) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Use -> to access properties of a developer');
        }
        if (!is_string($var)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception('Developer handle cannot be numeric');
        }
        $developer = $var;
        if ($role = $this->locateMaintainerRole($developer)) {
            $info = $this->info[$role[0]][$role[1]];
            foreach (array('name' => null, 'user' => $var, 'email' => null, 'active' => 'yes') as $key => $null) {
                if (!isset($info[$key])) {
                    $info[$key] = null;
                }
            }
            return new PEAR2_Pyrus_PackageFile_v2_Developer($this, $info, $role[0], $role[1]);
        }
        return new PEAR2_Pyrus_PackageFile_v2_Developer($this,
            array('name' => null, 'user' => $var, 'email' => null, 'active' => 'yes'), null, null);
    }

    function offsetSet($var, $value)
    {
        if (isset($this->info['user']) && is_string($this->info['user'])) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Use -> to access properties of a developer');
        }
        if (!is_string($var)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception('Developer handle cannot be numeric');
        }
        if (!($value instanceof PEAR2_Pyrus_PackageFile_v2_Developer)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Can only set a developer to a PEAR2_Pyrus_PackageFile_v2_Developer object'
            );
        }
        if (false !== ($i = $this->locateMaintainerRole($var))) {
            // remove old developer role, set new role
            unset($this->info[$i[0]][$i[1]]);
        }
        $i = count($this->info[$value->role]);
        $this->info[$value->role][] = $value->getInfo();
        $this->info[$value->role][$i]['user'] = $var;
        $this->save();
    }

    /**
     * Remove a developer from package.xml (by handle)
     * @param string $var
     */
    function offsetUnset($var)
    {
        if (isset($this->info['user']) && is_string($this->info['user'])) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Use -> to retrieve properties of a developer');
        }
        // remove developer
        $role = $this->locateMaintainerRole($var);
        if (!$role) {
            // already non-existent
            return;
        }
        unset($this->info[$role[0]][$role[1]]);
        $this->save();
    }

    /**
     * Test whether developer exists in package.xml (by handle)
     * @param string $var
     * @return bool
     */
    function offsetExists($var)
    {
        if (isset($this->info['user']) && is_string($this->info['user'])) {
            throw new PEAR2_Pyrus_PackageFile_v2_Developer_Exception(
                'Use -> to retrieve properties of a developer');
        }
        return (bool) $this->locateMaintainerRole($var);
    }

    /**
     * Retrieve the new index of this developer, newly added to this role
     * @return int
     */
    function getNewIndex($user, $role)
    {
        $i = $this->locateMaintainerRole($user);
        if (false === $i) {
            return count($this->info[$role]) - 1;
        }
        return $i[1];
    }

    function getInfo()
    {
        return $this->info;
    }

    function toArray()
    {
        $info = $this->info;
        $ret = array('name' => null, 'user' => null, 'email' => null, 'active' => null);
        foreach ($info as $key => $value) {
            $ret[$key] = $value;
        }
        return $ret;
    }

    function setInfo($info, $oldrole, $index, $role)
    {
        foreach (array_keys($info) as $key) {
            if ($info[$key] === null) {
                unset($info[$key]);
            }
        }
        if ($role !== null && $oldrole != $role) {
            // we just changed the role.
            if ($oldrole && isset($this->info[$oldrole][$index])) {
                unset($this->info[$oldrole][$index]);
                $this->info[$oldrole] = array_values($this->info[$oldrole]);
            }
            if (!count($info)) {
                // essentially remove the old one and wait for data to save the new
                return;
            }
            $this->info[$role][] = $info;
        } else {
            $this->info[$role][$index] = $info;
        }
    }

    /**
     * Save changes
     */
    protected function save($oldrole = null)
    {
        if ($this->parent instanceof self) {
            if ($this->role === null) {
                return;
            }
            $this->parent->setInfo($this->info, $oldrole, $this->index, $this->role);
            if ($this->role !== null && $oldrole != $this->role) {
                $this->index = $this->parent->getNewIndex($this->info['user'], $this->role);
            }
            $this->parent->save();
        } else {
            foreach ($this->info as $role => $info) {
                if (is_string($info)) {
                    $info = array($info);
                } else {
                    $info = array_values($info);
                }
                if (!count($info)) {
                    $this->parent->{'raw' . $role} = null;
                } else {
                    if (count($info) == 1) {
                        $info = $info[0];
                    }
                    $this->parent->{'raw' . $role} = $info;
                }
            }
        }
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Files
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Represents the files within a package file
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Files implements ArrayAccess
{
    protected $info;
    protected $parent;

    function __construct($parent, $info)
    {
        $this->parent = $parent;
        $this->info = $info;
    }

    function offsetUnset($var)
    {
        unset($this->info[$var]);
        $this->parent->setFilelistFile($var, null);
    }

    function offsetGet($var)
    {
        if (isset($this->info[$var])) {
            return new PEAR2_Pyrus_PackageFile_v2_Files_File($this, $this->parent, $this->info[$var]);
        }
        return null;
    }

    function offsetSet($var, $value)
    {
        if ($value instanceof ArrayObject) {
            $value = $value->getArrayCopy();
        }
        if (!is_array($value)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Files_Exception('File must be an array of '
                . 'attributes and tasks');
        }

        if (!isset($value['attribs'])) {
            // no tasks is assumed
            $value = array('attribs' => $value);
        }

        $value['attribs']['name'] = $var;
        if (!isset($value['attribs']['role'])) {
            throw new PEAR2_Pyrus_PackageFile_v2_Files_Exception('File role must be set for' .
                ' file ' . $var);
        }

        $this->info[$var] = $value;
        $this->parent->setFilelistFile($var, $value);
    }

    function offsetExists($var)
    {
        return isset($this->info[$var]);
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_License
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Represents the files within a package file
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_License implements ArrayAccess
{
    protected $parent;
    protected $info;

    function __construct($parent, $info)
    {
        $this->parent = $parent;
        $this->info = $info;
    }

    function getInfo()
    {
        return $this->info;
    }

    function offsetUnset($var)
    {
        if ($var == 'name') {
            if (is_array($this->info) && isset($this->info['_content'])) {
                unset($this->info['_content']);
            } elseif (is_string($this->info)) {
                $this->info = array();
            }
            $this->save();
            return;
        }
        if ($var == 'uri') {
            unset($this->info['attribs']['uri']);
            if (!count($this->info['attribs'])) {
                unset($this->info['attribs']);
                if (isset($this->info['_content'])) {
                    $this->info = $this->info['_content'];
                }
            }
            $this->save();
            return;
        }
        if ($var == 'path') {
            unset($this->info['attribs']['path']);
            if (!count($this->info['attribs'])) {
                unset($this->info['attribs']);
                if (isset($this->info['_content'])) {
                    $this->info = $this->info['_content'];
                }
            }
            $this->save();
            return;
        }
    }

    function offsetGet($var)
    {
        if ($var == 'uri') {
            if (is_array($this->info) && isset($this->info['attribs']) && isset($this->info['attribs']['uri'])) {
                return $this->info['attribs']['uri'];
            }
            return null;
        }
        if ($var == 'path') {
            if (is_array($this->info) && isset($this->info['attribs']) && isset($this->info['attribs']['path'])) {
                return $this->info['attribs']['path'];
            }
            return null;
        }
        if ($var == 'name') {
            if (is_array($this->info) && isset($this->info['_content'])) {
                return $this->info['_content']; 
            }
            if (!is_array($this->info)) {
                return $this->info;
            }
        }
        return null;
    }

    function offsetSet($var, $value)
    {
        if (!is_string($value)) {
            throw new PEAR2_Pyrus_PackageFile_v2_License_Exception('Can only set license to string');
        }

        if ($var == 'path' || $var == 'uri') {
            if (!is_array($this->info) || !isset($this->info['attribs'])) {
                if (!is_array($this->info)) {
                    $this->info = array('_content' => $this->info);
                }
                $this->info['attribs'] = array();
            }
        } else {
            if ($var == 'name') {
                if (!is_array($this->info)) {
                    $this->info = $value;
                    $this->save();
                    return;
                }
                $this->info['_content'] = $value;
                $this->save();
                return;
            }
            throw new PEAR2_Pyrus_PackageFile_v2_License_Exception('Unknown license trait ' . $var . ', cannot set value');
        }
        $this->info['attribs'][$var] = $value;
        $this->save();
    }

    function offsetExists($var)
    {
        if ($var == 'uri') {
            return isset($this->info['attribs']) && isset($this->info['attribs']['uri']);
        }
        if ($var == 'path') {
            return isset($this->info['attribs']) && isset($this->info['attribs']['path']);
        }
        if ($var == 'name') {
            if (!is_array($this->info)) {
                return sizeof($this->info);
            }
            return isset($this->info['_content']);
        }
        return false;
    }

    function save()
    {
        $this->parent->rawlicense = $this->info;
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Release
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Manage a release in package.xml
 *
 * To be used like:
 *
 * <code>
 * // release is a PHP package
 * $pf->type = 'php';
 * // release is an extension source package
 * $pf->type = 'extsrc';
 * $pf->release[0]->installconditions['php']->min('5.2.0');
 * // defaults to "min"
 * $pf->release[0]->installconditions['php'] = '5.2.0';
 * // defaults to "pattern"
 * $pf->release[0]->installconditions['arch'] = 'i386';
 * $pf->release[0]->installconditions['arch']->pattern('i386')->conflicts();
 * // defaults to "name"
 * $pf->release[0]->installconditions['os'] = 'windows';
 * // defaults to existing
 * $pf->release[0]->installconditions['extension'][0]->name('PDO');
 * $pf->release[0]->installconditions['extension'][0]->name('PDO')->min('1.0');
 * $pf->release[0]->ignore('path/to/file.ext');
 * $pf->release[0]->installAs('path/to/anotherfile.ext', 'new/name.php');
 * // add another release
 * $i = count($pf->release);
 * $pf->release[$i]->ignore('path/to/anotherfile.ext');
 * $pf->release[$i]->installAs('path/to/file.ext', 'new/name.php');
 * // remove release
 * unset($pf->release[1]);
 * // remove all releases
 * $pf->release = null;
 * </code>
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Release implements ArrayAccess, Countable
{
    private $_parent;
    private $_packageInfo;
    private $_filelist;
    protected $index;
    protected $info = array();

    function __construct($parent, $packageInfo, array $filelist, $index = null)
    {
        $this->_parent = $parent;
        $this->_packageInfo = $packageInfo;
        $this->_filelist = $filelist;
        if ($index !== null) {
            $this->index = $index;
            $this->info = $packageInfo;
        } else {
            if (isset($packageInfo[0])) {
                $this->info = $packageInfo;
            } else if (count($packageInfo)) {
                $this->info = array($packageInfo);
            }
        }
    }

    function __isset($var)
    {
        if (!isset($this->index)) {
            return false;
        }
        return isset($this->info[$var]);
    }

    function __get($var)
    {
        if (!isset($this->index)) {
            return null;
        }
        if ($var === 'configureoption') {
            if (!isset($this->info['configureoption'])) {
                $info = array();
            } else {
                $info = $this->info['configureoption'];
                if (!is_array($info) || !isset($info[0])) {
                    $info = array($info);
                }
            }
            return new PEAR2_Pyrus_PackageFile_v2_Release_ConfigureOption($this, $info);
        }
        if ($var === 'binarypackage') {
            if (!isset($this->info['binarypackage'])) {
                $info = array();
            } else {
                $info = $this->info['binarypackage'];
                if (!is_array($info)) {
                    $info = array($info);
                }
            }
            return new PEAR2_Pyrus_PackageFile_v2_Release_BinaryPackage($this, $info);
        }
        if ($var === 'installconditions') {
            if (!isset($this->info['installcondition'])) {
                $this->info['installcondition'] = array();
            }
            $conditions =
                new PEAR2_Pyrus_PackageFile_v2_Release_InstallCondition($this, $this->info['installcondition']);
            return $conditions;
        }
        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Unknown variable ' . $var .
            ', installconditions is the only supported variable');
    }

    function setBinaryPackage($info)
    {
        $this->info['binarypackage'] = $info;
    }

    function setConfigureOption($info)
    {
        $this->info['configureoption'] = $info;
    }

    function count()
    {
        if (isset($this->index)) {
            return 1;
        }
        return count($this->info);
    }

    function offsetGet($var)
    {
        if (is_int($var) && !isset($this->index)) {
            if (isset($this->info[0])) {
                if (!isset($this->info[$var])) {
                    if ($var != count($this)) {
                        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception(
                            'Can only set the ' .
                            'next highest release index ' . count($this) . ', not ' . $var);
                    }
                    $this->info[$var] = array();
                }
                return new PEAR2_Pyrus_PackageFile_v2_Release($this,
                           $this->info[$var], $this->_filelist, $var);
            } else {
                if ($var !== 0) {
                    throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Can only set the ' .
                        'next highest release index 0, not ' . $var);
                }
                $this->info[$var] = array();
                return new PEAR2_Pyrus_PackageFile_v2_Release($this,
                           $this->info[$var], $this->_filelist, $var);
            }
        }
    }

    /**
     * @return array
     */
    function getInstallCondition()
    {
        if (!isset($this->index)) {
            return null;
        }
        if (!isset($this->info['installcondition'])) {
            return false;
        }
        return $this->info['installcondition'];
    }

    function getInstallAs()
    {
        if (!isset($this->index)) {
            return null;
        }
        if (!isset($this->info['filelist'])) {
            return false;
        }
        if (!isset($this->info['filelist']['install'])) {
            return false;
        }
        return $this->info['filelist']['install'];
    }

    function getIgnore()
    {
        if (!isset($this->index)) {
            return null;
        }
        if (!isset($this->info['filelist'])) {
            return false;
        }
        if (!isset($this->info['filelist']['ignore'])) {
            return false;
        }
        return $this->info['filelist']['ignore'];
    }

    function ignores($file)
    {
        $ignore = $this->getIgnore();
        if (!$ignore) {
            return false;
        }
        if (!isset($ignore[0])) {
            $ignore = array($ignore);
        }
        foreach ($ignore as $ignored) {
            if ($ignored['attribs']['name'] == $file) {
                return true;
            }
        }
        return false;
    }

    function installsAs($file)
    {
        $install = $this->getInstallAs();
        if (!$install) {
            return $file;
        }
        if (!isset($install[0])) {
            $install = array($install);
        }
        foreach ($install as $as) {
            if ($as['attribs']['name'] == $file) {
                return $as['attribs']['as'];
            }
        }
        return $file;
    }

    function offsetSet($var, $value)
    {
        if ($var === null) {
            $var = count($this->info);
        }

        if (is_int($var)) {
            if ($value instanceof PEAR2_Pyrus_PackageFile_v2_Release) {
                $this->info[$var] = array('installcondition' => $value->getInstallCondition(),
                                          'install' => $value->getInstallAs(),
                                          'ignore' => $value->getIgnore());
                $this->save();
                return;
            }
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Cannot set ' . $var . ' to non-PEAR2_Pyrus_PackageFile_v2_Release');
        }
        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Cannot set ' . $var);
    }

    /**
     * @param string $var
     */
    function offsetUnset($var)
    {
        unset($this->info[$var]);
        $this->save();
    }

    /**
     * @param string $var
     * @return bool
     */
    function offsetExists($var)
    {
        return isset($this->info[$var]);
    }

    function ignore($file)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Cannot ignore ' .
                            'file ' . $file . ' without specifying which release section to ignore it in');
        }
        if (isset($this->_filelist[$file])) {
            if (!isset($this->info['filelist'])) {
                $this->info['filelist'] = array();
            }
            if (!isset($this->info['filelist']['ignore'])) {
                $this->info['filelist']['ignore'] = array(array('attribs' => array('name' => $file)));
            } else {
                if (!isset($this->info['filelist']['ignore'][0])) {
                    $this->info['filelist']['ignore'] = array($this->info['filelist']['ignore']);
                }
                $this->info['filelist']['ignore'][] = array('attribs' => array('name' => $file));
            }
            $this->save();
            return;
        }

        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Unknown file ' . $file .
            ' - add to filelist before ignoring');
    }

    function installAs($file, $newname)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Cannot install ' .
                            'file ' . $file . ' to ' . $newname .
                            ' without specifying which release section to install it in');
        }

        if (isset($this->_filelist[$file])) {
            if (!isset($this->info['filelist'])) {
                $this->info['filelist'] = array();
            }
            if (!isset($this->info['filelist']['install'])) {
                $this->info['filelist']['install'] = array(array('attribs' =>
                    array('name' => $file, 'as' => $newname)));
            } else {
                if (!isset($this->info['filelist']['install'][0])) {
                    $this->info['filelist']['install'] = array($this->info['filelist']['install']);
                }
                $this->info['filelist']['install'][] = array('attribs' =>
                    array('name' => $file, 'as' => $newname));
            }
            $this->save();
            return;
        }

        throw new PEAR2_Pyrus_PackageFile_v2_Release_Exception('Unknown file ' . $file .
            ' - add to filelist before adding install as tag');
    }

    function setInstallCondition(PEAR2_Pyrus_PackageFile_v2_Release_InstallCondition $c)
    {
        $this->info['installcondition'] = $c->getInfo();
        $this->save();
    }

    function setReleaseInfo($index, $info)
    {
        $this->info[$index] = $info;
    }

    /**
     * Saves results to the parent packagefile object
     */
    function save()
    {
        if (isset($this->index)) {
            $this->_parent->setReleaseInfo($this->index, $this->info);
            return $this->_parent->save();
        }
        $newXml = $this->info;
        foreach ($newXml as $index => $info) {
            if (isset($info['filelist'])) {
                if (isset($info['filelist']['ignore']) && count($info['filelist']['ignore']) == 1 && !isset($info['filelist']['ignore']['attribs'])) {
                    $newXml[$index]['filelist']['ignore'] = $newXml[$index]['filelist']['ignore'][0];
                }
                if (isset($info['filelist']['install']) && count($info['filelist']['install']) == 1 && !isset($info['filelist']['install']['attribs'])) {
                    $newXml[$index]['filelist']['install'] = $newXml[$index]['filelist']['install'][0];
                }
                if (array_key_exists('ignore', $info['filelist']) && !count($info['filelist']['ignore'])) {
                    unset($newXml[$index]['filelist']['ignore']);
                }
                if (array_key_exists('install', $info['filelist']) && !count($info['filelist']['install'])) {
                    unset($newXml[$index]['filelist']['install']);
                }
            }
            if (array_key_exists('installcondition', $info) && count($info['installcondition'])) {
                foreach (array('php', 'os', 'arch') as $key) {
                    if (!isset($info['installcondition'][$key])) {
                        continue;
                    }
                    foreach (array_keys($info['installcondition'][$key]) as $ikey) {
                        if ($info['installcondition'][$key][$ikey] === null) {
                            unset($newXml[$index]['installcondition'][$key][$ikey]);
                        }
                    }
                    if (!count($newXml[$index]['installcondition'][$key])) {
                        unset($newXml[$index]['installcondition'][$key]);
                    }
                }
                if (array_key_exists('extension', $info['installcondition']) && !count($info['installcondition']['extension'])) {
                    unset($newXml[$index]['installcondition']['extension']);
                }
                if (isset($info['installcondition']['extension'])) {
                    if (!isset($info['installcondition']['extension'][0])) {
                        $newXml[$index]['installcondition']['extension'] = $info['installcondition']['extension'] =
                            array($info['installcondition']['extension']);
                    }
                    foreach ($info['installcondition']['extension'] as $extkey => $ext) {
                        foreach (array_keys($ext) as $key) {
                            if ($ext[$key] === null) {
                                unset($newXml[$index]['installcondition']['extension'][$extkey][$key]);
                            }
                        }
                        if (!count($newXml[$index]['installcondition']['extension'][$extkey])) {
                            unset($newXml[$index]['installcondition']['extension'][$extkey]);
                        }
                    }
                    if (count($newXml[$index]['installcondition']['extension']) == 1) {
                        $newXml[$index]['installcondition']['extension'] =
                            array_values($newXml[$index]['installcondition']['extension']);
                        $newXml[$index]['installcondition']['extension'] =
                            $newXml[$index]['installcondition']['extension'][0];
                    } elseif (count($newXml[$index]['installcondition']['extension']) == 0) {
                        unset($newXml[$index]['installcondition']['extension']);
                    }
                }

                if (!count($newXml[$index]['installcondition'])) {
                    unset($newXml[$index]['installcondition']);
                    continue;
                }
            } else {
                unset($newXml[$index]['installcondition']);
            }
        }
        if (count($newXml) == 1) {
            $newXml = $newXml[0];
        }
        $this->_parent->rawrelease = $newXml;
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2_SImpleProperty
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Represents a simple array property like version or stability
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_SimpleProperty implements ArrayAccess
{
    protected $info;
    protected $name;
    protected $parent;

    /**
     * @param array The content of this element.  All allowed indices should be initialized to null
     */
    function __construct($parent, $info, $name)
    {
        $this->parent = $parent;
        $this->info = $info;
        $this->name = $name;
    }

    function offsetUnset($var)
    {
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Unknown ' . $this->name . ' property ' . $var);
        }
        $this->info[$var] = null;
        $this->save();
    }

    function offsetGet($var)
    {
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Unknown ' . $this->name . ' property ' . $var);
        }
        return $this->info[$var];
    }

    function offsetSet($var, $value)
    {
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Unknown ' . $this->name . ' property ' . $var);
        }
        if (!is_string($value)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Can only set ' . $this->name . ' to string');
        }
        $this->info[$var] = $value;
        $this->save();
    }

    function offsetExists($var)
    {
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Unknown ' . $this->name . ' property ' . $var);
        }
        return isset($this->info[$var]);
    }

    function getInfo()
    {
        return $this->info;
    }

    function save()
    {
        $info = $this->info;
        foreach(array_keys($this->info) as $key) {
            if (null === $info[$key]) {
                unset($info[$key]);
            }
        }
        $this->parent->{'raw' . $this->name} = $info;
    }
}<?php
class PEAR2_Pyrus_PackageFile_v2_UsesRoleTask implements ArrayAccess, Iterator, Countable
{
    protected $parent;
    protected $info;
    protected $type;
    protected $index;
    function __construct($parent, array $info, $type, $index = null)
    {
        $this->parent = $parent;
        $this->info = $info;
        $this->type = $type;
        $this->index = $index;
    }

    function current()
    {
        $info = current($this->info);
        foreach (array($this->type, 'package', 'channel', 'uri') as $key) {
            if (!array_key_exists($key, $info)) {
                $info[$key] = null;
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask($this, $info, $this->type, key($this->info));
    }

    function count()
    {
        return count($this->info);
    }

    function rewind()
    {
        reset($this->info);
    }

    function key()
    {
        $info = current($this->info);
        return $info[$this->type];
    }

    function next()
    {
        return next($this->info);
    }

    function valid()
    {
        return current($this->info);
    }

    function locateRoleTask($name)
    {
        foreach ($this->info as $i => $dep)
        {
            if (isset($dep[$this->type]) && $dep[$this->type] == $name) {
                return $i;
            }
        }
        return false;
    }

    function offsetGet($var)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'use -> operator to access properties of a uses' . $this->type);
        }
        $i = $this->locateRoleTask($var);
        if (false === $i) {
            $i = count($this->info);
            $info = array($this->type => $var, 'package' => null, 'channel' => null, 'uri' => null);
        } else {
            $info = $this->info[$i];
            foreach (array($this->type, 'package', 'channel', 'uri') as $key) {
                if (!array_key_exists($key, $this->info[$i])) {
                    $info[$key] = null;
                }
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask($this, $info, $this->type, $i);
    }

    function offsetSet($var, $value)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'use -> operator to access properties of a uses' . $this->type);
        }
        if (!($value instanceof PEAR2_Pyrus_PackageFile_v2_UsesRoleTask)) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'Can only set uses' . $this->type . ' to a PEAR2_Pyrus_PackageFile_v2_UsesRoleTask object');
        }
        if ($value->type != $this->type) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'Cannot set uses' . $this->type . ' to a uses' . $value->type . ' object');
        }
        $i = $this->locateRoleTask($var);
        if (false === $i) {
            $i = count($this->info);
        }
        $this->info[$i] = array($this->type => $var,
                                'package' => $value->package,
                                'channel' => $value->channel,
                                'uri' => $value->uri);
        $this->save();
    }

    function offsetExists($var)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'use -> operator to access properties of a uses' . $this->type);
        }
        $i = $this->locateRoleTask($var);
        return $i !== false;
    }

    function offsetUnset($var)
    {
        if ($this->index !== null) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'use -> operator to access properties of a uses' . $this->type);
        }
        $i = $this->locateRoleTask($var);
        if ($i === false) {
            return;
        }
        unset($this->info[$i]);
        $this->info = array_values($this->info);
        $this->save();
    }

    function __unset($var)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'use [] operator to access uses' . $this->type . 's');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'Unknown variable ' . $var . ' requested, should be one of ' .
                implode(', ', array_keys($this->info))
            );
        }
        $this->info[$var] = null;
        $this->save();
    }

    function __isset($var)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'use [] operator to access uses' . $this->type . 's');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'Unknown variable ' . $var . ' requested, should be one of ' .
                implode(', ', array_keys($this->info))
            );
        }
        return isset($this->info[$var]);
    }

    function __set($var, $value)
    {
        return $this->__call($var, array($value));
    }

    function __call($var, $args)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'use [] operator to access uses' . $this->type . 's');
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception('Unknown variable ' . $var . ', must be one of ' .
                            implode(', ', array_keys($this->info)));
        }
        if ($args[0] === null) {
            $this->info[$var] = null;
            $this->save();
            return $this;
        }
        if ($var === 'channel' || $var === 'package') {
            $this->info['uri'] = null;
        } elseif ($var === 'uri') {
            $this->info['channel'] = null;
            $this->info['package'] = null;
        }
        $this->info[$var] = $args[0];
        $this->save();
        return $this;
    }

    function __get($var)
    {
        if ($this->index === null) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception(
                'use [] operator to access uses' . $this->type . 's');
        }
        if ($var === 'type') {
            return 'uses' . $this->type;
        }
        if (!array_key_exists($var, $this->info)) {
            throw new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask_Exception('Unknown variable ' . $var . ', must be one of ' .
                            implode(', ', array_keys($this->info)));
        }
        if (!isset($this->info[$var])) {
            return null;
        }
        return $this->info[$var];
    }

    function getInfo()
    {
        return $this->info;
    }

    function setInfo($info, $index)
    {
        foreach (array_keys($info) as $key) {
            if ($info[$key] === null) {
                unset($info[$key]);
            }
        }
        $this->info[$index] = $info;
    }

    function save()
    {
        if ($this->parent instanceof self) {
            $this->parent->setInfo($this->info, $this->index);
            $this->parent->save();
            return;
        }
        $info = $this->info;
        if (count($info) == 1) {
            $info = $info[0];
        }
        $this->parent->{'rawuses' . $this->type} = $info;
    }
}
?><?php
/**
 * PEAR2_Pyrus_PackageFile_v2_Validator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Private validation class used by PEAR2_Pyrus_PackageFile_v2 - do not use directly, its
 * sole purpose is to split up the PEAR/PackageFile/v2.php file to make it smaller
 *
 * @access     private
 * @category   pear
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2_Validator
{
    const VERSION = '@PACKAGE_VERSION@';
    /**
     * @var array
     */
    var $_packageInfo;
    /**
     * @var PEAR2_Pyrus_PackageFile_v2
     */
    var $_pf;
    /**
     * @var PEAR2_Pyrus_ErrorStack
     */
    var $_stack;
    /**
     * @var int
     */
    var $_isValid = 0;
    /**
     * @var int
     */
    var $_filesValid = 0;
    /**
     * @var int
     */
    var $_curState = 0;
    protected $errors;

    function getErrors()
    {
        return $this->errors;
    }

    /**
     * @param PEAR2_Pyrus_PackageFile_v2
     * @param int
     */
    function validate(PEAR2_Pyrus_IPackage $pf, $state = PEAR2_Pyrus_Validate::NORMAL)
    {
        $this->errors = new PEAR2_MultiErrors;
        if (!$pf->schemaOK) {
            // this package.xml was created from scratch, not loaded from an existing
            // package.xml
            $dom = new DOMDocument;
            libxml_use_internal_errors(true);
            libxml_clear_errors();
            $dom->loadXML($pf);
            $a = $pf->toArray();
            if ($a['package']['attribs']['version'] == '2.1') {
                $schema = PEAR2_Pyrus::getDataPath() . '/package-2.1.xsd';
                // for running out of cvs
                if (!file_exists($schema)) {
                    $schema = dirname(dirname(dirname(dirname(dirname(__FILE__))))) . '/data/package-2.1.xsd';
                }
            } else {
                $schema = PEAR2_Pyrus::getDataPath() . '/package-2.0.xsd';
                // for running out of cvs
                if (!file_exists($schema)) {
                    $schema = dirname(dirname(dirname(dirname(dirname(__FILE__))))) . '/data/package-2.0.xsd';
                }
            }
            $dom->schemaValidate($schema);
            $causes = array();
            foreach (libxml_get_errors() as $error) {
                $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception("Line " .
                     $error->line . ': ' . $error->message);
            }
            if (count($this->errors)) {
                throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml, does' .
                    ' not validate against schema', $this->errors);
            }
        }
        $this->_pf = $pf;
        $this->_curState = $state;
        $this->_packageInfo = $this->_pf->toArray();
        $this->_packageInfo = $this->_packageInfo['package'];
        if (!isset($this->_packageInfo) || !is_array($this->_packageInfo)) {
            return false;
        }
        $myversion = self::VERSION;
        if ($myversion === '@PACKAGE_VERSION@') {
            // we're running from CVS, assume we're 2.0.0
            $myversion = '2.0.0';
        }
        $test = $this->_packageInfo;
        if (isset($test['dependencies']) &&
              isset($test['dependencies']['required']) &&
              isset($test['dependencies']['required']['pearinstaller']) &&
              isset($test['dependencies']['required']['pearinstaller']['min']) &&
              version_compare($myversion,
                $test['dependencies']['required']['pearinstaller']['min'], '<')) {
            $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                'This package.xml requires PEAR version ' .
                $test['dependencies']['required']['pearinstaller']['min'] .
                ' to parse properly, we are version ' . $myversion);
        }
        $fail = false;
        foreach ($pf->contents as $file) {
            // leverage the hidden iterators to do our validation
            $name = $file->dir . $file->name;
            if ($name[0] == '.' && $name[1] == '/') {
                // name is something like "./doc/whatever.txt"
                $this->errors->E_ERROR[] = new PEAR2_Pyrus_Package_Exception(
                    'File "' . $name . '" cannot begin with "."');
                continue;
            }
            if (!$this->_validateRole($file->role)) {
                if (isset($this->_packageInfo['usesrole'])) {
                    $roles = $this->_packageInfo['usesrole'];
                    if (!isset($roles[0])) {
                        $roles = array($roles);
                    }
                    foreach ($roles as $role) {
                        if ($role['role'] = $file->role) {
                            if (isset($role['uri'])) {
                                $package = $role['uri'];
                            } else {
                                $package = PEAR2_Pyrus_Config::
                                    parsedPackageNameToString(array('package' =>
                                        $role['package'], 'channel' => $role['channel']),
                                        true);
                            }
                            $msg = 'This package contains role "' . $file->role .
                                '" and requires package "' . $package
                                 . '" to be used';
                            $this->errors->E_WARNING[] =
                                new PEAR2_Pyrus_PackageFile_Exception($msg);
                        }
                    }
                }
                $this->errors->E_ERROR[] =
                    new PEAR2_Pyrus_PackageFile_Exception(
                    'File "' . $name . '" has invalid role "' .
                    $file->role . '", should be one of ' . implode(', ',
                    PEAR2_Pyrus_Installer_Role::getValidRoles($this->_pf->getPackageType())));
            }
            if (count($file->tasks) && $this->_curState != PEAR2_Pyrus_Validate::DOWNLOADING) { // has tasks
                $save = $file->getArrayCopy();
                foreach ($file->tasks as $task => $value) {
                    if ($tagClass = $this->_pf->getTask($task)) {
                        if (!is_array($value) || !isset($value[0])) {
                            $value = array($value);
                        }
                        foreach ($value as $v) {
                            try {
                                $ret = $tagClass::validateXml($this->_pf, $v, $save['attribs'], $file->name);
                            } catch (PEAR2_Pyrus_Task_Exception $e) {
                                $this->errors->E_ERROR[] =
                                    new PEAR2_Pyrus_PackageFile_Exception('Invalid task $task', $e);
                            }
                        }
                    } else {
                        if (isset($this->_packageInfo['usestask'])) {
                            $roles = $this->_packageInfo['usestask'];
                            if (!isset($roles[0])) {
                                $roles = array($roles);
                            }
                            foreach ($roles as $role) {
                                if ($role['task'] = $task) {
                                    if (isset($role['uri'])) {
                                        $package = $role['uri'];
                                    } else {
                                        $package = PEAR2_Pyrus_Config::
                                            parsedPackageNameToString(array('package' =>
                                                $role['package'], 'channel' => $role['channel']),
                                                true);
                                    }
                                    $msg = 'This package contains task "' .
                                        str_replace($this->_pf->getTasksNs() . ':', '', $task) .
                                        '" and requires package "' . $package
                                         . '" to be used';
                                    $this->errors->E_WARNING[] =
                                        new PEAR2_Pyrus_PackageFile_Exception($msg);
                                }
                            }
                        }
                        $this->errors->E_ERROR[] =
                            new PEAR2_Pyrus_PackageFile_Exception(
                            'Unknown task "' . $task . '" passed in file <file name="' .
                            $name . '">');
                    }
                }
            }
        }
        $this->_validateRelease();
        if (count($this->errors->E_ERROR)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml', $this->errors);
        }
        try {
            $validator = PEAR2_Pyrus_Config::current()
                ->channelregistry[$this->_pf->channel]
                ->getValidationObject($this->_pf->name);
        } catch (PEAR2_Pyrus_Config_Exception $e) {
            throw new PEAR2_Pyrus_PackageFile_Exception(
                'Unable to process channel-specific configuration for channel ' .
                $this->_pf->getChannel(), $e);
        } catch (Exception $e) {
            $valpack = PEAR2_Pyrus_Config::current()
                ->channelregistry[$this->_pf->channel]->getValidationPackage();
            $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                'Unknown channel ' . $this->_pf->channel);
            $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                'package "' . $this->_pf->channel . '/' . $this->_pf->name .
                '" cannot be properly validated without validation package "' .
                $this->_pf->channel . '/' . $valpack['name'] . '-' . $valpack['version'] . '"');
        }
        try {
            $validator->setPackageFile($this->_pf);
            $validator->setChannel(PEAR2_Pyrus_Config::current()
                ->channelregistry[$this->_pf->channel]);
            $validator->validate($state);
            // merge in errors from channel-specific validation
            $this->errors[] = $validator->getFailures();
        } catch (\Exception $e) {
            $this->errors->E_ERROR[] = $e;
        }
        if (count($this->errors->E_ERROR)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml',
                $this->errors);
        }
        if ($state == PEAR2_Pyrus_Validate::PACKAGING) {
            if ($this->_pf->type == 'bundle') {
                if (!$this->_analyzeBundledPackages()) {
                    throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml',
                        $this->errors);
                }
            } else {
                if (!$this->_analyzePhpFiles()) {
                    throw new PEAR2_Pyrus_PackageFile_Exception('Invalid package.xml',
                        $this->errors);
                }
            }
        }
        return $state;
    }

    function _validateFilelist($list)
    {
        $ignored_or_installed = array();
        if (isset($list['install'])) {
            if (!isset($list['install'][0])) {
                $list['install'] = array($list['install']);
            }
            foreach ($list['install'] as $file) {
                if (array_key_exists($file['attribs']['name'], $ignored_or_installed)) {
                    $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                        'Only one <install> tag is allowed for file "' .
                        $file['attribs']['name'] . '"');
                }
                if (!isset($this->_pf->files[$file['attribs']['name']])) {
                    $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                        '<install as> file "' . $file['attribs']['name'] . '" is not in <contents>');
                }
                if (!isset($ignored_or_installed[$file['attribs']['name']])) {
                    $ignored_or_installed[$file['attribs']['name']] = array();
                }
                $ignored_or_installed[$file['attribs']['name']][] = 1;
            }
        }
        if (isset($list['ignore'])) {
            if (!isset($list['ignore'][0])) {
                $list['ignore'] = array($list['ignore']);
            }
            foreach ($list['ignore'] as $file) {
                if (array_key_exists($file['attribs']['name'], $ignored_or_installed)) {
                    $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                        'Cannot have both <ignore> and <install> tags for file "' .
                        $file['attribs']['name'] . '"');
                }
                if (!isset($this->_pf->files[$file['attribs']['name']])) {
                    $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                        '<ignore> file "' . $file['attribs']['name'] . '" is not in <contents>');
                }
            }
        }
    }

    function _validateRelease()
    {
        if (isset($this->_packageInfo['phprelease'])) {
            $release = 'phprelease';
            $releases = $this->_packageInfo['phprelease'];
            if (!is_array($releases)) {
                return true;
            }
            if (!isset($releases[0])) {
                $releases = array($releases);
            }
        }
        foreach (array('', 'zend') as $prefix) {
            $releasetype = $prefix . 'extsrcrelease';
            if (isset($this->_packageInfo[$releasetype])) {
                $release = $releasetype;
                $releases = $this->_packageInfo[$releasetype];
                if (!is_array($releases)) {
                    return true;
                }
                if (!isset($releases[0])) {
                    $releases = array($releases);
                }
            }
            $releasetype = 'extbinrelease';
            if (isset($this->_packageInfo[$releasetype])) {
                $release = $releasetype;
                $releases = $this->_packageInfo[$releasetype];
                if (!is_array($releases)) {
                    return true;
                }
                if (!isset($releases[0])) {
                    $releases = array($releases);
                }
            }
        }
        if (isset($this->_packageInfo['bundle'])) {
            $release = 'bundle';
            $releases = $this->_packageInfo['bundle'];
            if (!is_array($releases) || !isset($releases[0])) {
                $releases = array($releases);
            }
        }
        foreach ($releases as $rel) {
            if (is_array($rel) && array_key_exists('filelist', $rel)) {
                if ($rel['filelist']) {
                    $this->_validateFilelist($rel['filelist']);
                }
            }
        }
    }

    /**
     * This is here to allow role extension through plugins
     * @param string
     */
    function _validateRole($role)
    {
        return in_array($role, PEAR2_Pyrus_Installer_Role::getValidRoles($this->_pf->getPackageType()));
    }

    function _analyzeBundledPackages()
    {
        if (!$this->_pf->type == 'bundle') {
            return false;
        }
        if (!$this->_pf->packagefile) {
            return false;
        }
        $dir_prefix = $this->_pf->filepath;
        foreach ($this->_pf->bundledpackage as $package) {
            if (!file_exists($dir_prefix . DIRECTORY_SEPARATOR . $package)) {
                $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                    'File "' . $dir_prefix . DIRECTORY_SEPARATOR . $package .
                    '" in package.xml does not exist');
                continue;
            }
            PEAR2_Pyrus_Log::log(1, "Analyzing bundled package $package");
            try {
                $ret = new PEAR2_Pyrus_Package_Tar($dir_prefix . DIRECTORY_SEPARATOR .
                    $package);
            } catch (Exception $e) {
                $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                    'File "' . $dir_prefix . DIRECTORY_SEPARATOR . $package .
                    '" in package.xml is not valid', $e);
                continue;
            }
        }
        return true;
    }

    function _analyzePhpFiles()
    {
        if (!$this->_pf->packagefile) {
            throw new PEAR2_Pyrus_PackageFile_Exception(
                'Cannot validate files, no path to package file is set (use setPackageFile())');
        }
        foreach ($this->_pf->contents as $fa) {
            if (!file_exists($this->_pf->getFilePath($fa->name))) {
                $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                    'File "' . $this->_pf->getFilePath($fa->name) .
                    '" in package.xml does not exist');
                continue;
            }
            $this->analyzeSourceCode($this->_pf->getFilePath($fa->name));
        }
        return !count($this->errors->E_ERROR);
    }

    /**
     * Analyze the source code of the given PHP file
     *
     * @param  string Filename of the PHP file
     * @param  boolean whether to analyze $file as the file contents
     * @return mixed
     */
    function analyzeSourceCode($file, $string = false)
    {
        if (!function_exists("token_get_all")) {
            throw new PEAR2_Pyrus_PackageFile_Exception(
                'Parser error: token_get_all() function must exist to analyze source code');
        }
        if (!($this->errors instanceof PEAR2_MultiErrors)) {
            $this->errors = new PEAR2_MultiErrors;
        }
        if ($string) {
            $contents = $file;
        } else {
            if (!$fp = @fopen($file, "r")) {
                return false;
            }
            fclose($fp);
            $contents = file_get_contents($file);
        }
        $tokens = token_get_all($contents);
/*
        for ($i = 0; $i < sizeof($tokens); $i++) {
            @list($token, $data) = $tokens[$i];
            if (is_string($token)) {
                var_dump($token);
            } else {
                print token_name($token) . ' ';
                var_dump(rtrim($data));
            }
        }
*/
        $look_for = 0;
        $paren_level = 0;
        $bracket_level = 0;
        $brace_level = 0;
        $lastphpdoc = '';
        $current_class = '';
        $current_interface = '';
        $current_class_level = -1;
        $current_function = '';
        $current_function_level = -1;
        $declared_classes = array();
        $declared_interfaces = array();
        $declared_functions = array();
        $declared_methods = array();
        $used_classes = array();
        $used_functions = array();
        $extends = array();
        $implements = array();
        $nodeps = array();
        $inquote = false;
        $interface = false;
        for ($i = 0; $i < sizeof($tokens); $i++) {
            if (is_array($tokens[$i])) {
                list($token, $data) = $tokens[$i];
            } else {
                $token = $tokens[$i];
                $data = '';
            }
            if ($inquote) {
                if ($token != '"' && $token != T_END_HEREDOC) {
                    continue;
                } else {
                    $inquote = false;
                    continue;
                }
            }
            switch ($token) {
                case T_WHITESPACE :
                    continue;
                case ';':
                    if ($interface) {
                        $current_function = '';
                        $current_function_level = -1;
                    }
                    break;
                case '"':
                case T_START_HEREDOC:
                    $inquote = true;
                    break;
                case T_CURLY_OPEN:
                case T_DOLLAR_OPEN_CURLY_BRACES:
                case '{': $brace_level++; continue 2;
                case '}':
                    $brace_level--;
                    if ($current_class_level == $brace_level) {
                        $current_class = '';
                        $current_class_level = -1;
                    }
                    if ($current_function_level == $brace_level) {
                        $current_function = '';
                        $current_function_level = -1;
                    }
                    continue 2;
                case '[': $bracket_level++; continue 2;
                case ']': $bracket_level--; continue 2;
                case '(': $paren_level++;   continue 2;
                case ')': $paren_level--;   continue 2;
                case T_INTERFACE:
                    $interface = true;
                case T_CLASS:
                    if (($current_class_level != -1) || ($current_function_level != -1)) {
                        if ($string) {
                            $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                                'Parser error: invalid PHP found in file');
                        } else {
                            $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                                'Parser error: invalid PHP found in file "' . $file . '"');
                        }
                        return false;
                    }
                case T_FUNCTION:
                case T_NEW:
                case T_EXTENDS:
                case T_IMPLEMENTS:
                    $look_for = $token;
                    continue 2;
                case T_STRING:
                    if ($look_for == T_CLASS) {
                        $current_class = $data;
                        $current_class_level = $brace_level;
                        $declared_classes[] = $current_class;
                    } elseif ($look_for == T_INTERFACE) {
                        $current_interface = $data;
                        $current_class_level = $brace_level;
                        $declared_interfaces[] = $current_interface;
                    } elseif ($look_for == T_IMPLEMENTS) {
                        $implements[$current_class] = $data;
                    } elseif ($look_for == T_EXTENDS) {
                        $extends[$current_class] = $data;
                    } elseif ($look_for == T_FUNCTION) {
                        if ($current_class) {
                            $current_function = "$current_class::$data";
                            $declared_methods[$current_class][] = $data;
                        } elseif ($current_interface) {
                            $current_function = "$current_interface::$data";
                            $declared_methods[$current_interface][] = $data;
                        } else {
                            $current_function = $data;
                            $declared_functions[] = $current_function;
                        }
                        $current_function_level = $brace_level;
                        $m = array();
                    } elseif ($look_for == T_NEW) {
                        $used_classes[$data] = true;
                    }
                    $look_for = 0;
                    continue 2;
                case T_VARIABLE:
                    $look_for = 0;
                    continue 2;
                case T_DOC_COMMENT:
                case T_COMMENT:
                    if (preg_match('!^/\*\*\s!', $data)) {
                        $lastphpdoc = $data;
                        if (preg_match_all('/@nodep\s+(\S+)/', $lastphpdoc, $m)) {
                            $nodeps = array_merge($nodeps, $m[1]);
                        }
                    }
                    continue 2;
                case T_DOUBLE_COLON:
                    if ($tokens[$i - 1][0] == T_VARIABLE) {
                        continue;
                    }
                    if (!($tokens[$i - 1][0] == T_WHITESPACE || $tokens[$i - 1][0] == T_STRING)) {
                        if ($string) {
                            $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                                'Parser error: invalid PHP found in file');
                        } else {
                            $this->errors->E_ERROR[] = new PEAR2_Pyrus_PackageFile_Exception(
                                'Parser error: invalid PHP found in file "' . $file . '"');
                        }
                        return false;
                    }
                    $class = $tokens[$i - 1][1];
                    if (strtolower($class) != 'parent') {
                        $used_classes[$class] = true;
                    }
                    continue 2;
            }
        }
        return array(
            "source_file" => $file,
            "declared_classes" => $declared_classes,
            "declared_interfaces" => $declared_interfaces,
            "declared_methods" => $declared_methods,
            "declared_functions" => $declared_functions,
            "used_classes" => array_diff(array_keys($used_classes), $nodeps),
            "inheritance" => $extends,
            "implements" => $implements,
            );
    }
}
?><?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_File
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Traverse the complete <contents> tag, one <dir> at a time
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_File extends RecursiveIteratorIterator
{
    function next()
    {
        parent::next();
        $x = $this->current();
        if (isset($x[0])) {
            parent::next();
            $x = $this->current();
        }
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_FileAttribsFilter
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Filter out the attributes meta-information when traversing the file list
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_FileAttribsFilter extends RecursiveFilterIterator
{
    function accept()
    {
        $it = $this->getInnerIterator();
        if (!$it->valid()) {
            return false;
        }
        $key = $it->key();
        if ($key === 'attribs') {
            return false;
        }
        return true;
    }
}
<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_FileContents
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Traverse the current <dir> in the <contents> tag
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_FileContents extends RecursiveArrayIterator
{
    protected $tag;
    protected $dir = '';
    private $_packagefile;
    function __construct($arr, $tag, PEAR2_Pyrus_PackageFile_v2 $parent, $dir = '')
    {
        $this->tag = $tag;
        $this->dir = $dir;
        $this->_packagefile = $parent;
        if ($arr instanceof PEAR2_Pyrus_PackageFile_v2Iterator_FileTag) {
            $arr = $arr->getArrayCopy();
        }
        parent::__construct($arr);
    }

    function getChildren ()
    {
        $arr = $this->current();
        $now = '';
        if ($this->key() == 'dir' && !isset($arr[0])) {
            $now = $arr['attribs']['name'];
            if (!$this->dir && $now == '/') {
                $now = '';
            }
        }
        $dir = $this->dir;
        if ($now && $dir) {
            if ($dir[strlen($dir) - 1] != '/') {
                $dir .= '/';
            }
        }
        if (isset($arr['attribs'])) unset($arr['attribs']);
        if (isset($arr[0])) {
            return new PEAR2_Pyrus_PackageFile_v2Iterator_FileContentsMulti($arr, $this->key(),
                $this->_packagefile, $dir . $now);
        }
        return new PEAR2_Pyrus_PackageFile_v2Iterator_FileContents($arr, $this->key(),
            $this->_packagefile, $dir . $now);
    }

    function hasChildren()
    {
        $arr = $this->current();
        if (!($arr instanceof PEAR2_Pyrus_PackageFile_v2Iterator_FileTag) && !is_array($arr)) {
            return false;
        }
        if (isset($arr['file']) || isset($arr['dir']) || isset($arr[0])) {
            return true;
        }
        return false;
    }

    function current()
    {
        $x = parent::current();
        return new PEAR2_Pyrus_PackageFile_v2Iterator_FileTag($x, $this->dir, $this->_packagefile);
    }
}
<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_FileContentsMulti
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * iterator for tags with multiple sub-tags
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_FileContentsMulti extends PEAR2_Pyrus_PackageFile_v2Iterator_FileContents
{
    function key()
    {
        return $this->tag;
    }
}
<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_FileInstallationFilter
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * filtered iterator for file installation
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_FileInstallationFilter extends FilterIterator
{
    static private $_parent;
    static private $_installGroup;
    static function setParent(PEAR2_Pyrus_PackageFile_v2 $parent)
    {
        self::$_parent = $parent;
        $errs = new PEAR2_MultiErrors;
        $depchecker = new PEAR2_Pyrus_Dependency_Validator(
            array('channel' => self::$_parent->channel,
                  'package' => self::$_parent->package),
            PEAR2_Pyrus_Validate::INSTALLING, $errs);
        foreach (self::$_parent->installGroup as $instance) {
            try {
                if (isset($instance['installconditions'])) {
                    $installconditions = $instance['installconditions'];
                    if (is_array($installconditions)) {
                        foreach ($installconditions as $type => $conditions) {
                            if (!isset($conditions[0])) {
                                $conditions = array($conditions);
                            }
                            foreach ($conditions as $condition) {
                                $ret = $depchecker->{"validate{$type}Dependency"}($condition);
                            }
                        }
                    }
                }
            } catch (Exception $e) {
                // can't use this release
                continue;
            }
            $release = array('install' => array(), 'ignore' => array());
            // this is the release to use
            if (isset($instance['filelist'])) {
                // ignore files
                if (isset($instance['filelist']['ignore'])) {
                    $ignore = isset($instance['filelist']['ignore'][0]) ?
                        $instance['filelist']['ignore'] :
                        array($instance['filelist']['ignore']);
                    foreach ($ignore as $ig) {
                        $release['ignore'][$ig['attribs']['name']] = true;
                    }
                }
                // install files as this name
                if (isset($instance['filelist']['install'])) {
                    $installas = isset($instance['filelist']['install'][0]) ?
                        $instance['filelist']['install'] :
                        array($instance['filelist']['install']);
                    foreach ($installas as $as) {
                        $release['install'][$as['attribs']['name']] =
                            $as['attribs']['as'];
                    }
                }
            }
            self::$_installGroup = $release;
            return;
        }
    }

    function current()
    {
        $file = $this->key();
        $curfile = parent::current();
        if (isset(self::$_installGroup['install'][$file])) {
            // add the install-as attribute for these files
            $curfile['attribs']['install-as'] =
                self::$_installGroup['install'][$file];
        }
        if ($b = self::$_parent->getBaseInstallDir($file)) {
            $curfile['attribs']['baseinstalldir'] = $b;
        }
        return new PEAR2_Pyrus_PackageFile_v2Iterator_FileTag($curfile,
            '', self::$_parent);
    }

    function accept()
    {
        $file = $this->getInnerIterator()->key();
        if (isset(self::$_installGroup['ignore'][$file])) {
            // skip ignored files
            return false;
        }
        return true;
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_FileTag
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Store the path to the current file recursively
 *
 * Information can be accessed in three ways:
 *
 * - $file['attribs'] as an array directly
 * - $file->name      as object member, to access attributes
 * - $file->tasks     as pseudo-object, to access each task
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_FileTag extends ArrayObject
{
    public $dir;
    /**
     * @var PEAR2_Pyrus_PackageFile_v2
     */
    private $_packagefile;
    function __construct($a, $t, $parent)
    {
        $this->_packagefile = $parent;
        parent::__construct($a);
        if ($t === '.') $t = '';
        $this->dir = $t;
        if ($this->dir && $this->dir != '/') $this->dir .= '/';
    }

    /**
     * Hide the install-as attribute (it is merged into the "name" attribute)
     *
     * @param string $offset
     * @return mixed
     */
    function offsetGet($offset)
    {
        if ($offset == 'attribs') {
            $ret = parent::offsetGet('attribs');
            if (isset($ret['install-as'])) {
                unset($ret['install-as']);
            }
            return $ret;
        }
        if ($offset == 'install-as') {
            $ret = parent::offsetGet('attribs');
            if (!isset($ret['install-as'])) {
                return null;
            }
            return $ret['install-as'];
        }
    }

    function __get($var)
    {
        if ($var == 'packagedname') {
            return $this->dir . $this['attribs']['name'];
        }
        if ($var == 'name') {
            $attribs = parent::offsetGet('attribs');
            if (isset($attribs['install-as'])) {
                return $attribs['install-as'];
            }
            return $this->dir . $this['attribs']['name'];
        }
        if ($var == 'tasks') {
            $ret = $this->getArrayCopy();
            unset($ret['attribs']);
            return $ret;
        }
        if ($var == 'install-as') {
            $attribs = parent::offsetGet('attribs');
            return $attribs['install-as'];
        }
        if (!isset($this['attribs'][$var])) {
            return null;
        }
        return $this['attribs'][$var];
    }

    /**
     * Allow setting of attributes and tasks directly
     *
     * @param string $var
     * @param string|object $value
     */
    function __set($var, $value)
    {
        if (strpos($var, $this->_packagefile->getTasksNs()) === 0) {
            // setting a file task
            if ($value instanceof PEAR2_Pyrus_Task_Common) {
                $this->_packagefile->setFileAttribute($this->dir .
                    $this['attribs']['name'], $var, $value->getInfo());
                return;
            }
            throw new PEAR2_Pyrus_PackageFile_Exception('Cannot set ' . $var . ' to non-' .
                'PEAR2_Pyrus_Task_Common object in file ' . $this->dir .
                $this['attribs']['name']);
        }
        $this->_packagefile->setFileAttribute($this->dir . $this['attribs']['name'],
            $var, $value);
        parent::__construct($this->_packagefile->files[$this->dir . $this['attribs']['name']]);
    }

    function __unset($var)
    {
        if (isset($this['attribs'][$var])) {
            unset($this['attribs'][$var]);
        }
    }

    function getInstallLocation()
    {
        $role = PEAR2_Pyrus_Installer_Role::factory($this->_packagefile, $this['attribs']['role'],
            PEAR2_Pyrus_Config::current());
        $role->setup(new PEAR2_Pyrus_Installer, $this->_packagefile, $this['attribs'], $this['attribs']['name']);
        if (!$role->isInstallable()) {
            return false;
        }
        return $role->getRelativeLocation($this->_packagefile, $this);
    }
}
<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * iterator for packaging
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator extends ArrayIterator
{
    static private $_parent;
    static function setParent(PEAR2_Pyrus_IPackageFile $parent)
    {
        self::$_parent = $parent;
    }

    function key()
    {
        $curfile = $this->current();
        $a = 'PEAR2_Pyrus_Installer_Role_' . ucfirst($curfile['attribs']['role']);
        $role = new $a(PEAR2_Pyrus_Config::current());
        // add the install-as attribute to retrieve packaging location
        return $role->getPackagingLocation(self::$_parent, $curfile['attribs']);
    }

    function current()
    {
        $curfile = parent::current();
        $curfile['attribs']['name'] = parent::key();
        if ($base = self::$_parent->getBaseInstallDir($curfile['attribs']['name'])) {
            $curfile['attribs']['baseinstalldir'] = $base;
        }
        if (isset($curfile['attribs']['md5sum'])) {
            unset($curfile['attribs']['md5sum']);
        }
        return $curfile;
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_v2Iterator_ScriptFileFilterIterator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class which iterates over all files, only returning those that contain script tasks.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2Iterator_ScriptFileFilterIterator extends FilterIterator
{
    private $_inner;
    private $_parent;
    private $_tasksNs;
    function __construct(array $arr, PEAR2_Pyrus_IPackageFile $parent)
    {
        $this->_parent = $parent;
        $this->_tasksNs = $this->_parent->getTasksNs();
        parent::__construct($this->_inner = new ArrayIterator($arr));
    }

    function accept()
    {
        if (!$this->_inner->valid()) {
            return false;
        }

        $file = $this->key();
        foreach ($this->_inner->current() as $key => $value) {
            if (strpos($key, $this->_tasksNs . ':') !== 0) {
                continue;
            }

            $task = str_replace(array($this->_tasksNs . ':', '-'), array('', ' '), $key);
            $task = str_replace(' ', '/', ucwords($task));
            $task = str_replace('/', '_', $task);
            $class = 'PEAR2_Pyrus_Task_' . $task;
            if (!class_exists($class, true)) {
                continue;
            }
            if ($class::TYPE == 'script') {
                return true;
            }
        }
        return false;
    }

    function current()
    {
        return $this->_parent->files[$this->_inner->key()];
    }
}<?php
/**
 * PEAR2_Pyrus_PackageFile_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for PackageFile
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_PackageFile_IValidator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for package file validators
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_PackageFile_IValidator
{
    public function extendedValidate(array $packageinfo);
}<?php
/**
 * PEAR_PackageFile_v2, package.xml version 2.1
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * File representing a package.xml file version 2.1
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile_v2 implements PEAR2_Pyrus_IPackageFile
{
    public $rootAttributes = array(
                                 'version' => '2.1',
                                 'xmlns' => 'http://pear.php.net/dtd/package-2.1',
                                 'xmlns:tasks' => 'http://pear.php.net/dtd/tasks-1.0',
                                 'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
                                 'xsi:schemaLocation' => 'http://pear.php.net/dtd/tasks-1.0
     http://pear.php.net/dtd/tasks-1.0.xsd
     http://pear.php.net/dtd/package-2.1
     http://pear.php.net/dtd/package-2.1.xsd',
                             );
    /**
     * Parsed package information
     *
     * For created-from-scratch packagefiles, set some basic information needed.
     * @var array
     * @access private
     */
    protected $packageInfo = array('attribs' => array(
        'version' => '2.1',
        'xmlns' => 'http://pear.php.net/dtd/package-2.1',
        'xmlns:tasks' => 'http://pear.php.net/dtd/tasks-1.0',
        'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
        'xsi:schemaLocation' => 'http://pear.php.net/dtd/tasks-1.0
     http://pear.php.net/dtd/tasks-1.0.xsd
     http://pear.php.net/dtd/package-2.1
     http://pear.php.net/dtd/package-2.1.xsd',
    ),
        'version' => array(
            'release' => '0.1.0',
            'api' => '0.1.0',
        ),
        'stability' => array(
            'release' => 'devel',
            'api' => 'alpha',
        ),
        'license' => array('attribs' => array('uri' => 'http://www.opensource.org/licenses/bsd-license.php'),
            '_content' => 'New BSD License',
        ),
        'dependencies' => array(
            'required' => array(
                'php' => array('min' => '5.2.0'),
                'pearinstaller' => array('min' => '2.0.0a1'),
            ),
        ),
        'phprelease' => array(),
    );

    /**
     * Set if the XML has been validated against schema
     *
     * @var unknown_type
     */
    private $_schemaValidated = false;

    protected $filelist = array();
    protected $baseinstalldirs = array();
    private $_dirtree = array();

    /**
     * Mapping of __get variables to method handlers
     * @var array
     */
    protected $getMap = array(
        'allmaintainers' => 'getAllMaintainers',
        'api-version' => 'getApiVersion',
        'api-state' => 'getApiState',
        'bundledpackage' => 'getBundledPackage',
        'channel' => 'getChannel',
        'compatible' => 'getCompatible',
        'configureoption' => 'getConfigureOption',
        'contents' => 'getContents',
        'date' => 'tag',
        'dependencies' => 'getDependencies',
        'description' => 'tag',
        'filepath' => 'getFilePath',
        'files' => 'getFiles',
        'installcontents' => 'getInstallContents',
        'installGroup' => 'getInstallGroup',
        'license' => 'getLicense',
        'maintainer' => 'getMaintainer',
        'name' => 'tag',
        'notes' => 'tag',
        'packagefile' => 'getPackageFile',
        'packagingcontents' => 'getPackagingContents',
        'providesextension' => 'tag',
        'rawdeps' => 'getRawDeps',
        'release' => 'getRelease',
        'release-version' => 'getReleaseVersion',
        'releases' => 'getReleases',
        'schemaOK' => 'getSchemaOK',
        'scriptfiles' => 'getScriptFiles',
        'sourcepackage' => 'getSourcePackage',
        'srcpackage' => 'tag',
        'srcchannel' => 'tag',
        'srcuri' => 'tag',
        'stability' => 'tag',
        'state' => 'getState',
        'summary' => 'tag',
        'time' => 'tag',
        'type' => 'getPackageType',
        'usesrole' => 'getUsesRoleTask',
        'usestask' => 'getUsesRoleTask',
        'version' => 'tag',
    );

    protected $setMap = array(
        'packagefile' => 'setPackageFile',
        'filepath' => 'setFilePath',
        'contents' => 'setContents',
        'channel' => 'setTag',
        'uri' => 'setTag',
        'state' => 'setState',
        'sourcepackage' => 'setSourcePackage',
        'license' => 'setLicense',
        'version' => 'setVersion',
        'stability' => 'setStability',
        'providesextension' => 'setTag',
        'srcpackage' => 'setTag',
        'srcuri' => 'setTag',
        'name' => 'setTag',
        'summary' => 'setTag',
        'description' => 'setTag',
        'date' => 'setTag',
        'time' => 'setTag',
        'notes' => 'setTag',
        'extends' => 'setTag',
        'type' => 'setType',
        'packagerversion' => 'setPackagerVersion'
    );

    protected $rawMap = array(
        'rawdependencies' => 'dependencies',
        'rawlicense' => 'license',
        'rawcontents' => 'contents',
        'rawconfigureoption' => array('setRawConfigureoption'), // array says call this function
        'rawrelease' => array('setRawRelease'), // array says call this function
        'rawcompatible' => 'compatible',
        'rawstability' => 'stability',
        'rawversion' => 'version',
        'rawusesrole' => 'usesrole',
        'rawusestask' => 'usestask',
        'rawlead' => 'lead',
        'rawdeveloper' => 'developer',
        'rawcontributor' => 'contributor',
        'rawhelper' => 'helper',
    );

    /**
     * path to package.xml or false if this is an abstract parsed-from-string xml
     * @var string|false
     * @access private
     */
    protected $_packageFile = false;

    /**
     * path to archive containing this package file, or false if this is a package.xml
     * or abstract parsed-from-string xml
     * @var string|false
     * @access private
     */
    protected $_archiveFile = false;

    /**
     * Optional Dependency group requested for installation
     * @var string
     * @access private
     */
    var $_requestedGroup = false;

    /**
     * Namespace prefix used for tasks in this package.xml - use tasks: whenever possible
     */
    var $_tasksNs;

    function setPackagefile($file, $archive = false)
    {
        $this->_packageFile = $file;
        $this->_archiveFile = $archive ? $archive : $file;
    }

    function getBundledPackage()
    {
        if ($this->getPackageType() !== 'bundle') {
            return false;
        }
        if (!isset($this->packageInfo['contents'])) {
            $this->packageInfo['contents'] = array();
        }
        if (!isset($this->packageInfo['contents']['bundledpackage'])) {
            $this->packageInfo['contents']['bundledpackage'] = array();
        }
        return new PEAR2_Pyrus_PackageFile_v2_BundledPackage($this, $this->packageInfo['contents']['bundledpackage']);
    }

    function getContents()
    {
        // allows stuff like:
        // foreach ($pf->contents as $file) {
        //     echo $file->name;
        //     $file->installed_as = 'hi';
        // }
        return new PEAR2_Pyrus_PackageFile_v2Iterator_File(
                new PEAR2_Pyrus_PackageFile_v2Iterator_FileAttribsFilter(
                new PEAR2_Pyrus_PackageFile_v2Iterator_FileContents(
                    $this->packageInfo['contents'], 'contents', $this)),
                    RecursiveIteratorIterator::LEAVES_ONLY);
    }

    function getInstallContents()
    {
        PEAR2_Pyrus_PackageFile_v2Iterator_FileInstallationFilter::setParent($this);
        return new PEAR2_Pyrus_PackageFile_v2Iterator_FileInstallationFilter(
                new ArrayIterator(
                    $this->filelist));
    }

    function getPackagingContents()
    {
        PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator::setParent($this);
        return new PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator(
                    $this->filelist);
    }

    function getScriptFiles()
    {
        return new PEAR2_Pyrus_PackageFile_v2Iterator_ScriptFileFilterIterator($this->filelist, $this);
    }

    function getPackageFile()
    {
        return $this->_packageFile;
    }

    function getFilePath()
    {
        return dirname($this->_packageFile);
    }

    function getInstallGroup()
    {
        $rel = $this->getPackageType();
        if ($rel != 'bundle') $rel .= 'release';
        $ret = $this->packageInfo[$rel];
        if (!isset($ret[0])) {
            return array($ret);
        }
        return $ret;
    }

    function getChannel()
    {
        if (isset($this->packageInfo['uri'])) {
            return '__uri';
        }
        return $this->tag('channel');
    }

    function getState()
    {
        if (!isset($this->packageInfo['stability']) ||
              !isset($this->packageInfo['stability']['release'])) {
            return false;
        }
        return $this->packageInfo['stability']['release'];
    }

    function getApiVersion()
    {
        if (!isset($this->packageInfo['version']) ||
              !isset($this->packageInfo['version']['api'])) {
            return false;
        }
        return $this->packageInfo['version']['api'];
    }

    function getReleaseVersion()
    {
        if (!isset($this->packageInfo['version']) ||
              !isset($this->packageInfo['version']['release'])) {
            return false;
        }
        return $this->packageInfo['version']['release'];
    }

    function getApiState()
    {
        if (!isset($this->packageInfo['stability']) ||
              !isset($this->packageInfo['stability']['api'])) {
            return false;
        }
        return $this->packageInfo['stability']['api'];
    }

    function getAllMaintainers()
    {
        $ret = array('lead' => array(), 'developer' => array(), 'helper' => array(), 'contributor' => array());
        foreach ($this->maintainer as $maintainer) {
            $ret[$maintainer->role][] = $maintainer;
        }
        return $ret;
    }

    function getReleases()
    {
        $type = $this->getPackageType();
        if ($type != 'bundle') {
            $type .= 'release';
        }
        if ($type && isset($this->packageInfo[$type])) {
            return $this->packageInfo[$type];
        }
        return false;
    }

    function getSourcePackage()
    {
        if (isset($this->packageInfo['extbinrelease']) ||
              isset($this->packageInfo['zendextbinrelease'])) {
            return array('channel' => $this->packageInfo['srcchannel'],
                         'package' => $this->packageInfo['srcpackage']);
        }
        return false;
    }

    function getLicense()
    {
        if (!isset($this->packageInfo['license'])) {
            $this->packageInfo['license'] = array();
        }
        return new PEAR2_Pyrus_PackageFile_v2_License($this, $this->packageInfo['license']);
    }

    function getFiles()
    {
        return new PEAR2_Pyrus_PackageFile_v2_Files($this, $this->filelist);
    }

    function getUsesRoleTask($var)
    {
        if (!isset($this->packageInfo[$var])) {
            return new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask($this, array(),
                                                               str_replace('uses', '', $var));
        }
        $info = $this->packageInfo[$var];
        if (count($info) && !isset($info[0])) {
            $info = array($info);
        }
        return new PEAR2_Pyrus_PackageFile_v2_UsesRoleTask($this, $info, str_replace('uses', '', $var));
    }

    function getMaintainer()
    {
        $info = array();
        foreach (array('lead', 'developer', 'contributor', 'helper') as $type) {
            if (isset($this->packageInfo[$type])) {
                $info[$type] = $this->packageInfo[$type];
                if (!isset($info[$type][0])) {
                    $info[$type] = array($info[$type]);
                }
            } else {
                $info[$type] = array();
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Developer($this, $info);
    }

    function getRawDeps()
    {
        return isset($this->packageInfo['dependencies']) ?
            $this->packageInfo['dependencies'] : false;
    }

    function getDependencies()
    {
        if (!isset($this->packageInfo['dependencies'])) {
            $this->packageInfo['dependencies'] = array();
        }
        return new PEAR2_Pyrus_PackageFile_v2_Dependencies(
            $this,
            $this->packageInfo['dependencies']);
    }

    function getRelease()
    {
        $t = $this->getPackageType();
        if (!$t) {
            $this->type = 'php';
            $t = 'phprelease';
        } else {
            if ($t != 'bundle') {
                $t .= 'release';
            }
        }
        if (!isset($this->packageInfo[$t]) || !is_array($this->packageInfo[$t])) {
            $this->packageInfo[$t] = array();
        }
        return new PEAR2_Pyrus_PackageFile_v2_Release(
            $this, $this->packageInfo[$t], $this->filelist);
    }

    function getCompatible()
    {
        if (!isset($this->packageInfo['compatible'])) {
            $compatible = array();
        } else {
            $compatible = $this->packageInfo['compatible'];
        }
        return new PEAR2_Pyrus_PackageFile_v2_Compatible(
            $this,
            $compatible);
    }

    function getConfigureOption()
    {
        if (!isset($this->packageInfo['configureoption'])) {
            $configureoption = array();
        } else {
            $configureoption = $this->packageInfo['configureoption'];
            if (count($configureoption) && !isset($configureoption[0])) {
                $configureoption = array($configureoption);
            }
        }
        return new PEAR2_Pyrus_PackageFile_v2_Configureoption($this, $configureoption);
    }

    function getSchemaOK()
    {
        return $this->_schemaValidated;
    }

    function getArchiveFile()
    {
        return $this->_archiveFile;
    }

    /**
     * Directly set the array that defines this packagefile
     *
     * WARNING: no validation.  This should only be performed by internal methods
     * inside Pyrus or by inputting an array saved from an existing PEAR_PackageFile_v2
     * @param array
     */
    function fromArray($pinfo)
    {
        $this->_schemaValidated = true;
        $this->packageInfo = $pinfo['package'];
    }

    function fromPackageFile(PEAR2_Pyrus_IPackageFile $package)
    {
        $this->fromArray($package->toArray());
        $this->setFilelist($package->getFileList());
        $this->setBaseInstallDirs($package->getBaseInstallDirs());
    }

    function hasFile($file)
    {
        return isset($this->filelist[$file]);
    }

    function getFile($file)
    {
        return $this->filelist[$file];
    }

    function setFilelist(array $list)
    {
        $this->filelist = $list;
    }

    function getFileList()
    {
        return $this->filelist;
    }

    function setFilelistFile($file, $info)
    {
        if ($info === null) {
            if (array_key_exists($file, $this->filelist)) {
                unset($this->filelist[$file]);
            }
            return;
        }
        $this->filelist[$file] = $info;
    }

    function setBaseInstallDirs(array $list)
    {
        $this->baseinstalldirs = $list;
    }

    function getBaseInstallDirs()
    {
        return $this->baseinstalldirs;
    }

    /**
     * @param string full path to file
     * @param string attribute name
     * @param string attribute value
     * @return bool success of operation
     */
    function setFileAttribute($filename, $attr, $value)
    {
        if (!in_array($attr, array('role', 'name', 'baseinstalldir', 'install-as'), true)) {
            // check to see if this is a task
            if ($this->isValidTask($attr)) {
                if (!isset($this->filelist[$filename][$attr])) {
                    $this->filelist[$filename][$attr] = $value;
                } else {
                    if (!isset($this->filelist[$filename][$attr][0])) {
                        $this->filelist[$filename][$attr] = array($this->filelist[$filename][$attr]);
                    }
                    $this->filelist[$filename][$attr][] = $value;
                }
                return;
            }
            throw new PEAR2_Pyrus_PackageFile_Exception(
                'Cannot set invalid attribute ' . $attr . ' for file ' . $filename);
        }
        if (!isset($this->filelist[$filename])) {
            throw new PEAR2_Pyrus_PackageFile_Exception(
                'Cannot set attribute ' . $attr . ' for non-existent file ' . $filename);
        }
        if ($attr == 'name') {
            throw new PEAR2_Pyrus_PackageFile_Exception('Cannot change name of file ' .
                $filename);
        }
        $this->filelist[$filename]['attribs'][$attr] = $value;
    }

    function isValidTask($name)
    {
        $tasksns = $this->getTasksNs();
        if (strlen($name) <= strlen($tasksns) + 1) {
            return false;
        }
        if (substr($name, 0, strlen($tasksns)) === $tasksns) {
            if ($name[strlen($tasksns)] == ':') {
                return true;
            }
        }
        return false;
    }

    /**
     * Used by uninstallation to set directory locations to erase
     * @param string $path
     */
    function setDirtree($path)
    {
        $this->_dirtree[$path] = true;
    }

    function getDirtree()
    {
        return $this->_dirtree;
    }

    function isNewPackage()
    {
        return version_compare($this->dependencies['required']->pearinstaller->min,
                               '2.0.0a1', '>=');
    }

    /**
     * Determines whether this package claims it is compatible with the version of
     * the package that has a recommended version dependency
     *
     * This function should only be called when the package has a recommended
     * version tag in a package or subpackage dependency on the package
     * represented by $pf, as no check is done to see whether $this
     * depends on $pf
     * @return boolean
     */
    function isCompatible(PEAR2_Pyrus_IPackageFile $pf)
    {
        if (!isset($this->packageInfo['compatible'])) {
            return false;
        }
        if (!isset($this->packageInfo['channel'])) {
            return false;
        }
        $me = $pf->version['release'];
        $found = false;
        foreach ($this->compatible as $info) {
            if (strtolower($info->name) == strtolower($pf->name)) {
                if ($info->channel == $pf->channel) {
                    $found = true;
                    break;
                }
            }
        }
        if (!$found) {
            return false;
        }
        if (isset($info->exclude)) {
            foreach ($info->exclude as $exclude) {
                if (version_compare($me, $exclude, '==')) {
                    return false;
                }
            }
        }
        if (version_compare($me, $info->min, '>=') && version_compare($me, $info->max, '<=')) {
            return true;
        }
        return false;
    }

    function isSubpackageOf(PEAR2_Pyrus_IPackageFile $p)
    {
        return $p->isSubpackage($this);
    }

    /**
     * Determines whether the passed in package is a subpackage of this package.
     *
     * No version checking is done, only name verification.
     * @return bool
     */
    function isSubpackage(PEAR2_Pyrus_IPackageFile $p)
    {
        foreach (array('required', 'optional', 'group') as $type) {
            if ($type === 'group') {
                foreach ($this->dependencies['group'] as $group) {
                    foreach ($group->subpackage as $dep) {
                        if (strtolower($dep->name) == strtolower($p->name)) {
                            if (isset($dep->channel)) {
                                if ($dep->channel == $p->channel) {
                                    return true;
                                }
                            } else {
                                if ($dep->uri == $p->uri) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            foreach ($this->dependencies[$type]->subpackage as $dep) {
                if (strtolower($dep->name) == strtolower($p->name)) {
                    if (isset($dep->channel)) {
                        if ($dep->channel == $p->channel) {
                            return true;
                        }
                    } else {
                        if ($dep->uri == $p->uri) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    function isEqual(PEAR2_Pyrus_IPackageFile $pkg)
    {
        if ($this->channel === '__uri') {
            return $pkg->name === $this->name && $pkg->uri === $this->uri;
        }

        return $pkg->name === $this->name && $pkg->channel === $this->channel;
    }

    /**
     * Returns true if any dependency, optional or required, exists on the package specified
     */
    function dependsOn(PEAR2_Pyrus_IPackageFile $pkg)
    {
        $uri = $pkg->uri;
        $package = $pkg->name;
        $channel = $pkg->channel;

        $deps = $this->dependencies;
        foreach (array('package', 'subpackage') as $type) {
            foreach (array('required', 'optional') as $needed) {
                foreach ($deps[$needed]->$type as $dep) {
                    if (strtolower($dep->name) == strtolower($package)) {
                        if (isset($dep->channel)) {
                            if ($dep->channel == strtolower($channel)) {
                                return true;
                            }
                        } else {
                            if ($dep->uri === $uri) {
                                return true;
                            }
                        }
                    }
                }
            }
            foreach ($deps['group'] as $group) {
                foreach ($group->$type as $dep) {
                    if (strtolower($dep->name) == strtolower($package)) {
                        if (isset($dep->channel)) {
                            if (strtolower($dep->channel) == strtolower($channel)) {
                                return true;
                            }
                        } else {
                            if ($dep->uri === $uri) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    /**
     * @return php|extsrc|extbin|zendextsrc|zendextbin|bundle|false
     */
    function getPackageType()
    {
        if (isset($this->packageInfo['phprelease'])) {
            return 'php';
        }
        if (isset($this->packageInfo['extsrcrelease'])) {
            return 'extsrc';
        }
        if (isset($this->packageInfo['extbinrelease'])) {
            return 'extbin';
        }
        if (isset($this->packageInfo['zendextsrcrelease'])) {
            return 'zendextsrc';
        }
        if (isset($this->packageInfo['zendextbinrelease'])) {
            return 'zendextbin';
        }
        if (isset($this->packageInfo['bundle'])) {
            return 'bundle';
        }
        return false;
    }

    function hasDeps()
    {
        return isset($this->packageInfo['dependencies']);
    }

    function getPackagexmlVersion()
    {
        if (isset($this->packageInfo['zendextsrcrelease'])) {
            return '2.1';
        }
        if (isset($this->packageInfo['zendextbinrelease'])) {
            return '2.1';
        }
        return '2.0';
    }

    /**
     * validate dependencies against the local registry, packages to be installed,
     * and environment (php version, OS, architecture, enabled extensions)
     *
     * @param array $toInstall an array of PEAR2_Pyrus_Package objects
     * @param PEAR2_MultiErrors $errs
     */
    function validateDependencies(array $toInstall, PEAR2_MultiErrors $errs)
    {
        $dep = new PEAR2_Pyrus_Dependency_Validator($this->packageInfo['name'],
            PEAR2_Pyrus_Validate::DOWNLOADING, $errs);
        $dep->validatePhpDependency($this->dependencies['required']->php);
        $dep->validatePearinstallerDependency($this->dependencies['required']->pearinstaller);
        foreach (array('required', 'optional') as $required) {
            foreach ($this->dependencies[$required]->package as $d) {
                $dep->validatePackageDependency($d, $toInstall);
            }
            foreach ($this->dependencies[$required]->subpackage as $d) {
                $dep->validateSubpackageDependency($d, $toInstall);
            }
            foreach ($this->dependencies[$required]->extension as $d) {
                $dep->validateExtensionDependency($d);
            }
        }
        foreach ($this->dependencies['required']->arch as $d) {
            $dep->validateArchDependency($d);
        }
        foreach ($this->dependencies['required']->os as $d) {
            $dep->validateOsDependency($d);
        }
    }

    function getValidator($state = PEAR2_Pyrus_Validate::NORMAL)
    {
        return new PEAR2_Pyrus_PackageFile_v2_Validator;
    }

    function getTasksNs()
    {
        if (!isset($this->_tasksNs)) {
            if (isset($this->packageInfo['attribs'])) {
                foreach ($this->packageInfo['attribs'] as $name => $value) {
                    if ($value == 'http://pear.php.net/dtd/tasks-1.0') {
                        $this->_tasksNs = str_replace('xmlns:', '', $name);
                        break;
                    }
                }
            }
        }
        return $this->_tasksNs;
    }

    /**
     * Determine whether a task name is a valid task.  Custom tasks may be defined
     * using subdirectories by putting a "-" in the name, as in <tasks:mycustom-task>
     *
     * Note that this method will auto-load the task class file and test for the existence
     * of the name with "-" replaced by "_" as in PEAR/Task/mycustom/task.php makes class
     * PEAR_Task_mycustom_task
     * @param string
     * @return boolean
     */
    function getTask($task)
    {
        $this->getTasksNs();
        // transform all '-' to '/' and 'tasks:' to '' so tasks:replace becomes replace
        $task = str_replace(array($this->_tasksNs . ':', '-'), array('', ' '), $task);
        $task = str_replace(' ', '/', ucwords($task));
        $test = str_replace('/', '_', $task);
        if (class_exists("PEAR2_Pyrus_Task_$test", true)) {
            return "PEAR2_Pyrus_Task_$test";
        }
        return false;
    }

    function getBaseInstallDir($file)
    {
        $file = dirname($file);
        while ($file !== '.' && $file != '/') {
            if (isset($this->baseinstalldirs[$file])) {
                return $this->baseinstalldirs[$file];
            }
            $file = dirname($file);
        }
        if (isset($this->baseinstalldirs[''])) {
            return $this->baseinstalldirs[''];
        }
        return false;
    }

    function __get($var)
    {
        if (isset($this->getMap[$var])) {
            return $this->{$this->getMap[$var]}($var);
        }
        return $this->tag($var);
    }

    function setTag($var, $value)
    {
        if ($var === 'uri') {
            if (isset($this->packageInfo['channel'])) {
                unset($this->packageInfo['channel']);
            }
        }
        if ($var === 'channel') {
            if (isset($this->packageInfo['uri'])) {
                unset($this->packageInfo['uri']);
            }
        }
        if ($value === null && isset($this->packageInfo[$var])) {
            unset($this->packageInfo[$var]);
            return;
        }
        $this->packageInfo[$var] = $value;
    }

    function setLicense($var, $value)
    {
        if ($value instanceof PEAR2_Pyrus_PackageFile_v2_License) {
            return $this->rawlicense = $value->getInfo();
        }
        $licensemap =
            array(
                'php' => 'http://www.php.net/license',
                'php license' => 'http://www.php.net/license',
                'lgpl' => 'http://www.gnu.org/copyleft/lesser.html',
                'bsd' => 'http://www.opensource.org/licenses/bsd-license.php',
                'bsd style' => 'http://www.opensource.org/licenses/bsd-license.php',
                'bsd-style' => 'http://www.opensource.org/licenses/bsd-license.php',
                'mit' => 'http://www.opensource.org/licenses/mit-license.php',
                'gpl' => 'http://www.gnu.org/copyleft/gpl.html',
                'apache' => 'http://www.opensource.org/licenses/apache2.0.php'
            );
        if (isset($licensemap[strtolower($value)])) {
            $this->rawlicense = array(
                'attribs' => array('uri' =>
                    $licensemap[strtolower($value)]),
                '_content' => $value
                );
        } else {
            // don't use bogus uri
            $this->rawlicense = (string) $value;
        }
    }

    function setType($var, $value)
    {
        if (!is_string($value)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('package.xml type must be a ' .
            'string, was a ' . gettype($value));
        }
        if ($value != 'bundle') {
            $value .= 'release';
        }
        if (in_array($value, $a = array('phprelease', 'extsrcrelease', 'extbinrelease',
                                        'zendextsrcrelease', 'zendextbinrelease', 'bundle'))) {
            foreach ($a as $type) {
                if ($value == $type) {
                    if (!isset($this->packageInfo[$type])) {
                        $this->packageInfo[$type] = array();
                    }
                    continue;
                }
                if (isset($this->packageInfo[$type])) {
                    unset($this->packageInfo[$type]);
                }
            }
        }
    }

    function setRawConfigureopion($var, $value)
    {
        $t = $this->getPackageType();
        if ($t != 'bundle') {
            $t .= 'release';
        }
        if ($value === null) {
            if (isset($this->packageInfo[$t]['configureoption'])) {
                unset($this->packageInfo[$t]['configureoption']);
            }
        } else {
            $this->packageInfo[$t]['configureoption'] = $value;
        }
    }

    function setRawRelease($var, $value)
    {
        $t = $this->getPackageType();
        if ($t != 'bundle') {
            $t .= 'release';
        }
        $this->packageInfo[$t] = $value;
    }

    function setPackagerVersion($var, $value)
    {
        $this->packageInfo['attribs']['packagerversion'] = $value;
    }

    function __set($var, $value)
    {
        if ($var === 'dependencies' && $value === null) {
            $this->packageInfo['dependencies'] = array();
            return;
        }
        if ($var === 'release' && $value === null) {
            $rel = $this->getPackageType();
            if ($rel) {
                if (isset($this->packageInfo[$rel . 'release'])) {
                    $rel .= 'release';
                }
                $this->packageInfo[$rel] = '';
            }
            return;
        }
        if (isset($this->setMap[$var])) {
            return $this->{$this->setMap[$var]}($var, $value);
        }
        if (isset($this->rawMap[$var])) {
            $actual = $this->rawMap[$var];
            if (is_array($actual)) {
                $actual = $actual[0];
                return $this->$actual($var, $value);
            }
            if ($value === null) {
                if (isset($this->packageInfo[$actual])) {
                    unset($this->packageInfo[$actual]);
                }
            } else {
                $this->packageInfo[$actual] = $value;
            }
            return;
        }
        throw new PEAR2_Pyrus_PackageFile_Exception('Cannot set ' . $var . ' directly');
    }

    /**
     * Return the contents of a tag
     * @param string $name
     */
    protected function tag($name)
    {
        if (!isset($this->packageInfo[$name]) && in_array($name, array('version',
                'stability',
                'providesextension', 'usesrole', 'usestask', 'srcpackage', 'srcuri',
                ), true)) {
            $this->packageInfo[$name] = array();
        }
        switch ($name) {
            case 'stability' :
            case 'version' :
                if (!isset($this->packageInfo[$name])) {
                    $this->packageInfo[$name] = array();
                }
                $info = $this->packageInfo[$name];
                if (!isset($info['release'])) {
                    $info['release'] = null;
                }
                if (!isset($info['api'])) {
                    $info['api'] = null;
                }
                return new PEAR2_Pyrus_PackageFile_v2_SimpleProperty(
                                $this, $info, $name);
        }
        if (!isset($this->packageInfo[$name])) {
            return false;
        }
        return $this->packageInfo[$name];
    }

    /**
     * Update the changelog based on the current information
     */
    function updateChangelog()
    {
        $license = $this->license;
        if ($license instanceof ArrayObject) {
            $license = $license->getArrayCopy();
        }
        $info = array(
            'version' => array(
                'release' => $this->version['release'],
                'api' => $this->version['api']
            ),
            'stability' => array(
                'release' => $this->stability['release'],
                'api' => $this->stability['api']
            ),
            'date' => $this->date,
            'license' => $license,
            'notes' => $this->notes,
        );

        if (!is_array($this->packageInfo['changelog'])) {
            $this->packageInfo['changelog'] = $info;
        } elseif (!isset($this->packageInfo['changelog'][0])) {
            $this->packageInfo['changelog'] = array($info, $this->packageInfo['changelog']);
        } else {
            array_unshift($this->packageInfo['changelog'], $info);
        }
    }

    function __toString()
    {
        $this->packageInfo['attribs'] = $this->rootAttributes;
        $this->packageInfo['date'] = date('Y-m-d');
        $this->packageInfo['time'] = date('H:i:s');
        $arr = $this->toArray();
        return (string) new PEAR2_Pyrus_XMLWriter($arr);
    }

    function toRaw()
    {
        return $this;
    }

    function toArray($forpackaging = false)
    {
        $this->packageInfo['contents'] = array(
            'dir' => array(
                'attribs' => array('name' => '/'),
                'file' => array()
            ));
        uksort($this->filelist, 'strnatcasecmp');
        $a = array_reverse($this->filelist, 1);
        if ($forpackaging) {
            PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator::setParent($this);
            $a = new PEAR2_Pyrus_PackageFile_v2Iterator_PackagingIterator($a);
        }
        $temp = array();
        foreach ($a as $name => $stuff) {
            if ($forpackaging) {
                // map old to new name
                $temp[$stuff['attribs']['name']] = $name;
            }
            // if we are packaging, $name is the new name
            $stuff['attribs']['name'] = $name;
            $this->packageInfo['contents']['dir']['file'][] = $stuff;
        }
        if (count($this->packageInfo['contents']['dir']['file']) == 1) {
            $this->packageInfo['contents']['dir']['file'] =
                $this->packageInfo['contents']['dir']['file'][0];
        }
        $arr = array();
        foreach (array('attribs', 'name', 'channel', 'uri', 'extends', 'summary',
                'description', 'lead',
                'developer', 'contributor', 'helper', 'date', 'time', 'version',
                'stability', 'license', 'notes', 'contents', 'compatible',
                'dependencies', 'providesextension', 'usesrole', 'usestask', 'srcpackage', 'srcuri',
                'phprelease', 'extsrcrelease', 'zendextsrcrelease', 'zendextbinrelease',
                'extbinrelease', 'bundle', 'changelog') as $index)
        {
            if (!isset($this->packageInfo[$index])) {
                continue;
            }
            $arr[$index] = $this->packageInfo[$index];
        }
        if ($forpackaging) {
            // process releases
            $reltag = $this->getPackageType();
            if ($reltag != 'bundle') {
                $reltag .= 'release';
                if (is_array($arr[$reltag])) {
                    if (!isset($arr[$reltag][0])) {
                        $arr[$reltag] = array($arr[$reltag]);
                    }
                    foreach ($arr[$reltag] as $i => $inf) {
                        if (!isset($inf['filelist'])) {
                            continue;
                        }
                        $inf = $inf['filelist'];
                        if (isset($inf['install'])) {
                            if (!isset($inf['install'][0])) {
                                if (isset($temp[$inf['install']['attribs']['name']])) {
                                    $arr[$reltag][$i]['filelist']['install']['attribs']
                                                       ['name'] =
                                        $temp[$inf['install']['attribs']['name']];
                                }
                            } else {
                                foreach ($inf['install'] as $j => $morinf) {
                                    if (isset($temp[$morinf['attribs']['name']])) {
                                        $arr[$reltag][$i]['filelist']['install'][$j]
                                                           ['attribs']['name'] =
                                            $temp[$morinf['attribs']['name']];
                                    }
                                }
                            }
                        }
                        if (isset($inf['ignore'])) {
                            if (!isset($inf['ignore'][0])) {
                                if (isset($temp[$inf['ignore']['attribs']['name']])) {
                                    $arr[$reltag][$i]['filelist']['ignore']
                                                       ['attribs']['name'] =
                                        $temp[$inf['ignore']['attribs']['name']];
                                }
                            } else {
                                foreach ($inf['ignore'] as $j => $morinf) {
                                    if (isset($temp[$morinf['attribs']['name']])) {
                                        $arr[$reltag][$i]['filelist']['ignore'][$j]
                                                           ['attribs']['name'] =
                                            $temp[$morinf['attribs']['name']];
                                    }
                                }
                            }
                        }
                    }
                    if (count($arr[$reltag]) == 1) {
                        $arr[$reltag] = $arr[$reltag][0];
                    }
                }
            }
        }
        $reltag = $this->getPackageType();
        if ($reltag != 'bundle') {
            $reltag .= 'release';
            $sortInstallAs = function ($a, $b)
                {
                    return strnatcasecmp($a['attribs']['name'], $b['attribs']['name']);
                };
            if (!is_array($arr[$reltag])) {
                // do nothing
            } elseif (!isset($arr[$reltag][0])) {
                if (isset($arr[$reltag]['filelist']) && isset($arr[$reltag]['filelist']['install'])
                    && isset($arr[$reltag]['filelist']['install'][0])) {
                    usort($arr[$reltag]['filelist']['install'], $sortInstallAs);
                }
                if (isset($arr[$reltag]['filelist']) && isset($arr[$reltag]['filelist']['ignore'])
                    && isset($arr[$reltag]['filelist']['ignore'][0])) {
                    usort($arr[$reltag]['filelist']['ignore'], $sortInstallAs);
                }
            } else {
                foreach ($arr[$reltag] as $i => $contents) {
                    if (!isset($contents['filelist'])) {
                        continue;
                    }
                    if (isset($contents['filelist']['install']) && isset($contents['filelist']['install'][0])) {
                        usort($arr[$reltag][$i]['filelist']['install'], $sortInstallAs);
                    }
                    if (isset($contents['filelist']['ignore']) && isset($contents['filelist']['ignore'][0])) {
                        usort($arr[$reltag][$i]['filelist']['ignore'], $sortInstallAs);
                    }
                }
            }
        }
        if (isset($this->packageInfo['dependencies'])) {
            if (isset($this->packageInfo['dependencies']['required'])) {
                $arr['dependencies']['required'] = array();
                foreach (array('php', 'pearinstaller', 'package', 'subpackage',
                            'extension', 'os', 'arch') as $index) {
                    if (!isset($this->packageInfo['dependencies']['required'][$index])) {
                        continue;
                    }
                    $arr['dependencies']['required'][$index] =
                        $this->packageInfo['dependencies']['required'][$index];
                }
            }
            if (isset($this->packageInfo['dependencies']['optional'])) {
                $arr['dependencies']['optional'] = array();
                foreach (array('package', 'subpackage', 'extension') as $index) {
                    if (!isset($this->packageInfo['dependencies']['optional'][$index])) {
                        continue;
                    }
                    $arr['dependencies']['optional'][$index] =
                        $this->packageInfo['dependencies']['optional'][$index];
                }
            }
            if (isset($this->packageInfo['dependencies']['group'])) {
                if (isset($this->packageInfo['dependencies']['group'][0])) {
                    foreach ($this->packageInfo['dependencies']['group'] as $i => $g) {
                        $arr['dependencies']['group'][$i] = array();
                        foreach (array('attribs', 'package', 'subpackage', 'extension') as $index) {
                            if (!isset($g[$index])) {
                                continue;
                            }
                            $arr['dependencies']['group'][$i][$index] = $g[$index];
                        }
                    }
                } else {
                    $a = $this->packageInfo['dependencies']['group'];
                    $arr['dependencies']['group'] = array();
                    foreach (array('attribs', 'package', 'subpackage', 'extension') as $index) {
                        if (!isset($a[$index])) {
                            continue;
                        }
                        $arr['dependencies']['group'][$index] = $a[$index];
                    }
                }
            }
        }
        return array('package' => $arr);
    }
}
<?php
/**
 * PEAR2_Pyrus_PECLBuild_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for a Pyrus PECL package builder.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PECLBuild_Exception extends PEAR2_Exception
{
}<?php
/**
 * PEAR2_Pyrus_Registry_Package_Base
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Registry package class base
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
abstract class PEAR2_Pyrus_Registry_Package_Base extends PEAR2_Pyrus_PackageFile_v2
                                                 implements ArrayAccess, PEAR2_Pyrus_IPackageFile, Iterator
{

    protected $packagename;
    protected $package;
    protected $channel;
    protected $reg;
    protected $iteratorPackages;
    protected $iteratorChannel;

    function __construct(PEAR2_Pyrus_Registry_Base $cloner)
    {
        $this->reg = $cloner;
    }

    function current()
    {
        $package = current($this->iteratorPackages);
        return $this[$this->iteratorChannel . '/' . $package];
    }

    function key()
    {
        return current($this->iteratorPackages);
    }

    function rewind()
    {
        if (!$this->iteratorChannel) {
            $this->iteratorChannel = PEAR2_Pyrus_Config::current()->default_channel;
        }
        $this->iteratorPackages = $this->reg->listPackages($this->iteratorChannel);
    }

    function next()
    {
        return next($this->iteratorPackages);
    }

    function valid()
    {
        if (!current($this->iteratorPackages)) {
            $this->iteratorChannel = false;
            return false;
        }
        return true;
    }

    function setIteratorChannel($channel)
    {
        $this->iteratorChannel = $channel;
    }

    function fromPackageFile(PEAR2_Pyrus_IPackageFile $package)
    {
        parent::fromPackageFile($package);
        // reconstruct filelist/baseinstalldirs
        // this assumes that the filelist has been flattened, which is
        // always true for registries
        // it also assumes we are not a bundle, which is also always true for
        // registries as bundles are not installable
        $contents = $this->packageInfo['contents']['dir']['file'];
        if (!isset($contents[0])) {
            $contents = array($contents);
        }
        foreach ($contents as $file) {
            $this->filelist[$file['attribs']['name']] = $file;
        }
        if (isset($this->packageInfo['contents']['dir']['attribs']['baseinstalldir'])) {
            $this->baseinstalldirs = array('/' => $this->packageInfo['contents']['dir']['attribs']['baseinstalldir']);
        }
    }

    function offsetExists($offset)
    {
        $info = PEAR2_Pyrus_Config::current()->channelregistry->parseName($offset);
        return $this->reg->exists($info['package'], $info['channel']);
    }

    function offsetGet($offset)
    {
        $this->packagename = $offset;
        $info = PEAR2_Pyrus_Config::current()->channelregistry->parseName($this->packagename);
        $this->package = $info['package'];
        $this->channel = $info['channel'];
        $intermediate = $this->reg->toPackageFile($info['package'], $info['channel']);
        $this->fromPackageFile($intermediate);
        $ret = clone $this;
        $this->packagename = null;
        $this->package = null;
        $this->channel = null;
        return $ret;
    }

    function offsetSet($offset, $value)
    {
        $this->reg->install($value);
    }

    function offsetUnset($offset)
    {
        $info = PEAR2_Pyrus_Config::current()->channelregistry->parseName($offset);
        $this->reg->uninstall($info['package'], $info['channel']);
    }

    function toRaw()
    {
        $info = new PEAR2_Pyrus_PackageFile_v2;
        $info->fromArray(array('package' => $this->packageInfo));
        return $info;
    }

    function __get($var)
    {
        if (!isset($this->packagename)) {
            throw new PEAR2_Pyrus_Registry_Exception('Attempt to retrieve ' . $var .
                ' from unknown package');
        }
        return parent::__get($var);
    }

    function __set($var, $value)
    {
        if (!isset($this->packagename)) {
            throw new PEAR2_Pyrus_Registry_Exception('Attempt to retrieve ' . $var .
                ' from unknown package');
        }
        parent::__set($var, $value);
        $this->reg->replace($this);
    }

    function getSchemaOK()
    {
        return true;
    }

    /**
     * Create vertices/edges of a directed graph for dependencies of this package
     *
     * Iterate over dependencies and create edges from this package to those it
     * depends upon
     * @param PEAR2_Pyrus_DirectedGraph $graph
     * @param array $packages channel/package indexed array of PEAR2_Pyrus_Package objects
     */
    function makeUninstallConnections(PEAR2_Pyrus_DirectedGraph $graph, array $packages)
    {
        $graph->add($this);
        foreach (array('required', 'optional') as $required) {
            foreach (array('package', 'subpackage') as $package) {
                foreach ($this->dependencies[$required]->$package as $d) {
                    if ($d->conflicts) {
                        continue;
                    }
                    if (isset($packages[$d->channel . '/' . $d->name])) {
                        $graph->connect($this, $packages[$d->channel . '/' . $d->name]);
                    }
                }
            }
        }
        foreach ($this->dependencies['group'] as $group) {
            foreach (array('package', 'subpackage') as $package) {
                foreach ($group->$package as $d) {
                    if (isset($packages[$d->channel . '/' . $d->name])) {
                        $graph->connect($this, $packages[$d->channel . '/' . $d->name]);
                    }
                }
            }
        }
    }

    public function validateUninstallDependencies(array $uninstallPackages,
                                                  PEAR2_MultiErrors $errs)
    {
        $ret = true;
        foreach ($uninstallPackages as $package) {
            foreach ($this->reg->getDependentPackages($package) as $deppackage) {
                $dep = new PEAR2_Pyrus_Dependency_Validator(
                    array('channel' => $deppackage->channel, 'package' => $deppackage->name),
                    PEAR2_Pyrus_Validate::UNINSTALLING, $errs);
                foreach ($uninstallPackages as $test) {
                    if ($deppackage->isEqual($test)) {
                        // we are uninstalling both the package that is depended upon
                        // and the parent package, so all dependencies are nulled
                        continue 2;
                    }
                }
                foreach (array('package', 'subpackage') as $packaged) {
                    $deps = $deppackage->dependencies['required']->$packaged;
                    if (isset($deps[$package->channel . '/' . $package->name])) {
                        $ret = $ret && $dep->validatePackageUninstall($deps[$package->channel . '/' . $package->name], $package);
                    }
                    $deps = $deppackage->dependencies['optional']->$packaged;
                    if (isset($deps[$package->channel . '/' . $package->name])) {
                        $ret = $ret && $dep->validatePackageUninstall($deps[$package->channel . '/' . $package->name], $package);
                    }
                }
            }
        }
        return $ret;
    }
}<?php
/**
 * PEAR_DependencyDB, advanced installed packages dependency database for
 * Pear1 registry
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Track dependency relationships between installed packages
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Tomas V.V.Cox <cox@idec.net.com>
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Pear1_DependencyDB
{
    /**
     * Filename of the dependency DB (usually .depdb)
     * @var string
     * @access private
     */
    var $_depdb = false;
    /**
     * File name of the lockfile (usually .depdblock)
     * @var string
     * @access private
     */
    var $_lockfile = false;
    /**
     * Open file resource for locking the lockfile
     * @var resource|false
     * @access private
     */
    var $_lockFp = false;
    /**
     * API version of this class, used to validate a file on-disk
     * @var string
     * @access private
     */
    var $_version = '1.0';

    function __construct($path)
    {
        $this->_depdb = $path . DIRECTORY_SEPARATOR . '.depdb';

        $this->_lockfile = dirname($this->_depdb) . DIRECTORY_SEPARATOR . '.depdblock';
    }

    function hasWriteAccess()
    {
        if (!file_exists($this->_depdb)) {
            $dir = $this->_depdb;
            while ($dir && $dir != '.') {
                $dir = dirname($dir); // cd ..
                if ($dir != '.' && file_exists($dir)) {
                    if (is_writeable($dir)) {
                        return true;
                    }
                    return false;
                }
            }
            return false;
        }
        return is_writeable($this->_depdb);
    }

    /**
     * Get a list of installed packages that depend on this package
     * @return array
     */
    function getDependentPackages(PEAR2_Pyrus_IPackageFile $pkg)
    {
        $data = $this->_getDepDB();

        if (isset($data['packages']) && isset($data['packages'][$pkg->channel][strtolower($pkg->name)])) {
            return $data['packages'][$pkg->channel][strtolower($pkg->name)];
        }
        return array();
    }

    /**
     * Get a list of the actual dependencies of installed packages that depend on
     * a package.
     * @return array
     */
    function getDependentPackageDependencies(PEAR2_Pyrus_IPackageFile $pkg)
    {
        $data = $this->_getDepDB();
        $channel = $pkg->channel;
        $package = strtolower($pkg->name);

        $depend = $this->getDependentPackages($pkg);
        if (!$depend) {
            return array();
        }

        $dependencies = array();
        foreach ($depend as $info) {
            $temp = $this->getDependencies($info);
            foreach ($temp as $dep) {
                if (isset($dep['dep'], $dep['dep']['channel'], $dep['dep']['name']) &&
                      $dep['dep']['channel'] == $channel &&
                      strtolower($dep['dep']['name']) == $package
                ) {
                    if (!isset($dependencies[$info['channel']])) {
                        $dependencies[$info['channel']] = array();
                    }

                    if (!isset($dependencies[$info['channel']][$info['package']])) {
                        $dependencies[$info['channel']][$info['package']] = array();
                    }
                    $dependencies[$info['channel']][$info['package']][] = $dep;
                }
            }
        }

        return $dependencies;
    }

    /**
     * Get a list of dependencies of this installed package
     * @return array
     */
    function getDependencies(PEAR2_Pyrus_IPackageFile $pkg)
    {
        $channel = $pkg->channel;
        $package = strtolower($pkg->name);

        $data = $this->_getDepDB();
        if (isset($data['dependencies'][$channel][$package])) {
            return $data['dependencies'][$channel][$package];
        }

        return false;
    }

    /**
     * Determine whether $parent depends on $child, near or deep
     */
    function dependsOn(PEAR2_Pyrus_IPackageFile $parent, PEAR2_Pyrus_IPackageFile $child)
    {
        $c = array();
        return $this->_dependsOn($parent, $child, $c);
    }

    function _dependsOn($parent, $child, &$checked)
    {
        $data = $this->_getDepDB();
        $channel = $parent->channel;
        $package = strtolower($parent->name);

        $depchannel = $child->channel;
        $deppackage = strtolower($child->name);

        if (isset($checked[$channel][$package][$depchannel][$deppackage])) {
            return false; // avoid endless recursion
        }

        $checked[$channel][$package][$depchannel][$deppackage] = true;
        if (!isset($data['dependencies'][$channel][$package])) {
            return false;
        }

        foreach ($data['dependencies'][$channel][$package] as $info) {
            if (isset($info['dep']['uri'])) {
                if ($info['dep']['uri'] === $child->uri) {
                    return true;
                }
                return false;
            }

            if (strtolower($info['dep']['channel']) == $depchannel &&
                  strtolower($info['dep']['name']) == $deppackage) {
                return true;
            }
        }

        foreach ($data['dependencies'][$channel][$package] as $info) {
            if (isset($info['dep']['uri'])) {
                if ($this->_dependsOn(array(
                        'uri' => $info['dep']['uri'],
                        'package' => $info['dep']['name']), $child, $checked)) {
                    return true;
                }
            } else {
                if ($this->_dependsOn(array(
                        'channel' => $info['dep']['channel'],
                        'package' => $info['dep']['name']), $child, $checked)) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Register dependencies of a package that is being installed or upgraded
     */
    function installPackage(PEAR2_Pyrus_IPackageFile $package)
    {
        $data = $this->_getDepDB();
        $this->_setPackageDeps($data, $package);
        $this->_writeDepDB($data);
    }

    /**
     * Remove dependencies of a package that is being uninstalled, or upgraded.
     *
     * Upgraded packages first uninstall, then install
     */
    function uninstallPackage($channel, $package)
    {
        $package = strtolower($package);
        $data = $this->_getDepDB();

        if (!isset($data['dependencies'][$channel][$package])) {
            return true;
        }

        foreach ($data['dependencies'][$channel][$package] as $dep) {
            $found      = false;
            $depchannel = isset($dep['dep']['uri']) ? '__uri' : strtolower($dep['dep']['channel']);
            $depname    = strtolower($dep['dep']['name']);
            if (isset($data['packages'][$depchannel][$depname])) {
                foreach ($data['packages'][$depchannel][$depname] as $i => $info) {
                    if ($info['channel'] == $channel && $info['package'] == $package) {
                        $found = true;
                        break;
                    }
                }
            }

            if ($found) {
                unset($data['packages'][$depchannel][$depname][$i]);
                if (!count($data['packages'][$depchannel][$depname])) {
                    unset($data['packages'][$depchannel][$depname]);
                    if (!count($data['packages'][$depchannel])) {
                        unset($data['packages'][$depchannel]);
                    }
                } else {
                    $data['packages'][$depchannel][$depname] =
                        array_values($data['packages'][$depchannel][$depname]);
                }
            }
        }

        unset($data['dependencies'][$channel][$package]);
        if (!count($data['dependencies'][$channel])) {
            unset($data['dependencies'][$channel]);
        }

        if (!count($data['dependencies'])) {
            unset($data['dependencies']);
        }

        if (!count($data['packages'])) {
            unset($data['packages']);
        }

        $this->_writeDepDB($data);
    }

    /**
     * Rebuild the dependency DB by reading registry entries.
     */
    function rebuildDB()
    {
        $depdb = array('_version' => $this->_version);
        if (!$this->hasWriteAccess()) {
            // allow startup for read-only with older Registry
            return $depdb;
        }
        $reg = PEAR2_Pyrus_Config::current()->registry;

        foreach (PEAR2_Pyrus_Config::current()->channelregistry as $channel) {
            foreach ($reg->listPackages($channel->name) as $package) {
                $this->_setPackageDeps($depdb, $package);
            }
        }

        $this->_writeDepDB($depdb);
    }

    /**
     * Register usage of the dependency DB to prevent race conditions
     * @param int one of the LOCK_* constants
     */
    private function _lock($mode = LOCK_EX)
    {
        if (stristr(php_uname(), 'Windows 9')) {
            return;
        }

        if ($mode != LOCK_UN && is_resource($this->_lockFp)) {
            // XXX does not check type of lock (LOCK_SH/LOCK_EX)
            return;
        }

        $open_mode = 'w';
        // XXX People reported problems with LOCK_SH and 'w'
        if ($mode === LOCK_SH) {
            if (!file_exists($this->_lockfile)) {
                touch($this->_lockfile);
            } elseif (!is_file($this->_lockfile)) {
                throw new PEAR2_Pyrus_Registry_Exception('could not create Dependency lock file, ' .
                    'it exists and is not a regular file');
            }
            $open_mode = 'r';
        }

        if (!is_resource($this->_lockFp)) {
            $this->_lockFp = @fopen($this->_lockfile, $open_mode);
        }

        if (!is_resource($this->_lockFp)) {
            throw new PEAR2_Pyrus_Registry_Exception("could not create Dependency lock file" .
                                     (isset($php_errormsg) ? ": " . $php_errormsg : ""));
        }

        if (!(int)flock($this->_lockFp, $mode)) {
            switch ($mode) {
                case LOCK_SH: $str = 'shared';    break;
                case LOCK_EX: $str = 'exclusive'; break;
                case LOCK_UN: $str = 'unlock';    break;
                default:      $str = 'unknown';   break;
            }

            throw new PEAR2_Pyrus_Registry_Exception("could not acquire $str lock ($this->_lockfile)");
        }
    }

    /**
     * Release usage of dependency DB
     * @access private
     */
    function _unlock()
    {
        $this->_lock(LOCK_UN);
        if (is_resource($this->_lockFp)) {
            fclose($this->_lockFp);
        }
        $this->_lockFp = null;
    }

    /**
     * Load the dependency database from disk
     * @return array
     */
    function _getDepDB()
    {
        if (!$this->hasWriteAccess()) {
            return array('_version' => $this->_version);
        }

        if (!file_exists($this->_depdb)) {
            return array('_version' => $this->_version);
        }

        if (!$fp = fopen($this->_depdb, 'r')) {
            throw new PEAR2_Pyrus_Registry_Exception("Could not open dependencies file `" .
                                                     $this->_depdb . "'");
        }

        $rt = get_magic_quotes_runtime();
        set_magic_quotes_runtime(0);
        clearstatcache();
        fclose($fp);
        $data = unserialize(file_get_contents($this->_depdb));
        set_magic_quotes_runtime($rt);
        return $data;
    }

    /**
     * Write out the dependency database to disk
     * @param array the database
     * @return true|PEAR_Error
     * @access private
     */
    function _writeDepDB($deps)
    {
        $this->_lock(LOCK_EX);

        if (!$fp = fopen($this->_depdb, 'wb')) {
            $this->_unlock();
            throw new PEAR2_Pyrus_Registry_Exception("Could not open dependencies file `" .
                                                     $this->_depdb . "' for writing");
        }

        $rt = get_magic_quotes_runtime();
        set_magic_quotes_runtime(0);
        fwrite($fp, serialize($deps));
        set_magic_quotes_runtime($rt);
        fclose($fp);
        $this->_unlock();
    }

    /**
     * Register all dependencies from a package in the dependencies database, in essence
     * "installing" the package's dependency information
     * @param array the database
     * @param PEAR_PackageFile_v1|PEAR_PackageFile_v2
     * @access private
     */
    function _setPackageDeps(&$data, PEAR2_Pyrus_IPackageFile $pkg)
    {
        $deps = $pkg->rawdeps;

        if (!$deps) {
            return;
        }

        if (!is_array($data)) {
            $data = array();
        }

        if (!isset($data['dependencies'])) {
            $data['dependencies'] = array();
        }

        $channel = $pkg->channel;
        $package = strtolower($pkg->name);

        if (!isset($data['dependencies'][$channel])) {
            $data['dependencies'][$channel] = array();
        }

        $data['dependencies'][$channel][$package] = array();
        if (isset($deps['required']['package'])) {
            if (!isset($deps['required']['package'][0])) {
                $deps['required']['package'] = array($deps['required']['package']);
            }

            foreach ($deps['required']['package'] as $dep) {
                $this->_registerDep($data, $pkg, $dep, 'required');
            }
        }

        if (isset($deps['optional']['package'])) {
            if (!isset($deps['optional']['package'][0])) {
                $deps['optional']['package'] = array($deps['optional']['package']);
            }

            foreach ($deps['optional']['package'] as $dep) {
                $this->_registerDep($data, $pkg, $dep, 'optional');
            }
        }

        if (isset($deps['required']['subpackage'])) {
            if (!isset($deps['required']['subpackage'][0])) {
                $deps['required']['subpackage'] = array($deps['required']['subpackage']);
            }

            foreach ($deps['required']['subpackage'] as $dep) {
                $this->_registerDep($data, $pkg, $dep, 'required');
            }
        }

        if (isset($deps['optional']['subpackage'])) {
            if (!isset($deps['optional']['subpackage'][0])) {
                $deps['optional']['subpackage'] = array($deps['optional']['subpackage']);
            }

            foreach ($deps['optional']['subpackage'] as $dep) {
                $this->_registerDep($data, $pkg, $dep, 'optional');
            }
        }

        if (isset($deps['group'])) {
            if (!isset($deps['group'][0])) {
                $deps['group'] = array($deps['group']);
            }

            foreach ($deps['group'] as $group) {
                if (isset($group['package'])) {
                    if (!isset($group['package'][0])) {
                        $group['package'] = array($group['package']);
                    }

                    foreach ($group['package'] as $dep) {
                        $this->_registerDep($data, $pkg, $dep, 'optional',
                            $group['attribs']['name']);
                    }
                }

                if (isset($group['subpackage'])) {
                    if (!isset($group['subpackage'][0])) {
                        $group['subpackage'] = array($group['subpackage']);
                    }

                    foreach ($group['subpackage'] as $dep) {
                        $this->_registerDep($data, $pkg, $dep, 'optional',
                            $group['attribs']['name']);
                    }
                }
            }
        }

        if ($data['dependencies'][$channel][$package] == array()) {
            unset($data['dependencies'][$channel][$package]);
            if (!count($data['dependencies'][$channel])) {
                unset($data['dependencies'][$channel]);
            }
        }
    }

    /**
     * @param array the database
     * @param PEAR2_Pyrus_IPackageFile
     * @param array the specific dependency
     * @param required|optional whether this is a required or an optional dep
     * @param string|false dependency group this dependency is from, or false for ordinary dep
     */
    function _registerDep(&$data, PEAR2_Pyrus_IPackageFile $pkg, $dep, $type, $group = false)
    {
        $info = array(
            'dep'   => $dep,
            'type'  => $type,
            'group' => $group
        );

        if (isset($dep['name'])) {
            $dep['name'] = strtolower($dep['name']);
        }
        $depchannel = isset($dep['channel']) ? $dep['channel'] : '__uri';
        if (!isset($data['dependencies'])) {
            $data['dependencies'] = array();
        }

        $channel = $pkg->channel;
        $package = strtolower($pkg->name);

        if (!isset($data['dependencies'][$channel])) {
            $data['dependencies'][$channel] = array();
        }

        if (!isset($data['dependencies'][$channel][$package])) {
            $data['dependencies'][$channel][$package] = array();
        }

        $data['dependencies'][$channel][$package][] = $info;
        if (isset($data['packages'][$depchannel][$dep['name']])) {
            $found = false;
            foreach ($data['packages'][$depchannel][$dep['name']] as $i => $p) {
                if ($p['channel'] == $channel && $p['package'] == $package) {
                    $found = true;
                    break;
                }
            }

            if (!$found) {
                $data['packages'][$depchannel][$dep['name']][] = array(
                    'channel' => $channel,
                    'package' => $package
                );
            }
        } else {
            if (!isset($data['packages'])) {
                $data['packages'] = array();
            }

            if (!isset($data['packages'][$depchannel])) {
                $data['packages'][$depchannel] = array();
            }

            if (!isset($data['packages'][$depchannel][$dep['name']])) {
                $data['packages'][$depchannel][$dep['name']] = array();
            }

            $data['packages'][$depchannel][$dep['name']][] = array(
                'channel' => $channel,
                'package' => $package
            );
        }
    }
}<?php
/**
 * PEAR2_Pyrus_Registry_Pear1_Package
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Package within the PEAR 1.x registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Pear1_Package extends PEAR2_Pyrus_Registry_Package_Base
{
    function fromPackageFile(PEAR2_Pyrus_IPackageFile $package)
    {
        PEAR2_Pyrus_PackageFile_v2::fromPackageFile($package);
        if (isset($this->packageInfo['contents']['dir']['attribs']['baseinstalldir'])) {
            $this->baseinstalldirs = array('/' => $this->packageInfo['contents']['dir']['attribs']['baseinstalldir']);
        }
    }
}<?php
/**
 * PEAR2_Pyrus_Registry_Sqlite3_Creator
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Initialize a sqlite3 registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Sqlite3_Creator
{
    /**
     * Initialize the database for the registry
     *
     * Registry information that must be stored:
     *
     * - A list of installed packages
     * - the files in each package
     * - known channels
     */
    function create(SQLite3 $database)
    {
        if (!@$database->exec('BEGIN')) {
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE packages (
           name TEXT(80) NOT NULL,
           channel TEXT(255) NOT NULL,
           version TEXT(20) NOT NULL,
           apiversion TEXT(20) NOT NULL,
           summary TEXT NOT NULL,
           description TEXT NOT NULL,
           stability TEXT(8) NOT NULL,
           apistability TEXT(8) NOT NULL,
           releasedate DATE NOT NULL,
           releasetime TIME,
           license TEXT(50) NOT NULL,
           licenseuri TEXT,
           licensepath TEXT,
           releasenotes TEXT,
           lastinstalledversion TEXT(20),
           installedwithpear TEXT(20),
           installtimeconfig TEXT(50),
           PRIMARY KEY (name, channel)
          );';
        $worked = $database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE configureoptions (
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           name TEXT(255) NOT NULL,
           prompt TEXT(255) NOT NULL,
           defaultValue TEXT(255),
           PRIMARY KEY (packages_name, packages_channel, name)
          );';
        $worked = $database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE maintainers (
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           role TEXT(11) NOT NULL,
           name TEXT(200) NOT NULL,
           user TEXT(20) NOT NULL,
           email TEXT(100) NOT NULL,
           active CHAR(3) NOT NULL,
           PRIMARY KEY (packages_name, packages_channel, user)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        // configpath is absolute path to role directory
        // relativepath is relative to role directory
        // packagepath is absolute path to full file path
        // this makes moving the database simple, just reconstruct packagepath from
        // the file role + the relative path
        $query = '
          CREATE TABLE files (
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           configpath TEXT(255) NOT NULL,
           packagepath TEXT(255) NOT NULL,
           role TEXT(30) NOT NULL,
           relativepath TEXT(255) NOT NULL,
           origpath TEXT(255) NOT NULL,
           baseinstalldir TEXT(255),
           tasks TEXT NOT NULL,
           PRIMARY KEY (packagepath, role),
           UNIQUE (packages_name, packages_channel, origpath)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE baseinstalldirs (
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           dirname TEXT(255) NOT NULL,
           baseinstall TEXT(255) NOT NULL,
           PRIMARY KEY (packages_name, packages_channel, dirname)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
            CREATE TABLE dep_groups (
             packages_name TEXT(80) NOT NULL,
             packages_channel TEXT(255) NOT NULL,
             groupname TEXT(80) NOT NULL,
             grouphint TEXT(255) NOT NULL,
             PRIMARY KEY (packages_name, packages_channel, groupname)
            );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE compatible_releases (
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           compat_package TEXT(80) NOT NULL,
           compat_channel TEXT(255) NOT NULL,
           min TEXT(20) NOT NULL,
           max TEXT(20) NOT NULL,
           PRIMARY KEY (packages_name, packages_channel, compat_package, compat_channel)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE compatible_releases_exclude (
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           compat_package TEXT(80) NOT NULL,
           compat_channel TEXT(255) NOT NULL,
           exclude TEXT(20) NOT NULL,
           PRIMARY KEY (packages_name, packages_channel, compat_package, compat_channel, exclude)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE extension_dependencies (
           required BOOL NOT NULL,
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           extension TEXT(80) NOT NULL,
           conflicts BOOL NOT NULL,
           min TEXT(20),
           max TEXT(20),
           recommended TEXT(20),
           groupname TEXT(80),
           PRIMARY KEY (required, packages_name, packages_channel, extension, groupname)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE extension_dependencies_exclude (
           required BOOL NOT NULL,
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           extension TEXT(80) NOT NULL,
           conflicts BOOL NOT NULL,
           exclude TEXT(20) NOT NULL,
           groupname TEXT(80),
           PRIMARY KEY (required, packages_name, packages_channel, extension,
                exclude, groupname)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE package_dependencies (
           required BOOL NOT NULL,
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           deppackage TEXT(80) NOT NULL,
           depchannel TEXT(255) NOT NULL,
           conflicts BOOL NOT NULL,
           min TEXT(20),
           max TEXT(20),
           recommended TEXT(20),
           is_subpackage BOOL NOT NULL,
           groupname TEXT(80),
           providesextension TEXT(80),
           PRIMARY KEY (required, packages_name, packages_channel, deppackage,
                depchannel, is_subpackage, groupname)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE package_dependencies_exclude (
           required BOOL NOT NULL,
           packages_name TEXT(80) NOT NULL,
           packages_channel TEXT(255) NOT NULL,
           deppackage TEXT(80) NOT NULL,
           depchannel TEXT(255) NOT NULL,
           conflicts BOOL NOT NULL,
           exclude TEXT(20) NOT NULL,
           is_subpackage BOOL NOT NULL,
           groupname TEXT(80),
           PRIMARY KEY (required, packages_name, packages_channel, deppackage, depchannel,
                exclude, is_subpackage, groupname)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
            CREATE TABLE os_dependencies (
             packages_name TEXT(80) NOT NULL,
             packages_channel TEXT(255) NOT NULL,
             osname TEXT(80),
             conflicts BOOL,
             PRIMARY KEY (packages_name, packages_channel, osname)
            )';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
            CREATE TABLE arch_dependencies (
             packages_name TEXT(80) NOT NULL,
             packages_channel TEXT(255) NOT NULL,
             pattern TEXT(80),
             conflicts BOOL,
             PRIMARY KEY (packages_name, packages_channel, pattern)
            )';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
            CREATE TABLE php_dependencies (
             packages_name TEXT(80) NOT NULL,
             packages_channel TEXT(255) NOT NULL,
             min TEXT(20),
             max TEXT(20),
             PRIMARY KEY (packages_name, packages_channel)
            )';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
             CREATE TABLE php_dependencies_exclude (
              packages_name TEXT(80) NOT NULL,
              packages_channel TEXT(255) NOT NULL,
              exclude TEXT(20) NOT NULL,
              PRIMARY KEY (packages_name, packages_channel, exclude)
             )';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
            CREATE TABLE pearinstaller_dependencies (
             packages_name TEXT(80) NOT NULL,
             packages_channel TEXT(255) NOT NULL,
             min TEXT(20),
             max TEXT(20),
             PRIMARY KEY (packages_name, packages_channel)
            )';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
             CREATE TABLE pearinstaller_dependencies_exclude (
              packages_name TEXT(80) NOT NULL,
              packages_channel TEXT(255) NOT NULL,
              exclude TEXT(20) NOT NULL,
              PRIMARY KEY (packages_name, packages_channel, exclude)
             )';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE channels (
           channel TEXT NOT NULL,
           summary TEXT NOT NULL,
           suggestedalias TEXT(50) NOT NULL,
           alias TEXT(50) NOT NULL,
           validatepackageversion TEXT(20) NOT NULL default "default",
           validatepackage NOT NULL default "PEAR_Validate",
           lastmodified TEXT,
           PRIMARY KEY (channel),
           UNIQUE(alias)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE channel_servers (
           channel TEXT NOT NULL,
           server TEXT NOT NULL,
           ssl integer NOT NULL default 0,
           port integer NOT NULL default 80,
           PRIMARY KEY (channel, server)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE channel_server_rest (
           channel TEXT NOT NULL,
           server TEXT NOT NULL,
           type TEXT NOT NULL,
           baseurl TEXT NOT NULL,
           PRIMARY KEY (channel, server, baseurl, type)
          );';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TABLE pearregistryversion (
           version TEXT(20) NOT NULL
          );

          INSERT INTO pearregistryversion VALUES("1.0.0");
        ';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
            CREATE TRIGGER package_delete DELETE ON packages
              FOR EACH ROW BEGIN
                DELETE FROM maintainers
                WHERE
                  maintainers.packages_name = old.name AND
                  maintainers.packages_channel = old.channel;
                DELETE FROM files
                WHERE
                  files.packages_name = old.name AND
                  files.packages_channel = old.channel;
                DELETE FROM baseinstalldirs
                WHERE
                  baseinstalldirs.packages_name = old.name AND
                  baseinstalldirs.packages_channel = old.channel;
                DELETE FROM package_dependencies
                WHERE
                  package_dependencies.packages_name = old.name AND
                  package_dependencies.packages_channel = old.channel;
                DELETE FROM package_dependencies_exclude
                WHERE
                  package_dependencies_exclude.packages_name = old.name AND
                  package_dependencies_exclude.packages_channel = old.channel;
                DELETE FROM os_dependencies
                WHERE
                  os_dependencies.packages_name = old.name AND
                  os_dependencies.packages_channel = old.channel;
                DELETE FROM arch_dependencies
                WHERE
                  arch_dependencies.packages_name = old.name AND
                  arch_dependencies.packages_channel = old.channel;
                DELETE FROM php_dependencies
                WHERE
                  php_dependencies.packages_name = old.name AND
                  php_dependencies.packages_channel = old.channel;
                DELETE FROM php_dependencies_exclude
                WHERE
                  php_dependencies_exclude.packages_name = old.name AND
                  php_dependencies_exclude.packages_channel = old.channel;
                DELETE FROM pearinstaller_dependencies
                WHERE
                  pearinstaller_dependencies.packages_name = old.name AND
                  pearinstaller_dependencies.packages_channel = old.channel;
                DELETE FROM pearinstaller_dependencies_exclude
                WHERE
                  pearinstaller_dependencies_exclude.packages_name = old.name AND
                  pearinstaller_dependencies_exclude.packages_channel = old.channel;
                DELETE FROM extension_dependencies
                WHERE
                  extension_dependencies.packages_name = old.name AND
                  extension_dependencies.packages_channel = old.channel;
                DELETE FROM extension_dependencies_exclude
                WHERE
                  extension_dependencies_exclude.packages_name = old.name AND
                  extension_dependencies_exclude.packages_channel = old.channel;
                DELETE FROM dep_groups
                WHERE
                  dep_groups.packages_name = old.name AND
                  dep_groups.packages_channel = old.channel;
              END;
        ';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
            CREATE TRIGGER channel_check BEFORE DELETE ON channels
            BEGIN
             SELECT RAISE(ROLLBACK, \'Cannot delete channel, installed packages use it\')
             WHERE old.channel IN (SELECT channel FROM packages);
            END;';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE TRIGGER channel_delete DELETE ON channels
            FOR EACH ROW BEGIN
              DELETE FROM channel_servers
              WHERE
                channel_servers.channel = old.channel;
              DELETE FROM channel_server_rest
              WHERE
                channel_server_rest.channel = old.channel;
            END;
        ';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE VIEW deps AS
            SELECT
                packages_name,
                packages_channel
                deppackage,
                depchannel,
                null as exclude,
                conflicts,
                min,
                max
            FROM package_dependencies
            UNION
            SELECT
                packages_name,
                packages_channel
                deppackage,
                depchannel,
                exclude,
                conflicts,
                null as min,
                null as max
            FROM package_dependencies_exclude
        ';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }

        $query = '
          CREATE VIEW protocols AS
            SELECT
                channel,
                server,
                baseurl as function,
                type as version,
                "rest" as protocol
            FROM channel_server_rest
        ';
        $worked = @$database->exec($query);
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }
        $worked = @$database->exec('COMMIT');
        if (!$worked) {
            @$database->exec('ROLLBACK');
            $error = $database->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot initialize SQLite3 registry: ' . $error);
        }
    }
}
<?php
/**
 * PEAR2_Pyrus_Registry_Sqlite3_Package
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Package within the sqlite3 registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Sqlite3_Package extends PEAR2_Pyrus_Registry_Package_Base
{
    public $dirty = false;

    function __set($var, $value)
    {
        if (!isset($this->packagename)) {
            throw new PEAR2_Pyrus_Registry_Exception('Attempt to retrieve ' . $var .
                ' from unknown package');
        }
        PEAR2_Pyrus_PackageFile_v2::__set($var, $value);
        // occasionally, this next line will result in failure to install when incomplete data is there,
        // so we silently skip the save, and mark the packagefile as dirty
        try {
            $this->reg->replace($this);
            $this->dirty = false;
        } catch (PEAR2_Pyrus_Registry_Exception $e) {
            $this->dirty = true;
        }
    }
}<?php
/**
 * PEAR2_Pyrus_Registry_Xml_Package
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Package within the xml registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Xml_Package extends PEAR2_Pyrus_Registry_Package_Base
{
}<?php
/**
 * PEAR2_Pyrus_Registry_Base
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for a Pyrus Registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
abstract class PEAR2_Pyrus_Registry_Base implements PEAR2_Pyrus_IRegistry
{
    protected $packagename;
    protected $packageList = array();

    /**
     * Used by the registry package classes to update info in an installed package
     */
    public function replace(PEAR2_Pyrus_IPackageFile $info)
    {
        return $this->install($info, true);
    }

    function cloneRegistry(PEAR2_Pyrus_Registry_Base $registry)
    {
        try {
            $packageiterator = $registry->package;
            foreach (PEAR2_Pyrus_Config::current()->channelregistry->listChannels() as $channel) {
                $packageiterator->setIteratorChannel($channel);
                foreach ($packageiterator as $package) {
                    if ($this->exists($package->name, $package->channel)) {
                        $old = $this->toPackageFile($package->name, $package->channel);
                        if ($old->date == $package->date && $old->time == $package->time) {
                            continue;
                        }
                    }
                    $this->replace($package);
                }
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot clone registry', $e);
        }
    }
}
<?php
/**
 * PEAR2_Pyrus_Registry_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus Registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Exception extends PEAR2_Exception {}
<?php
/**
 * PEAR2_Pyrus_Registry_Pear1
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Helgi ﬁormar ﬁorbjˆrnsson <dufuz@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/PEAR2/Pyrus
 */

/**
 * This is the central registry, that is used for all installer options,
 * stored in .reg files for PEAR 1 compatibility
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Helgi ﬁormar ﬁorbjˆrnsson <dufuz@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/PEAR2/Pyrus
 */
class PEAR2_Pyrus_Registry_Pear1 extends PEAR2_Pyrus_Registry_Base
{
    static public $dependencyDBClass = 'PEAR2_Pyrus_Registry_Pear1_DependencyDB';
    protected $_path;
    protected $filemap;

    function __construct($path)
    {
        if (!file_exists($path . '/.registry') && basename($path) !== 'php') {
            $path = $path . DIRECTORY_SEPARATOR . 'php';
        }
        $this->_path = $path;
        $this->filemap = $this->_path . DIRECTORY_SEPARATOR . '.filemap';
    }

    protected function rebuildFileMap()
    {
        $config = PEAR2_Pyrus_Config::current();
        $channels = array();
        foreach ($config->channelregistry as $channel) {
            $channels[$channel->name] = $this->listPackages($channel->name);
        }
        $files = array();
        foreach (PEAR2_Pyrus_Installer_Role::getValidRoles('php') as $role) {
            // set up a list of file role => configuration variable
            // for storing in the registry
            $roles[$role] =
                PEAR2_Pyrus_Installer_Role::factory('php', $role)->getLocationConfig();
        }
        foreach (PEAR2_Pyrus_Installer_Role::getValidRoles('extsrc') as $role) {
            // set up a list of file role => configuration variable
            // for storing in the registry
            if (isset($roles[$role])) {
                continue;
            }
            $roles[$role] =
                PEAR2_Pyrus_Installer_Role::factory('extsrc', $role)->getLocationConfig();
        }
        foreach ($channels as $channel => $packages) {
            foreach ($packages as $package) {
                foreach ($this->info($package, $channel, 'installedfiles') as $name => $attrs) {

                    $name = str_replace($config->{$roles[$attrs['role']]}, '', $name);
                    $file = str_replace('\\', '/', $name);

                    $file = preg_replace(',^/+,', '', $file);
                    if (!isset($files[$attrs['role']])) {
                        $files[$attrs['role']] = array();
                    }
                    if ($channel != 'pear.php.net') {
                        $files[$attrs['role']][$file] = array($channel,
                            strtolower($package));
                    } else {
                        $files[$attrs['role']][$file] = strtolower($package);
                    }
                }
            }
        }

        if (!@is_dir(dirname($this->filemap))) {
            mkdir(dirname($this->filemap), 0755, true);
        }
        $fp = fopen($this->filemap, 'wb');
        if (!$fp) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot write out Pear1 filemap');
        }

        fwrite($fp, serialize($files));
        fclose($fp);
    }

    protected function readFileMap()
    {
        if (!file_exists($this->filemap)) {
            return array();
        }

        $fp = @fopen($this->filemap, 'r');
        if (!$fp) {
            throw new PEAR2_Pyrus_Registry_Exception('Could not open Pear1 registry filemap "' . $this->filemap . '"');
        }

        clearstatcache();
        $rt = get_magic_quotes_runtime();
        set_magic_quotes_runtime(0);
        $fsize = filesize($this->filemap);
        $data = stream_get_contents($fp);
        fclose($fp);
        set_magic_quotes_runtime($rt);
        $tmp = unserialize($data);
        if (!$tmp && $fsize > 7) {
            throw new PEAR2_Pyrus_Registry_Exception('Invalid Pear1 registry filemap data');
        }
        return $tmp;
    }

    private function _nameRegistryPath(PEAR2_Pyrus_IPackageFile $info = null,
                                     $channel = null, $package = null, $version = null)
    {
        $channel = $info !== null ? $info->channel : $channel;
        $package = $info !== null ? $info->name    : $package;
        $path = $this->_namePath($channel, $package);
        return $path . '.reg';
    }

    private function _namePath($channel, $package)
    {
        if ($channel == 'pear.php.net') {
            $channel = '';
        } else {
            $channel = '.channel.' . strtolower($channel) . DIRECTORY_SEPARATOR;
        }

        return $this->_path . DIRECTORY_SEPARATOR .
            '.registry' . DIRECTORY_SEPARATOR . $channel . strtolower($package);
    }

    /**
     * Create the .registry/package.reg or file
     *
     * @param PEAR2_Pyrus_IPackageFile $pf
     */
    function install(PEAR2_Pyrus_IPackageFile $info, $replace = false)
    {
        $packagefile = $this->_nameRegistryPath($info);
        if (!@is_dir(dirname($packagefile))) {
            mkdir(dirname($packagefile), 0755, true);
        }

        if (!$replace) {
            $info->date = date('Y-m-d');
            $info->time = date('H:i:s');
        }

        $arr = $info->toArray();
        $arr = $arr['package'];
        $arr['old']['version'] = $info->version['release'];
        $arr['old']['release_date'] = $info->date;
        $arr['old']['release_state'] = $info->state;
        $license = $info->license['name'];
        $arr['old']['release_license'] = $license;
        $arr['old']['release_notes'] = $info->notes;
        $deps = array();
        $deps[] = array_merge(array('type' => 'php'), $info->dependencies['required']->php->getInfo());
        $map = array(
            'php' => 'php',
            'package' => 'pkg',
            'subpackage' => 'pkg',
            'extension' => 'ext',
            'os' => 'os',
            'pearinstaller' => 'pkg',
            );
        foreach (array('package', 'subpackage', 'extension') as $dtype) {
            foreach (array('required', 'optional') as $optorrequired) {
                $optional = ($optorrequired == 'optional');
                foreach ($info->dependencies['required']->package as $dep) {
                    $s = array('type' => $map[$dtype]);
                    if (isset($dep->channel)) {
                        $s['channel'] = $dep->channel;
                    }
                    if (isset($dep->uri)) {
                        $s['uri'] = $dep->uri;
                    }
                    if (isset($dep->name)) {
                        $s['name'] = $dep->name;
                    }
                    if ($dep->conflicts) {
                        $s['rel'] = 'not';
                    } else {
                        if (!isset($dep->min) &&
                              !isset($dep->max)) {
                            $s['rel'] = 'has';
                            $s['optional'] = $optional;
                        } elseif (isset($dep->min) &&
                              isset($dep->max)) {
                            $s['rel'] = 'ge';
                            $s1 = $s;
                            $s1['rel'] = 'le';
                            $s['version'] = $dep->min;
                            $s1['version'] = $dep->max;
                            if (isset($dep->channel)) {
                                $s1['channel'] = $dep->channel;
                            }
                            $s['name'] = $dep->name;
                            $s1['name'] = $dep->name;
                            $s['optional'] = $optional;
                            $s1['optional'] = $optional;
                            $deps[] = $s1;
                        } elseif (isset($dep->min)) {
                            $s['rel'] = 'ge';
                            if (isset($dep->exclude)) {
                                foreach ($dep->exclude as $exclude) {
                                    if ($exclude == $dep->min) {
                                        $s['rel'] = 'gt';
                                        break;
                                    }
                                }
                            }
                            $s['version'] = $dep->min;
                            $s['optional'] = $optional;
                            $s['name'] = $dep->name;
                        } elseif (isset($dep->max)) {
                            $s['rel'] = 'le';
                            if (isset($dep->exclude)) {
                                foreach ($dep->exclude as $exclude) {
                                    if ($exclude == $dep->max) {
                                        $s['rel'] = 'lt';
                                        break;
                                    }
                                }
                            }
                            $s['version'] = $dep->max;
                            $s['optional'] = $optional;
                            $s['name'] = $dep->name;
                        }
                    }
                }
            }
        }
        $arr['old']['release_deps'] = $deps;
        $maintainers = $info->allmaintainers;
        $maint = array();
        foreach (array('lead', 'developer', 'contributor', 'helper') as $role) {
            foreach ($maintainers[$role] as $maintainer) {
                $m = $maintainer->getInfo();
                $m = array_merge(array('role' => $role), $m);
                $m['handle'] = $m['user'];
                unset($m['handle']);
                $maint[] = $m;
            }
        }
        $arr['filelist'] = $info->getFilelist();
        foreach (PEAR2_Pyrus_Installer_Role::getValidRoles($info->getPackageType()) as $role) {
            // set up a list of file role => configuration variable
            // for storing in the registry
            $roles[$role] =
                PEAR2_Pyrus_Installer_Role::factory($info->getPackageType(), $role);
        }
        $config = PEAR2_Pyrus_Config::current();
        $dirtree = array();
        foreach ($info->installcontents as $file) {
            $relativepath = $roles[$file->role]->getRelativeLocation($info, $file);
            if (!$relativepath) {
                continue;
            }
            $arr['filelist'][$file['attribs']['name']] = $arr['filelist'][$file['attribs']['name']]['attribs'];
            $installedas = $config->{$roles[$file->role]->getLocationConfig()} .
                DIRECTORY_SEPARATOR . $relativepath;
            $arr['filelist'][$file['attribs']['name']]['installed_as'] = $installedas;
            $len = strlen($installedas) - strlen($relativepath) - 2;
            do {
                $installedas = dirname($installedas);
                if (strlen($installedas) > $len) {
                    $dirtree[$installedas] = 1;
                }
            } while (strlen($installedas) > $len);
        }
        $arr['filelist']['dirtree'] = array_keys($dirtree);
        $arr['old']['maintainers'] = $maint;
        $arr['xsdversion'] = '2.0';
        $arr['_lastmodified'] = time();

        file_put_contents($packagefile, serialize($arr));
        $this->rebuildFileMap();
        $classname = self::$dependencyDBClass;
        $dep = new $classname($this->_path);
        $dep->installPackage($info);
    }

    function uninstall($package, $channel)
    {
        $packagefile = $this->_nameRegistryPath(null, $channel, $package);
        @unlink($packagefile);
        $classname = self::$dependencyDBClass;
        $dep = new $classname($this->_path);
        $dep->uninstallPackage($channel, $package);
        $this->rebuildFileMap();
    }

    public function exists($package, $channel)
    {
        $packagefile = $this->_nameRegistryPath(null, $channel, $package);
        return @file_exists($packagefile) && @!is_dir($packagefile);
    }

    public function info($package, $channel, $field)
    {
        if (!$this->exists($package, $channel)) {
            throw new PEAR2_Pyrus_Registry_Exception('Unknown package ' . $channel .
                '/' . $package);
        }

        $pf = $this->toPackageFile($package, $channel);

        if ($field === null) {
            return $pf;
        }

        if ($field == 'version') {
            $field = 'release-version';
        }
        if ($field == 'installedfiles' || $field == 'dirtree') {
            $packagefile = $this->_namePath($channel, $package) . '.reg';
            if (!$packagefile || !isset($packagefile[0])) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot find registry for package ' .
                    $channel . '/' . $package);
            }

            $packagecontents = file_get_contents($packagefile);
            $data = @unserialize($packagecontents);
            if ($data === false) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve package file object ' .
                    'for package ' . $channel . '/' . $package . ', PEAR 1.x registry file might be corrupt!');
            }
            if ($field == 'dirtree') {
                $ret = $data['filelist']['dirtree'];
                usort($ret, 'strnatcasecmp');
                return array_reverse($ret);
            }

            $roles = array();
            $configpaths = array();
            $config = PEAR2_Pyrus_Config::current();
            foreach (PEAR2_Pyrus_Installer_Role::getValidRoles($pf->getPackageType()) as $role) {
                // set up a list of file role => configuration variable
                // for storing in the registry
                $roles[$role] =
                    PEAR2_Pyrus_Installer_Role::factory($pf->getPackageType(), $role);
                $configpaths[$role] = $config->{$roles[$role]->getLocationConfig()};
            }
            $ret = array();
            foreach ($data['filelist'] as $file) {
                if (!isset($file['installed_as'])) {
                    continue;
                }
                if (0 !== strpos($file['installed_as'], $configpaths[$file['role']])) {
                    // this was installed with a different configuration, so don't guess
                    $file['relativepath'] = basename($file['installed_as']);
                    $file['configpath'] = dirname($file['installed_as']);
                } else {
                    $file['relativepath'] = substr($file['installed_as'], strlen($configpaths[$file['role']]) + 1);
                    $file['configpath'] = $configpaths[$file['role']];
                }
                $ret[$file['installed_as']] = $file;
            }
            return $ret;
        }
        return $pf->$field;
    }

    public function listPackages($channel)
    {
        $dir = $this->_namePath($channel, '');
        if (!@file_exists($dir)) {
            return array();
        }

        $ret = array();
        try {
            foreach (new DirectoryIterator($dir) as $file) {
                if ($file->isDot() || !$file->isFile()) continue;
                $a = @unserialize(file_get_contents($file->getPathName()));
                // $a['name'] is not set on v1 regs
                if ($a !== false && isset($a['name'])) {
                    $ret[] = $a['name'];
                } elseif ($a !== false && isset($a['package'])) {
                    $ret[] = $a['package'];
                } else {
                    PEAR2_Pyrus_Log::log(0, 'Warning: corrupted REG registry entry: ' .
                        $file->getPathName());
                }
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Registry_Exception('Could not open channel directory for ' .
                'channel ' . $channel, $e);
        }
        return $ret;
    }

    public function toPackageFile($package, $channel)
    {
        if (!$this->exists($package, $channel)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve package file object ' .
                'for package ' . $channel . '/' . $package . ', it is not installed');
        }

        $packagefile = $this->_nameRegistryPath(null, $channel, $package);
        if (!$packagefile) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot find registry for package ' .
                $channel . '/' . $package);
        }

        $contents = file_get_contents($packagefile);
        if (!$contents) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot find registry for package ' .
                $channel . '/' . $package);
        }

        $data = @unserialize($contents);
        if ($data === false) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve package file object ' .
                'for package ' . $channel . '/' . $package . ', PEAR 1.x registry file might be corrupt!');
        }

        if (isset($data['xsdversion']) && $data['xsdversion'] == '1.0'
            || !isset($data['attribs'])
            || isset($data['attribs']) && $data['attribs']['version'] == '1.0') {
            // make scrappy minimal package.xml we can use for dependencies/info
            $pf = new PEAR2_Pyrus_PackageFile_v2;
            $pf->name = $data['package'];
            $pf->channel = 'pear.php.net';
            $pf->version['release'] = $pf->version['api'] = $data['version'];
            $pf->stability['release'] = $pf->stability['api'] = $data['release_state'];
            $pf->notes = $data['release_notes'];
            $pf->license['name'] = $data['release_license'];
            $pf->date = $data['release_date'];
            foreach ($data['maintainers'] as $maintainer) {
                $pf->maintainer[$maintainer['handle']]->name($maintainer['name'])
                   ->active('yes')->role($maintainer['role'])->email($maintainer['email']);
            }
            // we don't care what the ancient package depends on, really, so make it valid
            // and forget about it
            $pf->dependencies['required']->php->min = phpversion();
            $pf->dependencies['required']->pearinstaller->min = '1.4.0';
            unset($data['filelist']['dirtree']);
            foreach ($data['filelist'] as $file => $info) {
                $pf->files[$file] = array('attribs' => $info);
            }
        } else {
            // create packagefile v2 here
            $pf = new PEAR2_Pyrus_PackageFile_v2;
            $pf->fromArray(array('package' => $data));
            $contents = $data['contents']['dir']['file'];
            if (!isset($contents[0])) {
                $contents = array($contents);
            }
            foreach ($contents as $file) {
                $pf->files[$file['attribs']['name']] = $file;
            }
        }
        return $pf;
    }

    public function __get($var)
    {
        if ($var == 'package') {
            return new PEAR2_Pyrus_Registry_Pear1_Package($this);
        }
    }

    public function getDependentPackages(PEAR2_Pyrus_IPackageFile $package)
    {
        $class = self::$dependencyDBClass;
        $dep = new $class($this->_path);
        $ret = $dep->getDependentPackages($package);
        foreach ($ret as $i => $package) {
            $ret[$i] = $this->package[$package['channel'] . '/' . $package['package']];
        }
        return $ret;
    }

    /**
     * Detect any files already installed that would be overwritten by
     * files inside the package represented by $package
     */
    public function detectFileConflicts(PEAR2_Pyrus_IPackageFile $package)
    {
        $filemap = $this->readFileMap();
        if (!$filemap) {
            return array();
        }

        // now iterate over each file in the package, and note all the conflicts
        $roles = array();
        foreach (PEAR2_Pyrus_Installer_Role::getValidRoles($package->getPackageType()) as $role) {
            // set up a list of file role => configuration variable
            // for storing in the registry
            $roles[$role] =
                PEAR2_Pyrus_Installer_Role::factory($package->getPackageType(), $role);
        }
        $ret = array();
        foreach ($package->installcontents as $file) {
            $relativepath = $roles[$file->role]->getRelativeLocation($package, $file);
            if (!$relativepath) {
                continue;
            }
            if (isset($filemap[$file->role][$relativepath])) {
                if (is_array($filemap[$file->role][$relativepath])) {
                    $ret[] = array($relativepath => $filemap[$file->role][$relativepath][0] . '/' .
                        $this->info($filemap[$file->role][$relativepath][1],
                                    $filemap[$file->role][$relativepath][0], 'name'));
                } else {
                    $ret[] = array($relativepath =>
                                   'pear.php.net/' . $this->info($filemap[$file->role][$relativepath],
                                                                 'pear.php.net',
                                                                 'name'));
                }
            }
        }
        return $ret;
    }

    /**
     * Returns a list of registries present in the PEAR installation at $path
     * @param string
     * @return array
     */
    static public function detectRegistries($path)
    {
        if (file_exists($path . '/.registry') || is_dir($path . '/.registry')) {
            return array('Pear1');
        }
        if (basename($path) !== 'php') {
            $path = $path . DIRECTORY_SEPARATOR . 'php';
        }
        if (file_exists($path . '/.registry') || is_dir($path . '/.registry')) {
            return array('Pear1');
        }
        return array();
    }

    /**
     * Completely remove all traces of a PEAR 1.x registry
     */
    static public function removeRegistry($path)
    {
        $path = $path . DIRECTORY_SEPARATOR . 'php';
        if (!file_exists($path . '/.registry')) {
            return;
        }
        try {
            PEAR2_Pyrus_AtomicFileTransaction::rmrf(realpath($path . DIRECTORY_SEPARATOR . '.xmlregistry'));
        } catch (PEAR2_Pyrus_AtomicFileTransaction_Exception $e) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot remove Pear1 registry: ' . $e->getMessage(), $e);
        }
        $errs = new PEAR2_MultiErrors;
        try {
            if (file_exists($path . '/.channels')) {
                PEAR2_Pyrus_AtomicFileTransaction::rmrf(realpath($path . DIRECTORY_SEPARATOR . '.channels'));
            }
        } catch (PEAR2_Pyrus_AtomicFileTransaction_Exception $e) {
            $errs->E_ERROR[] = new PEAR2_Pyrus_Registry_Exception('Cannot remove Pear1 registry: ' . $e->getMessage(), $e);
        }
        foreach (array('.filemap', '.lock', '.depdb', '.depdblock') as $file) {
            if (file_exists($path . DIRECTORY_SEPARATOR . $file)
                && !@unlink(realpath($path . DIRECTORY_SEPARATOR . $file))) {
                $errs->E_ERROR[] = new PEAR2_Pyrus_Registry_Exception(
                            'Cannot remove Pear1 registry: Unable to remove ' . $file);
            }
        }
        if (count($errs->E_ERROR)) {
            throw new PEAR2_Pyrus_Registry_Exception('Unable to remove Pear1 registry', $errs);
        }
    }
}
<?php
/**
 * PEAR2_Pyrus_Registry_Sqlite3
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * This is the central registry, that is used for all installer options,
 * stored as an SQLite3 database
 *
 * Registry information that must be stored:
 *
 * - A list of installed packages
 * - the files in each package
 * - known channels
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @author    Helgi √ûormar √ûorbj√∂rnsson <helgi@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Sqlite3 extends PEAR2_Pyrus_Registry_Base
{
    /**
     * The database resources, stored by path
     *
     * This allows singleton access to the database by separate objects
     * @var SQLite3
     */
    static protected $databases = array();
    private $_path;
    protected $readonly;

    /**
     * Initialize the registry
     *
     * @param unknown_type $path
     */
    function __construct($path, $readonly = false)
    {
        $this->readonly = $readonly;
        if ($path && $path != ':memory:') {
            if (dirname($path) . DIRECTORY_SEPARATOR . '.pear2registry' != $path) {
                $path = $path . DIRECTORY_SEPARATOR . '.pear2registry';
            }
        }
        $this->_init($path, $readonly);
        $this->_path = $path ? $path : ':memory:';
    }

    private function _init($path, $readonly)
    {
        if (!$path) {
            $path = ':memory:';
        }
    
        if (isset(static::$databases[$path]) && static::$databases[$path]) {
            return;
        }

        if (!file_exists(dirname($path))) {
            if ($readonly) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot create SQLite3 registry, registry is read-only');
            }
            @mkdir(dirname($path), 0755, true);
        }

        @(static::$databases[$path] = new SQLite3($path));
        // ScottMac needs to fix sqlite3 FIXME
        if (static::$databases[$path]->lastErrorCode()) {
            $error = static::$databases[$path]->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot open SQLite3 registry: ' . $error);
        }

        $sql = 'SELECT version FROM pearregistryversion';
        if (@static::$databases[$path]->querySingle($sql) == '1.0.0') {
            return;
        }

        if ($readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot create SQLite3 registry, registry is read-only');
        }

        $a = new PEAR2_Pyrus_Registry_Sqlite3_Creator;
        try {
            $a->create(static::$databases[$path]);
        } catch (Exception $e) {
            unset(static::$databases[$path]);
            $a = get_class($e);
            throw new $a('Database initialization failed', 0, $e);
        }
    }

    function getDatabase()
    {
        return $this->_path;
    }

    /**
     * Add an installed package to the registry
     *
     * @param PEAR2_Pyrus_IPackageFile $info
     */
    function install(PEAR2_Pyrus_IPackageFile $info, $replace = false)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot install package, registry is read-only');
        }

        if (!isset(static::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite3 registry for ' . $this->_path);
        }

        try {
            // this ensures upgrade will work
            static::$databases[$this->_path]->exec('BEGIN');
            $this->uninstall($info->name, $info->channel);
        } catch (Exception $e) {
            // ignore errors
        }

        if (!$replace) {
            $info = $info->toRaw();
            // this avoids potential exception on setting date/time
            // which can happen if $info is a registry package that
            // has been uninstalled
            $info->date = date('Y-m-d');
            $info->time = date('H:i:s');
        }

        $licloc = $info->license;
        $licuri = $info->license['uri'];
        $licpath = $info->license['path'];
        $time = ($info->time ? $info->time : null);

        $sql = '
            INSERT INTO packages
              (name, channel, version, apiversion, summary,
               description, stability, apistability, releasedate,
               releasetime, license, licenseuri, licensepath,
               releasenotes, lastinstalledversion, installedwithpear,
               installtimeconfig)
            VALUES(:name, :channel, :versionrelease, :versionapi, :summary,
                :description, :stabilityrelease, :stabilityapi, :date, :time,
                :license, :licenseuri, :licensepath, :notes, :lastinstalledv,
                :lastinstalledp, :lastinstalltime
            )';

        $stmt = static::$databases[$this->_path]->prepare($sql);
        // this odd code eliminates notices
        $n = $info->name;
        $stmt->bindParam(':name',              $n);
        $c = $info->channel;
        $stmt->bindParam(':channel',           $c);
        $rv = $info->version['release'];
        $stmt->bindParam(':versionrelease',    $rv);
        $av = $info->version['api'];
        $stmt->bindParam(':versionapi',        $av);
        $s = $info->summary;
        $stmt->bindParam(':summary',           $s);
        $d = $info->description;
        $stmt->bindParam(':description',       $d);
        $rs = $info->stability['release'];
        $stmt->bindParam(':stabilityrelease',  $rs);
        $ra = $info->stability['api'];
        $stmt->bindParam(':stabilityapi',      $ra);
        $a = $info->date;
        $stmt->bindParam(':date',              $a);
        $stmt->bindParam(':time',              $time);
        $lname = $info->license['name'];
        $stmt->bindParam(':license',           $lname);
        $stmt->bindParam(':licenseuri',        $licuri, ($licuri === null) ? SQLITE3_NULL : SQLITE3_TEXT);
        $stmt->bindParam(':licensepath',       $licpath, ($licpath === null) ? SQLITE3_NULL : SQLITE3_TEXT);
        $t = $info->notes;
        $stmt->bindParam(':notes',             $t);
        $o = null;
        $stmt->bindParam(':lastinstalledv',    $o, SQLITE3_NULL);
        $v = '2.0.0';
        $stmt->bindParam(':lastinstalledp',    $v);
        $configsnapshot = PEAR2_Pyrus_Config::configSnapshot();
        $stmt->bindParam(':lastinstalltime',   $configsnapshot);

        if (!@$stmt->execute()) {
            static::$databases[$this->_path]->exec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                $info->channel . '/' . $info->name . ' could not be installed in registry: ' . static::$databases[$this->_path]->lastErrorMsg());
        }
        $stmt->close();

        $sql = '
            INSERT INTO maintainers
              (packages_name, packages_channel, role, name, user, email, active)
            VALUES
                (:name, :channel, :role, :m_name, :m_user, :m_email, :m_active)';

        $stmt = static::$databases[$this->_path]->prepare($sql);
        $n = $info->name;
        $c = $info->channel;
        foreach ($info->allmaintainers as $role => $maintainers) {
            foreach ($maintainers as $maintainer) {
                $stmt->clear();
                $stmt->bindParam(':name',     $n);
                $stmt->bindParam(':channel',  $c);
                $stmt->bindParam(':role',     $role);
                $mn = $maintainer->name;
                $stmt->bindParam(':m_name',   $mn);
                $mu = $maintainer->user;
                $stmt->bindParam(':m_user',   $mu);
                $me = $maintainer->email;
                $stmt->bindParam(':m_email',  $me);
                $ma = $maintainer->active;
                $stmt->bindParam(':m_active', $ma);

                if (!@$stmt->execute()) {
                    static::$databases[$this->_path]->exec('ROLLBACK');
                    throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                        $info->channel . '/' . $info->name . ' could not be installed in registry');
                }
            }
        }
        $stmt->close();

        $curconfig = PEAR2_Pyrus_Config::current();
        $roles     = array();

        $sql = '
            INSERT INTO configureoptions
              (packages_name, packages_channel, name, prompt, defaultValue)
            VALUES(:name, :channel, :oname, :prompt, :default)';

        $stmt = static::$databases[$this->_path]->prepare($sql);

        $stmt->bindValue(':name',     $n);
        $stmt->bindValue(':channel',  $c);
        
        foreach ($info->configureoption as $option) {
            $stmt->bindValue(':oname', $option->name);
            $stmt->bindValue(':prompt', $option->prompt);
            if ($option->default === null) {
                $stmt->bindValue(':default', null, SQLITE3_NULL);
            } else {
                $stmt->bindValue(':default', $option->default);
            }
        }

        $sql = '
            INSERT INTO files
              (packages_name, packages_channel, packagepath, configpath, role,
               relativepath, origpath, baseinstalldir, tasks)
            VALUES(:name, :channel, :path, :configpath, :role, :relativepath, :origpath, :baseinstall, :tasks)';

        $stmt = static::$databases[$this->_path]->prepare($sql);

        $stmt->bindParam(':name',     $n);
        $stmt->bindParam(':channel',  $c);
        foreach (PEAR2_Pyrus_Installer_Role::getValidRoles($info->getPackageType()) as $role) {
            // set up a list of file role => configuration variable
            // for storing in the registry
            $roles[$role] =
                PEAR2_Pyrus_Installer_Role::factory($info->getPackageType(), $role);
        }

        foreach ($info->installcontents as $file) {
            $relativepath = $roles[$file->role]->getRelativeLocation($info, $file);
            if (!$relativepath) {
                continue;
            }

            $stmt->bindParam(':relativepath', $relativepath);
            $p = $curconfig->{$roles[$file->role]->getLocationConfig()};
            $stmt->bindParam(':configpath',         $p);
            $stmt->bindValue(':path', $p . DIRECTORY_SEPARATOR . $relativepath);
            $o = $file['attribs']['name'];
            $stmt->bindParam(':origpath',     $o);
            $r = $file->role;
            $stmt->bindParam(':role',         $r);
            $bi = $file->baseinstalldir;
            $stmt->bindParam(':baseinstall',  $bi);
            $stmt->bindValue(':tasks',        serialize($file->tasks));

            if (!@$stmt->execute()) {
                static::$databases[$this->_path]->exec('ROLLBACK');
                throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                    $info->channel . '/' . $info->name . ' could not be installed in registry');
            }
        }
        $stmt->close();

        $sql = '
            INSERT INTO baseinstalldirs
              (packages_name, packages_channel, dirname, baseinstall)
            VALUES(:name, :channel, :dirname, :baseinstall)';

        $stmt = static::$databases[$this->_path]->prepare($sql);

        foreach ($info->getBaseInstallDirs() as $dir => $base) {
            $stmt->bindParam(':name',        $n);
            $stmt->bindParam(':channel',     $c);
            $stmt->bindParam(':dirname',     $dir);
            $stmt->bindParam(':baseinstall', $base);

            if (!@$stmt->execute()) {
                static::$databases[$this->_path]->exec('ROLLBACK');
                throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                    $info->channel . '/' . $info->name . ' could not be installed in registry');
            }
        }
        $stmt->close();

        if (count($info->compatible)) {
            $sql = '
                INSERT INTO compatible_releases
                    (packages_name, packages_channel,
                     compat_package, compat_channel, min, max)
                VALUES
                    (:name, :channel, :cname, :cchannel, :min, :max)';
            $stmt = static::$databases[$this->_path]->prepare($sql);

            $stmt->bindValue(':name', $n);
            $stmt->bindValue(':channel', $c);

            $sql2 = '
                INSERT INTO compatible_releases_exclude
                    (packages_name, packages_channel,
                     compat_package, compat_channel, exclude)
                VALUES
                    (:name, :channel, :cname, :cchannel, :exclude)';
            $stmt2 = static::$databases[$this->_path]->prepare($sql2);

            $stmt2->bindValue(':name', $n);
            $stmt2->bindValue(':channel', $c);
            foreach ($info->compatible as $compatible) {
                $stmt->bindValue(':cname', $compatible->name);
                $stmt->bindValue(':cchannel', $compatible->channel);
                $stmt->bindValue(':min', $compatible->min);
                $stmt->bindValue(':max', $compatible->max);
                if (!@$stmt->execute()) {
                    static::$databases[$this->_path]->exec('ROLLBACK');
                    throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                        $info->channel . '/' . $info->name . ' could not be installed in registry');
                }
                if (isset($compatible->exclude)) {
                    $stmt2->bindValue(':cname', $compatible->name);
                    $stmt2->bindValue(':cchannel', $compatible->channel);
                    foreach ($compatible->exclude as $exclude) {
                        $stmt2->bindValue(':exclude', $exclude);
                        if (!@$stmt2->execute()) {
                            static::$databases[$this->_path]->exec('ROLLBACK');
                            throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                                $info->channel . '/' . $info->name . ' could not be installed in registry');
                        }
                    }
                }
            }
        }

        $sql = '
            INSERT INTO extension_dependencies
                (required, packages_name, packages_channel, extension,
                 conflicts, min, max, recommended)
            VALUES
                (:required, :name, :channel, :extension,
                 :conflicts, :min, :max, :recommended)';
        $stmt = static::$databases[$this->_path]->prepare($sql);
        $first = true;
        foreach (array('required', 'optional') as $required) {
            foreach ($info->dependencies[$required]->extension as $d) {
                // $d is a PEAR2_Pyrus_PackageFile_v2_Dependencies_Package object
                $dmin         = $d->min;
                $dmax         = $d->max;
                $drecommended = $d->recommended;
                $ext          = $d->name;

                if (!$first) {
                    $stmt->clear();
                    $first = false;
                }
                $req = ($required == 'required' ? 1 : 0);
                $stmt->bindParam(':required', $req, SQLITE3_INTEGER);
                $stmt->bindParam(':name', $n);
                $stmt->bindParam(':channel', $c);
                $stmt->bindParam(':extension', $ext);
                $con = $d->conflicts;
                $stmt->bindParam(':conflicts', $con, SQLITE3_INTEGER);
                $stmt->bindParam(':min', $dmin);
                $stmt->bindParam(':max', $dmax);
                $stmt->bindParam(':recommended', $drecommended);

                if (!@$stmt->execute()) {
                    static::$databases[$this->_path]->exec('ROLLBACK');
                    throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                        $info->channel . '/' . $info->name . ' could not be installed in registry');
                }

                if (isset($d->exclude)) {
                    $sql = '
                        INSERT INTO extension_dependencies_exclude
                         (required, packages_name, packages_channel,
                          extension, exclude, conflicts)
                        VALUES(:required, :name, :channel, :extension,
                               :exclude, :conflicts)';

                    $stmt1 = static::$databases[$this->_path]->prepare($sql);
                    foreach ($d->exclude as $exclude) {
                        $stmt1->clear();
                        $req = ($required == 'required' ? 1 : 0);
                        $stmt1->bindParam(':required', $req, SQLITE3_INTEGER);
                        $stmt1->bindParam(':name', $n);
                        $stmt1->bindParam(':channel', $c);
                        $stmt1->bindParam(':extension', $ext);
                        $stmt1->bindParam(':exclude', $exclude);
                        $con = $d->conflicts;
                        $stmt1->bindParam(':conflicts', $con, SQLITE3_INTEGER);

                        if (!@$stmt1->execute()) {
                            static::$databases[$this->_path]->exec('ROLLBACK');
                            throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                                $info->channel . '/' . $info->name . ' could not be installed in registry');
                        }
                    }
                    $stmt1->close();
                }
            }
        }
        $stmt->close();

        $sql = '
            INSERT INTO package_dependencies
                (required, packages_name, packages_channel, deppackage,
                 depchannel, conflicts, min, max, recommended, is_subpackage, providesextension)
            VALUES
                (:required, :name, :channel, :dep_package, :dep_channel,
                 :conflicts, :min, :max, :recommended, :sub, :ext)';
        $stmt = static::$databases[$this->_path]->prepare($sql);

        $first = true;
        foreach (array('required', 'optional') as $required) {
            foreach (array('package', 'subpackage') as $package) {
                foreach ($info->dependencies[$required]->$package as $d) {
                    // $d is a PEAR2_Pyrus_PackageFile_v2_Dependencies_Package object
                    $dchannel     = $d->channel;
                    $dmin         = $d->min;
                    $dmax         = $d->max;
                    $drecommended = $d->recommended;
                    $dname        = $d->name;
                    $sub          = $package == 'subpackage';
                    $ext          = $d->providesextension;

                    if (!$first) {
                        $stmt->clear();
                        $first = false;
                    }
                    $req = ($required == 'required' ? 1 : 0);
                    $stmt->bindParam(':required', $req, SQLITE3_INTEGER);
                    $stmt->bindParam(':name', $n);
                    $stmt->bindParam(':channel', $c);
                    $stmt->bindParam(':dep_package', $dname);
                    $stmt->bindParam(':dep_channel', $dchannel);
                    $con = $d->conflicts;
                    $stmt->bindParam(':conflicts', $con, SQLITE3_INTEGER);
                    $stmt->bindParam(':min', $dmin);
                    $stmt->bindParam(':max', $dmax);
                    $stmt->bindParam(':recommended', $drecommended);
                    $stmt->bindParam(':sub', $sub);
                    if ($ext) {
                        $stmt->bindParam(':ext', $ext);
                    } else {
                        $stmt->bindParam(':ext', $ext, SQLITE3_NULL);
                    }

                    if (!@$stmt->execute()) {
                        static::$databases[$this->_path]->exec('ROLLBACK');
                        throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                            $info->channel . '/' . $info->name . ' could not be installed in registry');
                    }

                    if (isset($d->exclude)) {

                        $sql = '
                            INSERT INTO package_dependencies_exclude
                             (required, packages_name, packages_channel,
                              deppackage, depchannel, exclude, conflicts, is_subpackage)
                            VALUES(:required, :name, :channel, :dep_package,
                                :dep_channel, :exclude, :conflicts, :sub)';

                        $stmt1 = static::$databases[$this->_path]->prepare($sql);
                        foreach ($d->exclude as $exclude) {
                            $stmt1->clear();
                            $req = ($required == 'required' ? 1 : 0);
                            $stmt1->bindParam(':required', $req, SQLITE3_INTEGER);
                            $stmt1->bindParam(':name', $n);
                            $stmt1->bindParam(':channel', $c);
                            $stmt1->bindParam(':dep_package', $dname);
                            $stmt1->bindParam(':dep_channel', $dchannel);
                            $stmt1->bindParam(':exclude', $exclude);
                            $stmt1->bindParam(':sub', $sub);
                            $con = $d->conflicts;
                            $stmt1->bindParam(':conflicts', $con, SQLITE3_INTEGER);

                            if (!@$stmt1->execute()) {
                                static::$databases[$this->_path]->exec('ROLLBACK');
                                throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                                    $info->channel . '/' . $info->name . ' could not be installed in registry');
                            }
                        }
                        $stmt1->close();
                    }
                }
            }
        }
        $stmt->close();

        $sql = '
            INSERT INTO php_dependencies
              (packages_name, packages_channel, min, max)
            VALUES
                (:name, :channel, :min, :max)';

        $min = $info->dependencies['required']->php->min;
        $max = $info->dependencies['required']->php->max;
        $stmt = static::$databases[$this->_path]->prepare($sql);

        $stmt->bindParam(':name', $n);
        $stmt->bindParam(':channel', $c);
        $stmt->bindParam(':min', $min);
        if ($max === null) {
            $stmt->bindParam(':max', $max, SQLITE3_NULL);
        } else {
            $stmt->bindParam(':max', $max);
        }
        if (!@$stmt->execute()) {
            static::$databases[$this->_path]->exec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                $info->channel . '/' . $info->name . ' could not be installed in registry');
        }
        $stmt->close();

        $sql = '
            INSERT INTO php_dependencies_exclude
              (packages_name, packages_channel, exclude)
            VALUES
                (:name, :channel, :exclude)';
        $stmt = static::$databases[$this->_path]->prepare($sql);

        if ($info->dependencies['required']->php->exclude) {
            foreach ($info->dependencies['required']->php->exclude as $exclude) {
                $stmt->bindParam(':name', $n);
                $stmt->bindParam(':channel', $c);
                $stmt->bindParam(':exclude', $exclude);
                if (!$stmt->execute()) {
                    static::$databases[$this->_path]->exec('ROLLBACK');
                    throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                        $info->channel . '/' . $info->name . ' could not be installed in registry');
                }
            }
        }
        $stmt->close();

        $sql = '
            INSERT INTO pearinstaller_dependencies
              (packages_name, packages_channel, min, max)
            VALUES
                (:name, :channel, :min, :max)';

        $min = $info->dependencies['required']->pearinstaller->min;
        $max = $info->dependencies['required']->pearinstaller->max;
        $stmt = static::$databases[$this->_path]->prepare($sql);

        $stmt->bindParam(':name', $n);
        $stmt->bindParam(':channel', $c);
        $stmt->bindParam(':min', $min);
        if ($max === null) {
            $stmt->bindParam(':max', $max, SQLITE3_NULL);
        } else {
            $stmt->bindParam(':max', $max);
        }
        if (!@$stmt->execute()) {
            static::$databases[$this->_path]->exec('ROLLBACK');
            throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                $info->channel . '/' . $info->name . ' could not be installed in registry');
        }
        $stmt->close();

        $sql = '
            INSERT INTO pearinstaller_dependencies_exclude
              (packages_name, packages_channel, exclude)
            VALUES
                (:name, :channel, :exclude)';
        $stmt = static::$databases[$this->_path]->prepare($sql);

        if ($info->dependencies['required']->pearinstaller->exclude) {
            foreach ($info->dependencies['required']->pearinstaller->exclude as $exclude) {
                $stmt->bindParam(':name', $n);
                $stmt->bindParam(':channel', $c);
                $stmt->bindParam(':exclude', $exclude);
                if (!$stmt->execute()) {
                    static::$databases[$this->_path]->exec('ROLLBACK');
                    throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                        $info->channel . '/' . $info->name . ' could not be installed in registry');
                }
            }
        }
        $stmt->close();

        if (isset($info->dependencies['required']->os)) {
            $sql = '
                INSERT INTO os_dependencies
                  (packages_name, packages_channel, osname, conflicts)
                VALUES
                    (:name, :channel, :os, :conflicts)';
            $stmt = static::$databases[$this->_path]->prepare($sql);

            foreach ($info->dependencies['required']->os as $dep) {

                $stmt->clear();
                $stmt->bindParam(':name', $n);
                $stmt->bindParam(':channel', $c);
                $name = $dep['name'];
                $stmt->bindParam(':os', $name);
                $conflicts = isset($dep['conflicts']);
                $stmt->bindParam(':conflicts', $conflicts, SQLITE3_INTEGER);
                if (!@$stmt->execute()) {
                    static::$databases[$this->_path]->exec('ROLLBACK');
                    throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                        $info->channel . '/' . $info->name . ' could not be installed in registry');
                }
            }
            $stmt->close();
        }

        if (isset($info->dependencies['required']->arch)) {
            $sql = '
                INSERT INTO arch_dependencies
                  (packages_name, packages_channel, pattern, conflicts)
                VALUES
                    (:name, :channel, :arch, :conflicts)';

            $stmt = static::$databases[$this->_path]->prepare($sql);
            foreach ($info->dependencies['required']->arch as $dep) {

                $stmt->clear();
                $stmt->bindParam(':name', $n);
                $stmt->bindParam(':channel', $c);
                $name = $dep['pattern'];
                $stmt->bindParam(':arch', $name);
                $conflicts = isset($dep['conflicts']);
                $stmt->bindParam(':conflicts', $conflicts, SQLITE3_INTEGER);
                if (!@$stmt->execute()) {
                    static::$databases[$this->_path]->exec('ROLLBACK');
                    throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                        $info->channel . '/' . $info->name . ' could not be installed in registry');
                }
            }
            $stmt->close();
        }

        foreach ($info->dependencies['group'] as $group) {
            $gn = $group->name;
            $gh = $group->hint;

            $sql = '
                INSERT INTO dep_groups
                    (packages_name, packages_channel, groupname, grouphint)
                VALUES
                    (:name, :channel, :groupname, :grouphint)';
            $stmt = static::$databases[$this->_path]->prepare($sql);
            $stmt->bindParam(':name', $n);
            $stmt->bindParam(':channel', $c);
            $stmt->bindParam(':groupname', $gn);
            $stmt->bindParam(':grouphint', $gh);

            if (!@$stmt->execute()) {
                static::$databases[$this->_path]->exec('ROLLBACK');
                throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                    $info->channel . '/' . $info->name . ' could not be installed in registry');
            }
            $stmt->close();

            $sql = '
                INSERT INTO extension_dependencies
                    (required, packages_name, packages_channel, extension,
                     conflicts, min, max, recommended, groupname)
                VALUES
                    (0, :name, :channel, :extension,
                     :conflicts, :min, :max, :recommended, :groupname)';

            $stmt = static::$databases[$this->_path]->prepare($sql);
            foreach ($group->extension as $d) {
                // $d is a PEAR2_Pyrus_PackageFile_v2_Dependencies_Package object
                $dmin         = $d->min;
                $dmax         = $d->max;
                $drecommended = $d->recommended;
                $ext          = $d->name;

                $stmt->clear();
                $stmt->bindParam(':name', $n);
                $stmt->bindParam(':channel', $c);
                $stmt->bindParam(':extension', $ext);
                $con = $d->conflicts;
                $stmt->bindParam(':conflicts', $con, SQLITE3_INTEGER);
                $stmt->bindParam(':min', $dmin);
                $stmt->bindParam(':max', $dmax);
                $stmt->bindParam(':recommended', $drecommended);
                $stmt->bindParam(':groupname', $gn);

                if (!@$stmt->execute()) {
                    static::$databases[$this->_path]->exec('ROLLBACK');
                    throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                        $info->channel . '/' . $info->name . ' could not be installed in registry');
                }

                if (isset($d->exclude)) {
                    $sql = '
                        INSERT INTO extension_dependencies_exclude
                         (required, packages_name, packages_channel,
                          extension, exclude, conflicts, groupname)
                        VALUES(0, :name, :channel, :extension,
                               :exclude, :conflicts, :groupname)';

                    $stmt1 = static::$databases[$this->_path]->prepare($sql);
                    foreach ($d->exclude as $exclude) {
                        $stmt1->clear();
                        $stmt1->bindParam(':name', $n);
                        $stmt1->bindParam(':channel', $c);
                        $stmt1->bindParam(':extension', $ext);
                        $stmt1->bindParam(':exclude', $exclude);
                        $con = $d->conflicts;
                        $stmt1->bindParam(':conflicts', $con, SQLITE3_INTEGER);
                        $stmt1->bindParam(':groupname', $gn);

                        if (!@$stmt1->execute()) {
                            static::$databases[$this->_path]->exec('ROLLBACK');
                            throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                                $info->channel . '/' . $info->name . ' could not be installed in registry');
                        }
                    }
                    $stmt1->close();
                }
            }
            $stmt->close();
    
            $sql = '
                INSERT INTO package_dependencies
                  (required, packages_name, packages_channel, deppackage,
                   depchannel, conflicts, min, max, recommended, is_subpackage, groupname, providesextension)
                VALUES
                    (0, :name, :channel, :dep_package, :dep_channel, :conflicts, :min, :max, :recommended, :sub,
                     :group, :ext)';

            $stmt = static::$databases[$this->_path]->prepare($sql);
            foreach (array('package', 'subpackage') as $package) {
                foreach ($group->$package as $d) {
                    // $d is a PEAR2_Pyrus_PackageFile_v2_Dependencies_Package object
                    $dchannel     = $d->channel;
                    $dmin         = $d->min;
                    $dmax         = $d->max;
                    $dname        = $d->name;
                    $drecommended = $d->recommended;
                    $sub          = $package == 'subpackage';
                    $ext          = $d->providesextension;

                    $stmt->clear();
                    $stmt->bindParam(':name', $n);
                    $stmt->bindParam(':channel', $c);
                    $stmt->bindParam(':dep_package', $dname);
                    $stmt->bindParam(':dep_channel', $dchannel);
                    $con = $d->conflicts;
                    $stmt->bindParam(':conflicts', $con, SQLITE3_INTEGER);
                    $stmt->bindParam(':min', $dmin);
                    $stmt->bindParam(':max', $dmax);
                    $stmt->bindParam(':recommended', $drecommended);
                    $stmt->bindParam(':sub', $sub);
                    $stmt->bindParam(':group', $gn);
                    if ($ext) {
                        $stmt->bindParam(':ext', $ext);
                    } else {
                        $stmt->bindParam(':ext', $ext, SQLITE3_NULL);
                    }

                    if (!@$stmt->execute()) {
                        static::$databases[$this->_path]->exec('ROLLBACK');
                        throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                            $info->channel . '/' . $info->name . ' could not be installed in registry');
                    }

                    if (isset($d->exclude)) {

                        $sql = '
                            INSERT INTO package_dependencies_exclude
                             (required, packages_name, packages_channel,
                              deppackage, depchannel, exclude, conflicts, is_subpackage, groupname)
                            VALUES(0, :name, :channel, :dep_package,
                                :dep_channel, :exclude, :conflicts, :sub, :group)';

                        $stmt1 = static::$databases[$this->_path]->prepare($sql);
                        foreach ($d->exclude as $exclude) {
                            $stmt1->clear();
                            $req = 0;
                            $stmt1->bindParam(':required', $req, SQLITE3_INTEGER);
                            $stmt1->bindParam(':name',        $n);
                            $stmt1->bindParam(':channel',     $c);
                            $stmt1->bindParam(':dep_package', $dname);
                            $stmt1->bindParam(':dep_channel', $dchannel);
                            $stmt1->bindParam(':exclude',     $exclude);
                            $stmt1->bindParam(':sub', $sub);
                            $stmt1->bindParam(':group', $gn);
                            $con = $d->conflicts;
                            $stmt1->bindParam(':conflicts', $con, SQLITE3_INTEGER);

                            if (!@$stmt1->execute()) {
                                static::$databases[$this->_path]->exec('ROLLBACK');
                                throw new PEAR2_Pyrus_Registry_Exception('Error: package ' .
                                    $info->channel . '/' . $info->name . ' could not be installed in registry');
                            }
                        }
                        $stmt1->close();
                    }
                }
            }
        }
        $stmt->close();

        static::$databases[$this->_path]->exec('COMMIT');
    }

    function uninstall($package, $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot uninstall package, registry is read-only');
        }

        if (!isset(static::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite3 registry for ' . $this->_path);
        }

        $channel = PEAR2_Pyrus_Config::current()->channelregistry[$channel]->name;
        if (!$this->exists($package, $channel)) {
            throw new PEAR2_Pyrus_Registry_Exception('Unknown package ' . $channel . '/' .
                $package);
        }

        $sql = 'DELETE FROM packages WHERE name = "' .
              static::$databases[$this->_path]->escapeString($package) . '" AND channel = "' .
              static::$databases[$this->_path]->escapeString($channel) . '"';
        static::$databases[$this->_path]->exec($sql);
    }

    function exists($package, $channel)
    {
        if (!isset(static::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite3 registry for ' . $this->_path);
        }

        $sql = 'SELECT
                    COUNT(name)
                FROM packages
                WHERE
                    name = :name AND channel = :channel
            ';
        $stmt = static::$databases[$this->_path]->prepare($sql);
        $stmt->bindParam(':name',    $package);
        $stmt->bindParam(':channel', $channel);
        $result = @$stmt->execute();

        if (!$result) {
            $error = static::$databases[$this->_path]->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot search for package ' . $channel . '/' . $package .
                ': ' . $error);
        }
        $ret = $result->fetchArray(SQLITE3_NUM);
        return $ret[0];
    }

    function info($package, $channel, $field)
    {
        if (!isset(static::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite3 registry for ' . $this->_path);
        }

        if ($field == 'api-state') {
            $field = 'apistability';
        } elseif ($field == 'state') {
            $field = 'stability';
        } elseif ($field == 'release-version') {
            $field = 'version';
        } elseif ($field == 'api-version') {
            $field = 'apiversion';
        } elseif ($field == 'notes') {
            $field = 'releasenotes';
        } elseif ($field == 'date') {
            $field = 'releasedate';
        } elseif ($field == 'time') {
            $field = 'releasetime';
        } elseif ($field == 'installedfiles') {
            $ret = array();
            $sql = 'SELECT
                        configpath, relativepath, role, origpath, baseinstalldir
                    FROM files
                    WHERE
                        packages_name = :name AND packages_channel = :channel';

            $stmt = static::$databases[$this->_path]->prepare($sql);
            $stmt->bindParam(':name',    $package);
            $stmt->bindParam(':channel', $channel);
            $result = @$stmt->execute();

            if (!$result) {
                $error = static::$databases[$this->_path]->lastErrorMsg();
                throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve ' . $field .
                    ': ' . $error);
            }

            while ($file = $result->fetchArray(SQLITE3_ASSOC)) {
                if ($file['baseinstalldir']) {
                    $ret[$file['configpath'] . DIRECTORY_SEPARATOR . $file['relativepath']] =
                                                      array('role' => $file['role'],
                                                       'name' => $file['origpath'],
                                                       'baseinstalldir' => $file['baseinstalldir'],
                                                       'installed_as' => $file['configpath'] . DIRECTORY_SEPARATOR . $file['relativepath'],
                                                       'relativepath' => $file['relativepath'],
                                                       'configpath' => $file['configpath'],
                                                      );
                } else {
                    $ret[$file['configpath'] . DIRECTORY_SEPARATOR . $file['relativepath']] =
                                                      array('role' => $file['role'],
                                                       'name' => $file['origpath'],
                                                       'installed_as' => $file['configpath'] . DIRECTORY_SEPARATOR . $file['relativepath'],
                                                       'relativepath' => $file['relativepath'],
                                                       'configpath' => $file['configpath'],
                                                      );
                }
            }
            $stmt->close();

            return $ret;
        } elseif ($field == 'dirtree') {
            // if we are :memory: this can't work
            if ($this->_path === ':memory:') {
                return array();
            }

            $actual = dirname($this->_path);

            $files = $this->info($package, $channel, 'installedfiles');
            foreach ($files as $file => $unused) {
                do {
                    $file = dirname($file);
                    if (strlen($file) > strlen($actual)) {
                        $ret[$file] = 1;
                    }
                } while (strlen($file) > strlen($actual));
            }
            $ret = array_keys($ret);
            usort($ret, 'strnatcasecmp');
            return array_reverse($ret);
        }

        $sql = ' SELECT ' . $field . ' FROM packages WHERE
            name = \'' . static::$databases[$this->_path]->escapeString($package) . '\' AND
            channel = \'' . static::$databases[$this->_path]->escapeString($channel) . '\'';

        $info = @static::$databases[$this->_path]->querySingle($sql);
        if (static::$databases[$this->_path]->lastErrorCode()) {
            $error = static::$databases[$this->_path]->lastErrorMsg();
            throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve ' . $field .
                ': ' . $error);
        }

        return $info;
    }

    /**
     * List all packages in a given channel
     *
     * @param string $channel name of the channel being queried
     *
     * @return array One dimensional array with the package name as value
     */
    public function listPackages($channel)
    {
        if (!isset(static::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite3 registry for ' . $this->_path);
        }

        $ret = array();
        $sql = 'SELECT name FROM packages WHERE channel = :channel ORDER BY name';
        $stmt = static::$databases[$this->_path]->prepare($sql);
        $stmt->bindParam(':channel', $channel);
        $result = @$stmt->execute();

        while ($res = $result->fetchArray(SQLITE3_NUM)) {
            $ret[] = $res[0];
        }

        return $ret;
    }

    function __get($var)
    {
        if ($var === 'package') {
            return new PEAR2_Pyrus_Registry_Sqlite3_Package($this);
        }
    }

    /**
     * Extract a packagefile object from the registry
     * @return PEAR2_Pyrus_PackageFile_v2
     */
    function toPackageFile($package, $channel)
    {
        if (!isset(static::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_Registry_Exception('Error: no existing SQLite3 registry for ' . $this->_path);
        }
        if (!$this->exists($package, $channel)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve package file object ' .
                'for package ' . $channel . '/' . $package . ', it is not installed');
        }
        $ret = new PEAR2_Pyrus_PackageFile_v2;
        $ret->name        = $package;
        $ret->channel     = $channel;
        $ret->summary     = $this->info($package, $channel, 'summary');
        $ret->description = $this->info($package, $channel, 'description');

        $sql = 'SELECT * FROM maintainers
                WHERE packages_name = :name AND packages_channel = :channel';

        $stmt = static::$databases[$this->_path]->prepare($sql);
        $stmt->bindParam(':name',    $package);
        $stmt->bindParam(':channel', $channel);
        $result = @$stmt->execute();

        if (!$result) {
            throw new PEAR2_Pyrus_Registry_Exception('Could not retrieve package file object' .
                ' for package ' . $channel . '/' . $package . ', no maintainers registered');
        }

        while ($maintainer = $result->fetchArray(SQLITE3_ASSOC)) {
            $ret->maintainer[$maintainer['user']]
                ->name($maintainer['name'])
                ->role($maintainer['role'])
                ->email($maintainer['email'])
                ->active($maintainer['active']);
        }
        $stmt->close();

        $ret->date = $this->info($package, $channel, 'date');
        // FIXME why are we querying the same info twice ?
        if ($a = $this->info($package, $channel, 'time')) {
            $ret->time = $this->info($package, $channel, 'time');
        }

        $ret->version['release']   = $this->info($package, $channel, 'version');
        $ret->version['api']       = $this->info($package, $channel, 'apiversion');
        $ret->stability['release'] = $this->info($package, $channel, 'stability');
        $ret->stability['api']     = $this->info($package, $channel, 'apistability');
        $uri     = $this->info($package, $channel, 'licenseuri');
        $path    = $this->info($package, $channel, 'licensepath');
        $license = $this->info($package, $channel, 'license');
        if ($uri) {
            $ret->rawlicense = array('attribs' => array('uri' => $uri), '_content' => $license);
        } elseif ($path) {
            $ret->rawlicense = array('attribs' => array('path' => $path), '_content' => $license);
        } else {
            $ret->license = $license;
        }
        $ret->notes = $this->info($package, $channel, 'releasenotes');

        $sql = 'SELECT * FROM files
                WHERE packages_name = :name AND packages_channel = :channel';

        $stmt = static::$databases[$this->_path]->prepare($sql);
        $stmt->bindParam(':name',    $package);
        $stmt->bindParam(':channel', $channel);
        $result = @$stmt->execute();

        if (!$result) {
            throw new PEAR2_Pyrus_Registry_Exception('Could not retrieve package file object' .
                ' for package ' . $channel . '/' . $package . ', no files registered');
        }

        while ($file = $result->fetchArray(SQLITE3_ASSOC)) {
            $ret->files[$file['origpath']] = array_merge(
                                                array('attribs' => array('role' => $file['role'])),
                                                unserialize($file['tasks']));
            if ($file['baseinstalldir']) {
                $ret->setFileAttribute($file['origpath'], 'baseinstalldir', $file['baseinstalldir']);
            }
        }
        $stmt->close();

        $sql = 'SELECT dirname, baseinstall FROM baseinstalldirs
                WHERE packages_name = :name AND packages_channel = :channel';

        $stmt = static::$databases[$this->_path]->prepare($sql);
        $stmt->bindParam(':name',    $package);
        $stmt->bindParam(':channel', $channel);
        $result = @$stmt->execute();

        if (!$result) {
            throw new PEAR2_Pyrus_Registry_Exception('Could not retrieve package file object' .
                ' for package ' . $channel . '/' . $package . ', no files registered');
        }

        $dirs = array();
        while ($dir = $result->fetchArray(SQLITE3_ASSOC)) {
            $dirs[$dir['dirname']] = $dir['baseinstall'];
        }
        $ret->setBaseInstallDirs($dirs);
        $stmt->close();

        $sql = 'SELECT * FROM configureoptions
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $a = static::$databases[$this->_path]->query($sql);

        while ($option = $a->fetchArray()) {
            $ret->configureoption[$option['name']]->prompt($option['prompt'])->default($option['defaultValue']);
        }
        $this->fetchCompatible($ret);
        $this->fetchDeps($ret);
        $ret->release = null;
        return $ret;
    }

    function fetchCompatible(PEAR2_Pyrus_IPackageFile $ret)
    {
        $package = $ret->name;
        $channel = $ret->channel;
        $sql = 'SELECT * FROM compatible_releases
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $a = static::$databases[$this->_path]->query($sql);

        while ($dep = $a->fetchArray(SQLITE3_ASSOC)) {
            $ret->compatible[$dep['compat_channel'] . '/' . $dep['compat_package']]->min =
                $dep['min'];
            $ret->compatible[$dep['compat_channel'] . '/' . $dep['compat_package']]->max =
                $dep['max'];
        }

        $sql = 'SELECT * FROM compatible_releases_exclude
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $a = static::$databases[$this->_path]->query($sql);

        while ($dep = $a->fetchArray(SQLITE3_ASSOC)) {
            $ret->compatible[$dep['compat_channel'] . '/' . $dep['compat_package']]->exclude =
                $dep['exclude'];
        }
    }

    function fetchDeps(PEAR2_Pyrus_IPackageFile $ret)
    {
        $package = $ret->name;
        $channel = $ret->channel;
        $sql = 'SELECT * FROM php_dependencies
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $a = static::$databases[$this->_path]->query($sql);

        while ($dep = $a->fetchArray()) {
            $ret->dependencies['required']->php->min = $dep['min'];
            $ret->dependencies['required']->php->max = $dep['max'];
        }

        $sql = 'SELECT * FROM php_dependencies_exclude
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $a = static::$databases[$this->_path]->query($sql);

        while ($dep = $a->fetchArray()) {
            $ret->dependencies['required']->php->exclude($dep['exclude']);
        }

        $sql = 'SELECT * FROM pearinstaller_dependencies
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $a = static::$databases[$this->_path]->query($sql);

        while ($dep = $a->fetchArray()) {
            $ret->dependencies['required']->pearinstaller->min = $dep['min'];
            $ret->dependencies['required']->pearinstaller->max = $dep['max'];
        }

        $sql = 'SELECT * FROM pearinstaller_dependencies_exclude
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $a = static::$databases[$this->_path]->query($sql);

        while ($dep = $a->fetchArray()) {
            $ret->dependencies['required']->pearinstaller->exclude($dep['exclude']);
        }

        $sql = 'SELECT * FROM os_dependencies
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $a = static::$databases[$this->_path]->query($sql);

        while ($dep = $a->fetchArray(SQLITE3_ASSOC)) {
            $ret->dependencies['required']->os[$dep['osname']] = !$dep['conflicts'];
            $rawdeps = $ret->rawdeps;
        }

        $sql = 'SELECT * FROM arch_dependencies
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $a = static::$databases[$this->_path]->query($sql);

        while ($dep = $a->fetchArray()) {
            $ret->dependencies['required']->arch[$dep['pattern']] = !$dep['conflicts'];
        }

        $sql = 'SELECT * FROM package_dependencies
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
                //ORDER BY required, deppackage, depchannel, conflicts';
        $package_deps = static::$databases[$this->_path]->query($sql);

        $sql = 'SELECT * FROM package_dependencies_exclude
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
                //ORDER BY required, deppackage, depchannel, conflicts, exclude';
        $excludes = static::$databases[$this->_path]->query($sql);
        if (!$package_deps) {
            $ret = $this->fetchDepGroups($ret);
            return $ret;
        }

        $provides = array();
        while ($dep = $package_deps->fetchArray(SQLITE3_ASSOC)) {
            $required = $dep['required'] ? 'required' : 'optional';
            $package = $dep['is_subpackage'] ? 'subpackage' : 'package';
            if ($dep['groupname']) {
                $group = $dep['groupname'];
                $d = $ret->dependencies['group']->$group->{$package}[$dep['depchannel'] . '/' . $dep['deppackage']];
            } else {
                $d = $ret->dependencies[$required]->{$package}[$dep['depchannel'] . '/' . $dep['deppackage']];
            }
            $d->min($dep['min']);
            $d->max($dep['max']);
            if ($dep['conflicts']) {
                $d->conflicts();
            }
            $d->recommended($dep['recommended']);
            $provides[] = $dep;
        }

        while ($dep = $excludes->fetchArray(SQLITE3_ASSOC)) {
            $required = $dep['required'] ? 'required' : 'optional';
            $package = $dep['is_subpackage'] ? 'subpackage' : 'package';

            if ($dep['groupname']) {
                $group = $dep['groupname'];
                $d = $ret->dependencies['group']->$group->{$package}[$dep['depchannel'] . '/' . $dep['deppackage']];
            } else {
                $d = $ret->dependencies[$required]->{$package}[$dep['depchannel'] . '/' . $dep['deppackage']];
            }

            $d->exclude($dep['exclude']);
        }
        foreach ($provides as $dep){
            $required = $dep['required'] ? 'required' : 'optional';
            $package = $dep['is_subpackage'] ? 'subpackage' : 'package';
            if ($dep['groupname']) {
                $group = $dep['groupname'];
                $ret->dependencies['group']->$group->{$package}[$dep['depchannel'] . '/' . $dep['deppackage']]->providesextension($dep['providesextension']);
            } else {
                $ret->dependencies[$required]->{$package}[$dep['depchannel'] . '/' . $dep['deppackage']]->providesextension($dep['providesextension']);
            }
        }

        $ret = $this->fetchExtensionDeps($ret);
        $ret = $this->fetchDepGroups($ret);
        return $ret;
    }

    function fetchDepGroups(PEAR2_Pyrus_IPackageFile $ret)
    {
        $package = $ret->name;
        $channel = $ret->channel;

        $sql = 'SELECT * FROM dep_groups
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $groups = static::$databases[$this->_path]->query($sql);
        if ($groups) {
            while ($group = $groups->fetchArray(SQLITE3_ASSOC)) {
                $ret->dependencies['group']->{$group['groupname']}->hint = $group['grouphint'];
            }
        }
        return $ret;
    }

    function fetchExtensionDeps(PEAR2_Pyrus_IPackageFile $ret)
    {
        $package = $ret->name;
        $channel = $ret->channel;
        $sql = 'SELECT * FROM extension_dependencies
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $extension_deps = static::$databases[$this->_path]->query($sql);

        $sql = 'SELECT * FROM extension_dependencies_exclude
                WHERE
                    packages_name = "' . static::$databases[$this->_path]->escapeString($package) . '" AND
                    packages_channel = "' . static::$databases[$this->_path]->escapeString($channel) . '"';
        $excludes = static::$databases[$this->_path]->query($sql);
        if (!$extension_deps) {
            return $ret;
        }
        while ($dep = $extension_deps->fetchArray(SQLITE3_ASSOC)) {
            $required = $dep['required'] ? 'required' : 'optional';
            if ($dep['groupname']) {
                $group = $dep['groupname'];
                $d = $ret->dependencies['group']->$group->extension[$dep['extension']];
            } else {
                $d = $ret->dependencies[$required]->extension[$dep['extension']];
            }
            $d->min($dep['min']);
            $d->max($dep['max']);
            if ($dep['conflicts']) {
                $d->conflicts();
            }
            $d->recommended($dep['recommended']);
            $provides[] = $dep;
        }

        while ($dep = $excludes->fetchArray(SQLITE3_ASSOC)) {
            $required = $dep['required'] ? 'required' : 'optional';

            if ($dep['groupname']) {
                $group = $dep['groupname'];
                $d = $ret->dependencies['group']->$group->extension[$dep['extension']];
            } else {
                $d = $ret->dependencies[$required]->extension[$dep['extension']];
            }

            $d->exclude($dep['exclude']);
        }

        return $ret;
    }

    public function getDependentPackages(PEAR2_Pyrus_IPackageFile $package)
    {
        if (!isset(static::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite3 channel registry for ' . $this->_path);
        }

        $ret = array();
        $sql = 'SELECT
                    packages_channel, packages_name
                FROM package_dependencies
                WHERE
                    deppackage = :name AND depchannel = :channel
                ORDER BY packages_channel, packages_name';
        $stmt = static::$databases[$this->_path]->prepare($sql);
        $pn = $package->name;
        $stmt->bindParam(':name', $pn, SQLITE3_TEXT);
        $pp = $package->channel;
        $stmt->bindParam(':channel', $pp, SQLITE3_TEXT);
        $result = @$stmt->execute();

        while ($res = $result->fetchArray()) {
            try {
                $ret[] = $this->package[$res[0] . '/' . $res[1]];
            } catch (Exception $e) {
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Could not retrieve ' .
                    'dependent package ' . $res[0] . '/' . $res[1], $e);
            }
        }

        return $ret;
    }

    /**
     * Detect any files already installed that would be overwritten by
     * files inside the package represented by $package
     */
    public function detectFileConflicts(PEAR2_Pyrus_IPackageFile $package)
    {
        if (!isset(static::$databases[$this->_path])) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Error: no existing SQLite3 channel registry for ' . $this->_path);
        }

        $ret = array();
        $sql = 'SELECT
                    packages_channel, packages_name
                FROM files
                WHERE
                    packagepath = :path
                ORDER BY packages_channel, packages_name';
        $stmt = static::$databases[$this->_path]->prepare($sql);
        // now iterate over each file in the package, and note all the conflicts
        $roles = array();
        foreach (PEAR2_Pyrus_Installer_Role::getValidRoles($package->getPackageType()) as $role) {
            // set up a list of file role => configuration variable
            // for storing in the registry
            $roles[$role] =
                PEAR2_Pyrus_Installer_Role::factory($package->getPackageType(), $role);
        }
        $ret = array();
        $config = PEAR2_Pyrus_Config::current();
        foreach ($package->installcontents as $file) {
            $stmt->reset();
            $relativepath = $roles[$file->role]->getRelativeLocation($package, $file);
            if (!$relativepath) {
                continue;
            }
            $testpath = $config->{$roles[$file->role]->getLocationConfig()} .
                    DIRECTORY_SEPARATOR . $relativepath;
            $stmt->bindParam(':path', $testpath, SQLITE3_TEXT);
            $result = $stmt->execute();

            while ($res = $result->fetchArray(SQLITE3_ASSOC)) {
                $ret[] = array($relativepath => $res['packages_channel'] . '/' . $res['packages_name']);
            }
        }
        return $ret;
    }

    /**
     * Returns a list of registries present in the PEAR installation at $path
     * @param string
     * @return array
     */
    static public function detectRegistries($path)
    {
        if (file_exists($path . '/.pear2registry') || is_file($path . '/.pear2registry')) {
            return array('Sqlite3');
        }
        return array();
    }

    /**
     * Completely remove all traces of an sqlite3 registry
     */
    static public function removeRegistry($path)
    {
        if ($path === ':memory:') {
            unset(static::$databases[$path]);
            return;
        }
        if (dirname($path) . DIRECTORY_SEPARATOR . '.pear2registry' != $path) {
            $path = $path . DIRECTORY_SEPARATOR . '.pear2registry';
        }
        if (!file_exists($path)) {
            return;
        }
        if (isset(static::$databases[$path])) {
            static::$databases[$path]->close();
            unset(static::$databases[$path]);
        }
        if (!@unlink($path)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot remove Sqlite3 registry: Unable to remove SQLite database');
        }
    }
}<?php
/**
 * PEAR2_Pyrus_Registry_Xml
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * This is the central registry, that is used for all installer options,
 * stored in xml files
 *
 * It is designed for providing redundancy to the Sqlite3 registry and for
 * managing simple installation situations such as bundling a few packages
 * inside another application, or for distributing a registry with an
 * unzip-and-go application that can be used to construct an Sqlite3 registry.
 *
 * File conflict resolution can be done manually, via detectFileConflicts()
 * and is extremely slow, as each installed package must be processed in order
 * to determine the list of installed files.
 * 
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry_Xml extends PEAR2_Pyrus_Registry_Base
{
    protected $readonly;
    private $_path;

    function __construct($path, $readonly = false)
    {
        $this->_path = $path;
        $this->readonly = $readonly;
    }

    private function _nameRegistryPath(PEAR2_Pyrus_IPackageFile $info = null,
                                     $channel = null, $package = null, $version = null)
    {
        $channel = $info !== null ? $info->channel : $channel;
        $package = $info !== null ? $info->name : $package;
        $path = $this->_namePath($channel, $package);
        $version = $info !== null ? $info->version['release'] : $version;
        return $path . DIRECTORY_SEPARATOR . $version . '-package.xml';
    }

    private function _namePath($channel, $package)
    {
        return $this->_path . DIRECTORY_SEPARATOR .
            '.xmlregistry' . DIRECTORY_SEPARATOR . 'packages' . DIRECTORY_SEPARATOR .
            str_replace('/', '!', $channel) .
            DIRECTORY_SEPARATOR . $package;
    }

    /**
     * Create the Channel!PackageName-Version-package.xml file
     *
     * @param PEAR2_Pyrus_IPackageFile $pf
     */
    function install(PEAR2_Pyrus_IPackageFile $info, $replace = false)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot install package, registry is read-only');
        }
        // remove previously installed version for upgrade
        $this->uninstall($info->name, $info->channel);
        $packagefile = $this->_nameRegistryPath($info);
        if (!@is_dir(dirname($packagefile))) {
            mkdir(dirname($packagefile), 0755, true);
        }

        if (!$replace) {
            $info->date = date('Y-m-d');
            $info->time = date('H:i:s');
        }
        foreach ($info->files as $name => $file) {
            unset($file->{'install-as'});
        }
        $arr = $info->toArray();
        file_put_contents($packagefile, (string) new PEAR2_Pyrus_XMLWriter($arr));
    }

    function uninstall($package, $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot install package, registry is read-only');
        }
        if (!$this->exists($package, $channel)) {
            return;
        }
        $packagefile = glob($this->_namePath($channel, $package) .
            DIRECTORY_SEPARATOR . '*.xml');
        if (!$packagefile || !isset($packagefile[0])) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot find registry for package ' .
                $channel . '/' . $package);
        }
        unlink($packagefile[0]);
        rmdir(dirname($packagefile[0]));
    }

    public function exists($package, $channel)
    {
        $packagefile = $this->_namePath($channel, $package);
        return @file_exists($packagefile) && @is_dir($packagefile);
    }

    public function info($package, $channel, $field)
    {
        if (!$this->exists($package, $channel)) {
            throw new PEAR2_Pyrus_Registry_Exception('Unknown package ' . $channel .
                '/' . $package);
        }
        $packagefile = glob($this->_namePath($channel, $package) .
            DIRECTORY_SEPARATOR . '*.xml');
        if (!$packagefile || !isset($packagefile[0])) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot find registry for package ' .
                $channel . '/' . $package);
        }
        
        $packageobject = new PEAR2_Pyrus_Package($packagefile[0]);

        if ($field === null) {
            return $packageobject->getInternalPackage()->getPackageFile()->getPackageFileObject();
        }

        if ($field == 'version') {
            $field = 'release-version';
        } elseif ($field == 'installedfiles') {
            $ret = array();
            try {
                $config = new PEAR2_Pyrus_Config_Snapshot($packageobject->date . ' ' . $packageobject->time);
            } catch (Exception $e) {
                throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve files, config ' .
                                        'snapshot could not be processed', $e);
            }
            $roles = array();
            foreach (PEAR2_Pyrus_Installer_Role::getValidRoles($packageobject->getPackageType()) as $role) {
                // set up a list of file role => configuration variable
                // for storing in the registry
                $roles[$role] =
                    PEAR2_Pyrus_Installer_Role::factory($packageobject->getPackageType(), $role);
            }
            $ret = array();
            foreach ($packageobject->installcontents as $file) {
                $relativepath = $roles[$file->role]->getRelativeLocation($packageobject, $file);
                if (!$relativepath) {
                    continue;
                }
                $filepath = $config->{$roles[$file->role]->getLocationConfig()} .
                    DIRECTORY_SEPARATOR . $relativepath;
                $attrs = $file->getArrayCopy();
                $ret[$filepath] = $attrs['attribs'];
                $ret[$filepath]['installed_as'] = $filepath;
                $ret[$filepath]['relativepath'] = $relativepath;
                $ret[$filepath]['configpath'] = $config->{$roles[$file->role]->getLocationConfig()};
            }
            return $ret;
        } elseif ($field == 'dirtree') {
            $files = $this->info($package, $channel, 'installedfiles');
            foreach ($files as $file => $unused) {
                do {
                    $file = dirname($file);
                    if (strlen($file) > strlen($this->_path)) {
                        $ret[$file] = 1;
                    }
                } while (strlen($file) > strlen($this->_path));
            }
            $ret = array_keys($ret);
            usort($ret, 'strnatcasecmp');
            return array_reverse($ret);
        }

        return $packageobject->$field;
    }

    public function listPackages($channel)
    {
        $dir = $this->_namePath($channel, '');
        if (!@file_exists($dir)) {
            return array();
        }
        $ret = array();
        try {
            $parser = new PEAR2_Pyrus_XMLParser;
            foreach (new DirectoryIterator($dir) as $file) {
                if ($file->isDot()) {
                    continue;
                }
                try {
                    foreach (new DirectoryIterator($file->getPathName()) as $registries) {
                        if ($registries->isDir()) {
                            continue;
                        }
                        $a = $parser->parse($registries->getPathName());
                        $ret[] = $a['package']['name'];
                    }
                } catch (Exception $e) {
                    PEAR2_Pyrus_Log::log(0, 'Warning: corrupted XML registry entry: ' .
                        $file->getPathName() . ': ' . $e);
                }
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Registry_Exception('Could not open channel directory for ' .
                'channel ' . $channel, $e);
        }
        return $ret;
    }

    public function toPackageFile($package, $channel)
    {
        if (!$this->exists($package, $channel)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve package file object ' .
                'for package ' . $channel . '/' . $package . ', it is not installed');
        }
        $packagefile = $this->info($package, $channel, null);
        
        return $packagefile;
    }

    public function __get($var)
    {
        if ($var == 'package') {
            return new PEAR2_Pyrus_Registry_Xml_Package($this);
        }
    }

    /**
     * This is EXTREMELY inefficient, and should only be used
     * if an Sqlite3 registry is unavailable
     */
    public function getDependentPackages(PEAR2_Pyrus_IPackageFile $package)
    {
        // first construct a list of all installed packages
        $all = array();
        $config = PEAR2_Pyrus_Config::current();
        foreach ($config->channelregistry as $channel) {
            foreach ($this->listPackages($channel->name) as $packagename) {
                $all[] = $this->package[$channel->name . '/' . $packagename];
            }
        }

        $ret = array();
        // now scan them to see which packages depend on this one
        foreach ($all as $test) {
            if ($test->isEqual($package)) {
                continue;
            }
            if ($test->dependsOn($package)) {
                $ret[] = $test;
            }
        }
        return $ret;
    }

    /**
     * Detect any files already installed that would be overwritten by
     * files inside the package represented by $package
     */
    public function detectFileConflicts(PEAR2_Pyrus_IPackageFile $package)
    {
        // construct list of all installed files
        $allfiles = array();
        $filesByPackage = array();
        $config = PEAR2_Pyrus_Config::current();
        foreach ($config->channelregistry as $channel) {
            foreach ($this->listPackages($channel->name) as $packagename) {
                $files = $this->info($packagename, $channel->name, 'installedfiles');
                $newfiles = array();
                foreach ($files as $file) {
                    $newfiles[$file['installed_as']] = $file;
                }
                $filesByPackage[$channel->name . '/' . $packagename] = $newfiles;
                $allfiles = array_merge($allfiles, $newfiles);
            }
        }

        // now iterate over each file in the package, and note all the conflicts
        $roles = array();
        foreach (PEAR2_Pyrus_Installer_Role::getValidRoles($package->getPackageType()) as $role) {
            // set up a list of file role => configuration variable
            // for storing in the registry
            $roles[$role] =
                PEAR2_Pyrus_Installer_Role::factory($package->getPackageType(), $role);
        }
        $ret = array();
        foreach ($package->installcontents as $file) {
            $relativepath = $roles[$file->role]->getRelativeLocation($package, $file);
            if (!$relativepath) {
                continue;
            }
            $testpath = $config->{$roles[$file->role]->getLocationConfig()} .
                    DIRECTORY_SEPARATOR . $relativepath;
            if (isset($allfiles[$testpath])) {
                foreach ($filesByPackage as $pname => $files) {
                    if (isset($files[$testpath])) {
                        $ret[] = array($relativepath => $pname);
                        break;
                    }
                }
            }
        }
        return $ret;
    }

    /**
     * Returns a list of registries present in the PEAR installation at $path
     * @param string
     * @return array
     */
    static public function detectRegistries($path)
    {
        if (file_exists($path . '/.xmlregistry') || is_dir($path . '/.xmlregistry')) {
            return array('Xml');
        }
        return array();
    }

    /**
     * Completely remove all traces of an xml registry
     */
    static public function removeRegistry($path)
    {
        if (!file_exists($path . '/.xmlregistry')) {
            return;
        }
        try {
            PEAR2_Pyrus_AtomicFileTransaction::rmrf(realpath($path . DIRECTORY_SEPARATOR . '.xmlregistry'));
        } catch (PEAR2_Pyrus_AtomicFileTransaction_Exception $e) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot remove XML registry: ' . $e->getMessage(), $e);
        }
    }
}
<?php
/**
 * PEAR_REST_10
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implement REST 1.0
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_REST_10
{
    /**
     * @var PEAR2_Pyrus_REST
     */
    protected $rest;
    protected $options;
    function __construct($options = array())
    {
        $this->options = $options;
        $this->rest = new PEAR2_Pyrus_REST($this->options);
    }

    /**
     * Retrieve information about a remote package to be downloaded from a REST server
     *
     * @param string $base The uri to prepend to all REST calls
     * @param array $packageinfo an array of format:
     * <pre>
     *  array(
     *   'package' => 'packagename',
     *   'channel' => 'channelname',
     *  ['state' => 'alpha' (or valid state),]
     *  -or-
     *  ['version' => '1.whatever']
     * </pre>
     * @param string $prefstate Current preferred_state config variable value
     * @param bool $installed the installed version of this package to compare against
     * @return array|false|PEAR_Error see {@link returnDownloadURL()}
     */
    function getDownloadURL($base, $packageinfo, $prefstate, $installed)
    {
        $channel = $packageinfo['channel'];
        $package = $packageinfo['package'];
        $states = PEAR2_Pyrus_Installer::betterStates($prefstate, true);
        if (!$states) {
            throw new PEAR2_Pyrus_REST_Exception('"' . $prefstate . '" is not a valid state');
        }
        $state   = isset($packageinfo['state'])   ? $packageinfo['state']   : null;
        $version = isset($packageinfo['version']) ? $packageinfo['version'] : null;
        try {
            $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) . '/allreleases.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('No releases available for package "' .
                $channel . '/' . $package . '"', $e);
        }
        if (!isset($info['r'])) {
            return false;
        }
        $release = $found = false;
        if (!is_array($info['r']) || !isset($info['r'][0])) {
            $info['r'] = array($info['r']);
        }
        foreach ($info['r'] as $release) {
            if (!isset($this->options['force']) && ($installed &&
                  version_compare($release['v'], $installed, '<'))) {
                continue;
            }
            if (isset($state)) {
                // try our preferred state first
                if ($release['s'] == $state) {
                    $found = true;
                    break;
                }
                // see if there is something newer and more stable
                // bug #7221
                if (in_array($release['s'], PEAR2_Pyrus_Installer::betterStates($state), true)) {
                    $found = true;
                    break;
                }
            } elseif (isset($version)) {
                if ($release['v'] == $version) {
                    $found = true;
                    break;
                }
            } else {
                if (in_array($release['s'], $states)) {
                    $found = true;
                    break;
                }
            }
        }
        return $this->returnDownloadURL($base, $package, $release, $info, $found);
    }

    function getDepDownloadURL($base, $dependency, $deppackage,
                               $prefstate = 'stable', $installed = false)
    {
        $channel = $dependency['channel'];
        $package = $dependency['name'];
        $states = PEAR2_Pyrus_Installer::betterStates($prefstate, true);
        if (!$states) {
            throw new PEAR2_Pyrus_REST_Exception('"' . $prefstate . '" is not a valid state');
        }
        $state   = isset($dependency['state'])   ? $dependency['state']   : null;
        $version = isset($dependency['version']) ? $dependency['version'] : null;
        try {
            $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) . '/allreleases.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Package "' . $deppackage['channel'] . '/' . $deppackage['package']
                . '" dependency "' . $channel . '/' . $package . '" has no releases', $e);
        }
        if (!is_array($info) || !isset($info['r'])) {
            return false;
        }
        $exclude = array();
        $min = $max = $recommended = false;
        $min = isset($dependency['min']) ? $dependency['min'] : false;
        $max = isset($dependency['max']) ? $dependency['max'] : false;
        $recommended = isset($dependency['recommended']) ?
            $dependency['recommended'] : false;
        if (isset($dependency['exclude'])) {
            if (!isset($dependency['exclude'][0])) {
                $exclude = array($dependency['exclude']);
            }
        }
        $release = $found = false;
        if (!is_array($info['r']) || !isset($info['r'][0])) {
            $info['r'] = array($info['r']);
        }
        foreach ($info['r'] as $release) {
            if (!isset($this->options['force']) && ($installed &&
                  version_compare($release['v'], $installed, '<'))) {
                continue;
            }
            if (in_array($release['v'], $exclude)) { // skip excluded versions
                continue;
            }
            // allow newer releases to say "I'm OK with the dependent package"
            if (isset($release['co'])) {
                if (!is_array($release['co']) || !isset($release['co'][0])) {
                    $release['co'] = array($release['co']);
                }
                foreach ($release['co'] as $entry) {
                    if (isset($entry['x']) && !is_array($entry['x'])) {
                        $entry['x'] = array($entry['x']);
                    } elseif (!isset($entry['x'])) {
                        $entry['x'] = array();
                    }
                    if ($entry['c'] == $deppackage['channel'] &&
                          strtolower($entry['p']) == strtolower($deppackage['package']) &&
                          version_compare($deppackage['version'], $entry['min'], '>=') &&
                          version_compare($deppackage['version'], $entry['max'], '<=') &&
                          !in_array($release['v'], $entry['x'])) {
                        $recommended = $release['v'];
                        break;
                    }
                }
            }
            if ($recommended) {
                if ($release['v'] != $recommended) { // if we want a specific
                    // version, then skip all others
                    continue;
                } else {
                    if (!in_array($release['s'], $states)) {
                        // the stability is too low, but we must return the
                        // recommended version if possible
                        return $this->returnDownloadURL($base, $package, $release, $info, true);
                    }
                }
            }
            if ($min && version_compare($release['v'], $min, 'lt')) { // skip too old versions
                continue;
            }
            if ($max && version_compare($release['v'], $max, 'gt')) { // skip too new versions
                continue;
            }
            if ($installed && version_compare($release['v'], $installed, '<')) {
                continue;
            }
            if (in_array($release['s'], $states)) { // if in the preferred state...
                $found = true; // ... then use it
                break;
            }
        }
        return $this->returnDownloadURL($base, $package, $release, $info, $found);
    }

    /**
     * Take raw data and return the array needed for processing a download URL
     *
     * @param string $base REST base uri
     * @param string $package Package name
     * @param array $release an array of format array('v' => version, 's' => state)
     *                       describing the release to download
     * @param array $info list of all releases as defined by allreleases.xml
     * @param bool|null $found determines whether the release was found or this is the next
     *                    best alternative.  If null, then versions were skipped because
     *                    of PHP dependency
     * @return array|PEAR_Error
     * @access private
     */
    protected function returnDownloadURL($base, $package, $release, $info, $found, $phpversion = false)
    {
        if (!$found) {
            $release = $info['r'][0];
        }
        try {
            $pinfo = $this->rest->retrieveCacheFirst($base . 'p/' . strtolower($package) . '/' .
            'info.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Package "' . $package .
                '" does not have REST info xml available', $e);
        }
        try {
            $releaseinfo = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package) . '/' .
            $release['v'] . '.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Package "' . $package . '" Version "' . $release['v'] .
                '" does not have REST xml available', $e);
        }
        try {
            $packagexml = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package) . '/' .
            'package.' . $release['v'] . '.xml', false, true);
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Package "' . $package . '" Version "' . $release['v'] .
                '" does not have REST dependency information available', $e);
        }
        $allinfo = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
            '/allreleases.xml');
        if (!is_array($allinfo['r']) || !isset($allinfo['r'][0])) {
            $allinfo['r'] = array($allinfo['r']);
        }
        $compatible = false;
        foreach ($allinfo['r'] as $release) {
            if ($release['v'] != $releaseinfo['v']) {
                continue;
            }
            if (!isset($release['co'])) {
                break;
            }
            $compatible = array();
            if (!is_array($release['co']) || !isset($release['co'][0])) {
                $release['co'] = array($release['co']);
            }
            foreach ($release['co'] as $entry) {
                $comp = array();
                $comp['name'] = $entry['p'];
                $comp['channel'] = $entry['c'];
                $comp['min'] = $entry['min'];
                $comp['max'] = $entry['max'];
                if (isset($entry['x']) && !is_array($entry['x'])) {
                    $comp['exclude'] = $entry['x'];
                }
                $compatible[] = $comp;
            }
            if (count($compatible) == 1) {
                $compatible = $compatible[0];
            }
            break;
        }
        if (isset($pinfo['dc']) && isset($pinfo['dp'])) {
            if (is_array($pinfo['dp'])) {
                $deprecated = array('channel' => (string) $pinfo['dc'],
                                    'package' => trim($pinfo['dp']['_content']));
            } else {
                $deprecated = array('channel' => (string) $pinfo['dc'],
                                    'package' => trim($pinfo['dp']));
            }
        } else {
            $deprecated = false;
        }
        if ($found) {
            return
                array('version' => $releaseinfo['v'],
                      'info' => $packagexml,
                      'package' => $releaseinfo['p']['_content'],
                      'stability' => $releaseinfo['st'],
                      'url' => $releaseinfo['g'],
                      'compatible' => $compatible,
                      'deprecated' => $deprecated,
                );
        } else {
            return
                array('version' => $releaseinfo['v'],
                      'package' => $releaseinfo['p']['_content'],
                      'stability' => $releaseinfo['st'],
                      'info' => $packagexml,
                      'compatible' => $compatible,
                      'deprecated' => $deprecated,
                      'php' => $phpversion
                );
        }
    }

    function listPackages($base)
    {
        try {
            $packagelist = $this->rest->retrieveData($base . 'p/packages.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Cannot list packages', $e);
        }
        if (!is_array($packagelist) || !isset($packagelist['p'])) {
            return array();
        }
        if (!is_array($packagelist['p'])) {
            $packagelist['p'] = array($packagelist['p']);
        }
        return $packagelist['p'];
    }

    /**
     * List all categories of a REST server
     *
     * @param string $base base URL of the server
     * @return array of categorynames
     */
    function listCategories($base)
    {
        $categories = array();

        // c/categories.xml does not exist;
        // check for every package its category manually
        // This is SLOOOWWWW : ///
        try {
            $packagelist = $this->rest->retrieveData($base . 'p/packages.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Could not list categories', $e);
        }
        if (!is_array($packagelist) || !isset($packagelist['p'])) {
            $ret = array();
            return $ret;
        }
        if (!is_array($packagelist['p'])) {
            $packagelist['p'] = array($packagelist['p']);
        }

        try {
            foreach ($packagelist['p'] as $package) {
                $inf = $this->rest->retrieveData($base . 'p/' . strtolower($package) . '/info.xml');
                $cat = $inf['ca']['_content'];
                if (!isset($categories[$cat])) {
                    $categories[$cat] = $inf['ca'];
                }
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Could not list categories', $e);
        }
        return array_values($categories);
    }

    /**
     * List a category of a REST server
     *
     * @param string $base base URL of the server
     * @param string $category name of the category
     * @param boolean $info also download full package info
     * @return array of packagenames
     */
    function listCategory($base, $category, $info=false)
    {
        // gives '404 Not Found' error when category doesn't exist
        try {
            $packagelist = $this->rest->retrieveData($base.'c/'.urlencode($category).'/packages.xml');
        } catch (PEAR2_Pyrus_REST_HTTPException $e) {
            throw new PEAR2_Pyrus_REST_Exception('Unknown category ' . $category, $e);
        }
        if (!is_array($packagelist) || !isset($packagelist['p'])) {
            return array();
        }
        if (!is_array($packagelist['p']) ||
            !isset($packagelist['p'][0])) { // only 1 pkg
            $packagelist = array($packagelist['p']);
        } else {
            $packagelist = $packagelist['p'];
        }

        if ($info == true) {
            // get individual package info
            foreach ($packagelist as $i => $packageitem) {
                $url = sprintf('%s'.'r/%s/latest.txt',
                        $base,
                        strtolower($packageitem['_content']));
                try {
                    $version = $this->rest->retrieveData($url);
                } catch (Exception $e) {
                    break; // skipit
                }
                $url = sprintf('%s'.'r/%s/%s.xml',
                        $base,
                        strtolower($packageitem['_content']),
                        $version);
                try {
                    $info = $this->rest->retrieveData($url);
                } catch (Exception $e) {
                    break; // skipit
                }
                $packagelist[$i]['info'] = $info;
            }
        }

        return $packagelist;
    }


    function listAll($base, $dostable, $basic = true, $searchpackage = false, $searchsummary = false)
    {
        try {
            $packagelist = $this->rest->retrieveData($base . 'p/packages.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Could not retrieve package list to list all',
                $e);
        }
        $ret = array();
        if (!is_array($packagelist) || !isset($packagelist['p'])) {
            return $ret;
        }
        if (!is_array($packagelist['p'])) {
            $packagelist['p'] = array($packagelist['p']);
        }

        // only search-packagename = quicksearch !
        if ($searchpackage && (!$searchsummary || empty($searchpackage))) {
            $newpackagelist = array();
            foreach ($packagelist['p'] as $package) {
                if (!empty($searchpackage) && stristr($package, $searchpackage) !== false) {
                    $newpackagelist[] = $package;
                }
            }
            $packagelist['p'] = $newpackagelist;
        }
        foreach ($packagelist['p'] as $progress => $package) {
            if ($basic) { // remote-list command
                try {
                    if ($dostable) {
                        $latest = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
                            '/stable.txt');
                    } else {
                        $latest = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
                            '/latest.txt');
                    }
                } catch (Exception $e) {
                    $latest = false;
                }
                $info = array('stable' => $latest);
            } else { // list-all command
                try {
                    $inf = $this->rest->retrieveData($base . 'p/' . strtolower($package) . '/info.xml');
                } catch (Exception $e) {
                    throw new PEAR2_Pyrus_REST_Exception(
                        'Cannot list all, can\'t get package info for ' . $package, $e);
                }
                if ($searchpackage) {
                    $found = (!empty($searchpackage) && stristr($package, $searchpackage) !== false);
                    if (!$found && !(isset($searchsummary) && !empty($searchsummary)
                        && (stristr($inf['s'], $searchsummary) !== false
                            || stristr($inf['d'], $searchsummary) !== false)))
                    {
                        continue;
                    };
                }
                try {
                    $releases = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
                        '/allreleases.xml');
                } catch (Exception $e) {
                    continue;
                }
                if (!isset($releases['r'][0])) {
                    $releases['r'] = array($releases['r']);
                }
                unset($latest);
                unset($unstable);
                unset($stable);
                unset($state);
                foreach ($releases['r'] as $release) {
                    if (!isset($latest)) {
                        if ($dostable && $release['s'] == 'stable') {
                            $latest = $release['v'];
                            $state = 'stable';
                        }
                        if (!$dostable) {
                            $latest = $release['v'];
                            $state = $release['s'];
                        }
                    }
                    if (!isset($stable) && $release['s'] == 'stable') {
                        $stable = $release['v'];
                        if (!isset($unstable)) {
                            $unstable = $stable;
                        }
                    }
                    if (!isset($unstable) && $release['s'] != 'stable') {
                        $latest = $unstable = $release['v'];
                        $state = $release['s'];
                    }
                    if (isset($latest) && !isset($state)) {
                        $state = $release['s'];
                    }
                    if (isset($latest) && isset($stable) && isset($unstable)) {
                        break;
                    }
                }
                $deps = array();
                if (!isset($unstable)) {
                    $unstable = false;
                    $state = 'stable';
                    if (isset($stable)) {
                        $latest = $unstable = $stable;
                    }
                } else {
                    $latest = $unstable;
                }
                if (!isset($latest)) {
                    $latest = false;
                }
                if ($latest) {
                    try {
                        $d = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package) . '/deps.' .
                           $latest . '.txt');
                        $d = unserialize($d);
                        if ($d) {
                            $pf = new PEAR2_Pyrus_PackageFile_v2;
                            $deps = $pf->dependencies;
                        }
                    } catch (Exception $e) {
                        $deps = false;
                    }
                }
                if (!isset($stable)) {
                    $stable = '-n/a-';
                }
                if (!$searchpackage) {
                    $info = array('stable' => $latest, 'summary' => $inf['s'], 'description' =>
                        $inf['d'], 'deps' => $deps, 'category' => $inf['ca']['_content'],
                        'unstable' => $unstable, 'state' => $state);
                } else {
                    $info = array('stable' => $stable, 'summary' => $inf['s'], 'description' =>
                        $inf['d'], 'deps' => $deps, 'category' => $inf['ca']['_content'],
                        'unstable' => $unstable, 'state' => $state);
                }
            }
            $ret[$package] = $info;
        }
        return $ret;
    }

    function listLatestUpgrades($base, $pref_state, $installed, $channel, &$reg)
    {
        try {
            $packagelist = $this->rest->retrieveData($base . 'p/packages.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Could not retrieve latest upgrades', $e);
        }
        $ret = array();
        if (!is_array($packagelist) || !isset($packagelist['p'])) {
            return $ret;
        }
        if (!is_array($packagelist['p'])) {
            $packagelist['p'] = array($packagelist['p']);
        }
        foreach ($packagelist['p'] as $package) {
            if (!isset($installed[strtolower($package)])) {
                continue;
            }
            $inst_version = $reg->packageInfo($package, 'version', $channel);
            $inst_state = $reg->packageInfo($package, 'release_state', $channel);
            try {
                $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
                    '/allreleases.xml');
            } catch (Exception $e) {
                continue; // no remote releases
            }
            if (!isset($info['r'])) {
                continue;
            }
            $found = false;
            $release = false;
            if (!is_array($info['r']) || !isset($info['r'][0])) {
                $info['r'] = array($info['r']);
            }
            // $info['r'] is sorted by version number
            foreach ($info['r'] as $release) {
                if ($inst_version && version_compare($release['v'], $inst_version, '<=')) {
                    // not newer than the one installed
                    break;
                }

                // new version > installed version
                if (!$pref_state) {
                    // every state is a good state
                    $found = true;
                    break;
                } else {
                    $new_state = $release['s'];
                    // if new state >= installed state: go
                    if (in_array($new_state, PEAR2_Pyrus_Installer::betterStates($inst_state, true))) {
                        $found = true;
                        break;
                    } else {
                        // only allow to lower the state of package,
                        // if new state >= preferred state: go
                        if (in_array($new_state, PEAR2_Pyrus_Installer::betterStates($pref_state, true))) {
                            $found = true;
                            break;
                        }
                    }
                }
            }
            if (!$found) {
                continue;
            }
            try {
                $relinfo = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package) . '/' .
                $release['v'] . '.xml');
            } catch (Exception $e) {
                throw new PEAR2_Pyrus_REST_Exception('Cannot retrieve latest upgrade release' .
                    ' information for package ' . $package, $e);
            }
            $ret[$package] = array(
                    'version' => $release['v'],
                    'state' => $release['s'],
                    'filesize' => $relinfo['f'],
                );
        }
        return $ret;
    }

    function packageInfo($base, $package)
    {
        try {
            $pinfo = $this->rest->retrieveData($base . 'p/' . strtolower($package) . '/info.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Unknown package: "' . $package . '"', $e);
        }
        $releases = array();
        try {
            $allreleases = $this->rest->retrieveData($base . 'r/' . strtolower($package) .
                '/allreleases.xml');
            if (!is_array($allreleases['r']) || !isset($allreleases['r'][0])) {
                $allreleases['r'] = array($allreleases['r']);
            }
            $pf = new PEAR2_Pyrus_PackageFile_v2;
            foreach ($allreleases['r'] as $release) {
                try {
                    $ds = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package) . '/deps.' .
                        $release['v'] . '.txt');
                } catch (Exception $e) {
                    continue;
                }
                if (!isset($latest)) {
                    $latest = $release['v'];
                }
                $pf->dependencies = unserialize($ds);
                $ds = $pf->dependencies;
                try {
                    $info = $this->rest->retrieveCacheFirst($base . 'r/' . strtolower($package)
                        . '/' . $release['v'] . '.xml');
                } catch (Exception $e) {
                    continue;
                }
                $releases[$release['v']] = array(
                    'doneby' => $info['m'],
                    'license' => $info['l'],
                    'summary' => $info['s'],
                    'description' => $info['d'],
                    'releasedate' => $info['da'],
                    'releasenotes' => $info['n'],
                    'state' => $release['s'],
                    'deps' => $ds ? $ds : array(),
                );
            }
        } catch (Exception $e) {
            $latest = '';
        }
        if (isset($pinfo['dc']) && isset($pinfo['dp'])) {
            if (is_array($pinfo['dp'])) {
                $deprecated = array('channel' => (string) $pinfo['dc'],
                                    'package' => trim($pinfo['dp']['_content']));
            } else {
                $deprecated = array('channel' => (string) $pinfo['dc'],
                                    'package' => trim($pinfo['dp']));
            }
        } else {
            $deprecated = false;
        }
        return array(
            'name' => $pinfo['n'],
            'channel' => $pinfo['c'],
            'category' => $pinfo['ca']['_content'],
            'stable' => $latest,
            'license' => $pinfo['l'],
            'summary' => $pinfo['s'],
            'description' => $pinfo['d'],
            'releases' => $releases,
            'deprecated' => $deprecated,
            );
    }
}
?><?php
/**
 * PEAR2_Pyrus_REST_11 - implement faster list-all/remote-list command
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implement REST 1.1
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_REST_11 extends PEAR2_Pyrus_REST_10
{

    function listAll($base, $dostable, $basic = true)
    {
        $categorylist = $this->_rest->retrieveData($base . 'c/categories.xml');
        if (PEAR::isError($categorylist)) {
            return $categorylist;
        }
        $ret = array();
        if (!is_array($categorylist['c']) || !isset($categorylist['c'][0])) {
            $categorylist['c'] = array($categorylist['c']);
        }
        PEAR::pushErrorHandling(PEAR_ERROR_RETURN);

        foreach ($categorylist['c'] as $progress => $category) {
            $category = $category['_content'];
            $packagesinfo = $this->_rest->retrieveData($base .
                'c/' . urlencode($category) . '/packagesinfo.xml');

            if (PEAR::isError($packagesinfo)) {
                continue;
            }

            if (!is_array($packagesinfo) || !isset($packagesinfo['pi'])) {
                continue;
            }

            if (!is_array($packagesinfo['pi']) || !isset($packagesinfo['pi'][0])) {
                $packagesinfo['pi'] = array($packagesinfo['pi']);
            }

            foreach ($packagesinfo['pi'] as $packageinfo) {
                $info = $packageinfo['p'];
                $package = $info['n'];
                $releases = isset($packageinfo['a']) ? $packageinfo['a'] : false;
                unset($latest);
                unset($unstable);
                unset($stable);
                unset($state);

                if ($releases) {
                    if (!isset($releases['r'][0])) {
                        $releases['r'] = array($releases['r']);
                    }
                    foreach ($releases['r'] as $release) {
                        if (!isset($latest)) {
                            if ($dostable && $release['s'] == 'stable') {
                                $latest = $release['v'];
                                $state = 'stable';
                            }
                            if (!$dostable) {
                                $latest = $release['v'];
                                $state = $release['s'];
                            }
                        }
                        if (!isset($stable) && $release['s'] == 'stable') {
                            $stable = $release['v'];
                            if (!isset($unstable)) {
                                $unstable = $stable;
                            }
                        }
                        if (!isset($unstable) && $release['s'] != 'stable') {
                            $unstable = $release['v'];
                            $state = $release['s'];
                        }
                        if (isset($latest) && !isset($state)) {
                            $state = $release['s'];
                        }
                        if (isset($latest) && isset($stable) && isset($unstable)) {
                            break;
                        }
                    }
                }

                if ($basic) { // remote-list command
                    if (!isset($latest)) {
                        $latest = false;
                    }
                    if ($dostable) {
                        // $state is not set if there are no releases
                        if (isset($state) && $state == 'stable') {
                            $ret[$package] = array('stable' => $latest);
                        } else {
                            $ret[$package] = array('stable' => '-n/a-');
                        }
                    } else {
                        $ret[$package] = array('stable' => $latest);
                    }
                    continue;
                }

                // list-all command
                $deps = array();
                if (!isset($unstable)) {
                    $unstable = false;
                    $state = 'stable';
                    if (isset($stable)) {
                        $latest = $unstable = $stable;
                    }
                } else {
                    $latest = $unstable;
                }

                if (!isset($latest)) {
                    $latest = false;
                }

                if ($latest && isset($packageinfo['deps'])) {
                    if (!is_array($packageinfo['deps']) ||
                          !isset($packageinfo['deps'][0])) {
                        $packageinfo['deps'] = array($packageinfo['deps']);
                    }
                    $d = false;
                    foreach ($packageinfo['deps'] as $dep) {
                        if ($dep['v'] == $latest) {
                            $d = unserialize($dep['d']);
                        }
                    }
                    if ($d) {
                        if (isset($d['required'])) {
                            if (!class_exists('PEAR_PackageFile_v2')) {
                                require_once 'PEAR/PackageFile/v2.php';
                            }
                            if (!isset($pf)) {
                                $pf = new PEAR_PackageFile_v2;
                            }
                            $pf->setDeps($d);
                            $tdeps = $pf->getDeps();
                        } else {
                            $tdeps = $d;
                        }
                        foreach ($tdeps as $dep) {
                            if ($dep['type'] !== 'pkg') {
                                continue;
                            }
                            $deps[] = $dep;
                        }
                    }
                }

                $info = array('stable' => $latest, 'summary' => $info['s'],
                    'description' =>
                    $info['d'], 'deps' => $deps, 'category' => $info['ca']['_content'],
                    'unstable' => $unstable, 'state' => $state);
                $ret[$package] = $info;
            }
        }
        PEAR::popErrorHandling();
        return $ret;
    }

    /**
     * List all categories of a REST server
     *
     * @param string $base base URL of the server
     * @return array of categorynames
     */
    function listCategories($base)
    {
        $categorylist = $this->_rest->retrieveData($base . 'c/categories.xml');
        if (PEAR::isError($categorylist)) {
            return $categorylist;
        }
        if (!is_array($categorylist) || !isset($categorylist['c'])) {
            return array();
        }
        if (isset($categorylist['c']['_content'])) {
            // only 1 category
            $categorylist['c'] = array($categorylist['c']);
        }
        return $categorylist['c'];
    }

    /**
     * List packages in a category of a REST server
     *
     * @param string $base base URL of the server
     * @param string $category name of the category
     * @param boolean $info also download full package info
     * @return array of packagenames
     */
    function listCategory($base, $category, $info=false)
    {
        if ($info == false) {
            $url = '%s'.'c/%s/packages.xml';
        } else {
            $url = '%s'.'c/%s/packagesinfo.xml';
        }
        $url = sprintf($url,
                    $base,
                    urlencode($category));

        // gives '404 Not Found' error when category doesn't exist
        $packagelist = $this->_rest->retrieveData($url);
        if (PEAR::isError($packagelist)) {
            return $packagelist;
        }
        if (!is_array($packagelist)) {
            return array();
        }

        if ($info == false) {
            if (!isset($packagelist['p'])) {
                return array();
            }
            if (!is_array($packagelist['p']) ||
                !isset($packagelist['p'][0])) { // only 1 pkg
                $packagelist = array($packagelist['p']);
            } else {
                $packagelist = $packagelist['p'];
            }
            return $packagelist;
        } else {
            // info == true
            if (!isset($packagelist['pi'])) {
                return array();
            }
            if (!is_array($packagelist['pi']) ||
                !isset($packagelist['pi'][0])) { // only 1 pkg
                $packagelist_pre = array($packagelist['pi']);
            } else {
                $packagelist_pre = $packagelist['pi'];
            }

            $packagelist = array();
            foreach ($packagelist_pre as $i => $item) {
                // compatibility with r/<latest.txt>.xml
                if (isset($item['a']['r'][0])) {
                    // multiple releases
                    $item['p']['v'] = $item['a']['r'][0]['v'];
                    $item['p']['st'] = $item['a']['r'][0]['s'];
                } elseif (isset($item['a'])) {
                    // first and only release
                    $item['p']['v'] = $item['a']['r']['v'];
                    $item['p']['st'] = $item['a']['r']['s'];
                }

                $packagelist[$i] = array('attribs' => $item['p']['r'],
                                         '_content' => $item['p']['n'],
                                         'info' => $item['p']);
            }
        }

        return $packagelist;
    }
}
?><?php
/**
 * PEAR_REST_13
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */


/**
 * Implement REST 1.3
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_REST_13 extends PEAR2_Pyrus_REST_10
{
    /**
     * Retrieve information about a remote package to be downloaded from a REST server
     *
     * This is smart enough to resolve the minimum PHP version dependency prior to download
     * @param string $base The uri to prepend to all REST calls
     * @param array $packageinfo an array of format:
     * <pre>
     *  array(
     *   'package' => 'packagename',
     *   'channel' => 'channelname',
     *  ['state' => 'alpha' (or valid state),]
     *  -or-
     *  ['version' => '1.whatever']
     * </pre>
     * @param string $prefstate Current preferred_state config variable value
     * @param bool $installed the installed version of this package to compare against
     * @return array|false|PEAR_Error see {@link returnDownloadURL(()}
     */
    function getDownloadURL($base, $packageinfo, $prefstate, $installed)
    {
        $channel = $packageinfo['channel'];
        $package = $packageinfo['package'];
        $states = PEAR2_Pyrus_Installer::betterStates($prefstate, true);
        if (!$states) {
            throw new PEAR2_Pyrus_REST_Exception('"' . $prefstate . '" is not a valid state');
        }
        $state   = isset($packageinfo['state'])   ? $packageinfo['state']   : null;
        $version = isset($packageinfo['version']) ? $packageinfo['version'] : null;
        try {
            $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) . '/allreleases2.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('No releases available for package "' .
                $channel . '/' . $package . '"', $e);
        }
        if (!isset($info['r'])) {
            return false;
        }
        $release = $found = false;
        if (!is_array($info['r']) || !isset($info['r'][0])) {
            $info['r'] = array($info['r']);
        }
        $skippedphp = false;
        foreach ($info['r'] as $release) {
            if (!isset($this->options['force']) && ($installed &&
                  version_compare($release['v'], $installed, '<'))) {
                continue;
            }
            if (isset($state)) {
                // try our preferred state first
                if ($release['s'] == $state) {
                    if (!isset($version) && version_compare($release['m'], phpversion(), '>')) {
                        // skip releases that require a PHP version newer than our PHP version
                        $skippedphp = $release;
                        continue;
                    }
                    $found = true;
                    break;
                }
                // see if there is something newer and more stable
                // bug #7221
                if (in_array($release['s'], PEAR2_Pyrus_Installer::betterStates($state), true)) {
                    if (!isset($version) && version_compare($release['m'], phpversion(), '>')) {
                        // skip releases that require a PHP version newer than our PHP version
                        $skippedphp = $release;
                        continue;
                    }
                    $found = true;
                    break;
                }
            } elseif (isset($version)) {
                if ($release['v'] == $version) {
                    if (!isset($this->options['force']) &&
                          !isset($version) &&
                          version_compare($release['m'], phpversion(), '>')) {
                        // skip releases that require a PHP version newer than our PHP version
                        $skippedphp = $release;
                        continue;
                    }
                    $found = true;
                    break;
                }
            } else {
                if (in_array($release['s'], $states)) {
                    if (version_compare($release['m'], phpversion(), '>')) {
                        // skip releases that require a PHP version newer than our PHP version
                        $skippedphp = $release;
                        continue;
                    }
                    $found = true;
                    break;
                }
            }
        }
        if (!$found && $skippedphp) {
            $found = null;
        }
        return $this->returnDownloadURL($base, $package, $release, $info, $found, $skippedphp);
    }

    function getDepDownloadURL($base, $dependency, $deppackage,
                               $prefstate = 'stable', $installed = false)
    {
        $channel = $dependency['channel'];
        $package = $dependency['name'];
        $states = PEAR2_Pyrus_Installer::betterStates($prefstate, true);
        if (!$states) {
            throw new PEAR2_Pyrus_REST_Exception('"' . $prefstate . '" is not a valid state');
        }
        $state   = isset($dependency['state'])   ? $dependency['state']   : null;
        $version = isset($dependency['version']) ? $dependency['version'] : null;
        // FIXME aren't we just doing the same thing twice over here ?
        $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) .  '/allreleases2.xml');
        try {
            $info = $this->rest->retrieveData($base . 'r/' . strtolower($package) . '/allreleases2.xml');
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_REST_Exception('Package "' . $deppackage['channel'] . '/' . $deppackage['package']
                . '" dependency "' . $channel . '/' . $package . '" has no releases', $e);
        }
        if (!is_array($info) || !isset($info['r'])) {
            return false;
        }
        $exclude = array();
        $min = $max = $recommended = false;
        $pinfo['package'] = $dependency['name'];
        $min = isset($dependency['min']) ? $dependency['min'] : false;
        $max = isset($dependency['max']) ? $dependency['max'] : false;
        $recommended = isset($dependency['recommended']) ? $dependency['recommended'] : false;
        if (isset($dependency['exclude'])) {
            if (!isset($dependency['exclude'][0])) {
                $exclude = array($dependency['exclude']);
            }
        }

        $skippedphp = $release = $found = false;
        if (!is_array($info['r']) || !isset($info['r'][0])) {
            $info['r'] = array($info['r']);
        }
        foreach ($info['r'] as $release) {
            if (!isset($this->options['force']) && ($installed &&
                  version_compare($release['v'], $installed, '<'))) {
                continue;
            }
            if (in_array($release['v'], $exclude)) { // skip excluded versions
                continue;
            }
            // allow newer releases to say "I'm OK with the dependent package"
            if (isset($release['co'])) {
                if (!is_array($release['co']) || !isset($release['co'][0])) {
                    $release['co'] = array($release['co']);
                }
                foreach ($release['co'] as $entry) {
                    if (isset($entry['x']) && !is_array($entry['x'])) {
                        $entry['x'] = array($entry['x']);
                    } elseif (!isset($entry['x'])) {
                        $entry['x'] = array();
                    }
                    if ($entry['c'] == $deppackage['channel'] &&
                          strtolower($entry['p']) == strtolower($deppackage['package']) &&
                          version_compare($deppackage['version'], $entry['min'], '>=') &&
                          version_compare($deppackage['version'], $entry['max'], '<=') &&
                          !in_array($release['v'], $entry['x'])) {
                        if (version_compare($release['m'], phpversion(), '>')) {
                            // skip dependency releases that require a PHP version
                            // newer than our PHP version
                            $skippedphp = $release;
                            continue;
                        }
                        $recommended = $release['v'];
                        break;
                    }
                }
            }
            if ($recommended) {
                if ($release['v'] != $recommended) { // if we want a specific
                    // version, then skip all others
                    continue;
                } else {
                    if (!in_array($release['s'], $states)) {
                        // the stability is too low, but we must return the
                        // recommended version if possible
                        return $this->returnDownloadURL($base, $package, $release, $info, true);
                    }
                }
            }
            if ($min && version_compare($release['v'], $min, 'lt')) { // skip too old versions
                continue;
            }
            if ($max && version_compare($release['v'], $max, 'gt')) { // skip too new versions
                continue;
            }
            if ($installed && version_compare($release['v'], $installed, '<')) {
                continue;
            }
            if (in_array($release['s'], $states)) { // if in the preferred state...
                if (version_compare($release['m'], phpversion(), '>')) {
                    // skip dependency releases that require a PHP version
                    // newer than our PHP version
                    $skippedphp = $release;
                    continue;
                }
                $found = true; // ... then use it
                break;
            }
        }
        if (!$found && $skippedphp) {
            $found = null;
        }
        return $this->returnDownloadURL($base, $package, $release, $info, $found, $skippedphp);
    }
}<?php
/**
 * PEAR2_Pyrus_REST_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for REST
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_REST_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_REST_HTTPException
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception for REST HTTP
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_REST_HTTPException extends PEAR2_Pyrus_REST_Exception {}<?php
/**
 * This script handles the command line interface commands to Pyrus
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * This script handles the command line interface commands to Pyrus
 *
 * Each command is a separate method, and will be called with the arguments
 * entered by the end user.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ScriptFrontend_Commands implements PEAR2_Pyrus_ILog
{
    public $commands = array();
    // for unit-testing ease
    public static $configclass = 'PEAR2_Pyrus_Config';
    public static $downloadClass = 'PEAR2_HTTP_Request';
    protected $term = array(
        'bold'   => '',
        'normal' => '',
    );

    function __construct()
    {
        PEAR2_Pyrus_Log::attach($this);
        $a = new ReflectionClass($this);
        foreach ($a->getMethods() as $method) {
            $name = $method->name;
            if ($name[0] == '_' || $name === 'run' || $name === 'log') {
                continue;
            }
            $this->commands[preg_replace_callback('/[A-Z]/',
                    function($m) {return "-" . strtolower($m[0]);}, $name)] = $name;
        }
        $term = getenv('TERM');
        if (function_exists('posix_isatty') && !posix_isatty(1)) {
            // output is being redirected to a file or through a pipe
        } elseif ($term) {
            if (preg_match('/^(xterm|vt220|linux)/', $term)) {
                $this->term['bold']   = sprintf("%c%c%c%c", 27, 91, 49, 109);
                $this->term['normal'] = sprintf("%c%c%c", 27, 91, 109);
            } elseif (preg_match('/^vt100/', $term)) {
                $this->term['bold']   = sprintf("%c%c%c%c%c%c", 27, 91, 49, 109, 0, 0);
                $this->term['normal'] = sprintf("%c%c%c%c%c", 27, 91, 109, 0, 0);
            }
        }
    }

    function _bold($text)
    {
        if (empty($this->term['bold'])) {
            return strtoupper($text);
        }

        return $this->term['bold'] . $text . $this->term['normal'];
    }

    /**
     * This method acts as a controller which dispatches the request to the
     * correct command/method.
     *
     * <code>
     * $cli = PEAR2_Pyrus_ScriptFrontend_Commands();
     * $cli->run($args = array (0 => 'install',
     *                          1 => 'PEAR2/Pyrus_Developer/package.xml'));
     * </code>
     *
     * The above code will dispatch to the install command
     *
     * @param array $args An array of command line arguments.
     *
     * @return void
     */
    function run($args)
    {
        try {
            if (!count($args)) {
                $args[0] = 'help';
            }
            $this->_findPEAR($args);
            if (isset($this->commands[$args[0]])) {
                $command = array_shift($args);
                $command = $this->commands[$command];
                $this->$command($args);
            } else {
                $this->help($args);
            }
        } catch (Exception $e) {
            echo "Operation failed:\n$e";
        }
    }

    function _ask($question, array $choices = null, $default = null)
    {
        if (is_array($choices)) {
            foreach ($choices as $i => $choice) {
                if (is_int($i) && ($default === null || ($default !== null && !is_string($default)))) {
                    $is_int = false;
                } else {
                    $is_int = true;
                }
                break;
            }
        }
previous:
        echo $question,"\n";
        if ($choices !== null) {
            echo "Please choose:\n";
            foreach ($choices as $i => $choice) {
                if ($is_int) {
                    echo '  ',$choice,"\n";
                } else {
                    echo '  [',$i,'] ',$choice,"\n";
                }
            }
        }
        if ($default !== null) {
            echo '[',$default,']';
        }
        echo ' : ';
        $answer = $this->_readStdin();

        if (!strlen($answer)) {
            if ($default !== null) {
                $answer = $default;
            } else {
                $answer = null;
            }
        } elseif ($choices !== null) {
            if (($is_int && in_array($answer, $choices)) || (!$is_int && array_key_exists($answer, $choices))) {
                return $answer;
            } else {
                echo "Please choose one choice\n";
                goto previous;
            }
        }
        return $answer;
    }

    function _readStdin($amount = 1024)
    {
        return trim(fgets(STDIN, $amount));
    }

    function _findPEAR(&$arr)
    {
        if (isset($arr[0]) && @file_exists($arr[0]) && @is_dir($arr[0])) {
            $maybe = array_shift($arr);
            $maybe = realpath($maybe);
            echo "Using PEAR installation found at $maybe\n";
            $configclass = static::$configclass;
            $config = $configclass::singleton($maybe);
            return;
        }
        $configclass = static::$configclass;
        if (!$configclass::userInitialized()) {
            echo "Pyrus: No user configuration file detected\n";
            if ('yes' === $this->_ask("It appears you have not used Pyrus before, welcome!  Initialize install?", array('yes', 'no'), 'yes')) {
                echo "Great.  We will store your configuration in:\n  ",$configclass::getDefaultUserConfigFile(),"\n";
previous:
                $path = $this->_ask("Where would you like to install packages by default?", null, getcwd());
                echo "You have chosen:\n", $path, "\n";
                if (!realpath($path)) {
                    echo " this path does not yet exist\n";
                    if ('yes' !== $this->_ask("Create it?", array('yes', 'no'), 'yes')) {
                        goto previous;
                    }
                } elseif (!is_dir($path)) {
                    echo $path," exists, and is not a directory\n";
                    goto previous;
                }
                $configclass = static::$configclass;
                $config = $configclass::singleton($path);
                $config->saveConfig();
                echo "Thank you, enjoy using Pyrus\n";
                echo "Documentation is at http://pear.php.net\n";
            } else {
                echo "OK, thank you, finishing execution now\n";
                exit;
            }
        }
        $configclass = static::$configclass;
        $mypath = $configclass::current()->my_pear_path;
        if ($mypath) {
            foreach (explode(PATH_SEPARATOR, $mypath) as $path) {
                echo "Using PEAR installation found at $path\n";
                $configclass = static::$configclass;
                $config = $configclass::singleton($path);
                return;
            }
        }
    }

    /**
     * Display the help dialog and list all commands supported.
     *
     * @param array $args Array of command line arguments
     */
    function help($args)
    {
        if (isset($args[0]) && $args[0] == 'help') {
            echo "Commands supported:\n";
            foreach ($this->commands as $command => $true) {
                echo "$command\n";
            }
        } else {
            if (isset($args[0])) {
                echo "Unknown command: $args[0]\n";
            }
            echo "Commands supported:\n";
            foreach ($this->commands as $command => $true) {
                echo "$command [PEARPath]\n";
            }
        }
    }

    /**
     * install a local or remote package
     *
     * @param array $args
     */
    function install($args)
    {
        PEAR2_Pyrus_Installer::begin();
        try {
            $packages = array();
            foreach ($args as $arg) {
                PEAR2_Pyrus_Installer::prepare($packages[] = new PEAR2_Pyrus_Package($arg));
            }
            PEAR2_Pyrus_Installer::commit();
            foreach (PEAR2_Pyrus_Installer::getInstalledPackages() as $package) {
                echo 'Installed ' . $package->channel . '/' . $package->name . '-' .
                    $package->version['release'] . "\n";
                if ($package->type === 'extsrc' || $package->type === 'zendextsrc') {
                    echo " ==> To build this PECL package, use the build command\n";
                }
            }
        } catch (Exception $e) {
            echo $e;
            exit -1;
        }
    }

    /**
     * uninstall an installed package
     *
     * @param array $args
     */
    function uninstall($args)
    {
        PEAR2_Pyrus_Uninstaller::begin();
        try {
            $packages = $non = $failed = array();
            foreach ($args as $arg) {
                try {
                    if (!isset(PEAR2_Pyrus_Config::current()->registry->package[$arg])) {
                        $non[] = $arg;
                        continue;
                    }
                    $packages[] = PEAR2_Pyrus_Uninstaller::prepare($arg);
                } catch (Exception $e) {
                    $failed[] = $arg;
                }
            }
            PEAR2_Pyrus_Uninstaller::commit();
            foreach ($non as $package) {
                echo "Package $package not installed, cannot uninstall\n";
            }
            foreach ($packages as $package) {
                echo 'Uninstalled ', $package->channel, '/', $package->name, "\n";
            }
            foreach ($failed as $package) {
                echo "Package $package could not be uninstalled\n";
            }
        } catch (Exception $e) {
            echo $e;
            exit -1;
        }
    }

    /**
     * download a remote package
     *
     * @param array $args
     */
    function download($args)
    {
        PEAR2_Pyrus_Config::current()->download_dir = getcwd();
        $packages = array();
        foreach ($args as $arg) {
            try {
                $packages[] = array(new PEAR2_Pyrus_Package($arg), $arg);
            } catch (Exception $e) {
                echo "failed to init $arg for download (", $e->getMessage(), ")\n";
            }
        }
        foreach ($packages as $package) {
            $arg = $package[1];
            $package = $package[0];
            echo "Downloading ", $arg, '...';
            try {
                if ($package->isRemote()) {
                    $package->download();
                } else {
                    $package->copyTo(getcwd());
                }
                $path = $package->getInternalPackage()->getTarballPath();
                echo "done ($path)\n";
            } catch (Exception $e) {
                echo 'failed! (', $e->getMessage(), ")\n";
            }
        }
    }

    /**
     * Upgrade a package
     *
     * @param array $args
     */
    function upgrade($args)
    {
        PEAR2_Pyrus_Installer::$options['upgrade'] = true;
        $this->install($args);
    }

    /**
     * list all the installed packages
     *
     * @param array $args
     */
    function listPackages($args)
    {
        $reg = PEAR2_Pyrus_Config::current()->registry;
        $creg = PEAR2_Pyrus_Config::current()->channelregistry;
        $cascade = array(array($reg, $creg));
        $p = $reg;
        $c = $creg;
        while ($p = $p->getParent()) {
            $c = $c->getParent();
            $cascade[] = array($p, $c);
        }
        array_reverse($cascade);
        foreach ($cascade as $p) {
            $c = $p[1];
            $p = $p[0];
            echo "Listing installed packages [", $p->getPath(), "]:\n";
            $packages = array();
            foreach ($c as $channel) {
                PEAR2_Pyrus_Config::current()->default_channel = $channel->name;
                foreach ($p->package as $package) {
                    $packages[$channel->name][] = $package->name;
                }
            }
            asort($packages);
            foreach ($packages as $channel => $stuff) {
                echo "[channel $channel]:\n";
                foreach ($stuff as $package) {
                    echo " $package\n";
                }
            }
        }
    }

    /**
     * List all the known channels
     *
     * @param array $args
     */
    function listChannels($args)
    {
        $creg = PEAR2_Pyrus_Config::current()->channelregistry;
        $cascade = array($creg);
        while ($c = $creg->getParent()) {
            $cascade[] = $c;
            $creg = $c;
        }
        array_reverse($cascade);
        foreach ($cascade as $c) {
            echo "Listing channels [", $c->getPath(), "]:\n";
            foreach ($c as $channel) {
                echo $channel->name . ' (' . $channel->alias . ")\n";
            }
        }
    }

    /**
     * remotely connect to a channel server and grab the channel information,
     * then add it to the current pyrus managed repo
     *
     * @param array $args $args[0] should be the channel name, eg:pear.unl.edu
     */
    function channelDiscover($args)
    {
        // try secure first
        $chan = 'https://' . $args[0] . '/channel.xml';
        $dl = self::$downloadClass;
        $http = new $dl($chan);
        try {
            $response = $http->sendRequest();
            if ($response->code != 200) {
                throw new Exception('Download of channel.xml failed');
            }
addchan_success:    
            $chan = new PEAR2_Pyrus_Channel(new PEAR2_Pyrus_ChannelFile($response->body, true));
            PEAR2_Pyrus_Config::current()->channelregistry->add($chan);
            echo "Discovery of channel ", $chan->name, " successful\n";
        } catch (Exception $e) {
            try {
                $chan = 'http://' . $args[0] . '/channel.xml';
                $http = new $dl($chan);
                $response = $http->sendRequest();
                if ($response->code != 200) {
                    throw new Exception('Download of channel.xml failed');
                }
                goto addchan_success;
            } catch (Exception $e) {
                // failed, re-throw original error
                echo "Discovery of channel ", $args[0], " failed: ", $e->getMessage();
            }
        }
    }

    /**
     * add a channel to the current pyrus managed path using the raw channel.xml
     *
     * @param array $args $args[0] should be the channel.xml filename
     */
    function channelAdd($args)
    {
        echo "Adding channel from channel.xml:\n";
        $chan = new PEAR2_Pyrus_Channel(new PEAR2_Pyrus_ChannelFile($args[0]));
        PEAR2_Pyrus_Config::current()->channelregistry->add($chan);
        echo "Adding channel ", $chan->name, " successful\n";
    }

    function channelDel($args)
    {
        $chan = PEAR2_Pyrus_Config::current()->channelregistry->get($args[0], false);
        if (count(PEAR2_Pyrus_Config::current()->registry->listPackages($chan->name))) {
            echo "Cannot remove channel ", $chan->name, " packages are installed\n";
            exit -1;
        }
        PEAR2_Pyrus_Config::current()->channelregistry->delete($chan);
        echo "Deleting channel ", $chan->name, " successful\n";
    }

    function upgradeRegistry($args)
    {
        if (!file_exists($args[0]) || !is_dir($args[0])) {
            echo "Cannot upgrade registries at ", $args[0], ", path does not exist or is not a directory\n";
            exit -1;
        }
        echo "Upgrading registry at path ", $args[0], "\n";
        $registries = PEAR2_Pyrus_Registry::detectRegistries($args[0]);
        if (!count($registries)) {
            echo "No registries found\n";
            exit;
        }
        if (!in_array('Pear1', $registries)) {
            echo "Registry already upgraded\n";
            exit;
        }
        $pear1 = new PEAR2_Pyrus_Registry_Pear1($args[0]);
        if (!in_array('Sqlite3', $registries)) {
            $sqlite3 = new PEAR2_Pyrus_Registry_Sqlite3($args[0]);
            $sqlite3->cloneRegistry($pear1);
        }
        if (!in_array('Xml', $registries)) {
            $xml = new PEAR2_Pyrus_Registry_Xml($args[0]);
            $sqlite3 = new PEAR2_Pyrus_Registry_Sqlite3($args[0]);
            $xml->cloneRegistry($sqlite3);
        }
        if (isset($args[1]) && $args[1] == '--removeold') {
            PEAR2_Pyrus_Registry_Pear1::removeRegistry($args[0]);
        }
    }

    function runScripts($args)
    {
        $runner = new PEAR2_Pyrus_ScriptRunner($this);
        $reg = PEAR2_Pyrus_Config::current()->registry;
        foreach ($args as $package) {
            $package = $reg->package[$package];
            $runner->run($package);
        }
    }

    /**
     * Display pyrus configuration vars
     *
     * @param array $args
     */
    function configShow($args)
    {
        $conf = PEAR2_Pyrus_Config::current();
        echo "System paths:\n";
        foreach ($conf->mainsystemvars as $var) {
            echo "  $var => " . $conf->$var . "\n";
        }
        echo "Custom System paths:\n";
        foreach ($conf->customsystemvars as $var) {
            echo "  $var => " . $conf->$var . "\n";
        }
        echo "User config (from " . $conf->userfile . "):\n";
        foreach ($conf->mainuservars as $var) {
            echo "  $var => " . $conf->$var . "\n";
        }
        echo "Custom User config (from " . $conf->userfile . "):\n";
        foreach ($conf->customuservars as $var) {
            echo "  $var => " . $conf->$var . "\n";
        }
    }

    /**
     * Set a configuration option.
     *
     * @param array $args
     */
    function set($args)
    {
        $conf = PEAR2_Pyrus_Config::current();
        if (in_array($args[0], $conf->uservars)) {
            echo "Setting $args[0] in " . $conf->userfile . "\n";
            $conf->{$args[0]} = $args[1];
        } elseif (in_array($args[0], $conf->systemvars)) {
            echo "Setting $args[0] in system paths\n";
            $conf->{$args[0]} = $args[1];
        } else {
            echo "Unknown config variable: $args[0]\n";
            exit -1;
        }
        $conf->saveConfig();
    }

    /**
     * Set up a pear path managed by pyrus.
     *
     * @param array $args Arguments
     */
    function mypear($args)
    {
        echo "Setting my pear repositories to:\n";
        echo implode("\n", $args) . "\n";
        $args = implode(PATH_SEPARATOR, $args);
        PEAR2_Pyrus_Config::current()->my_pear_path = $args;
        PEAR2_Pyrus_Config::current()->saveConfig();
    }

    function build($args)
    {
        echo "Building PECL extensions\n";
        $builder = new PEAR2_Pyrus_PECLBuild($this);
        foreach ($args as $arg) {
            $package = PEAR2_Pyrus_Config::current()->registry->package[$arg];
            $builder->installBuiltStuff($package, $builder->build($package));
        }
    }

    /**
     * This is why we need to move to a better CLI system...
     *
     * make it possible to call confirmDialog() without it showing up as a command
     */
    function __call($func, $params)
    {
        if ($func === 'confirmDialog') {
            return $this->_confirmDialog($params[0]);
        }
        if ($func === 'display') {
            return $this->_display($params[0]);
        }
        if ($func === 'ask') {
            return call_user_func_array(array($this, '_ask'), $params);
        }
        throw new \Exception('Unknown method ' . $func . ' in class PEAR2_Pyrus_ScriptFrontend\Commands');
    }

    /**
     * Ask for user input, confirm the answers and continue until the user is satisfied
     * @param array an array of arrays, format array('name' => 'paramname', 'prompt' =>
     *              'text to display', 'type' => 'string'[, default => 'default value'])
     * @return array
     */
    function _confirmDialog($params)
    {
        $answers = $prompts = $types = array();
        foreach ($params as $param) {
            $prompts[$param['name']] = $param['prompt'];
            $types[$param['name']]   = $param['type'];
            $answers[$param['name']] = isset($param['default']) ? $param['default'] : '';
        }

        $tried = false;
        do {
            if ($tried) {
                $i = 1;
                foreach ($answers as $var => $value) {
                    if (!strlen($value)) {
                        echo $this->_bold("* Enter an answer for #" . $i . ": ({$prompts[$var]})\n");
                    }
                    $i++;
                }
            }

            $answers = $this->_userDialog('', $prompts, $types, $answers);
            $tried   = true;
        } while (is_array($answers) && count(array_filter($answers)) != count($prompts));

        return $answers;
    }

    function _display($text)
    {
        echo $text, "\n";
    }

    function _userDialog($command, $prompts, $types = array(), $defaults = array(), $screensize = 20)
    {
        if (!is_array($prompts)) {
            return array();
        }

        $testprompts = array_keys($prompts);
        $result      = $defaults;

        reset($prompts);
        if (count($prompts) === 1) {
            foreach ($prompts as $key => $prompt) {
                $type    = $types[$key];
                $default = isset($defaults[$key]) ? $defaults[$key] : false;
                print "$prompt ";
                if ($default) {
                    print "[$default] ";
                }
                print ": ";

                $line         = $this->_readStdin(2048);
                $result[$key] =  ($default && trim($line) == '') ? $default : trim($line);
            }

            return $result;
        }

        $first_run = true;
        while (true) {
            $descLength = max(array_map('strlen', $prompts));
            $descFormat = "%-{$descLength}s";
            $last       = count($prompts);

            $i = 0;
            foreach ($prompts as $n => $var) {
                $res = isset($result[$n]) ? $result[$n] : null;
                printf("%2d. $descFormat : %s\n", ++$i, $prompts[$n], $res);
            }
            print "\n1-$last, 'all', 'abort', or Enter to continue: ";

            $tmp = $this->_readStdin();
            if (empty($tmp)) {
                break;
            }

            if ($tmp == 'abort') {
                return false;
            }

            if (isset($testprompts[(int)$tmp - 1])) {
                $var     = $testprompts[(int)$tmp - 1];
                $desc    = $prompts[$var];
                $current = @$result[$var];
                print "$desc [$current] : ";
                $tmp = $this->_readStdin();
                if ($tmp !== '') {
                    $result[$var] = $tmp;
                }
            } elseif ($tmp == 'all') {
                foreach ($prompts as $var => $desc) {
                    $current = $result[$var];
                    print "$desc [$current] : ";
                    $tmp = $this->_readStdin();
                    if (trim($tmp) !== '') {
                        $result[$var] = trim($tmp);
                    }
                }
            }

            $first_run = false;
        }

        return $result;
    }

    function log($level, $message)
    {
        static $data = array();
        if (PEAR2_Pyrus_Config::initializing()) {
            // we can't check verbose until initializing is complete, so save
            // the message, and only display the log after config is initialized
            $data[] = array($level, $message);
            return;
        }
        if (count($data)) {
            $save = $data;
            $data = array();
            foreach ($save as $info) {
                $this->log($info[0], $info[1]);
            }
        }
        if ($level <= PEAR2_Pyrus_Config::current()->verbose) {
            echo $message, "\n";
        }
    }
}
<?php
/**
 * PEAR2_Pyrus_Task_Exception_InvalidTask
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus Tasks that are invalid for other reasons
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Exception_InvalidTask extends PEAR2_Pyrus_Task_Exception
{
    function __construct($task, $file, $reason)
    {
        parent::__construct('task <' . $task . '> in file ' . $file .
                    ' is invalid because of "' . $reason . '"');
    }
}<?php
/**
 * PEAR2_Pyrus_Task_Exception_MissingAttribute
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus Tasks that are invalid due to a missing attribute
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Exception_MissingAttribute extends PEAR2_Exception
{
    function __construct($task, $attribute, $file)
    {
        parent::__construct('task <' . $task . '> is missing attribute "' . $attribute .
                    '" in file ' . $file);
    }
}<?php
/**
 * PEAR2_Pyrus_Task_Exception_NoAttributes
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus Tasks that are invalid because there are no attributes present
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Exception_NoAttributes extends PEAR2_Exception
{
    function __construct($task, $file)
    {
        parent::__construct('task <' . $task . '> has no attributes in file ' . $file);
    }
}<?php
/**
 * PEAR2_Pyrus_Task_Exception_WrongAttributeValue
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus Tasks that are invalid because the attribute value is invalid
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Exception_WrongAttributeValue extends PEAR2_Exception
{
    function __construct($task, $attribute, $wrongvalue, $file, array $validvalues)
    {
        parent::__construct('task <' . $task . '> attribute "' . $attribute .
                    '" has the wrong value "' . $wrongvalue . '" '.
                    'in file ' . $file . ', expecting one of "' . implode (', ', $validvalues) . '"');
    }
}<?php
/**
 * <tasks:postinstallscript> paramgroup param object
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements the postinstallscript file task <param> tag
 *
 * Sample usage:
 *
 * <code>
 * $task->paramgroup['nameid']->instructions('hi there')
 *  ->condition($task->paramgroup['previous']->param['paramname'], '>=', '25')
 *  ->param['paramname']->prompt('blah')->type('string')->defaultValue('hi');
 * </code>
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Postinstallscript_Paramgroup_Param implements ArrayAccess, Iterator, Countable
{
    protected $info;
    protected $index = null;
    protected $parent;
    protected $tasksNs;

    function __construct($tasksNs, $parent, array $info, $index = null)
    {
        if ($tasksNs) {
            if ($tasksNs[strlen($tasksNs)-1] != ':') {
                $tasksNs .= ':';
            }
        } else {
            $tasksNs = '';
        }
        $this->tasksNs = $tasksNs;
        $this->parent = $parent;
        $this->info = $info;
        $this->index = $index;
    }

    function count()
    {
        return count($this->info);
    }

    function current()
    {
        $i = key($this->info);
        foreach (array('name', 'prompt', 'type', 'default') as $key) {
            if (!array_key_exists($this->tasksNs . $key, $this->info[$i])) {
                $this->info[$i][$this->tasksNs . $key] = null;
            }
        }
        return new self($this->tasksNs, $this, $this->info[$i], $i);
    }

    function rewind()
    {
        reset($this->info);
    }

    function key()
    {
        $i = key($this->info);
        return $this->info[$i][$this->tasksNs . 'id'];
    }

    function next()
    {
        return next($this->info);
    }

    function valid()
    {
        return current($this->info);
    }

    function locateParam($name)
    {
        foreach ($this->info as $i => $param)
        {
            if (isset($param[$this->tasksNs . 'name']) && $param[$this->tasksNs . 'name'] == $name) {
                return $i;
            }
        }
        return false;
    }

    function offsetGet($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use -> operator to access param properties');
        }
        $i = $this->locateParam($var);
        if (false === $i) {
            $i = count($this->info);
            $this->info[$i] = array($this->tasksNs . 'name' => $var,
                                    $this->tasksNs . 'prompt' => null,
                                    $this->tasksNs . 'type' => null,
                                    $this->tasksNs . 'default' => null);
        } else {
            foreach (array('name', 'prompt', 'type', 'default') as $key) {
                if (!array_key_exists($this->tasksNs . $key, $this->info[$i])) {
                    $this->info[$i][$this->tasksNs . $key] = null;
                }
            }
        }
        return new self($this->tasksNs, $this, $this->info[$i], $i);
    }

    function offsetSet($var, $value)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_PackageFile_v2_Dependencies_Exception('Use -> operator to access param properties');
        }
        if (!($value instanceof self)) {
            throw new PEAR2_Pyrus_Task_Exception('Can only set $param[\'' .
                $var .
                '\'] to PEAR2_Pyrus_Task_Postinstallscript_Paramgroup_Param object');
        }
        if ($var === null) {
            $var = $value->id;
        }
        if ($value->id != $var) {
            throw new PEAR2_Pyrus_Task_Exception('Cannot set ' .
                $var . ' to ' .
                $value->id .
                ', use $param[] to set a new value');
        }
        if (false === ($i = $this->locateParam($var))) {
            $i = count($this->info);
        }
        $this->info[$i] = $value->getInfo();
        $this->save();
    }

    function offsetExists($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use -> operator to access param properties');
        }
        $i = $this->locateParam($var);
        return $i !== false;
    }

    function offsetUnset($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use -> operator to access param properties');
        }
        $i = $this->locateParam($var);
        if ($i === false) {
            return;
        }
        unset($this->info[$i]);
        $this->info = array_values($this->info);
        $this->save();
    }

    function __get($var)
    {
        if ($var === 'paramgroup') {
            if ($this->parent instanceof self) {
                return $this->parent->paramgroup;
            }
            return $this->parent;
        }
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use [] operator to access params');
        }
        if (!array_key_exists($this->tasksNs . $var, $this->info)) {
            $info = array_keys($this->info);
            $a = $this->tasksNs;
            array_walk($info, function(&$key) use ($a) {$key = str_replace($a, '', $key);});
            throw new PEAR2_Pyrus_Task_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', $info)
            );
        }
        return $this->info[$this->tasksNs . $var];
    }

    function __isset($var)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use [] operator to access paramgroups');
        }
        if (!array_key_exists($this->tasksNs . $var, $this->info)) {
            $info = array_keys($this->info);
            $a = $this->tasksNs;
            array_walk($info, function(&$key) use ($a) {$key = str_replace($a, '', $key);});
            throw new PEAR2_Pyrus_Task_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', $info)
            );
        }
        return isset($this->info[$this->tasksNs . $var]);
    }

    function __unset($var)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use [] operator to access params');
        }
        if (!array_key_exists($this->tasksNs . $var, $this->info)) {
            $info = array_keys($this->info);
            $a = $this->tasksNs;
            array_walk($info, function(&$key) use ($a) {$key = str_replace($a, '', $key);});
            throw new PEAR2_Pyrus_Task_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', $info)
            );
        }
        $this->info[$this->tasksNs . $var] = null;
        $this->save();
    }

    function __set($var, $value)
    {
        return $this->__call($var, array($value));
    }

    function __call($var, $args)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use [] operator to access params');
        }
        if (!array_key_exists($this->tasksNs . $var, $this->info)) {
            $info = array_keys($this->info);
            $a = $this->tasksNs;
            array_walk($info, function(&$key) use ($a) {$key = str_replace($a, '', $key);});
            throw new PEAR2_Pyrus_Task_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', $info)
            );
        }
        if (!count($args) || $args[0] === null) {
            $this->info[$this->tasksNs . $var] = null;
            $this->save();
            return $this;
        }
        $this->info[$this->tasksNs . $var] = $args[0];
        $this->save();
        return $this;
    }

    function getInfo()
    {
        return $this->info;
    }

    /**
     * Return $this->info, but without the tasks: namespace
     */
    function getPrompts()
    {
        $prompts = array();
        $info = $this->info;
        if (count($info) && !isset($info[0])) {
            $info = array($info);
        }
        foreach ($info as $i => $prompt) {
            foreach ($prompt as $key => $thing) {
                $prompts[$i][str_replace($this->tasksNs, '', $key)] = $thing;
            }
        }
        return $prompts;
    }

    function setInfo($index, $info)
    {
        foreach ($info as $key => $null) {
            if ($null === null) {
                unset($info[$key]);
                continue;
            }
            if (is_array($null) && count($null) == 1) {
                $info[$key] = $null[0];
            }
        }
        $this->info[$index] = $info;
    }

    function save()
    {
        if ($this->parent instanceof self) {
            $this->parent->setInfo($this->index, $this->info);
        } else {
            $info = $this->info;
            if (!count($info)) {
                $info = null;
            }
            $this->parent->setParams($info);
        }
        $this->parent->save();
    }
}
?><?php
/**
 * <tasks:postinstallscript> paramgroup object
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements the postinstallscript file task <paramgroup> tag
 *
 * Sample usage:
 *
 * <code>
 * $task->paramgroup['nameid']->instructions('hi there')
 *  ->condition($task->paramgroup['previous']->param['paramname'], '>=', '25')
 *  ->param['paramname']->prompt('blah')->type('string')->defaultValue('hi');
 * </code>
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Postinstallscript_Paramgroup implements ArrayAccess, Iterator, Countable
{
    protected $info;
    protected $index = null;
    protected $parent;
    protected $tasksNs;

    function __construct($tasksNs, $parent, array $info, $index = null)
    {
        if ($tasksNs) {
            if ($tasksNs[strlen($tasksNs)-1] != ':') {
                $tasksNs .= ':';
            }
        } else {
            $tasksNs = '';
        }
        $this->tasksNs = $tasksNs;
        $this->parent = $parent;
        $this->info = $info;
        $this->index = $index;
    }

    /**
     * Determines whether the <conditiontype> tag in this paramgroup is satisfied by
     * the last <paramgroup>.
     *
     * If this is a simple paramgroup with no conditiontype, this always returns true.
     * Otherwise, this processes the conditiontype, and determines whether the variable
     * specified was satisfied by the last executed paramgroup
     * @return bool
     */
    function matchesConditionType(array $answers = null)
    {
        if (!isset($this->name)) {
            return true;
        }
        if (!isset($answers)) {
            throw new PEAR2_Pyrus_Task_Exception('Invalid post-install script, <conditiontype> can only ' .
                                                 'be used if the previous paramgroup has prompts');
        }

        if (isset($answers[$this->name])) {
            switch ($this->conditiontype) {
                case '=' :
                    if ($answers[$this->name] == $this->value) {
                        return true;
                    }
                break;
                case '!=' :
                    if ($answers[$this->name] != $this->value) {
                        return true;
                    }
                break;
                case 'preg_match' :
                    if (@preg_match('/' . $this->value . '/',
                          $answers[$this->name])) {
                        return true;
                    }
                break;
                default :
                return false;
            }
        }
        return false;
    }

    function count()
    {
        return count($this->info);
    }

    function current()
    {
        $i = key($this->info);
        foreach (array('id', 'instructions', 'name', 'conditiontype', 'value', 'param') as $key) {
            if (!array_key_exists($this->tasksNs . $key, $this->info[$i])) {
                $this->info[$i][$this->tasksNs . $key] = null;
            }
        }
        return new self($this->tasksNs, $this, $this->info[$i], $i);
    }

    function rewind()
    {
        reset($this->info);
    }

    function key()
    {
        $i = key($this->info);
        return $this->info[$i][$this->tasksNs . 'id'];
    }

    function next()
    {
        return next($this->info);
    }

    function valid()
    {
        return current($this->info);
    }

    function locateParamgroup($id)
    {
        foreach ($this->info as $i => $paramgroup)
        {
            if (isset($paramgroup[$this->tasksNs . 'id']) && $paramgroup[$this->tasksNs . 'id'] == $id) {
                return $i;
            }
        }
        return false;
    }

    function offsetGet($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use -> operator to access paramgroup properties');
        }
        $i = $this->locateParamgroup($var);
        if (false === $i) {
            $i = count($this->info);
            $this->info[$i] = array($this->tasksNs . 'id' => $var,
                                    $this->tasksNs . 'instructions' => null,
                                    $this->tasksNs . 'name' => null,
                                    $this->tasksNs . 'conditiontype' => null,
                                    $this->tasksNs . 'value' => null,
                                    $this->tasksNs . 'param' => null);
        } else {
            foreach (array('id', 'instructions', 'name', 'conditiontype', 'value', 'param') as $key) {
                if (!array_key_exists($this->tasksNs . $key, $this->info[$i])) {
                    $this->info[$i][$this->tasksNs . $key] = null;
                }
            }
        }
        return new self($this->tasksNs, $this, $this->info[$i], $i);
    }

    function offsetSet($var, $value)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use -> operator to access paramgroup properties');
        }
        if (!($value instanceof self)) {
            throw new PEAR2_Pyrus_Task_Exception('Can only set $paramgroup[\'' .
                $var .
                '\'] to PEAR2_Pyrus_Task_Postinstallscript_Paramgroup object');
        }
        if ($var === null) {
            $var = $value->id;
        }
        if ($value->id != $var) {
            throw new PEAR2_Pyrus_Task_Exception('Cannot set ' .
                $var . ' to ' .
                $value->id .
                ', use $paramgroup[] to set a new value');
        }
        if (false === ($i = $this->locateParamgroup($var))) {
            $i = count($this->info);
        }
        $this->info[$i] = $value->getInfo();
        $this->save();
    }

    function offsetExists($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use -> operator to access paramgroup properties');
        }
        $i = $this->locateParamgroup($var);
        return $i !== false;
    }

    function offsetUnset($var)
    {
        if (isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use -> operator to access paramgroup properties');
        }
        $i = $this->locateParamgroup($var);
        if ($i === false) {
            return;
        }
        unset($this->info[$i]);
        $this->info = array_values($this->info);
        $this->save();
    }

    function __get($var)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use [] operator to access paramgroups');
        }
        if (!array_key_exists($this->tasksNs . $var, $this->info)) {
            $info = array_keys($this->info);
            $a = $this->tasksNs;
            array_walk($info, function(&$key) use ($a) {$key = str_replace($a, '', $key);});
            throw new PEAR2_Pyrus_Task_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', $info)
            );
        }
        if ($var === 'param') {
            $ret = $this->info[$this->tasksNs . 'param'];
            if ($ret === null) {
                $ret = array();
            } elseif (is_array($ret) && !isset($ret[0])) {
                $ret = array($ret);
            }
            return new PEAR2_Pyrus_Task_Postinstallscript_Paramgroup_Param($this->tasksNs, $this, $ret);
        }
        return $this->info[$this->tasksNs. $var];
    }

    function __isset($var)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use [] operator to access paramgroups');
        }
        if (!array_key_exists($this->tasksNs. $var, $this->info)) {
            $info = array_keys($this->info);
            $a = $this->tasksNs;
            array_walk($info, function(&$key) use ($a) {$key = str_replace($a, '', $key);});
            throw new PEAR2_Pyrus_Task_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', $info)
            );
        }
        return isset($this->info[$this->tasksNs. $var]);
    }

    function __unset($var)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use [] operator to access paramgroups');
        }
        if (!array_key_exists($this->tasksNs. $var, $this->info)) {
            $info = array_keys($this->info);
            $a = $this->tasksNs;
            array_walk($info, function(&$key) use ($a) {$key = str_replace($a, '', $key);});
            throw new PEAR2_Pyrus_Task_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', $info)
            );
        }
        $this->info[$this->tasksNs. $var] = null;
        $this->save();
    }

    function __set($var, $value)
    {
        return $this->__call($var, array($value));
    }

    function __call($var, $args)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use [] operator to access paramgroups');
        }
        if (!array_key_exists($this->tasksNs. $var, $this->info)) {
            $info = array_keys($this->info);
            $a = $this->tasksNs;
            array_walk($info, function(&$key) use ($a) {$key = str_replace($a, '', $key);});
            throw new PEAR2_Pyrus_Task_Exception(
                'Unknown variable ' . $var . ', should be one of ' . implode(', ', $info)
            );
        }
        if (!count($args) || $args[0] === null) {
            $this->info[$this->tasksNs. $var] = null;
            $this->save();
            return $this;
        }
        if ($var == 'param') {
            if (!isset($this->info[$this->tasksNs. $var])) {
                $this->info[$this->tasksNs. $var] = $args;
            } else {
                if (!is_array($this->info[$this->tasksNs. $var])) {
                    $this->info[$this->tasksNs. $var] = array($this->info[$this->tasksNs. $var]);
                }
                $this->info[$this->tasksNs. $var] = array_merge($this->info[$this->tasksNs. $var], $args);
            }
        } else {
            if ($var === 'name') {
                if (!strpos($args[0], '::')) {
                    throw new PEAR2_Pyrus_Task_Exception('name must reference a previous paramgroup\'s param with ' .
                                                         'syntax paramgroup::paramname');
                }
                $name = explode('::', $args[0]);
                if (count($name) != 2) {
                    throw new PEAR2_Pyrus_Task_Exception('name must reference a previous paramgroup\'s param with ' .
                                                         'syntax paramgroup::paramname');
                }
                if ($name[0] == $this->id) {
                    throw new PEAR2_Pyrus_Task_Exception('name must reference a previous paramgroup\'s param.  ' .
                                                         $args[0] . ' references this paramgroup');
                }
                if (!isset($this->parent[$name[0]])) {
                    throw new PEAR2_Pyrus_Task_Exception('name must reference a previous paramgroup\'s param.  ' .
                                                         'paramgroup "' . $name[0] . '" is not yet created');
                }
                if (!isset($this->parent[$name[0]]->param[$name[1]])) {
                    throw new PEAR2_Pyrus_Task_Exception('name must reference a previous paramgroup\'s param.  ' .
                                                         'paramgroup "' . $name[0] . '" param "' .
                                                         $name[1] . '" is not yet created');
                }
            }
            $this->info[$this->tasksNs. $var] = $args[0];
        }
        $this->save();
        return $this;
    }

    function getInfo()
    {
        return $this->info;
    }

    function setInfo($index, $info)
    {
        foreach ($info as $key => $null) {
            if ($null === null) {
                unset($info[$key]);
                continue;
            }
            if (is_array($null) && count($null) == 1) {
                $info[$key] = $null[0];
            }
        }
        $this->info[$index] = $info;
    }

    function setParams($info)
    {
        if ($info === null) {
            unset($this->info[$this->tasksNs. 'param']);
            return;
        }
        if (count($info) == 1) {
            $info = $info[0];
        }
        $this->info[$this->tasksNs. 'param'] = $info;
    }

    /**
     * Set the condition for this paramgroup
     * @param PEAR2_Pyrus_Task_Postinstallscript_Paramgroup_Param $parameter the
     *        previous parameter whose value we use for the condition check
     * @param string $operator one of =, !=, or preg_match
     * @param string $value the value to match the parameter against
     */
    function condition(PEAR2_Pyrus_Task_Postinstallscript_Paramgroup_Param $parameter = null, $operator = null,
                       $value = null)
    {
        if (!isset($this->index)) {
            throw new PEAR2_Pyrus_Task_Exception('Use [] operator to access paramgroups');
        }
        if ($parameter === null) {
            $this->name = null;
            $this->conditiontype = null;
            $this->value = null;
            return;
        }
        $this->name = $parameter->paramgroup->id . '::' . $parameter->name;
        if ($operator != '=' && $operator != '!=' && $operator != 'preg_match') {
            throw new PEAR2_Pyrus_Task_Exception('Invalid operator for post-install script condition, ' .
                                                 ' must be one of =, != or preg_match');
        }
        $this->conditiontype = $operator;
        $this->value = $value;
    }

    function save()
    {
        if ($this->parent instanceof self) {
            $this->parent->setInfo($this->index, $this->info);
            $this->parent->save();
        } else {
            $info = $this->info;
            if (count($info) == 1) {
                $info = $info[0];
            } elseif (!count($info)) {
                $info = null;
            }
            $this->parent->setParamgroups($info);
        }
    }
}
?><?php
/**
 * <tasks:replace> - read/write version
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: rw.php,v 1.1 2006/12/28 20:42:32 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Release 1.4.0a10
 */
/**
 * Base class
 */
require_once 'PEAR/Task/Replace.php';
/**
 * Abstracts the replace task xml.
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 1.4.0a10
 */
class PEAR_Task_Replace_rw extends PEAR_Task_Replace
{
    function PEAR_Task_Replace_rw(&$pkg, &$config, &$logger, $fileXml)
    {
        parent::PEAR_Task_Common($config, $logger, PEAR_TASK_PACKAGE);
        $this->_contents = $fileXml;
        $this->_pkg = &$pkg;
        $this->_params = array();
    }

    function validate()
    {
        return $this->validateXml($this->_pkg, $this->_params, $this->config, $this->_contents);
    }

    function setInfo($from, $to, $type)
    {
        $this->_params = array('attribs' => array('from' => $from, 'to' => $to, 'type' => $type));
    }

    function getName()
    {
        return 'replace';
    }

    function getXml()
    {
        return $this->_params;
    }
}
?><?php
/**
 * <tasks:unixeol> - read/write version
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: rw.php,v 1.1 2006/12/28 20:42:32 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Release 1.4.0a10
 */
/**
 * Base class
 */
require_once 'PEAR/Task/Unixeol.php';
/**
 * Abstracts the unixeol task xml.
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 1.4.0a10
 */
class PEAR_Task_Unixeol_rw extends PEAR_Task_Unixeol
{
    function PEAR_Task_Unixeol_rw(&$pkg, &$config, &$logger, $fileXml)
    {
        parent::PEAR_Task_Common($config, $logger, PEAR_TASK_PACKAGE);
        $this->_contents = $fileXml;
        $this->_pkg = &$pkg;
        $this->_params = array();
    }

    function validate()
    {
        return true;
    }

    function getName()
    {
        return 'unixeol';
    }

    function getXml()
    {
        return '';
    }
}
?><?php
/**
 * <tasks:windowseol> - read/write version
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: rw.php,v 1.1 2006/12/28 20:42:32 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Release 1.4.0a10
 */
/**
 * Base class
 */
require_once 'PEAR/Task/Windowseol.php';
/**
 * Abstracts the windowseol task xml.
 * @category   pear
 * @package    PEAR
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  1997-2006 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 1.4.0a10
 */
class PEAR_Task_Windowseol_rw extends PEAR_Task_Windowseol
{
    function PEAR_Task_Windowseol_rw(&$pkg, &$config, &$logger, $fileXml)
    {
        parent::PEAR_Task_Common($config, $logger, PEAR_TASK_PACKAGE);
        $this->_contents = $fileXml;
        $this->_pkg = &$pkg;
        $this->_params = array();
    }

    function validate()
    {
        return true;
    }

    function getName()
    {
        return 'windowseol';
    }

    function getXml()
    {
        return '';
    }
}
?><?php
/**
 * PEAR_Task_Common, base class for installer tasks
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
/**
 * A task is an operation that manipulates the contents of a file.
 *
 * Simple tasks operate on 1 file.  Multiple tasks are executed after all files have been
 * processed and installed, and are designed to operate on all files containing the task.
 * The Post-install script task simply takes advantage of the fact that it will be run
 * after installation, replace is a simple task.
 *
 * Combining tasks is possible, but ordering is significant.
 *
 * <file name="test.php" role="php">
 *  <tasks:replace from="@data-dir@" to="data_dir" type="pear-config"/>
 *  <tasks:postinstallscript/>
 * </file>
 *
 * This will first replace any instance of @data-dir@ in the test.php file
 * with the path to the current data directory.  Then, it will include the
 * test.php file and run the script it contains to configure the package post-installation.
 *
 * The observer pattern is used, so that updates from a MultipleProxy from one
 * member task can be used to save changes to the parent file object.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
abstract class PEAR2_Pyrus_Task_Common extends \ArrayObject implements \SplSubject
{
    const PACKAGE = 1;
    const INSTALL = 2;
    const PACKAGEANDINSTALL = 3;
    const POSTINSTALL = 4; // this is used by post-install scripts
    /**
     * Valid types for this version are 'simple' and 'multiple'
     *
     * - simple tasks operate on the contents of a file and write out changes to disk
     * - multiple tasks operate on the contents of many files and write out the
     *   changes directly to disk
     *
     * Child task classes must override this property.
     * @access protected
     */
    const TYPE = 'simple';
    /**
     * Determines which install phase this task is executed under
     */
    const PHASE = PEAR2_Pyrus_Task_Common::INSTALL;
    /**
     * @param PEAR_Config
     * @param PEAR_Common
     */

    static $multiple = array();

    protected $installphase;
    protected $xml;
    protected $taskAttributes;
    protected $lastVersion;
    protected $pkg;
    protected $observers = array();

    /**
     * Initialize a task instance with the parameters
     * @param PEAR2_Pyrus_Package|PEAR2_Pyrus_IPackageFile package information
     * @param int install phase
     * @param array raw, parsed xml
     * @param array attributes from the <file> tag containing this task
     * @param string|null last installed version of this package
     */
    function __construct($pkg, $phase, $xml, $attribs, $lastversion)
    {
        $this->pkg = $pkg;
        $this->installphase = $phase;
        $this->xml = $xml;
        $this->taskAttributes = $attribs;
        $this->lastVersion = $lastversion;
        if (static::TYPE == 'multiple') {
            self::$multiple[get_class($this)][] = $this;
        }
    }

    /**
     * Validate the basic contents of a task tag.
     *
     * On error, one of the PEAR2_Pyrus_Task_Exception_* exceptions should be thrown.
     *
     *  - {@link PEAR2_Pyrus_Task_Exception_NoAttributes}: use this exception for
     *    missing attributes that should be present.
     *  - {@link PEAR2_Pyrus_Task_Exception_MissingAttribute}: use this exception
     *    for a specific missing attribute.
     *  - {@link PEAR2_Pyrus_Task_Exception_WrongAttributeValue}: use this
     *    exception for an incorrect value for an attribute.
     *  - {@link PEAR2_Pyrus_Task_Exception_InvalidTask}: use this exception for
     *    general validation errors
     *
     * It is also possible to throw multiple validation errors, by using a
     * {@link PEAR2_MultiErrors} object as a cause parameter to
     * {@link PEAR2_Pyrus_Task_Exception}.
     * @param PEAR_Pyrus_IPackageFile
     * @param array
     * @param array the entire parsed <file> tag
     * @param string the filename of the package.xml
     * @throws PEAR2_Pyrus_Task_Exception
     * @throws PEAR2_Pyrus_Task_Exception_NoAttributes
     * @throws PEAR2_Pyrus_Task_Exception_MissingAttribute
     * @throws PEAR2_Pyrus_Task_Exception_WrongAttributeValue
     * @throws PEAR2_Pyrus_Task_Exception_InvalidTask
     * @abstract
     */
    static function validateXml(PEAR2_Pyrus_IPackage $pkg, $xml, $fileXml, $file)
    {
    }

    /**
     * Begin a task processing session.  All multiple tasks will be processed after each file
     * has been successfully installed, all simple tasks should perform their task here and
     * return any errors using the custom throwError() method to allow forward compatibility
     *
     * This method MUST NOT write out any changes to disk
     * @param PEAR_Pyrus_IPackageFile
     * @param resource open file pointer, set to the beginning of the file
     * @param string the eventual final file location (informational only)
     * @return string|false false to skip this file, otherwise return the new contents
     * @throws PEAR2_Pyrus_Task_Exception on errors, throw this exception
     * @abstract
     */
    function startSession($fp, $dest)
    {
    }

    function setupPostInstall()
    {
    }

    /**
     * This method is used to process each of the tasks for a particular multiple class
     * type.  Simple tasks need not implement this method.
     * @param array an array of tasks
     * @access protected
     * @static
     * @abstract
     */
    function run($tasks)
    {
    }

    final static function hasPostinstallTasks()
    {
        return count(self::$multiple);
    }

    final static function runPostinstallTasks()
    {
        foreach (self::$multiple as $class => $tasks) {
            $class::run(self::$multiple[$class]);
        }
        self::$multiple[$class] = array();
    }

    function isPreProcessed()
    {
        return false;
    }

    function getInfo()
    {
        return $this->xml;
    }

    function attach(SplObserver $observer)
    {
        $this->observers[] = $observer;
    }

    function detach(SplObserver $observed)
    {
        foreach ($this->observers as $i => $observer) {
            if ($observer === $observed) {
                unset($this->observers[$i]);
                $this->observers = array_values($this->observers);
                return;
            }
        }
    }

    function notify()
    {
        foreach ($this->observers as $observer) {
            $observer->update($this);
        }
    }
}
?><?php
/**
 * PEAR2_Pyrus_Task_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Pyrus Tasks
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Exception extends PEAR2_Exception
{
    /**#@+
     * Error codes for task validation routines
     */
    const NOATTRIBS = 1;
    const MISSING_ATTRIB = 2;
    const WRONG_ATTRIB_VALUE = 3;
    const INVALID = 4;
    /**#@-*/
}<?php
/**
 * PEAR2_Pyrus_Task_MultipleProxy, container for multiple tasks to be executed
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
/**
 * A container for multiple tasks
 *
 * This is used when a file contains multiple copies of the same task name,
 * such as multiple <tasks:replace> tags
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_MultipleProxy extends \ArrayObject implements \IteratorAggregate, \SplObserver
{
    protected $name;
    protected $parent;
    protected $fileattribs;
    /**
     * @param PEAR2_Pyrus_IPackage|PEAR2_Pyrus_IPackageFile
     * @param array a group of tasks
     */
    function __construct($parent, array $tasks, $fileattribs, $name)
    {
        $this->parent = $parent;
        $this->name = $name;
        $this->fileattribs = $fileattribs;
        parent::__construct($tasks);
        foreach ($tasks as $task) {
            $task->attach($this);
        }
    }

    /**
     * Begin a task processing session.  All multiple tasks will be processed after each file
     * has been successfully installed, all simple tasks should perform their task here and
     * return any errors using the custom throwError() method to allow forward compatibility
     *
     * This method MUST NOT write out any changes to disk
     * @param PEAR_Pyrus_IPackageFile
     * @param resource open file pointer, set to the beginning of the file
     * @param string the eventual final file location (informational only)
     * @return string|false false to skip this file, otherwise return the new contents
     * @throws PEAR2_Pyrus_Task_Exception on errors, throw this exception
     * @abstract
     */
    function startSession($fp, $dest)
    {
        foreach ($this as $task) {
            $task->startSession($fp, $dest);
            if (!rewind($fp)) {
                throw new PEAR2_Pyrus_Task_Exception('task ' . $this->name .
                                                          ' closed the file pointer, invalid task');
            }
        }
    }

    function isPreProcessed()
    {
        foreach ($this as $task) {
            if (!$task->isPreProcessed()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Iterate over each task and aggregate their content, then pass it to the parent
     * package object
     */
    function getInfo()
    {
        $ret = array();
        foreach ($this as $task) {
            $ret[] = $task->getInfo();
        }
        if (count($ret) == 1) {
            $ret = $ret[0];
        }
        return $ret;
    }

    function add()
    {
        $task = str_replace('-', ' ', $this->name);
        $task = str_replace(' ', '/', ucwords($task));
        $task = str_replace('/', '_', $task);
        $c = 'PEAR2_Pyrus_Task_' . $task;
        $ret = new $c($this->parent, PEAR2_Pyrus_Validate::NORMAL, array(), $this->fileattribs, null);
        $this[] = $ret;
        $ret->attach($this);
        return $ret;
    }

    function update(SplSubject $subject)
    {
        $ret = $subject->getInfo();
        if (empty($ret)) {
            foreach ($this as $i => $task) {
                if ($subject === $task) {
                    unset($this[$i]);
                    $this->exchangeArray(array_values($this->getArrayCopy()));
                    break;
                }
            }
        }
        $this->parent->files[$this->fileattribs['name']]->{$this->name} = $this;
    }
}
?><?php
/**
 * <tasks:postinstallscript>
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements the postinstallscript file task.
 *
 * Note that post-install scripts are handled separately from installation, by the
 * "pyrus run-scripts" command
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Postinstallscript extends PEAR2_Pyrus_Task_Common
{
    const TYPE = 'script';
    const PHASE = PEAR2_Pyrus_Task_Common::POSTINSTALL;
    protected $scriptClass;
    protected $obj;

    /**
     * Initialize a task instance with the parameters
     * @param array raw, parsed xml
     * @param array attributes from the <file> tag containing this task
     * @param string|null last installed version of this package, if any (useful for upgrades)
     */
    function __construct($pkg, $phase, $xml, $attribs, $lastversion)
    {
        parent::__construct($pkg, $phase, $xml, $attribs, $lastversion);
        $this->scriptClass = str_replace(array('/', '.php'), array('_', ''), $attribs['name']) . '_postinstall';
        $this->_filename = $attribs['name'];
    }

    /**
     * Validate the basic contents of a <postinstallscript> tag
     * @param PEAR_Pyrus_IPackageFile
     * @param array
     * @param array the entire parsed <file> tag
     * @param string the filename of the package.xml
     * @throws PEAR2_Pyrus_Task_Exception_InvalidTask
     */
    static function validateXml(PEAR2_Pyrus_IPackage $pkg, $xml, $fileXml, $file)
    {
        if ($fileXml['role'] != 'php') {
            throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                             'Post-install script "' .
                                                             $fileXml['name'] . '" must be role="php"');
        }
        try {
            $filecontents = $pkg->getFileContents($fileXml['name']);
        } catch (\Exception $e) {
            throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                             'Post-install script "' .
                                                             $fileXml['name'] . '" is not valid: ' .
                                                             $e->getMessage(), $e);
        }

        $validator = $pkg->getValidator();
        $analysis = $validator->analyzeSourceCode($filecontents, true);
        if (!$analysis) {
            $warnings = array();
            // iterate over the problems
            foreach ($validator->getErrors() as $warn) {
                $warnings[] = $warn->getMessage();
            }
            $warnings = implode($warnings);
            throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file, 
                                                             'Analysis of post-install script "' .
                                                             $fileXml['name'] . '" failed: ' . $warnings,
                                                             $validator->getErrors());
        }
        if (count($analysis['declared_classes']) != 1) {
            throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                             'Post-install script "' .
                                                             $fileXml['name'] .
                                                             '" must declare exactly 1 class');
        }
        $class = $analysis['declared_classes'][0];
        if ($class != str_replace(array('/', '.php'), array('_', ''),
              $fileXml['name']) . '_postinstall') {
            throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                             'Post-install script "' .
                                                             $fileXml['name'] . '" class "' .
                                                             $class . '" must be named "' .
                                                             str_replace(array('/', '.php'),
                                                                         array('_', ''),
                                                                         $fileXml['name']) .
                                                             '_postinstall"');
        }
        if (!isset($analysis['declared_methods'][$class])) {
            throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                             'Post-install script "' .
                                                             $fileXml['name'] .
                                                             '" must declare methods init() and run()');
        }
        $methods = array('init' => 0, 'run' => 1);
        foreach ($analysis['declared_methods'][$class] as $method) {
            if (isset($methods[$method])) {
                unset($methods[$method]);
            }
        }
        if (count($methods)) {
            throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                             'Post-install script "' .
                                                             $fileXml['name'] .
                                                             '" must declare methods init() and run()');
        }
        $definedparams = array();
        $tasksNamespace = $pkg->getTasksNs() . ':';
        if (!isset($xml[$tasksNamespace . 'paramgroup'])) {
            return true;
        }
        $params = $xml[$tasksNamespace . 'paramgroup'];
        if (!is_array($params) || !isset($params[0])) {
            $params = array($params);
        }
        foreach ($params as $param) {
            if (!isset($param[$tasksNamespace . 'id'])) {
                throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                             'Post-install script "' .
                                                             $fileXml['name'] .
                                                             '" <paramgroup> must have ' .
                                                             'an <id> tag');
            }
            if (isset($param[$tasksNamespace . 'name'])) {
                if (!in_array($param[$tasksNamespace . 'name'], $definedparams)) {
                    throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                                     'Post-install script "' .
                                                                     $fileXml['name'] . '" ' .
                                                                     '<paramgroup> id "' .
                                                                     $param[$tasksNamespace .'id'] .
                                                                     '" conditiontype parameter "' .
                                                                     $param[$tasksNamespace . 'name'] .
                                                                     '" has not been previously defined');
                }
                if (!isset($param[$tasksNamespace . 'conditiontype'])) {
                    throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                                     'Post-install script "' .
                                                                     $fileXml['name'] . '" ' .
                                                                     '<paramgroup> id "' .
                                                                     $param[$tasksNamespace . 'id'] .
                                                                     '" must have a ' .
                                                                     '<conditiontype> tag ' .
                                                                     'containing either "=", ' .
                                                                     '"!=", or "preg_match"');
                }
                if (!in_array($param[$tasksNamespace . 'conditiontype'],
                      array('=', '!=', 'preg_match'))) {
                    throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                                     'Post-install script "' .
                                                                     $fileXml['name'] . '" ' .
                                                                     '<paramgroup> id "' .
                                                                     $param[$tasksNamespace . 'id'] .
                                                                     '" must have a ' .
                                                                     '<conditiontype> tag ' .
                                                                     'containing either "=", ' .
                                                                     '"!=", or "preg_match"');
                }
                if (!isset($param[$tasksNamespace . 'value'])) {
                    throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                                     'Post-install script "' .
                                                                     $fileXml['name'] . '" ' .
                                                                     '<paramgroup> id "' .
                                                                     $param[$tasksNamespace . 'id'] .
                                                                     '" must have a ' .
                                                                     '<value> tag containing ' .
                                                                     'expected parameter value');
                }
            }
            if (isset($param[$tasksNamespace . 'instructions'])) {
                if (!is_string($param[$tasksNamespace . 'instructions'])) {
                    throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                                     'Post-install script "' .
                                                                     $fileXml['name'] . '" ' .
                                                                     '<paramgroup> id "' .
                                                                     $param[$tasksNamespace . 'id'] .
                                                                     '" <instructions> must be simple text');
                }
            }
            if (!isset($param[$tasksNamespace . 'param'])) {
                continue; // <param> is no longer required
            }
            $subparams = $param[$tasksNamespace . 'param'];
            if (!is_array($subparams) || !isset($subparams[0])) {
                $subparams = array($subparams);
            }
            foreach ($subparams as $subparam) {
                if (!isset($subparam[$tasksNamespace . 'name'])) {
                    throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                                     'Post-install script "' .
                                                                     $fileXml['name'] . '" parameter for ' .
                                                                     '<paramgroup> id "' .
                                                                     $param[$tasksNamespace . 'id'] .
                                                                     '" must have ' .
                                                                     'a <name> tag');
                }
                if (!preg_match('/[a-zA-Z0-9]+/',
                      $subparam[$tasksNamespace . 'name'])) {
                    throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                                     'Post-install script "' .
                                                                     $fileXml['name'] . '" parameter "' .
                                                                     $subparam[$tasksNamespace . 'name'] .
                                                                     '" for ' .
                                                                     '<paramgroup> id "' .
                                                                     $param[$tasksNamespace . 'id'] .
                                                                     '" is not a valid name.  Must ' .
                                                                     'contain only alphanumeric characters');
                }
                if (!isset($subparam[$tasksNamespace . 'prompt'])) {
                    throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                                     'Post-install script "' .
                                                                     $fileXml['name'] . '" parameter "' .
                                                                     $subparam[$tasksNamespace . 'name'] .
                                                                     '" for ' .
                                                                     '<paramgroup> id "' .
                                                                     $param[$tasksNamespace . 'id'] .
                                                                     '" must have a ' .
                                                                     '<prompt> tag');
                }
                if (!isset($subparam[$tasksNamespace . 'type'])) {
                    throw new PEAR2_Pyrus_Task_Exception_InvalidTask('postinstallscript', $file,
                                                                     'Post-install script "' .
                                                                     $fileXml['name'] . '" parameter "' .
                                                                     $subparam[$tasksNamespace . 'name'] .
                                                                     '" for ' .
                                                                     '<paramgroup> id "' .
                                                                     $param[$tasksNamespace . 'id'] .
                                                                     '" must have a ' .
                                                                     '<type> tag');
                }
                $definedparams[] = $param[$tasksNamespace . 'id'] . '::' .
                $subparam[$tasksNamespace . 'name'];
            }
        }
        return true;
    }

    /**
     * Unlike other tasks, the installed file name is passed in instead of the file contents,
     * because this task is handled post-installation
     * @param PEAR2_Pyrus_IPackage
     * @param string path to the post-install script
     * @return bool false to skip this file
     */
    function setupPostInstall()
    {
        $files = PEAR2_Pyrus_Config::current()->registry->info($this->pkg->name, $this->pkg->channel,
                                                               'installedfiles');
        foreach ($files as $path => $info) {
            if ($info['name'] == $this->_filename) {
                break;
            }
        }
        PEAR2_Pyrus_Log::log(0, 'Including external post-installation script "' .
            $path . '" - any errors are in this script');
        include $path;
        if (class_exists($this->scriptClass)) {
            PEAR2_Pyrus_Log::log(0, 'Inclusion succeeded');
        } else {
            throw new PEAR2_Pyrus_Task_Exception('init of post-install script class "' . $this->scriptClass
                . '" failed');
        }
        $this->obj = new $this->scriptClass;
        PEAR2_Pyrus_Log::log(1, 'running post-install script "' . $this->scriptClass . '->init()"');
        try {
            $this->obj->init($this->pkg, $this->lastVersion);
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Task_Exception('init of post-install script "' . $this->scriptClass .
                '->init()" failed', $e);
        }
        PEAR2_Pyrus_Log::log(0, 'init succeeded');
        return true;
    }

    /**
     * No longer used
     * @see PEAR_PackageFile_v2::runPostinstallScripts()
     * @param array an array of tasks
     * @param string install or upgrade
     * @access protected
     * @static
     */
    function run($tasks)
    {
    }

    function __get($var)
    {
        if ($var === 'scriptobject') {
            return $this->obj;
        }
        if ($var === 'paramgroup') {
            if (!isset($this->xml) || !is_array($this->xml) || !isset($this->xml['paramgroup'])) {
                $params = array();
            } else {
                $params = $this->xml['paramgroup'];
                if (count($params) && !isset($params[0])) {
                    $params = array($params);
                }
            }
            return new PEAR2_Pyrus_Task_Postinstallscript_Paramgroup($this->pkg->getTasksNs(),
                                                                     $this, $params);
        }
        throw new PEAR2_Pyrus_Task_Exception('Invalid variable ' . $var . ' requested from Post-install script task');
    }

    function setParamgroups($info)
    {
        if ($info === null) {
            unset($this->xml['paramgroup']);
            return;
        }
        $this->xml['paramgroup'] = $info;
        $this->notify();
    }
}
?><?php
/**
 * <tasks:replace>
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements the replace file task.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Replace extends PEAR2_Pyrus_Task_Common
{
    const TYPE = 'simple';
    const PHASE = PEAR2_Pyrus_Task_Common::PACKAGEANDINSTALL;
    var $_replacements;

    /**
     * Initialize a task instance with the parameters
     * @param array raw, parsed xml
     * @param array attributes from the <file> tag containing this task
     * @param string|null last installed version of this package
     */
    function __construct($pkg, $phase, $xml, $attribs, $lastversion)
    {
        parent::__construct($pkg, $phase, $xml, $attribs, $lastversion);
        $this->_replacements = isset($xml['attribs']) ? array($xml) : $xml;
    }

    /**
     * Validate the basic contents of a <replace> tag
     * @param PEAR_Pyrus_IPackageFile
     * @param array
     * @param array the entire parsed <file> tag
     * @param string the filename of the package.xml
     * @throws PEAR2_Pyrus_Task_Exception_InvalidTask
     */
    static function validateXml(PEAR2_Pyrus_IPackage $pkg, $xml, $fileXml, $file)
    {
        if (!isset($xml['attribs'])) {
            throw new PEAR2_Pyrus_Task_Exception_NoAttributes('replace', $file);
        }
        $errs = new PEAR2_MultiErrors;
        foreach (array('type', 'to', 'from') as $attrib) {
            if (!isset($xml['attribs'][$attrib])) {
                $errs->E_ERROR[] =
                    new PEAR2_Pyrus_Task_Exception_MissingAttribute('replace',
                                                                    $attrib, $file);
            }
        }
        if ($count = count($errs->E_ERROR)) {
            if ($count == 1) {
                throw $errs->E_ERROR[0];
            }
            throw new PEAR2_Pyrus_Task_Exception('Invalid replace task, multiple missing attributes', $errs);
        }
        if ($xml['attribs']['type'] == 'pear-config') {
            $config = PEAR2_Pyrus_Config::current();
            if (!in_array($xml['attribs']['to'], $config->systemvars)) {
                throw new PEAR2_Pyrus_Task_Exception_WrongAttributeValue('replace',
                                                                         'to', $xml['attribs']['to'],
                                                                         $file,
                                                                         $config->systemvars);
            }
        } elseif ($xml['attribs']['type'] == 'php-const') {
            if (defined($xml['attribs']['to'])) {
                return true;
            } else {
                throw new PEAR2_Pyrus_Task_Exception_WrongAttributeValue('replace',
                                                                         'to', $xml['attribs']['to'],
                                                                         $file,
                                                                         array('valid PHP constant'));
            }
        } elseif ($xml['attribs']['type'] == 'package-info') {
            if (in_array($xml['attribs']['to'],
                array('name', 'summary', 'channel', 'notes', 'extends', 'description',
                    'release_notes', 'license', 'release-license', 'license-uri',
                    'version', 'api-version', 'state', 'api-state', 'release_date',
                    'date', 'time'))) {
                return true;
            } else {
                throw new PEAR2_Pyrus_Task_Exception_WrongAttributeValue('replace',
                                                                         'to', $xml['attribs']['to'],
                                                                         $file,
                    array('name', 'summary', 'channel', 'notes', 'extends', 'description',
                    'release_notes', 'license', 'release-license', 'license-uri',
                    'version', 'api-version', 'state', 'api-state', 'release_date',
                    'date', 'time'));
            }
        } else {
            throw new PEAR2_Pyrus_Task_Exception_WrongAttributeValue('replace',
                                                                     'type', $xml['attribs']['type'],
                                                                     $file,
                                                                     array('pear-config',
                                                                           'package-info',
                                                                           'php-const'));
        }
        return true;
    }

    /**
     * Do a package.xml 1.0 replacement, with additional package-info fields available
     *
     * See validateXml() source for the complete list of allowed fields
     * @param PEAR2_Pyrus_IPackage
     * @param resource open file pointer, set to the beginning of the file
     * @param string the eventual final file location (informational only)
     * @return string|false
     */
    function startSession($fp, $dest)
    {
        $contents = stream_get_contents($fp);
        $subst_from = $subst_to = array();
        foreach ($this->_replacements as $a) {
            $a = $a['attribs'];
            $to = '';
            if ($a['type'] == 'pear-config') {
                if ($this->installphase == PEAR2_Pyrus_Task_Common::PACKAGE) {
                    return false;
                }
                $to = PEAR2_Pyrus_Config::current()->{$a['to']};
                if (is_null($to)) {
                    PEAR2_Pyrus_Log::log(0, "$dest: invalid pear-config replacement: $a[to]");
                    return false;
                }
            } elseif ($a['type'] == 'php-const') {
                if ($this->installphase == PEAR2_Pyrus_Task_Common::PACKAGE) {
                    return false;
                }
                if (defined($a['to'])) {
                    $to = constant($a['to']);
                } else {
                    PEAR2_Pyrus_Log::log(0, "$dest: invalid php-const replacement: $a[to]");
                    return false;
                }
            } else {
                if ($t = $this->pkg->{$a['to']}) {
                    if ($a['to'] == 'version') {
                        $t = $t['release'];
                    }
                    $to = $t;
                } else {
                    PEAR2_Pyrus_Log::log(0, "$dest: invalid package-info replacement: $a[to]");
                    return false;
                }
            }
            if (!is_null($to)) {
                $subst_from[] = $a['from'];
                $subst_to[] = $to;
            }
        }
        PEAR2_Pyrus_Log::log(3, "doing " . sizeof($subst_from) .
            " substitution(s) for $dest");
        if (sizeof($subst_from)) {
            $contents = str_replace($subst_from, $subst_to, $contents);
        }
        rewind($fp);
        ftruncate($fp, 0);
        fwrite($fp, $contents);
        return true;
    }

    function isPreProcessed()
    {
        if ($this->_replacements[0]['attribs']['type'] == 'package-info') {
            return true;
        }
        return false;
    }
}
?><?php
/**
 * <tasks:unixeol>
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements the unix line endings file task.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Unixeol extends PEAR2_Pyrus_Task_Common
{
    const TYPE = 'simple';
    const PHASE = PEAR2_Pyrus_Task_Common::PACKAGEANDINSTALL;
    var $_replacements;

    /**
     * Initialize a task instance with the parameters
     * @param array raw, parsed xml
     * @param array attributes from the <file> tag containing this task
     * @param string|null last installed version of this package
     */
    function __construct($pkg, $phase, $xml, $attribs, $lastversion)
    {
        parent::__construct($pkg, $phase, $xml, $attribs, $lastversion);
    }

    /**
     * Validate the basic contents of a <unixeol> tag
     * @param PEAR_Pyrus_IPackageFile
     * @param array
     * @param array the entire parsed <file> tag
     * @param string the filename of the package.xml
     * @throws PEAR2_Pyrus_Task_Exception_InvalidTask
     */
    static function validateXml(PEAR2_Pyrus_IPackage $pkg, $xml, $fileXml, $file)
    {
        if (is_array($xml) && count($xml) || $xml === '') {
            throw new PEAR2_Pyrus_Task_Exception_InvalidTask('unixeol', $file, 'no attributes allowed');
        }
        return true;
    }

    /**
     * Replace all line endings with line endings customized for the current OS
     *
     * See validateXml() source for the complete list of allowed fields
     * @param PEAR2_Pyrus_IPackage
     * @param resource open file pointer, set to the beginning of the file
     * @param string the eventual final file location (informational only)
     * @return string
     */
    function startSession($fp, $dest)
    {
        $contents = stream_get_contents($fp);
        PEAR2_Pyrus_Log::log(3, "replacing all line endings with \\n in $dest");
        $contents = preg_replace("/\r\n|\n\r|\r|\n/", "\n", $contents);
        rewind($fp);
        ftruncate($fp, 0);
        fwrite($fp, $contents);
        return true;
    }

    function isPreProcessed()
    {
        return true;
    }
}
?><?php
/**
 * <tasks:windowseol>
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements the windows line endsings file task.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Task_Windowseol extends PEAR2_Pyrus_Task_Common
{
    const TYPE = 'simple';
    const PHASE = PEAR2_Pyrus_Task_Common::PACKAGEANDINSTALL;
    var $_replacements;

    /**
     * Initialize a task instance with the parameters
     * @param array raw, parsed xml
     * @param array attributes from the <file> tag containing this task
     * @param string|null last installed version of this package
     */
    function __construct($pkg, $phase, $xml, $attribs, $lastversion)
    {
        parent::__construct($pkg, $phase, $xml, $attribs, $lastversion);
    }

    /**
     * Validate the basic contents of a <qindowseol> tag
     * @param PEAR_Pyrus_IPackageFile
     * @param array
     * @param array the entire parsed <file> tag
     * @param string the filename of the package.xml
     * @throws PEAR2_Pyrus_Task_Exception_InvalidTask
     */
    static function validateXml(PEAR2_Pyrus_IPackage $pkg, $xml, $fileXml, $file)
    {
        if (is_array($xml) && count($xml) || $xml === '') {
            throw new PEAR2_Pyrus_Task_Exception_InvalidTask('windowseol', $file, 'no attributes allowed');
        }
        return true;
    }

    /**
     * Replace all line endings with windows line endings
     *
     * See validateXml() source for the complete list of allowed fields
     * @param PEAR2_Pyrus_IPackage
     * @param resource open file pointer, set to the beginning of the file
     * @param string the eventual final file location (informational only)
     * @return string
     */
    function startSession($fp, $dest)
    {
        $contents = stream_get_contents($fp);
        PEAR2_Pyrus_Log::log(3, "replacing all line endings with \\r\\n in $dest");
        $contents = preg_replace("/\r\n|\n\r|\r|\n/", "\r\n", $contents);
        rewind($fp);
        ftruncate($fp, 0);
        fwrite($fp, $contents);
        return true;
    }

    function isPreProcessed()
    {
        return true;
    }
}
?><?php
/**
 * PEAR2_Pyrus_Validate_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for Validate
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Validate_Exception extends PEAR2_Exception
{
    /**
     * package.xml field that failed channel-specific validation
     *
     * @var string
     */
    public $field;
    /**
     * The reason that validation failed
     *
     * @var string
     */
    public $reason;
    /**
     * Set up message/field combination for package.xml validation
     *
     * @param string $msg
     * @param string $field
     */
    public function __construct($msg, $field)
    {
        $this->reason = $msg;
        $msg = 'Channel validator error: field "' . $field . '" - ' .
                    $msg;
        parent::__construct($msg);
        $this->field = $field;
    }
}<?php
/**
 * Channel Validator for the pecl.php.net channel
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Channel Validator for the pecl.php.net channel
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Validator_PECL extends PEAR2_Pyrus_Validate
{
    function validateVersion()
    {
        if ($this->_state == PEAR2_Pyrus_Validate::PACKAGING) {
            $version = $this->_packagexml->version['release'];
            $versioncomponents = explode('.', $version);
            $last = array_pop($versioncomponents);
            if (substr($last, 1, 2) == 'rc') {
                $this->_addFailure('version', 'Release Candidate versions must have ' .
                'upper-case RC, not lower-case rc');
                return false;
            }
        }
        return true;
    }

    function validatePackageName()
    {
        $ret = parent::validatePackageName();
        if (in_array($this->_packagexml->getPackageType(), array('extsrc', 'zendextsrc'))) {
            $package  = $this->_packagexml->name;
            $provides = $this->_packagexml->providesextension;
            if (strtolower($package) != strtolower($provides)) {
                $this->_addWarning('providesextension', 'package name "' .
                    $package . '" is different from extension name "' .
                    $provides . '"');
            }
        }

        return $ret;
    }
}<?php
/**
 * PEAR2_Pyrus_XMLParser_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for the XMLParser
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_XMLParser_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_XMLWriter_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Exception class for the XMLWriter
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_XMLWriter_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_AtomicFileTransaction
 *
 * This class implements a simple, nearly atomic way of handling file installation
 * transaction similar to the way a database handles a query transaction.
 *
 * To use, first call {@link PEAR2_Pyrus_AtomicFileTransaction::begin()} and
 * then remove old files with {@link PEAR2_Pyrus_AtomicFileTransaction::removePath()}
 * or install new files with {@link PEAR2_Pyrus_AtomicFileTransaction::createOrOpenPath()}.
 *
 * To abort, use {@link PEAR2_Pyrus_AtomicFileTransaction::rollback()}, and to
 * finish, use {@link PEAR2_Pyrus_AtomicFileTransaction::commit()} followed by
 * {@link PEAR2_Pyrus_AtomicFileTransaction::removeBackups()}.
 *
 * The separation of backup removal from committing allows attempting to modify the
 * registry in between file installation and removal of backups, so that in the
 * worst case, it is easy to completely roll back the file installation without
 * any loss of information, even after the process has terminated.
 *
 * To repair a broken commit or rollback, use
 * {@link PEAR2_Pyrus_AtomicFileTransaction::repair()}.
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Atomic file installation infrastructure, guarantees safe installation.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_AtomicFileTransaction
{
    static protected $allTransactObjects = array();
    static protected $intransaction = false;
    static protected $inrepair = false;
    protected $rolepath;
    protected $journalpath;
    protected $backuppath;
    protected $defaultMode;
    protected $committed = false;

    protected function __construct($rolepath)
    {
        $this->rolepath = $rolepath;
        $this->backuppath = dirname($rolepath) . DIRECTORY_SEPARATOR .
            '.old-' . basename($rolepath);
        $this->journalpath = dirname($rolepath) . DIRECTORY_SEPARATOR .
            '.journal-' . basename($rolepath);
        $this->defaultMode = PEAR2_Pyrus_Config::current()->umask;
    }

    /**
     * Repair from a previously failed transaction cut off mid-transaction
     */
    static function repair()
    {
        if (static::$intransaction) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot repair while in a transaction');
        }
        static::$inrepair = true;
        static::$allTransactObjects = array();
        $config = PEAR2_Pyrus_Config::current();
        $remove = array();
        foreach ($config->systemvars as $var) {
            if (!strpos($var, '_dir')) {
                continue;
            }

            $path = $config->$var;
            $backuppath = dirname($path) . DIRECTORY_SEPARATOR . '.old-' . basename($path);
            if (file_exists($backuppath) && is_dir($backuppath)) {
                if (file_exists($path)) {
                    if (is_dir($path)) {
                        // this is the new stuff from journal path, so move it out of the way
                        $journalpath = dirname($path) . DIRECTORY_SEPARATOR . '.journal-' . basename($path);
                        $remove[] = $journalpath;
                        rename($path, $journalpath);
                    } else {
                        static::$inrepair = false;
                        throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                            'Repair failed - ' . $var . ' path ' . $path .
                            ' is not a directory.  Move this file out of the way and ' .
                            'try the repair again'
                        );
                    }
                }
                // restore backup
                rename($backuppath, $path);
            }
        }
        foreach ($remove as $path) {
            static::rmrf($path);
        }
        static::$inrepair = false;
    }

    /**
     * @param string|PEAR2_Pyrus_Installer_Role_Common $rolepath
     * @return PEAR2_Pyrus_AtomicFileTransaction
     */
    static function getTransactionObject($rolepath)
    {
        if ($rolepath instanceof PEAR2_Pyrus_Installer_Role_Common) {
            $rolepath = PEAR2_Pyrus_Config::current()->{$rolepath->getLocationConfig()};
        }
        if (isset(static::$allTransactObjects[$rolepath])) {
            return static::$allTransactObjects[$rolepath];
        }
        $ret = static::$allTransactObjects[$rolepath] = new PEAR2_Pyrus_AtomicFileTransaction($rolepath);

        if (static::$intransaction) {
            // start the transaction process for this atomic transaction object
            $errs =  new PEAR2_MultiErrors;
            try {
                $ret->beginTransaction();
            } catch (\Exception $e) {
                $errs->E_ERROR[] = $e;
                foreach (static::$allTransactObjects as $path2 => $transact) {
                    try {
                        $transact->removeJournalPath();
                    } catch (\Exception $e2) {
                        $errs->E_WARNING[] = $e2;
                    }
                }
                throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                    'Unable to begin transaction for ' . $rolepath, $errs
                );
            }
        }
        return $ret;
    }

    function removePath($relativepath, $strict = true)
    {
        if (!static::$intransaction) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot remove ' . $relativepath .
                                                                  ' - not in a transaction');
        }
        $path = $this->journalpath . DIRECTORY_SEPARATOR . $relativepath;
        if (!file_exists($path)) {
            return;
        }
        if (is_dir($path)) {
            if (!@rmdir($path) && $strict) {
                throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                    'Cannot remove directory ' . $relativepath . ' in ' . $this->journalpath);
            }
        } else {
            if (!@unlink($path) && $strict) {
                throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                    'Cannot remove file ' . $relativepath . ' in ' . $this->journalpath);
            }
        }
    }

    function mkdir($relativepath, $mode = null)
    {
        if (!static::$intransaction) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot create directory ' . $relativepath .
                                                                  ' - not in a transaction');
        }
        $path = $this->journalpath . DIRECTORY_SEPARATOR . str_replace('/', DIRECTORY_SEPARATOR, $relativepath);
        if (file_exists($path)) {
            if (is_dir($path)) {
                return;
            }
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot create directory ' . $relativepath .
                                                                  ', it is a file');
        }
        if (!@mkdir($path, $mode, true)) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Unable to make directory ' .
                $relativepath . ' in ' . $this->journalpath);
        }
        if ($mode === null) {
            $mode = $this->defaultMode;
        }
        if ($mode) {
            $old = umask(0);
            chmod($path, $mode);
            umask($old);
        }
    }

    /**
     * To perform modifications on a path within the journal transaction
     */
    function openPath($relativepath)
    {
        if (!static::$intransaction) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot open ' . $relativepath .
                                                                  ' - not in a transaction');
        }
        $path = $this->journalpath . DIRECTORY_SEPARATOR . str_replace('/', DIRECTORY_SEPARATOR, $relativepath);
        $fp = @fopen($path, 'rb+');
        if (!$fp) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Unable to open ' .
                $relativepath . ' for writing in ' . $this->journalpath);
        }
        return $fp;
    }

    function createOrOpenPath($relativepath, $contents = null, $mode = null)
    {
        if (!static::$intransaction) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot create ' . $relativepath .
                                                                  ' - not in a transaction');
        }
        if ($mode === null) {
            $mode = $this->defaultMode;
        }
        $path = $this->journalpath . DIRECTORY_SEPARATOR . str_replace('/', DIRECTORY_SEPARATOR, $relativepath);
        if ($contents) {
            if (is_resource($contents)) {
                $fp = @fopen($path, 'wb');
                if (!$fp) {
                    throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Unable to open ' .
                        $relativepath . ' for writing in ' . $this->journalpath);
                }
                if (false === stream_copy_to_stream($contents, $fp)) {
                    fclose($fp);
                    throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Unable to copy to ' .
                        $relativepath . ' in ' . $this->journalpath);
                }
                fclose($fp);
            } else {
                if (!@file_put_contents($path, $contents)) {
                    throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Unable to write to ' .
                        $relativepath . ' in ' . $this->journalpath);
                }
            }
            if ($mode) {
                $old = umask(0);
                chmod($path, $mode);
                umask($old);
            }
            return $path;
        } else {
            $fp = @fopen($path, 'wb');
            if (!$fp) {
                throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Unable to open ' .
                    $relativepath . ' for writing in ' . $this->journalpath);
            }
            if ($mode) {
                $old = umask(0);
                chmod($path, $mode);
                umask($old);
            }
            return $fp;
        }
    }

    /**
     * Remove all empty directories on uninstall
     */
    static function rmEmptyDirs($dirtrees)
    {
        foreach ($dirtrees as $dirtree) {
            foreach ($dirtree as $dir) {
                foreach (static::$allTransactObjects as $path => $obj) {
                    if (0 === strpos($path, $dir)) {
                        // only remove empty directories, don't throw exception on
                        // non-empty directories
                        $obj->rmrf($dir, true, false);
                    }
                }
            }
        }
    }

    static function rmrf($path, $onlyEmptyDirs = false, $strict = true)
    {
        foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($path),
                                               RecursiveIteratorIterator::CHILD_FIRST)
                 as $file) {
            if ($file->getFilename() == '.' || $file->getFilename() == '..') {
                continue;
            }
            if (is_dir($file->getPathname())) {
                if (!rmdir($file->getPathname())) {
                    if (!$strict) {
                        return;
                    }
                    throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                        'Unable to fully remove ' . $path);
                }
            } else {
                if ($onlyEmptyDirs) {
                    if (!$strict) {
                        return;
                    }
                    throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                        'Unable to fully remove ' . $path . ', directory is not empty');
                    return;
                }
                if (!unlink($file->getPathname())) {
                    throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                        'Unable to fully remove ' . $path);
                }
            }
        }
        rmdir($path);
    }

    function copyToJournal()
    {
        try {
            $oldumask = umask();
            umask(000);
            foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this->rolepath),
                                                   RecursiveIteratorIterator::SELF_FIRST)
                     as $file) {
                if ($file->getFilename() == '.' || $file->getFilename() == '..') {
                    continue;
                }
                $time = $file->getMTime();
                $atime = $file->getATime();
                $perms = $file->getPerms();
                $src = str_replace($this->rolepath . DIRECTORY_SEPARATOR, '', $file->getPathname());
                if (is_dir($file->getPathname())) {
                    if (!mkdir($this->journalpath . DIRECTORY_SEPARATOR . $src, $perms)) {
                        umask($oldumask);
                        throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                            'Unable to complete journal creation for transaction');
                    }
                    if (!touch($this->journalpath . DIRECTORY_SEPARATOR . $src, $time, $atime)) {
                        umask($oldumask);
                        throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                            'Unable to complete journal creation for transaction');
                    }
                    continue;
                }
                if (!copy($file->getPathName(), $this->journalpath . DIRECTORY_SEPARATOR . $src)) {
                    umask($oldumask);
                    throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                        'Unable to complete journal creation for transaction');
                }
                if (!touch($this->journalpath . DIRECTORY_SEPARATOR . $src, $time, $atime)) {
                    umask($oldumask);
                    throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                        'Unable to complete journal creation for transaction');
                }
                if (!chmod($this->journalpath . DIRECTORY_SEPARATOR . $src, $perms)) {
                    umask($oldumask);
                    throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                        'Unable to complete journal creation for transaction');
                }
            }
            umask($oldumask);
        } catch (\UnexpectedValueException $e) {
            // directory does not exist, so we ignore the exception and reset umask
            umask($oldumask);
            return;
        }
    }

    static function begin()
    {
        if (static::$intransaction) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot begin - already in a transaction');
        }
        $errs = new PEAR2_MultiErrors;
        try {
            foreach (static::$allTransactObjects as $path => $transact) {
                $transact->beginTransaction();
            }
            static::$intransaction = true;
        } catch (\Exception $e) {
            static::$intransaction = true;
            $errs->E_ERROR = $e;
            $exit = false;
            foreach (static::$allTransactObjects as $path2 => $transact) {
                if ($exit) {
                    break;
                }
                if ($path2 === $path) {
                    $exit = true;
                }
                try {
                    $transact->removeJournalPath();
                } catch (\Exception $e2) {
                    $errs->E_WARNING[] = $e2;
                }
            }
        }
        if (count($errs)) {
            static::$intransaction = false;
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                'Unable to begin transaction', $errs
            );
        }
    }

    function beginTransaction()
    {
        if (!file_exists($this->journalpath)) {
create_journal:
            @mkdir($this->journalpath, 0755, true);
            if (!file_exists($this->journalpath)) {
                throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                    'unrecoverable transaction error: cannot create journal path ' . $this->journalpath);
            }
            $this->copyToJournal();
        } elseif (!is_dir($this->journalpath)) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                'unrecoverable transaction error: journal path ' . $this->journalpath .
                ' exists and is not a directory');
        } else {
            $this->rmrf($this->journalpath);
            goto create_journal;
        }
    }

    static function rollback()
    {
        if (!static::$intransaction) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot rollback - not in a transaction');
        }
        foreach (static::$allTransactObjects as $transaction) {
            // restore the original source as quickly as possible
            $transaction->restoreBackup();
        }
        $failed = array();
        $errs = new PEAR2_MultiErrors;
        foreach (static::$allTransactObjects as $path => $transaction) {
            try {
                // ... and then delete the transaction
                $transaction->removeJournalPath();
            } catch (PEAR2_Pyrus_AtomicFileTransaction_Exception $e) {
                $errs->E_WARNING[] = $e;
            }
        }
        static::$intransaction = false;
        if (count($errs)) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Warning: rollback did not succeed for all transactions',
                                                                  $errs);
        }
    }

    function restoreBackup()
    {
        if (!$this->committed) {
            return;
        }
        if (!file_exists($this->rolepath)) {
            rename($this->backuppath, $this->rolepath);
        } elseif (!file_exists($this->journalpath) && file_exists($this->rolepath)  && file_exists($this->backuppath)) {
            rename($this->rolepath, $this->journalpath);
            rename($this->backuppath, $this->rolepath);
        }
    }

    function removeJournalPath()
    {
        if (!static::$intransaction) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot remove journal path - not in a transaction');
        }
        if (!file_exists($this->journalpath) || !is_dir($this->journalpath)) {
            return;
        }
        $this->rmrf($this->journalpath);
    }

    static function commit()
    {
        if (!static::$intransaction) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot commit - not in a transaction');
        }
        $errs = new PEAR2_MultiErrors;
        try {
            foreach (static::$allTransactObjects as $transaction) {
                $transaction->backupAndCommit();
            }
        } catch (\Exception $e) {
            $errs->E_ERROR[] = $e;
            static::rollback();
        }
        if (count($errs->E_ERROR)) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('ERROR: commit failed',
                                                                  $errs);
        } elseif (count($errs->E_WARNING)) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Warning: removal of backups did not succeed',
                                                                  $errs);
        }
    }

    static function removeBackups()
    {
        if (!static::$intransaction) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot remove backups - not in a transaction');
        }
        $errs = new PEAR2_MultiErrors;
        foreach (static::$allTransactObjects as $path => $transaction) {
            try {
                $transaction->removeBackup();
            } catch (PEAR2_Pyrus_AtomicFileTransaction_Exception $e) {
                $errs->E_WARNING[] = $e;
            }
        }
        if (count($errs->E_WARNING)) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Warning: removal of backups did not succeed',
                                                                  $errs);
        }
        static::$intransaction = false;
    }

    function removeBackup()
    {
        if ($this->committed && file_exists($this->backuppath)) {
            $this->rmrf($this->backuppath);
        }
    }

    function backupAndCommit()
    {
        if (!static::$intransaction) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception('Cannot commit - not in a transaction');
        }
        if (file_exists($this->backuppath) || (file_exists($this->rolepath) && !rename($this->rolepath, $this->backuppath))) {
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                'CRITICAL - unable to complete transaction, rename of actual to backup path failed');
        }
        // here is the only critical moment - a failure in between these two renames
        // leaves us with no source
        if (!rename($this->journalpath, $this->rolepath)) {
            rename($this->backuppath, $this->rolepath);
            throw new PEAR2_Pyrus_AtomicFileTransaction_Exception(
                'CRITICAL - unable to complete transaction, rename of journal to actual path failed');
        }
        $this->committed = true;
    }
}<?php
/**
 * PEAR2_Pyrus_Channel
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Pyrus.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Channel implements PEAR2_Pyrus_IChannel
{
    protected $internal;
    
    /**
     * Construct a PEAR2_Pyrus_Channel object
     *
     */
    function __construct(PEAR2_Pyrus_IChannelFile $info)
    {
        $this->internal = $info;
    }

    function __get($var)
    {
        return $this->internal->$var;
    }
    
    function __set($var, $value)
    {
        $this->internal->$var = $value;
    }
    
    function __toString()
    {
        return $this->internal->__toString();
    }
    
    function __call($func, $args)
    {
        // delegate to the internal object
        return call_user_func_array(array($this->internal, $func), $args);
    }
    
    public function getValidationObject($package = false)
    {
        return $this->internal->getValidationObject($package);
    }
    
    public function getValidationPackage()
    {
        return $this->internal->getValidationPackage();
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelFile
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for a PEAR2 package file
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelFile implements PEAR2_Pyrus_IChannelFile
{
    protected $info;
    public $path;

    /**
     * Take a local channel.xml and parse it.
     * @param string file name, or xml string
     */
    function __construct($file, $isxml = false, $isremote = false)
    {
        $this->path = $file;
        $parser = new PEAR2_Pyrus_ChannelFile_Parser_v1;
        if ($isxml) {
            $data = $file;
        } elseif ($isremote) {
            if (strpos($file, 'http://') === 0
                || strpos($file, 'https://') === 0) {
                $data = $this->_fromURL($file);
            } else {
                try {
                    $xml_url = 'https://' . $file . '/channel.xml';
                    $data = $this->_fromURL($xml_url);
                } catch (\Exception $e) {
                    // try insecure
                    try {
                        $xml_url = 'http://' . $file . '/channel.xml';
                        $data = $this->_fromURL($xml_url);
                    } catch (\Exception $e2) {
                        // failed, re-throw original error
                        throw $e;
                    }
                }
            }
        } else {
            $data = @file_get_contents($file);
        }
        if ($data === false || empty($data)) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('Unable to open channel xml file '
                . $file . ' or file was empty.');
        }
        $this->info = $parser->parse($data);
    }

    function __get($var)
    {
        return $this->info->$var;
    }
    
    function __set($var, $value)
    {
        $this->info->$var = $value;
    }
    
    function __call($func, $args)
    {
        // delegate to the internal object
        if (!is_callable(array($this->info, $func))) {
            throw new PEAR2_Pyrus_ChannelFile_Exception('unknown method: ' . @get_class($this->info) . '::' .
                                                        $func);
        }
        return call_user_func_array(array($this->info, $func), $args);
    }
    
    function __toString()
    {
        return $this->info->__toString();
    }

    /**
     * Attempts to get the xml from the URL specified.
     * 
     * @param string $xml_url URL to the channel xml http://pear.php.net/channel.xml
     * 
     * @return string Channel XML
     */
    protected function _fromURL($xml_url)
    {
        $http = new PEAR2_HTTP_Request($xml_url);
        $response = $http->sendRequest();
        return $response->body;
    }
}
<?php
/**
 * PEAR2_Pyrus_ChannelRegistry
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Pyrus.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ChannelRegistry implements ArrayAccess, IteratorAggregate, PEAR2_Pyrus_IChannelRegistry
{
    /**
     * Class to instantiate for singleton.
     *
     * This is useful for unit-testing and for extending the registry
     * @var string
     */
    static public $className = 'PEAR2_Pyrus_ChannelRegistry';
    /**
     * The parent registry
     *
     * This is used to implement cascading registries
     * @var PEAR2_Pyrus_ChannelRegistry
     */
    protected $parent;
    protected $path;
    protected $readonly;
    private $_registries = array();

    public function __construct($path, $registries = array('Sqlite3', 'Xml'), $readonly = false)
    {
        $this->path = $path;
        $this->readonly = $readonly;
        $exceptions = array();
        foreach ($registries as $registry) {
            try {
                $registry = ucfirst($registry);
                $registry = "PEAR2_Pyrus_ChannelRegistry_$registry";
                if (!class_exists($registry, true)) {
                    $exceptions[] = new PEAR2_Pyrus_ChannelRegistry_Exception(
                        'Unknown channel registry type: ' . $registry);
                    continue;
                }
                $this->_registries[] = new $registry($path, $readonly);
            } catch (PEAR2_Pyrus_ChannelRegistry_Exception $e) {
                $exceptions[] = $e;
            }
        }
        if (!count($this->_registries)) {
            throw new PEAR2_Pyrus_Registry_Exception(
                'Unable to initialize registry for path "' . $path . '"',
                $exceptions);
        }
    }

    public function setParent(PEAR2_Pyrus_ChannelRegistry $parent = null)
    {
        $this->parent = $parent;
    }

    /**
     * Add a channel to the registry.
     *
     * @param PEAR2_Pyrus_IChannel $channel Channel to add.
     */
    public function add(PEAR2_Pyrus_IChannel $channel, $update = false, $lastmodified = false)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel, registry is read-only');
        }
        foreach ($this->_registries as $reg) {
            $reg->add($channel, $update, $lastmodified);
        }
    }

    public function update(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot update channel, registry is read-only');
        }
        foreach ($this->_registries as $reg) {
            $reg->update($channel);
        }
    }

    public function delete(PEAR2_Pyrus_IChannel $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel, registry is read-only');
        }
        switch ($channel->name) {
            case 'pear.php.net' :
            case 'pear2.php.net' :
            case 'pecl.php.net' :
            case '__uri' :
                throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete default channel ' .
                    $channel->name);
        }
        foreach ($this->_registries as $reg) {
            $reg->delete($channel);
        }
    }

    public function get($channel, $strict = true)
    {
        try {
            return $this->_registries[0]->get($channel, $strict);
        } catch (Exception $e) {
            // don't fail on the default channels, these should always exist
            switch ($channel) {
                case 'pear.php.net' :
                    return $this->_registries[0]->getPearChannel();
                case 'pear2.php.net' :
                    return $this->_registries[0]->getPear2Channel();
                case 'pecl.php.net' :
                    return $this->_registries[0]->getPeclChannel();
                case '__uri' :
                    return $this->_registries[0]->getUriChannel();
            }
            throw $e;
        }
    }

    /**
     * Check if channel has been discovered and in the registry.
     *
     * @param string $channel Channel name or alias: pear.php.net, pear
     * @param bool   $strict  Do not check aliases.
     * 
     * @return bool
     */
    public function exists($channel, $strict = true)
    {
        if (!$this->_registries[0]->exists($channel, $strict)) {
            switch ($channel) {
                case 'pear.php.net' :
                case 'pear2.php.net' :
                case 'pecl.php.net' :
                case '__uri' :
                    return true;
            }
            if (!$strict) {
                switch ($channel) {
                    case 'pear' :
                    case 'pear2' :
                    case 'pecl' :
                        return true;
                }
            }
            return false;
        }
        return true;
    }

    public function parseName($name, $defaultChannel = 'pear2.php.net')
    {
        foreach ($this->_registries as $reg) {
            try {
                return $reg->parseName($name, $defaultChannel);
            } catch (Exception $e) {
                continue;
            }
        }
        if ($this->parent) {
            return $this->parent->parseName($name, $defaultChannel);
        }
        // recycle last exception
        throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unable to process package name', $e);
    }

    public function parsedNameToString($name)
    {
        foreach ($this->_registries as $reg) {
            try {
                return $reg->parsedNameToString($name);
            } catch (Exception $e) {
                continue;
            }
        }
        if ($this->parent) {
            return $this->parent->parsedNameToString($name);
        }
        // recycle last exception
        throw new PEAR2_Pyrus_ChannelRegistry_Exception('Unable to convert to package name string', $e);
    }

    public function listChannels()
    {
        return $this->_registries[0]->listChannels();
    }

    public function offsetGet($offset)
    {
        return $this->get($offset);
    }

    public function offsetSet($offset, $value)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot add channel, registry is read-only');
        }
        if ($value instanceof PEAR2_Pyrus_IChannelFile) {
            $value = new PEAR2_Pyrus_Channel($value);
        }
        foreach ($this->_registries as $reg) {
            $reg->add($value);
        }
    }

    public function offsetExists($offset)
    {
        return $this->exists($offset);
    }

    public function offsetUnset($offset)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_ChannelRegistry_Exception('Cannot delete channel, registry is read-only');
        }
        $chan = $this->get($offset, false);
        foreach ($this->_registries as $reg) {
            $reg->delete($chan);
        }
    }

    public function __call($method, $args)
    {
        return call_user_func_array(array($this->_registries[0], $method), $args);
    }

    public function getIterator()
    {
        return $this->_registries[0];
    }

    public function getParent()
    {
        return $this->parent;
    }

    public function getPath()
    {
        return $this->path;
    }
}
<?php
/**
 * PEAR2_Pyrus_Config
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Pyrus's master configuration manager
 *
 * Unlike PEAR version 1.x, the new Pyrus configuration manager is tightly bound
 * to include_path, and will search through include_path for system configuration
 * Pyrus installations.  In addition, the configuration is minimal.  If no changes
 * have been made since instantiation, no attempt is made to write out the configuration
 * file
 *
 * The User configuration file will be looked for in these locations:
 *
 * Unix:
 *
 * - home directory
 * - current directory
 *
 * Windows:
 *
 * - local settings directory on windows for the current user.
 *   This is looked up directly in the windows registry using COM
 * - current directory
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Config
{
    /**
     * location of PEAR2 installation
     *
     * @var string
     */
    protected $pearDir;

    /**
     * location of user-specific configuration file
     *
     * @var string
     */
    protected $userFile;

    /**
     * registry for this {@link $pearDir} value
     *
     * @var PEAR2_Pyrus_Registry
     */
    protected $myregistry;

    /**
     * channel registry for this {@link $pearDir} value
     *
     * @var PEAR2_Pyrus_Channel_Registry
     */
    protected $mychannelRegistry;
    /**
     * registry for plugins, which are kept in the plugin_dir directory
     *
     * @var PEAR2_Pyrus_PluginRegistry
     */
    protected $mypluginregistry;

    /**
     * configuration values for this configuration object
     *
     * @var string
     */
    protected $values;

    static protected $initializing = false;
    /**
     * mapping of path => PEAR2 configuration objects
     *
     * @var array
     */
    static protected $configs = array();

    /**
     * mapping of path => flag on modification
     *
     * If an index is not set, it has not been modified
     * @var array
     */
    static protected $configDirty = array();

    /**
     * The last instantiated configuration
     *
     * @var PEAR2_Pyrus_Config
     */
    static protected $current;

    /**
     * Default values for custom configuration values set by custom file roles.
     * @var array
     */
    static protected $customDefaults = array();

    /**
     * Default values for configuration.
     *
     * @php_dir@ is automatically replaced with the current
     * PEAR2 configuration location
     * @var array
     */
    static protected $defaults =
        array(
            'php_dir' => '@php_dir@/php', // pseudo-value in this implementation
            'ext_dir' => '@php_dir@/ext',
            'doc_dir' => '@php_dir@/docs',
            'bin_dir' => PHP_BINDIR,
            'data_dir' => '@php_dir@/data', // pseudo-value in this implementation
            'cfg_dir' => '@php_dir@/cfg',
            'www_dir' => '@php_dir@/www',
            'test_dir' => '@php_dir@/tests',
            'src_dir' => '@php_dir@/src',
            'php_bin' => '',
            'php_prefix' => '',
            'php_suffix' => '',
            'php_ini' => '',
            'default_channel' => 'pear2.php.net',
            'preferred_mirror' => 'pear2.php.net',
            'auto_discover' => 0,
            'http_proxy' => '',
            'cache_dir' => '@php_dir@/cache',
            'temp_dir' => '@php_dir@/temp',
            'download_dir' => '@php_dir@/downloads',
            'username' => '',
            'password' => '',
            'verbose' => 1,
            'preferred_state' => 'stable',
            'umask' => '0022',
            'cache_ttl' => 3600,
            'sig_type' => '',
            'sig_bin' => '',
            'sig_keyid' => '',
            'sig_keydir' => '',
            'my_pear_path' => '@php_dir@',
            'plugins_dir' => '@default_config_dir@',
        );

    /**
     * Mapping of user configuration file path => config values
     *
     * @var array
     */
    static protected $userConfigs = array();

    /**
     * Configuration variable names that are bound to the PEAR installation
     *
     * These are values that should not change for different users
     * @var array
     */
    static protected $pearConfigNames = array(
            'php_dir', // pseudo-value in this implementation
            'ext_dir',
            'cfg_dir',
            'doc_dir',
            'bin_dir',
            'data_dir', // pseudo-value in this implementation
            'www_dir',
            'test_dir',
            'src_dir',
            'php_bin',
            'php_ini',
            'php_prefix',
            'php_suffix',
        );

    /**
     * Custom configuration variable names that are bound to the PEAR installation
     *
     * These are values that should not change for different users, and are
     * set by custom file roles
     * @var array
     */
    static protected $customPearConfigNames = array();

    /**
     * Configuration variable names that are user-specific
     *
     * These are values that are user preferences rather than
     * information necessary for installation on the filesystem.
     * @var array
     */
    static protected $userConfigNames = array(
            'default_channel',
            'preferred_mirror',
            'auto_discover',
            'http_proxy',
            'cache_dir',
            'temp_dir',
            'download_dir',
            'username',
            'password',
            'verbose',
            'preferred_state',
            'umask',
            'cache_ttl',
            'sig_type',
            'sig_bin',
            'sig_keyid',
            'sig_keydir',
            'my_pear_path', // PATH_SEPARATOR-separated list of PEAR repositories to manage
            'plugins_dir', // full path to location where pyrus plugins are installed
        );
    /**
     * Configuration variable names that are user-specific
     *
     * These are values that are user preferences rather than
     * information necessary for installation on the filesystem, and
     * are set up by custom file roles
     * @var array
     */
    static protected $customUserConfigNames = array();

    /**
     * __get variables that cannot be used as custom config values
     * @var array
     */
    static protected $magicVars = array('registry',
                                        'channelregistry',
                                        'systemvars',
                                        'uservars',
                                        'mainsystemvars',
                                        'mainuservars',
                                        'userfile',
                                        'path');
    /**
     * Set up default configuration values that need to be determined at runtime
     *
     * The ext_dir variable, bin_dir variable, and php_ini are set up in
     * this method.
     */
    protected static function constructDefaults()
    {
        static $called = false;
        if ($called) {
            return;
        }

        $called = true;
        // set up default ext_dir
        if (getenv('PHP_PEAR_EXTENSION_DIR')) {
            self::$defaults['ext_dir'] = getenv('PHP_PEAR_EXTENSION_DIR');
            PEAR2_Pyrus_Log::log(5, 'used PHP_PEAR_EXTENSION_DIR environment variable');
        } elseif (ini_get('extension_dir')) {
            self::$defaults['ext_dir'] = ini_get('extension_dir');
            PEAR2_Pyrus_Log::log(5, 'used ini_get(extension_dir)');
        } elseif (defined('PEAR_EXTENSION_DIR')) {
            self::$defaults['ext_dir'] = PEAR_EXTENSION_DIR;
            PEAR2_Pyrus_Log::log(5, 'used PEAR_EXTENSION_DIR constant');
        }

        // set up default bin_dir
        if (getenv('PHP_PEAR_BIN_DIR')) {
            self::$defaults['bin_dir'] = getenv('PHP_PEAR_BIN_DIR');
            PEAR2_Pyrus_Log::log(5, 'used PHP_PEAR_BIN_DIR environment variable');
        } elseif (PATH_SEPARATOR == ';') {
            // we're on windows, and shouldn't use PHP_BINDIR
            do {
                if (!isset($_ENV) || !isset($_ENV['PATH'])) {
                    $path = getenv('PATH');
                } else {
                    $path = $_ENV['PATH'];
                }

                if (!$path) {
                    PEAR2_Pyrus_Log::log(5, 'used PHP_BINDIR on windows for bin_dir default');
                    break; // can't get PATH, so use PHP_BINDIR
                }

                $paths = explode(';', $path);
                foreach ($paths as $path) {
                    if ($path != '.' && is_writable($path)) {
                        // this place will do
                        PEAR2_Pyrus_Log::log(5, 'used ' . $path . ' for default bin_dir');
                        self::$defaults['bin_dir'] = $path;
                    }
                }
            } while (false);
        } else {
            PEAR2_Pyrus_Log::log(5, 'used PHP_BINDIR for bin_dir default');
        }

        // construct php_bin
        if (substr(PHP_OS, 0, 3) == 'WIN') {
            if (file_exists(self::$defaults['bin_dir'] . DIRECTORY_SEPARATOR . 'php.exe')) {
                self::$defaults['php_bin'] = self::$defaults['bin_dir'] . DIRECTORY_SEPARATOR . 'php.exe';
            } else {
                foreach (explode(PATH_SEPARATOR, $_ENV['PATH']) as $path) {
                    if (file_exists($path . DIRECTORY_SEPARATOR . 'php.exe')) {
                        self::$defaults['php_bin'] = $path . DIRECTORY_SEPARATOR . 'php.exe';
                    }
                }
            }
        } else {
            if (file_exists(self::$defaults['bin_dir'] . DIRECTORY_SEPARATOR . 'php')) {
                self::$defaults['php_bin'] = self::$defaults['bin_dir'] . DIRECTORY_SEPARATOR . 'php';
            } elseif (isset($_ENV['PATH'])) {
                foreach (explode(PATH_SEPARATOR, $_ENV['PATH']) as $path) {
                    if (file_exists($path . DIRECTORY_SEPARATOR . 'php')) {
                        self::$defaults['php_bin'] = $path . DIRECTORY_SEPARATOR . 'php';
                    }
                }
            }
        }

        foreach (array_merge(self::$pearConfigNames,
                             self::$userConfigNames) as $name) {
            // make sure we've got valid paths for the underlying OS
            self::$defaults[$name] = str_replace('/', DIRECTORY_SEPARATOR,
                                                 self::$defaults[$name]);
        }

        self::$defaults['php_ini'] = php_ini_loaded_file();
        if (self::$defaults['php_ini']) {
            PEAR2_Pyrus_Log::log(5, 'Used ' . self::$defaults['php_ini'] . ' for php.ini location');
        } else {
            PEAR2_Pyrus_Log::log(5, 'Could not find php.ini');
        }
    }

    /**
     * parse a configuration for a PEAR2 installation
     *
     * @param string $pearDirectory This can be either a single path, or a
     *                              PATH_SEPARATOR-separated list of directories
     * @param string $userfile
     */
    protected function __construct($pearDirectory = false, $userfile = false)
    {
        self::$initializing = true;
        self::constructDefaults();
        if ($pearDirectory) {
            $pearDirectory = str_replace(array('\\', '//', '/'),
                                         array('/',  '/', DIRECTORY_SEPARATOR),
                                         $pearDirectory);
        }

        $this->loadUserSettings($pearDirectory, $userfile);
        $pearDirectory = $this->setupCascadingRegistries($pearDirectory);
        if ($pearDirectory) {
            $this->loadConfigFile($pearDirectory);
        }
        self::$configs[$pearDirectory] = $this;
        $this->pearDir = $pearDirectory;

        // Always set the current config to the most recently created one.
        self::$current = $this;
        self::$initializing = false;
    }

    static function initializing()
    {
        return self::$initializing;
    }

    /**
     * Retrieve configuration for a PEAR2 installation
     *
     * @param string $pearDirectory
     * @param string $userfile
     * @return PEAR2_Pyrus_Config
     */
    static public function singleton($pearDirectory = false, $userfile = false)
    {
        if ($pearDirectory && file_exists($pearDirectory)) {
            $pearDirectory = realpath($pearDirectory);
        }
        if (isset(self::$configs[$pearDirectory])) {
            return self::$configs[$pearDirectory];
        }
        self::$configs[$pearDirectory] = new static($pearDirectory, $userfile);
        return self::$configs[$pearDirectory];
    }

    /**
     * set the paths to scan for pyrus installations
     */
    public function setCascadingRegistries($path)
    {
        $paths = explode(PATH_SEPARATOR, $path);

        $paths = array_unique($paths);
        $readonly = false;
        foreach ($paths as $path) {
            try {
                if ($path === '.') continue;
                
                $registry_class        = PEAR2_Pyrus_Registry::$className;
                $channelregistry_class = PEAR2_Pyrus_ChannelRegistry::$className;

                $registries = PEAR2_Pyrus_Registry::detectRegistries($path);
                if (!count($registries)) {
                    if ($readonly) {
                        // no installation present
                        continue;
                    }
                    $registries = array('Sqlite3', 'Xml');
                }

                $registry         = new $registry_class($path, $registries, $readonly);
                $channel_registry = new $channelregistry_class($path, $registries, $readonly);
                
                if (!$readonly) {
                    $this->myregistry        = $registry;
                    $this->mychannelRegistry = $channel_registry;
                }

                $readonly = true;
                
                $registry->setParent(); // clear any previous parent
                $channel_registry->setParent(); // clear any previous parent
                
                if (isset($last)) {
                    $last->setParent($registry);
                    $lastc->setParent($channel_registry);
                }

                $last  = $registry;
                $lastc = $channel_registry;
                
            } catch (Exception $e) {
                if (!$readonly) {
                    throw new PEAR2_Pyrus_Config_Exception(
                        'Cannot initialize primary registry in path ' .
                        $path, $e);
                } else {
                    // silently skip this registry
                    continue;
                }
            }
        }
        return $paths[0];
    }

    /**
     * Retrieve the currently active primary configuration
     * @return PEAR2_Pyrus_Config
     */
    static public function current()
    {
        if (isset(self::$current)) {
            return self::$current;
        }
        // default
        return static::singleton();
    }

    /**
     * Can be used to determine whether this user has ever run pyrus before
     */
    static public function userInitialized()
    {
        $userfile = static::getDefaultUserConfigFile();
        if (isset(self::$current)) {
            if (self::$current->userfile != $userfile) {
                // an explicit userfile was specified, so we assume this was intentional
                return true;
            }
        }
        if (!file_exists($userfile)) {
            // try cwd, this could work
            $test = realpath(getcwd() . DIRECTORY_SEPARATOR . 'pearconfig.xml');
            if ($test && file_exists($test)) {
                PEAR2_Pyrus_Log::log(5, 'User is initialized, found user configuration file in current directory' .
                    $userfile);
                return true;
            }
        } else {
            PEAR2_Pyrus_Log::log(5, 'User is initialized, found default user configuration file ' .
                $userfile);
            return true;
        }
        // no way to tell, must be explicit
        return false;
    }

    static public function getDefaultUserConfigFile()
    {
        if (class_exists('COM', false)) {
            return self::locateLocalSettingsDirectory() . DIRECTORY_SEPARATOR .
                'pear' . DIRECTORY_SEPARATOR . 'pearconfig.xml';
        } else {
            return self::locateLocalSettingsDirectory() . DIRECTORY_SEPARATOR .
                '.pear' . DIRECTORY_SEPARATOR . 'pearconfig.xml';
        }
    }

    /**
     * determines where user-specific configuration files should be saved.
     *
     * On unix, this is ~user/ or a location in /tmp based on the current directory.
     * On windows, this is your Documents and Settings folder.
     * @return string
     */
    static protected function locateLocalSettingsDirectory()
    {
        if (class_exists('COM', false)) {
            $shell = new COM('Wscript.Shell');
            $value = $shell->SpecialFolders('MyDocuments');
            return $value;
        }

        if (isset($_ENV['HOME'])) {
            return $_ENV['HOME'];
        } elseif ($e = getenv('HOME')) {
            return $e;
        }

        if (isset($_ENV['PWD'])) {
            $cwd = $_ENV['PWD'];
        } else {
            $cwd = getcwd();
        }
        
        return '/tmp/' . md5($cwd);
        
    }

    /**
     * Load the user configuration file
     *
     * This loads exclusively the user config
     * @return string path to the PEAR installation we are using
     */
    protected function loadUserSettings($pearDirectory, $userfile = false)
    {
        if (!$userfile) {
            $userfile = static::getDefaultUserConfigFile();

            if (!file_exists($userfile)) {
                $test = realpath(getcwd() . DIRECTORY_SEPARATOR . 'pearconfig.xml');
                if ($test && file_exists($test)) {
                    PEAR2_Pyrus_Log::log(5, 'Found user configuration file in current directory' .
                        $userfile);
                    $userfile = $test;
                }
            } else {
                PEAR2_Pyrus_Log::log(5, 'Found default user configuration file ' .
                    $userfile);
            }
        } else {
            PEAR2_Pyrus_Log::log(5, 'Using explicit user configuration file ' . $userfile);
        }

        $this->userFile = $userfile;
        if (!$userfile || !file_exists($userfile)) {
            PEAR2_Pyrus_Log::log(5, 'User configuration file ' . $userfile . ' not found');
            return;
        }

        if (isset(self::$userConfigs[$userfile])) {
            return;
        }

        libxml_use_internal_errors(true);
        libxml_clear_errors();
        $x = simplexml_load_file($userfile);
        if (!$x) {
            $errors = libxml_get_errors();
            $e = new PEAR2_MultiErrors;
            foreach ($errors as $err) {
                $e->E_ERROR[] = new PEAR2_Pyrus_Config_Exception(trim($err->message));
            }
            libxml_clear_errors();
            throw new PEAR2_Pyrus_Config_Exception(
                'Unable to parse invalid user PEAR configuration at "' . $userfile . '"',
                $e);
        }

        $unsetvalues = array_diff(array_keys((array) $x), array_merge(self::$userConfigNames, self::$customUserConfigNames));
        // remove values that are not recognized user config variables
        foreach ($unsetvalues as $value) {
            if ($value == '@attributes') {
                continue;
            }
            PEAR2_Pyrus_Log::log(5, 'Removing unrecognized user configuration value ' .
                $value);
            unset($x->$value);
        }

        if (self::initializing()) {
            self::$userConfigs[$userfile] = (array) $x;
            return;
        }
        $this->setupCascadingRegistries($pearDirectory);

        self::$userConfigs[$userfile] = (array) $x;
    }

    /**
     * automatically cascade include_path here if necessary
     */
    function cascadePath($pearDirectory)
    {
        $paths = explode(PATH_SEPARATOR, $pearDirectory);
        $primary = $paths[0];
        if (count($paths) == 1) {
            // add registries within include_path by default
            // if explicit path is specified, user knows what they
            // are doing, don't add include_path
            $include_path = explode(PATH_SEPARATOR, get_include_path());
            foreach ($include_path as $i => $path) {
                if ($path === '.') {
                    continue;
                }
                if (substr($path, strlen($path) - 3) == 'php' && $path[strlen($path) - 4] == DIRECTORY_SEPARATOR) {
                    // include_path goes to the php_dir which is always php, so our config
                    // file is in the parent directory.
                    $extra[] = dirname($path);
                } else {
                    $extra[] = $path;
                }
            }
            PEAR2_Pyrus_Log::log(1, 'Automatically cascading include_path components ' . implode(', ', $extra));
            array_unshift($extra, $primary);
            $paths = $extra;
        }
        $paths = array_unique($paths);
        $pearDirectory = implode(PATH_SEPARATOR, $paths);
        return $pearDirectory;
    }

    function setupCascadingRegistries($pearDirectory)
    {
        if (!$this->my_pear_path) {
            if (!$pearDirectory) {
                $pearDirectory = getcwd();
            }
            $this->my_pear_path = $this->cascadePath($pearDirectory);
            PEAR2_Pyrus_Log::log(5, 'Assuming my_pear_path is ' . $this->my_pear_path);
            $pearDirectory = $this->setCascadingRegistries($this->my_pear_path);
        } else {
            if (!$pearDirectory) {
                $pearDirectory = $this->setCascadingRegistries((string) $this->my_pear_path);
            } else {
                // ensure that $pearDirectory is a part of this cascading directory path
                $pearDirectory = $this->setCascadingRegistries((string)$pearDirectory .
                        PATH_SEPARATOR . $this->my_pear_path);
            }
        }

        return $pearDirectory;
    }

    /**
     * Extract configuration from system + user configuration files
     *
     * Configuration is stored in XML format, in two locations.
     *
     * The system configuration contains all of the important directory
     * configuration variables like data_dir, and the location of php.ini and
     * the php executable php.exe or php.  This configuration is tightly bound
     * to the repository, and cannot be moved.  As such, php_dir is auto-defined
     * as dirname(/path/to/pear/.config), or /path/to/pear.
     *
     * Only 1 user configuration file is allowed, and contains user-specific
     * settings, including the locations where to download package releases
     * and where to cache files downloaded from the internet.  If false is passed
     * in, PEAR2_Pyrus_Config will attempt to guess at the config file location as
     * documented in the class docblock {@link PEAR2_Pyrus_Config}.
     * @param string $pearDirectory
     * @param string|false $userfile
     */
    protected function loadConfigFile($pearDirectory)
    {
        if (isset(self::$configs[$pearDirectory]) ||
              !file_exists($pearDirectory . DIRECTORY_SEPARATOR . '.config')) {
            PEAR2_Pyrus_Log::log(5, 'Configuration not found for ' . $pearDirectory .
                ', assuming defaults');
            return;
        }
        PEAR2_Pyrus_Log::log(5, 'Loading configuration for ' . $pearDirectory);
        $this->helperLoadConfigFile($pearDirectory, $pearDirectory . DIRECTORY_SEPARATOR . '.config');
    }

    protected function helperLoadConfigFile($pearDirectory, $file, $extrainfo = '')
    {
        if ($extrainfo) {
            $extrainfo .= ' ';
        }
        libxml_use_internal_errors(true);
        libxml_clear_errors();
        $x = simplexml_load_file($file);
        if (!$x) {
            $errors = libxml_get_errors();
            $e = new PEAR2_MultiErrors;
            foreach ($errors as $err) {
                $e->E_ERROR[] = new PEAR2_Pyrus_Config_Exception(trim($err->message));
            }
            libxml_clear_errors();
            throw new PEAR2_Pyrus_Config_Exception(
                'Unable to parse invalid PEAR configuration ' . $extrainfo . 'at "' . $pearDirectory . '"',
                $e);
        }

        $unsetvalues = array_diff($keys = array_keys((array) $x), array_merge(self::$pearConfigNames, self::$customPearConfigNames));
        // remove values that are not recognized system config variables
        // both data_dir and php_dir are abstract values, delete them if present
        $unsetvalues[] = 'php_dir';
        $unsetvalues[] = 'data_dir';
        foreach ($unsetvalues as $value) {
            if (!in_array($value, $keys)) {
                continue;
            }

            PEAR2_Pyrus_Log::log(5, 'Removing unrecognized configuration ' . $extrainfo . 'value ' .
                $value);
            unset($x->$value);
        }
        $this->values = (array) $x;
    }

    /**
     * Save both the user configuration file and the system file
     *
     * If the userfile is not passed in, it is saved in the default
     * location which is either in ~/.pear/pearconfig.xml or on Windows
     * in the Documents and Settings directory
     * @param string $userfile path to alternate user configuration file
     */
    function saveConfig($userfile = false)
    {
        if (!$userfile) {
            if ($this->userFile) {
                $userfile = $this->userFile;
            } else {
                $userfile = self::getDefaultUserConfigFile();
                // FIXME any reason why we don't name it .pear on windows ? no special meaning
            }
        }

        $userfile = str_replace(array('\\', '//', '/'),
                                array('/',  '/', DIRECTORY_SEPARATOR),
                                $userfile);

        $test = $userfile;
        while ($test && !file_exists($test)) {
            $test = dirname($test);
        }

        if (!is_writable($test)) {
            throw new PEAR2_Pyrus_Config_Exception('Cannot save configuration, no' .
                ' filesystem permissions to modify user configuration file ' . $userfile);
        }

        $test = $this->pearDir . '.config';
        while ($test && !file_exists($test)) {
            $test = dirname($test);
        }

        if (!is_writable($test)) {
            throw new PEAR2_Pyrus_Config_Exception('Cannot save configuration, no' .
                ' filesystem permissions to modify PEAR directory ' . $this->pearDir . '.config');
        }

        $x = simplexml_load_string('<pearconfig version="1.0"></pearconfig>');
        foreach (self::$userConfigNames as $var) {
            $x->$var = (string) $this->$var;
        }

        foreach (self::$customUserConfigNames as $var) {
            $x->$var = (string) $this->$var;
        }

        $userfiledir = dirname($userfile);
        if (!file_exists($userfiledir) && !@mkdir($userfiledir, 0777, true)) {
            throw new PEAR2_Pyrus_Config_Exception(
                'Unable to create directory ' . $userfiledir . ' to save ' .
                'user configuration ' . $userfile);
        }
        file_put_contents($userfile, $x->asXML());

        if (!isset(static::$configDirty[$this->pearDir])) {
            // no changes have been made to the config, no need to write it out
            return;
        }

        $system = $this->pearDir . '.config';
        if (dirname($system) != $this->pearDir) {
            $system = $this->pearDir . DIRECTORY_SEPARATOR . '.config';
        }
        if (!file_exists(dirname($system)) && !@mkdir(dirname($system), 0777, true)) {
            throw new PEAR2_Pyrus_Config_Exception(
                'Unable to create directory ' . dirname($system) . ' to save ' .
                'system configuration ' . $system);
        }

        $x = simplexml_load_string('<pearconfig version="1.0"></pearconfig>');
        $path = dirname($system) . DIRECTORY_SEPARATOR;
        foreach (self::$pearConfigNames as $var) {
            if ($var === 'php_dir' || $var === 'data_dir') {
                continue; // both of these are abstract
            }
            $x->$var = $this->$var;
        }

        foreach (self::$customPearConfigNames as $var) {
            $x->$var = $this->$var;
        }
        file_put_contents($system, $x->asXML());
        unset(static::$configDirty[$this->pearDir]);
        // save a snapshot for installation purposes
        static::configSnapshot();
    }

    /**
     * Save a snapshot of the current config, and return the file name
     *
     * If the latest snapshot is the same as the existing configuration,
     * simply return the filename
     * @return string basename of the snapshot file of the current configuration
     */
    static public function configSnapshot()
    {
        $conf = self::current();
        $snapshotdir = $conf->pearDir . DIRECTORY_SEPARATOR . '.configsnapshots';
        if (!file_exists($snapshotdir)) {
            // this will be simple - no snapshots exist yet
            if (!@mkdir($snapshotdir, 0755, true)) {
                throw new PEAR2_Pyrus_Config_Exception(
                    'Unable to create directory ' . $snapshotdir . ' to save ' .
                    'system configuration snapshots');
            }

            $snapshot = 'configsnapshot-' . date('Y-m-d H:i:s') . '.xml';
            $x = simplexml_load_string('<pearconfig version="1.0"></pearconfig>');
            foreach (self::$pearConfigNames as $var) {
                $x->$var = $conf->$var;
            }

            foreach (self::$customPearConfigNames as $var) {
                $x->$var = $conf->$var;
            }

            PEAR2_Pyrus_Log::log(5, 'Saving configuration snapshot ' . $snapshot);
            file_put_contents($snapshotdir . DIRECTORY_SEPARATOR . $snapshot, $x->asXML());
            return $snapshot;
        }
        // scan existing snapshots, if any, for a match
        $dir = opendir($snapshotdir);
        while (false !== ($snapshot = readdir($dir))) {
            if ($snapshot[0] == '.') continue;
            $x = simplexml_load_file($snapshotdir . DIRECTORY_SEPARATOR . $snapshot);
            foreach (self::$pearConfigNames as $var) {
                if ($x->$var != $conf->$var) continue 2;
            }

            foreach (self::$customPearConfigNames as $var) {
                if (!isset($x->var) || $x->$var != $conf->$var) continue 2;
            }

            // found a match
            PEAR2_Pyrus_Log::log(5, 'Found matching configuration snapshot ' . $snapshot);
            return $snapshot;
        }
        PEAR2_Pyrus_Log::log(5, 'No matching configuration snapshot found');
        // no matches found
        $snapshot = 'configsnapshot-' . date('Y-m-d H:i:s') . '.xml';
        $i = 0;
        while (file_exists($snapshotdir . DIRECTORY_SEPARATOR . $snapshot)) {
            $i++;
            // keep appending ".1" until we get a unique filename
            $snapshot = 'configsnapshot-' . date('Y-m-d H:i:s') . str_repeat('.1', $i) . '.xml';
        }
        // save the snapshot
        $x = simplexml_load_string('<pearconfig version="1.0"></pearconfig>');
        foreach (self::$pearConfigNames as $var) {
            $x->$var = $conf->$var;
        }

        foreach (self::$customPearConfigNames as $var) {
            $x->$var = $conf->$var;
        }

        PEAR2_Pyrus_Log::log(5, 'Saving configuration snapshot ' . $snapshot);
        file_put_contents($snapshotdir . DIRECTORY_SEPARATOR . $snapshot, $x->asXML());
        return $snapshot;
    }

    /**
     * Load a configuration
     */
    static public function addConfigValue($key, $default, $system = true)
    {
        if (in_array($key, self::$magicVars, true)) {
            throw new PEAR2_Pyrus_Config_Exception('Invalid custom configuration variable '
                                                   . $key . ', already in use for retrieving configuration information');
        }

        if (!preg_match('/^[a-z0-9-_]+\\z/', $key)) {
            throw new PEAR2_Pyrus_Config_Exception('Invalid custom configuration variable name "'.  $key . '"');
        }

        if ($system) {
            if (in_array($key, self::$pearConfigNames)) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing configuration value "' . $key . '"');
            }

            if (in_array($key, self::$customPearConfigNames)) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing custom configuration value "' . $key . '"');
            }

            if (in_array($key, self::$userConfigNames)) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing user configuration value "' . $key . '" with system value');
            }

            if (in_array($key, self::$customUserConfigNames)) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing custom user configuration value "' . $key . '" with system value');
            }
            $var = 'customPearConfigNames';
        } else {
            if (in_array($key, self::$userConfigNames)) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing configuration value "' . $key . '"');
            }

            if (in_array($key, self::$customUserConfigNames)) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing custom configuration value "' . $key . '"');
            }

            if (in_array($key, self::$pearConfigNames)) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing configuration value "' . $key . '" with user value');
            }

            if (in_array($key, self::$customPearConfigNames)) {
                throw new PEAR2_Pyrus_Config_Exception('Cannot override existing custom system configuration value "' . $key . '" with user value');
            }
            $var = 'customUserConfigNames';
        }
        self::${$var}[count(self::${$var})] = $key;
        self::$customDefaults[$key] = $default;
    }

    public function defaultValue($key)
    {
        if (isset(self::$defaults[$key])) {
            if ($key === 'verbose') {
                // this prevents a rather nasty loop if logging is checking on verbose
                return self::$defaults['verbose'];
            }
            PEAR2_Pyrus_Log::log(5, 'Replacing @php_dir@ for config variable ' .
                                 $key .
                ' default value "' . self::$defaults[$key] . '"');
            $ret = str_replace('@php_dir@', $this->pearDir, self::$defaults[$key]);
            PEAR2_Pyrus_Log::log(5, 'Replacing @default_config_dir@ for config variable ' .
                                 $key .
                ' default value "' . self::$defaults[$key] . '"');
            return str_replace('@default_config_dir@', dirname($this->userFile), $ret);
        }
        PEAR2_Pyrus_Log::log(5, 'Replacing @php_dir@ for config variable ' .
                             $key .
            ' default value "' . self::$customDefaults[$key] . '"');
        $ret = str_replace('@php_dir@', $this->pearDir, self::$customDefaults[$key]);
        PEAR2_Pyrus_Log::log(5, 'Replacing @default_config_dir@ for config variable ' .
                             $key .
            ' default value "' . self::$customDefaults[$key] . '"');
        return str_replace('@default_config_dir@', dirname($this->userFile), $ret);
    }

    public function __get($key)
    {
        if (in_array($key, array_merge(self::$pearConfigNames, self::$userConfigNames,
                                          self::$customPearConfigNames,
                                          self::$customUserConfigNames))) {
            if ((!isset(self::$userConfigs[$this->userFile][$key])
                && !isset($this->values[$key])) || $key === 'php_dir'
                || $key === 'data_dir'
            ) {
                if (isset(self::$defaults[$key])) {
                    if ($key === 'verbose') {
                        // this prevents a rather nasty loop if logging is checking on verbose
                        return self::$defaults['verbose'];
                    }
                    PEAR2_Pyrus_Log::log(5, 'Replacing @php_dir@ for config variable ' .
                                         $key .
                        ' default value "' . self::$defaults[$key] . '"');
                    $ret = str_replace('@php_dir@', $this->pearDir, self::$defaults[$key]);
                    PEAR2_Pyrus_Log::log(5, 'Replacing @default_config_dir@ for config variable ' .
                                         $key .
                        ' default value "' . self::$defaults[$key] . '"');
                    return str_replace('@default_config_dir@', dirname($this->userFile), $ret);
                } else {
                    PEAR2_Pyrus_Log::log(5, 'Replacing @php_dir@ for config variable ' .
                                         $key .
                        ' default value "' . self::$customDefaults[$key] . '"');
                    $ret = str_replace('@php_dir@', $this->pearDir, self::$customDefaults[$key]);
                    PEAR2_Pyrus_Log::log(5, 'Replacing @default_config_dir@ for config variable ' .
                                         $key .
                        ' default value "' . self::$customDefaults[$key] . '"');
                    return str_replace('@default_config_dir@', dirname($this->userFile), $ret);
                }
            }

            if (in_array($key, array_merge(self::$pearConfigNames,
                                             self::$customPearConfigNames))) {
                PEAR2_Pyrus_Log::log(5, 'Replacing @php_dir@ for config variable ' . $key .
                    ' value "' . $this->values[$key] . '"');
                $ret = str_replace('@php_dir@', $this->pearDir, $this->values[$key]);
                PEAR2_Pyrus_Log::log(5, 'Replacing @default_config_dir@ for config variable ' .
                                     $key .
                    ' default value "' . $this->values[$key] . '"');
                return str_replace('@default_config_dir@', dirname($this->userFile), $ret);
            }

            return self::$userConfigs[$this->userFile][$key];
        }

        if ($key == 'registry') {
            return $this->myregistry;
        }

        if ($key == 'pluginregistry') {
            if (!isset($this->mypluginregistry)) {
                $this->mypluginregistry = new PEAR2_Pyrus_Registry($this->__get('plugins_dir', array('Sqlite3', 'Xml')));
            }
            return $this->mypluginregistry;
        }

        if ($key == 'channelregistry') {
            return $this->mychannelRegistry;
        }

        if ($key == 'systemvars') {
            return array_merge(self::$pearConfigNames, self::$customPearConfigNames);
        }

        if ($key == 'uservars') {
            return array_merge(self::$userConfigNames, self::$customUserConfigNames);
        }

        if ($key == 'mainsystemvars') {
            return self::$pearConfigNames;
        }

        if ($key == 'mainuservars') {
            return self::$userConfigNames;
        }

        if ($key == 'userfile') {
            return $this->userFile;
        }

        if ($key == 'path') {
            return $this->pearDir;
        }

        if ($key == 'customsystemvars') {
            return self::$customPearConfigNames;
        }

        if ($key == 'customuservars') {
            return self::$customUserConfigNames;
        }

        throw new PEAR2_Pyrus_Config_Exception(
            'Unknown configuration variable "' . $key . '" in location ' .
            $this->pearDir);
    }

    public function __unset($key)
    {
        if (in_array($key, self::$magicVars, true)) {
            throw new PEAR2_Pyrus_Config_Exception('Cannot unset magic value ' . $key);
        }

        if ($key === 'php_dir' || $key === 'data_dir') {
            throw new PEAR2_Pyrus_Config_Exception('Cannot unset ' . $key);
        }

        if (isset($this->values[$key])) {
            unset($this->values[$key]);
            static::$configDirty[$this->pearDir] = 1;
            return;
        }

        if (isset(self::$userConfigs[$this->userFile][$key])) {
            unset(self::$userConfigs[$this->userFile][$key]);
        }
    }

    public function __isset($key)
    {
        if (in_array($key, self::$magicVars, true)) {
            return true;
        }

        if ($key === 'php_dir' || $key === 'data_dir') {
            return true;
        }

        if (in_array($key, self::$pearConfigNames)
            || in_array($key, self::$customPearConfigNames)) {
            return isset($this->values[$key]);
        }

        return isset(self::$userConfigs[$this->userFile][$key]);
    }

    public function __set($key, $value)
    {
        if (in_array($key, self::$magicVars, true)) {
            throw new PEAR2_Pyrus_Config_Exception('Cannot set magic configuration variable ' . $key);
        }

        if ($key == 'php_dir') {
            throw new PEAR2_Pyrus_Config_Exception('Cannot set php_dir, move the repository to change this value');
        }

        if ($key == 'data_dir') {
            throw new PEAR2_Pyrus_Config_Exception('Cannot set data_dir, move the repository to change this value');
        }

        if (!isset(self::$defaults[$key]) && !isset(self::$customDefaults[$key])) {
            throw new PEAR2_Pyrus_Config_Exception(
                'Unknown configuration variable "' . $key . '" in location ' .
                $this->pearDir);
        }

        if (in_array($key, self::$pearConfigNames)
            || in_array($key, self::$customPearConfigNames)) {
            $this->values[$key] = $value;
            static::$configDirty[$this->pearDir] = 1;
            return;
        }

        self::$userConfigs[$this->userFile][$key] = $value;
    }

    /**
     * Parse a string to determine which package file is requested
     *
     * This differentiates between the three kinds of packages:
     *
     *  - local files
     *  - remote static URLs
     *  - dynamic abstract package names
     * @param string $pname
     * @return string|array A string is returned if this is a file, otherwise an array
     *                      containing information is returned
     */
    static public function parsePackageName($pname, $assumeabstract = false)
    {
        if (!$assumeabstract && @file_exists($pname) && @is_file($pname)) {
            return $pname;
        }
        return self::current()->channelregistry->parseName($pname);
    }

    static public function parsedPackageNameToString($name)
    {
        return self::current()->channelregistry->parsedNameToString($name);
    }
}
<?php
/**
 * PEAR2_Pyrus_DirectedGraph
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Implements a graph data type, used for topological sorting of packages.
 *
 * This structure allows us to sort dependencies into the correct order for installation.
 * Iteration uses a depth-first search to perform a topological sort.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_DirectedGraph implements Iterator
{
    const WHITE = 0;
    const GRAY = 1;
    const BLACK = 2;
    protected $vertices = array();
    /**
     * Map data to abstract vertex
     *
     * @var array
     */
    protected $map = array();
    /**
     * Topologically sorted vertices
     * @var array
     */
    protected $blackVertices = array();

    /**
     * Add a data vertex
     *
     * @param object $data
     * @return PEAR2_Pyrus_DirectedGraph_Vertex
     */
    function add($data)
    {
        $vertex = new PEAR2_Pyrus_DirectedGraph_Vertex($data);
        $this->vertices[spl_object_hash($vertex)] = $vertex;
        $this->map[spl_object_hash($data)] = spl_object_hash($vertex);
        return $vertex;
    }

    /**
     * Connect two vertices in a directed graph
     *
     * This can be used with a fluent interface
     * @param object|PEAR2_Pyrus_DirectedGraph_Vertex $from
     * @param object|PEAR2_Pyrus_DirectedGraph_Vertex $to
     * @return PEAR2_Pyrus_DirectedGraph
     */
    function connect($from, $to)
    {
        if ($from instanceof PEAR2_Pyrus_DirectedGraph_Vertex) {
            $a = spl_object_hash($from);
        } else {
            if (!isset($this->map[spl_object_hash($from)])) {
                $a = $this->add($from);
            } else {
                $a = $this->vertices[$this->map[spl_object_hash($from)]];
            }
        }
        if ($to instanceof PEAR2_Pyrus_DirectedGraph_Vertex) {
            $b = spl_object_hash($to);
        } else {
            if (!isset($this->map[spl_object_hash($to)])) {
                $b = $this->add($to);
            } else {
                $b = $this->vertices[$this->map[spl_object_hash($to)]];
            }
        }
        $this->vertices[spl_object_hash($a)]->connect($b);
        return $this;
    }

    function current()
    {
        return current($this->blackVertices)->data;
    }

    function next()
    {
        return next($this->blackVertices);
    }

    function key()
    {
        return key($this->blackVertices);
    }

    function valid()
    {
        return current($this->blackVertices);
    }

    function rewind()
    {
        $this->topologicalSort();
    }

    /**
     * Sort the vertices by their connections
     */
    function topologicalSort()
    {
        $this->blackVertices = array();
        if (!count($this->vertices)) {
            return;
        }
        foreach ($this->vertices as $vertex) {
            $vertex->color(self::WHITE);
        }
        while (count($this->blackVertices) <  count($this->vertices)) {
            // select a vertex to start
            foreach ($this->vertices as $vertex) {
                if ($vertex->color() == self::BLACK) {
                    // already sorted
                    continue;
                }
                break;
            }
            do {
                // this vertex has been discovered
                $vertex->color(self::GRAY);
                if (!count($vertex)) {
                    // no adjacent edges
                    $this->blackVertices[] = $vertex;
                    $vertex->color(self::BLACK);
                    continue 2;
                }
                $black = true;
                // iterate over adjacent vertices to find a white vertex
                foreach ($vertex as $edge) {
                    if ($edge->color() == self::BLACK) {
                        continue;
                    }
                    if (!count($edge)) {
                        // no adjacent undiscovered vertices, we found a black one
                        $edge->color(self::BLACK);
                        $this->blackVertices[] = $edge;
                        continue;
                    }
                    $black = false;
                    $edge->color(self::GRAY);
                }
                if ($black) {
                    // found a new vertex
                    $this->blackVertices[] = $vertex;
                    $vertex->color(self::BLACK);
                } else {
                    foreach ($vertex as $edge) {
                        if ($edge->color() == self::BLACK) {
                            continue;
                        }
                        $vertex = $edge;
                        break;
                    }
                }
            } while (!$black);
        }
    }
}<?php
/**
 * PEAR2_Pyrus_Exception
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base Exception class for Pyrus.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Exception extends PEAR2_Exception {}<?php
/**
 * PEAR2_Pyrus_FileTransactions
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Pyrus.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_FileTransactions
{
    private $fileOperations = array();
    static private $_registeredTransactions =
        array(
            'backup' => false,
            'chmod' => false,
            'delete' => false,
            'removebackup' => false,
            'mkdir' => false,
            /* to enable the next three, use registerTransaction() */
//            'rename' => false,
//            'rmdir' => false,
//            'installedas' => false,
        );

    /**
     * Add a file operation to the current file transaction.
     *
     * @see begin()
     * @param string $type This can be one of:
     *    - rename:  rename a file ($data has 3 values)
     *    - backup:  backup an existing file ($data has 1 value)
     *    - removebackup:  clean up backups created during install ($data has 1 value)
     *    - chmod:   change permissions on a file ($data has 2 values)
     *    - delete:  delete a file ($data has 1 value)
     *    - rmdir:   delete a directory if empty ($data has 1 value)
     *    - installedas: mark a file as installed ($data has 4 values).
     * @param array $data For all file operations, this array must contain the
     *    full path to the file or directory that is being operated on.  For
     *    the rename command, the first parameter must be the file to rename,
     *    the second its new name, the third whether this is a PHP extension.
     *
     *    The installedas operation contains 4 elements in this order:
     *    1. Filename as listed in the filelist element from package.xml
     *    2. Full path to the installed file
     *    3. Full path from the php_dir configuration variable used in this
     *       installation
     *    4. Relative path from the php_dir that this file is installed in
     */
    function __call($type, $data)
    {
        if ($type == 'chmod') {
            $octmode = decoct($data[0]);
            PEAR2_Pyrus_Log::log(3, "adding to transaction: $type $octmode $data[1]");
        } else {
            PEAR2_Pyrus_Log::log(3, "adding to transaction: $type " . implode(" ", $data));
        }
        $this->fileOperations[] = array($type, $data);
    }

    function begin($rollback_in_case = false)
    {
        if (count($this->fileOperations) && $rollback_in_case) {
            $this->rollback();
        }
        $this->fileOperations = array();
    }

    function commit()
    {
        $n = count($this->fileOperations);
        PEAR2_Pyrus_Log::log(2, "about to commit $n file operations");
        // {{{ first, check permissions and such manually
        $errors = array();

        foreach ($this->fileOperations as $tr) {
            list($type, $data) = $tr;
            switch ($type) {
                case 'backup' :
                    break;
                case 'chmod' :
                    // check that file is writable
                    if (!is_writable($data[1])) {
                        $errors[] = "permission denied ($type): $data[1] " . decoct($data[0]);
                    }
                    break;
                case 'delete' :
                    if (!file_exists($data[0])) {
                        PEAR2_Pyrus_Log::log(2, "warning: file $data[0] doesn'" .
                            "t exist, can't be deleted");
                    }
                    // check that directory is writable
                    if (file_exists($data[0])) {
                        if (!is_writable(dirname($data[0]))) {
                            $errors[] = "permission denied ($type): $data[0]";
                        } else {
                            // make sure the file to be deleted can be opened for writing
                            $fp = false;
                            if (!is_dir($data[0]) &&
                                  (!is_writable($data[0]) || !($fp = @fopen($data[0], 'a')))) {
                                $errors[] = "permission denied ($type): $data[0]";
                            } elseif ($fp) {
                                fclose($fp);
                            }
                        }
                    }
                    break;
                case 'mkdir' :
                case 'removebackup' :
                    break;
                default :
                    $callback = self::$_registeredTransactions[$type];
                    $callback->check($data, $errors);
            }
        }
        if (count($errors) > 0) {
            foreach ($errors as $error) {
                if (!isset($this->_options['soft'])) {
                    PEAR2_Pyrus_Log::log(1, $error);
                }
            }
            if (!isset($this->_options['ignore-errors'])) {
                return false;
            }
        }
        $this->_dirtree = array();
        foreach ($this->fileOperations as $tr) {
            list($type, $data) = $tr;
            switch ($type) {
                case 'backup' :
                    if (!@copy($data[0], $data[0] . '.bak')) {
                        PEAR2_Pyrus_Log::log(1, 'Could not copy ' . $data[0] . ' to ' . $data[0] .
                            '.bak ' . $php_errormsg);
                        return false;
                    }
                    PEAR2_Pyrus_Log::log(3, "+ backup $data[0] to $data[0].bak");
                    break;
                case 'chmod' :
                    if (!@chmod($data[1], $data[0])) {
                        PEAR2_Pyrus_Log::log(1, 'Could not chmod ' . $data[1] . ' to ' .
                            decoct($data[0]) . ' ' . $php_errormsg);
                        return false;
                    }
                    $octmode = decoct($data[0]);
                    PEAR2_Pyrus_Log::log(3, "+ chmod $octmode $data[1]");
                    break;
                case 'delete' :
                    if (file_exists($data[0])) {
                        if (!@unlink($data[0])) {
                            PEAR2_Pyrus_Log::log(1, 'Could not delete ' . $data[0] . ' ' .
                                $php_errormsg);
                            return false;
                        }
                        PEAR2_Pyrus_Log::log(3, "+ rm $data[0]");
                    }
                    break;
                case 'mkdir' :
                    break;
                case 'removebackup' :
                    if (file_exists($data[0] . '.bak') && is_writable($data[0] . '.bak')) {
                        unlink($data[0] . '.bak');
                        PEAR2_Pyrus_Log::log(3, "+ rm backup of $data[0] ($data[0].bak)");
                    }
                    break;
                default :
                    $callback = self::$_registeredTransactions[$type];
                    $callback->commit($data, $errors);
            }
        }
        PEAR2_Pyrus_Log::log(2, "successfully committed $n file operations");
        $this->fileOperations = array();
        return true;
    }

    function registerTransaction($name, PEAR2_Pyrus_IFileTransaction $callback)
    {
        if (in_array($name, array_keys(self::$_registeredTransactions), true)) {
            throw new PEAR2_Pyrus_FileTransactions_Exception('transaction type ' . $name .
                ' is already registered');
        }
        self::$_registeredTransactions[$name] = $callback;
    }

    function rollback()
    {
        $n = count($this->fileOperations);
        PEAR2_Pyrus_Log::log(2, "rolling back $n file operations");
        foreach ($this->fileOperations as $tr) {
            list($type, $data) = $tr;
            switch ($type) {
                case 'backup' :
                    if (file_exists($data[0] . '.bak')) {
                        @unlink($data[0]);
                        @copy($data[0] . '.bak', $data[0]);
                        PEAR2_Pyrus_Log::log(3, "+ restore $data[0] from $data[0].bak");
                    }
                    break;
                case 'chmod' :
                case 'delete' :
                case 'removebackup' :
                    break;
                case 'mkdir' :
                    @rmdir($data[0]);
                    PEAR2_Pyrus_Log::log(3, "+ rmdir $data[0]");
                    break;
                default :
                    $callback = self::$_registeredTransactions[$type];
                    $callback->rollback($data, $errors);
            }
        }
        foreach (self::$_registeredTransactions as $callback) {
            if (!$callback) {
                continue;
            }
            $callback->cleanup();
        }
        $this->fileOperations = array();
    }
}<?php
/**
 * PEAR2_Pyrus_IChannel
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for channels
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_IChannel
{
    function __get($var);
    function __toString();
    public function getValidationObject($package = false);
    public function getValidationPackage();
}
<?php
/**
 * PEAR2_Pyrus_IChannel
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for channels
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_IChannelFile
{
    function __get($var);
    function __set($var, $value);
    function __toString();
}
<?php
/**
 * PEAR2_Pyrus_IChannelRegistry
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for PEAR2 channel registry.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_IChannelRegistry
{
    public function add(PEAR2_Pyrus_IChannel $channel, $update = false, $lastmodified = false);
    public function update(PEAR2_Pyrus_IChannel $channel);
    public function delete(PEAR2_Pyrus_IChannel $channel);
    public function get($channel, $strict = true);
    public function exists($channel, $strict = true);
    public function parseName($name);
    public function parsedNameToString($name);
    public function listChannels();
}
<?php
/**
 * PEAR2_Pyrus_IFileTransaction
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for file transactions
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_IFileTransaction
{
    public function check($data, &$errors);
    public function commit($data, &$errors);
    public function rollback($data, &$errors);
    public function cleanup();
}<?php
/**
 * PEAR2_Pyrus_ILog
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for loggin in Pyrus
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_ILog
{
    public function log($level, $message);
}<?php
/**
 * PEAR2_Pyrus_Installer
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Pyrus Installer class
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Installer
{
    /**
     * Flag that determines the behavior of {@link begin()}
     *
     * If true, begin() will do nothing.  If false, then
     * {@link static::$installPackages} will be reset to an empty array
     * @var bool
     */
    protected static $inTransaction = false;

    /**
     * Packages that will be installed
     *
     * This list is used when {@link commit()} is called to determine
     * the packages to install
     * @var array
     */
    protected static $installPackages = array();

    /**
     * Packages that were installed
     *
     * This list is used when {@link rollback()} is called to determine
     * the packages that should be removed
     * @var array
     */
    protected static $installedPackages = array();

    /**
     * Packages that have been installed and also successfully registered as installed
     *
     * This list is used when {@link rollback()} is called to determine
     * the packages that should be removed from the registry
     * @var array
     */
    protected static $registeredPackages = array();

    /**
     * Packages that were removed during installation
     *
     * This list is used when {@link rollback()} is called to restore state
     * the packages to install
     * @var array
     */
    protected static $removedPackages = array();
    
    protected static $phase = 1;

    /**
     * Installer options.  Valid indices are:
     *
     * - upgrade (upgrade or install packages)
     * - optionaldeps (also automatically download/install optional deps)
     * - force
     * @var array
     */
    public static $options = array();
    /**
     * Prepare installation of packages
     */
    static function begin()
    {
        if (!static::$inTransaction) {
            static::$installPackages = array();
            static::$installedPackages = array();
            static::$removedPackages = array();
            static::$inTransaction = true;
            static::$phase = 1;
        }
    }

    /**
     * Add a package to the list of packages to be downloaded
     *
     * This function checks to see if an identical package is already being downloaded,
     * and manages removing duplicates or erroring out on a conflict
     * @param PEAR2_Pyrus_Package $package
     */
    static function prepare(PEAR2_Pyrus_IPackage $package)
    {
        if (!isset(static::$installPackages[$package->channel . '/' . $package->name])) {
            // checking of validity for upgrade is done by PEAR2_Pyrus_Package_Dependency::retrieve(),
            // so all deps that make it this far can be added
            if (PEAR2_Pyrus_Config::current()->registry->exists(
                  $package->name, $package->channel)) {
                if (!$package->isUpgradeable()) {
                    if (!isset(static::$options['force'])) {
                        // installed package is the same or newer version than this one
                        PEAR2_Pyrus_Log::log(1, 'Skipping installed package ' .
                            $package->channel . '/' . $package->name);
                        return;
                    }
                }
            }
            static::$installPackages[$package->channel . '/' . $package->name] = $package;
            return;
        }
        $clone = static::$installPackages[$package->channel . '/' . $package->name];
        if ($package->isStatic() && !$clone->isStatic()) {
            // always prefer explicitly versioned over abstract
            static::$installPackages[$package->channel . '/' . $package->name] = $package;
            return;
        }
        if (!$package->isStatic() && !$clone->isStatic()) {
            // identical, ignore this package
            return;
        }
        // compare version
        if ($package->isStatic() && $clone->isStatic() && $package->version['release'] === $clone->version['release']) {
            // identical, ignore this package
            return;
        }
        if (!static::$options['force']) {
            //
            static::rollback();
            throw new PEAR2_Pyrus_Installer_Exception('Cannot install ' .
                $package->channel . '/' . $package->name . ', two conflicting' .
                ' versions are required by packages that depend on it (' .
                $package->version['release'] . ' and ' . $clone->version['release']);
        }
        PEAR2_Pyrus_Log::log(0, 'Warning: two conflicting versions of ' .
            $package->channel . '/' . $package->name .
            ' are required by packages that depend on it (' .
            $package->version['release'] . ' and ' . $clone->version['release']);
    }

    /**
     * Download and prepare all dependencies
     *
     * @param PEAR2_Pyrus_Package $package
     */
    static function prepareDependencies(PEAR2_Pyrus_IPackage $package)
    {
        foreach (array('package', 'subpackage') as $p) {
            foreach ($package->dependencies['required']->$p as $dep) {
                if ($dep->conflicts) {
                    continue;
                }
                PEAR2_Pyrus_Package_Dependency::retrieve(get_called_class(), static::$installPackages, $dep, $package);
            }
        }
        if ($package->requestedGroup) {
            foreach (array('package', 'subpackage') as $p) {
                foreach ($package->dependencies['group']->{$package->requestedGroup}->$p as $dep) {
                    if ($dep->conflicts) {
                        continue;
                    }
                    PEAR2_Pyrus_Package_Dependency::retrieve(get_called_class(), static::$installPackages, $dep, $package);
                }
            }
        }
        if (!isset(static::$options['optionaldeps'])) {
            return;
        }
        foreach (array('package', 'subpackage') as $p) {
            foreach ($package->dependencies['optional']->$p as $dep) {
                if ($dep->conflicts) {
                    continue;
                }
                PEAR2_Pyrus_Package_Dependency::retrieve(get_called_class(), static::$installPackages, $dep, $package);
            }
        }
    }

    /**
     * Cancel installation
     */
    static function rollback()
    {
        if (static::$inTransaction) {
            static::$inTransaction = false;
            $reg = PEAR2_Pyrus_Config::current()->registry;
            $err = new PEAR2_MultiErrors;
            foreach (static::$registeredPackages as $package) {
                try {
                    if (!$reg->exists($package[0]->name, $package[0]->channel)) {
                        continue;
                    }
                    $reg->uninstall($package[0]->name, $package[0]->channel);
                    if ($package[1]) {
                        $reg->install($package[1]);
                    }
                } catch (Exception $e) {
                    $err->E_ERROR[] = $e;
                }
            }
            foreach (static::$removedPackages as $package) {
                if (!$reg->exists($package->name, $package->channel)) {
                    try {
                        $reg->uninstall($package->name, $package->channel);
                    } catch (Exception $e) {
                        $err->E_ERROR[] = $e;
                    }
                }
                try {
                    $reg->install($package->getPackageFile()->info);
                } catch (Exception $e) {
                    $err->E_ERROR[] = $e;
                }
            }
            static::$installPackages = array();
            static::$installedPackages = array();
            static::$registeredPackages = array();
            static::$removedPackages = array();
            if (count($err)) {
                throw new PEAR2_Pyrus_Installer_Exception('Could not successfully rollback', $err);
            }
        }
    }

    /**
     * Prior to committing, ensure all dependencies are resolved properly.
     *
     * This is split off from commit() solely for unit testing purposes
     */
    static function preCommitDependencyResolve()
    {
        if (!static::$inTransaction) {
            return false;
        }
        if (!count(static::$installPackages)) {
            return;
        }
        $done = true;
        $allpackages = $packages = static::$installPackages;
        do {
            foreach ($allpackages as $package => $info) {
                if (!$info->isRemote()) {
                    // anything downloaded is good
                    static::prepareDependencies($info);
                    continue;
                }
                $dep = PEAR2_Pyrus_Package_Dependency::getCompositeDependency($info);
                try {
                    if (true === $info->figureOutBestVersion($dep)) {
                        // we just changed version from a previously calculated version,
                        // so restart
                        $unset = PEAR2_Pyrus_Package_Dependency::removePackage($info);
                        foreach ($unset as $p) {
                            unset(static::$installPackages[$p]);
                        }
                        // just added some new packages that affect dependencies
                        $done = false;
                        continue 2;
                    }
                    static::prepareDependencies($info);
                } catch (PEAR2_Pyrus_Channel_Exception $e) {
                    throw new PEAR2_Pyrus_Installer_Exception('Dependency validation failed ' .
                        'for some packages to install, installation aborted', $e);
                }
            }
            $packages = array();
            foreach (array_diff(array_keys(static::$installPackages), array_keys($allpackages)) as $package) {
                $packages[$package] = static::$installPackages[$package];
            }
            $allpackages = static::$installPackages;
            $done = !count($packages);
        } while (!$done);
        if (!isset(self::$options['force'])) {
            // now iterate over the list and remove any packages that are installed with this version
            $packages = static::$installPackages;
            $reg = PEAR2_Pyrus_Config::current()->registry;
            foreach ($packages as $key => $package) {
                if ($reg->info($package->name, $package->channel, 'version') === $package->version['release']) {
                    unset(static::$installPackages[$key]);
                }
            }
        }
    }

    /**
     * Install packages slated for installation during transaction
     */
    static function commit()
    {
        if (!static::$inTransaction) {
            return false;
        }
        try {
            static::preCommitDependencyResolve();
            $installer = new PEAR2_Pyrus_Installer;
            // validate dependencies
            $errs = new PEAR2_MultiErrors;
            foreach (static::$installPackages as $package) {
                $package->validateDependencies(static::$installPackages, $errs);
            }
            if (count($errs->E_ERROR)) {
                throw new PEAR2_Pyrus_Installer_Exception('Dependency validation failed ' .
                    'for some packages to install, installation aborted', $errs);
            }
            // download non-local packages
            foreach (static::$installPackages as $package) {
                $package->download();
            }

            // now validate everything to the fine-grained level
            foreach (static::$installPackages as $package) {
                $package->validate(PEAR2_Pyrus_Validate::INSTALLING);
            }

            // create dependency connections and load them into the directed graph
            $graph = new PEAR2_Pyrus_DirectedGraph;
            foreach (static::$installPackages as $package) {
                $package->makeConnections($graph, static::$installPackages);
            }
            // topologically sort packages and install them via iterating over the graph
            try {
                PEAR2_Pyrus_AtomicFileTransaction::begin();
                foreach ($graph as $package) {
                    if (isset(static::$installedPackages[$package->channel . '/' . $package->name])) {
                        continue;
                    }
                    $installer->install($package);
                    static::$installedPackages[$package->channel . '/' . $package->name] = $package;
                }
                PEAR2_Pyrus_AtomicFileTransaction::commit();
            } catch (PEAR2_Pyrus_AtomicFileTransaction_Exception $e) {
                PEAR2_Pyrus_AtomicFileTransaction::rollback();
                throw new PEAR2_Pyrus_Installer_Exception('Installation of ' . $package->channel .
                                                          '/' . $package->name . ' failed', $e);
            }
            $reg = PEAR2_Pyrus_Config::current()->registry;
            foreach (static::$installedPackages as $package) {
                try {
                    $previous = $reg->toPackageFile($package->name, $package->channel, true);
                } catch (\Exception $e) {
                    $previous = null;
                }
                $reg->install($package->getPackageFile()->info);
                static::$registeredPackages[] = array($package, $previous);
            }
            static::$installPackages = array();
            PEAR2_Pyrus_Config::current()->saveConfig();
            // success
            PEAR2_Pyrus_AtomicFileTransaction::removeBackups();
            static::$inTransaction = false;
        } catch (Exception $e) {
            static::rollback();
            throw $e;
        }
    }

    static function getInstalledPackages()
    {
        return static::$installedPackages;
    }

    /**
     * Install a fully downloaded package
     *
     * Using PEAR2_Pyrus_FileTransactions and the woPEAR2_Pyrus_PEAR2_Installer_Role* to
     * group files in appropriate locations, the install() method then passes
     * on the registration of installation to PEAR2_Pyrus_Registry.  If necessary,
     * PEAR2_Pyrus_Config will update the install-time snapshots of configuration
     * @param PEAR2_Pyrus_Package $package
     */
    function install(PEAR2_Pyrus_IPackage $package)
    {
        $this->_options = array();
        try {
            $lastversion = PEAR2_Pyrus_Config::current()->registry->info(
                                    $package->name, $package->channel, 'version');
        } catch (Exception $e) {
            $lastversion = null;
        }
        $globalreplace = array('attribs' =>
                    array('from' => '@' . 'PACKAGE_VERSION@',
                          'to' => 'version',
                          'type' => 'package-info'));

        foreach ($package->installcontents as $file) {
            $channel = $package->channel;
            // {{{ assemble the destination paths
            if (!in_array($file->role,
                  PEAR2_Pyrus_Installer_Role::getValidRoles($package->getPackageType()))) {
                throw new PEAR2_Pyrus_Installer_Exception('Invalid role `' .
                        $file->role .
                        "' for file " . $file->name);
            }
            $role = PEAR2_Pyrus_Installer_Role::factory($package->getPackageType(), $file->role);
            $role->setup($this, $package, $file['attribs'], $file->name);
            if (!$role->isInstallable()) {
                continue;
            }

            $transact = PEAR2_Pyrus_AtomicFileTransaction::getTransactionObject($role);

            $info = $role->getRelativeLocation($package, $file, true);
            $dir = $info[0];
            $dest_file = $info[1];

            // }}}

            // pretty much nothing happens if we are only registering the install
            if (isset($this->_options['register-only'])) {
                continue;
            }
            try {
                $transact->mkdir($dir, 0755);
            } catch (PEAR2_Pyrus_AtomicFileTransaction_Exception $e) {
                throw new PEAR2_Pyrus_Installer_Exception("failed to mkdir $dir", $e);
            }
            PEAR2_Pyrus_Log::log(3, "+ mkdir $dir");

            if ($file->md5sum) {
                $md5sum = md5_file($package->getFilePath($file->packagedname));
                if (strtolower($md5sum) == strtolower($file->md5sum)) {
                    PEAR2_Pyrus_Log::log(2, "md5sum ok: $dest_file");
                } else {
                    if (empty($options['force'])) {
                        if (!isset($options['ignore-errors'])) {
                            throw new PEAR2_Pyrus_Installer_Exception(
                                "bad md5sum for file $file");
                        } else {
                            if (!isset($options['soft'])) {
                                PEAR2_Pyrus_Log::log(0,
                                    "warning : bad md5sum for file $dest_file");
                            }
                        }
                    } else {
                        if (!isset($options['soft'])) {
                            PEAR2_Pyrus_Log::log(0,
                                "warning : bad md5sum for file $dest_file");
                        }
                    }
                }
            }

            if (strpos(PHP_OS, 'WIN') === false) {
                if ($role->isExecutable()) {
                    $mode = (~octdec(PEAR2_Pyrus_Config::current()->umask) & 0777);
                    PEAR2_Pyrus_Log::log(3, "+ chmod +x $dest_file");
                } else {
                    $mode = (~octdec(PEAR2_Pyrus_Config::current()->umask) & 0666);
                }
            } else {
                $mode = null;
            }

            try {
                $transact->createOrOpenPath($dest_file, $package->getFileContents($file->packagedname, true), $mode);
            } catch (PEAR2_Pyrus_AtomicFileTransaction_Exception $e) {
                throw new PEAR2_Pyrus_Installer_Exception(
                    "failed writing to $dest_file", $e);
            }

            $tasks = $file->tasks;
            // only add the global replace task if it is not preprocessed
            if ($package->isNewPackage() && !$package->isPreProcessed()) {
                if (isset($tasks['tasks:replace'])) {
                    if (isset($tasks['tasks:replace'][0])) {
                        $tasks['tasks:replace'][] = $globalreplace;
                    } else {
                        $tasks['tasks:replace'] = array($tasks['tasks:replace'],
                            $globalreplace);
                    }
                } else {
                    $tasks['tasks:replace'] = $globalreplace;
                }
            }
            $fp = false;
            foreach (new PEAR2_Pyrus_Package_Creator_TaskIterator($tasks, $package,
                                                                  PEAR2_Pyrus_Task_Common::INSTALL, $lastversion)
                      as $name => $task) {
                if (!$fp) {
                    $fp = $transact->openPath($dest_file);
                }
                $task->startSession($fp, $dest_file);
                if (!rewind($fp)) {
                    throw new PEAR2_Pyrus_Installer_Exception('task ' . $name .
                                                              ' closed the file pointer, invalid task');
                }
            }
            if ($fp) {
                fclose($fp);
            }
        }
    }

    /**
     * Return an array containing all of the states that are more stable than
     * or equal to the passed in state
     *
     * @param string Release state
     * @param boolean Determines whether to include $state in the list
     * @return false|array False if $state is not a valid release state
     */
    static function betterStates($state, $include = false)
    {
        static $states = array('snapshot', 'devel', 'alpha', 'beta', 'stable');
        $i = array_search($state, $states);
        if ($i === false) {
            return false;
        }
        if ($include) {
            $i--;
        }
        return array_slice($states, $i + 1);
    }
}
<?php
/**
 * PEAR2_Pyrus_IPackage
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_IPackage extends ArrayAccess, PEAR2_Pyrus_IPackageFile
{
    function getFileContents($file, $asstream = false);
    function getFilePath($file);
    function getFrom();
    function isStatic();
    function isUpgradeable();
    function __call($func, $args);
    /**
     * This allows a package to flexibly access its package.xml and return it
     * @return PEAR2_Pyrus_IPackageFile
     */
    function getPackageFileObject();
    /**
     * Used by the download command to relocate a local tarball to the
     * download directory
     */
    function copyTo($where);
}
<?php
/**
 * Basic requirement for implementing a packagefile
 */
interface PEAR2_Pyrus_IPackageFile
{
    function __get($var);
    function __set($var, $value);
    function __toString();
    function toArray($forpackaging = false);
    function getValidator();
}
<?php
/**
 * PEAR2_Pyrus_IRegistry
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Interface for a PEAR2 Pyrus managed installation registry
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
interface PEAR2_Pyrus_IRegistry
{
    public function install(PEAR2_Pyrus_IPackageFile $info, $replace = false);
    /**
     * Used by the registry package classes to update info in an installed package
     */
    public function replace(PEAR2_Pyrus_IPackageFile $info);
    public function uninstall($name, $channel);
    public function exists($package, $channel);
    public function info($package, $channel, $field);
    public function listPackages($channel);
    public function __get($var);
    /**
     * @return PEAR2_Pyrus_IPackageFile
     */
    public function toPackageFile($package, $channel);
    /**
     * Retrieve a list of package objects that depend on this package
     */
    public function getDependentPackages(PEAR2_Pyrus_IPackageFile $package);
    /**
     * Detect any files already installed that would be overwritten by
     * files inside the package represented by $package
     */
    public function detectFileConflicts(PEAR2_Pyrus_IPackageFile $package);
    /**
     * Returns a list of registries present in the PEAR installation at $path
     * @param string
     * @return array
     */
    static public function detectRegistries($path);
    /**
     * Completely remove all traces of a registry
     */
    static public function removeRegistry($path);
}
<?php
/**
 * PEAR2_Pyrus_Log
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Standard logging class for Pyrus
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Log
{
    static public $log = array();
    static public $maxlevel = 7;
    static protected $observers = array();
    static public function log($level, $message)
    {
        if (count(self::$observers)) {
            foreach (self::$observers as $observer) {
                $observer->log($level, $message);
            }
        }
        for ($i = $level; $i <= self::$maxlevel; $i++) {
            self::$log[$i][] = $message;
        }
    }

    static public function attach(PEAR2_Pyrus_ILog $observer)
    {
        self::$observers[spl_object_hash($observer)] = $observer;
    }

    static public function detach(PEAR2_Pyrus_ILog $observer)
    {
        unset(self::$observers[spl_object_hash($observer)]);
    }
}<?php
/**
 * The PEAR2_Pyrus_OSGuess class
 *
 * PHP versions 4 and 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category   pear
 * @package    PEAR
 * @author     Stig Bakken <ssb@php.net>
 * @author     Gregory Beaver <cellog@php.net>
 * @copyright  1997-2007 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    CVS: $Id: Guess.php,v 1.25 2006/12/14 00:24:37 cellog Exp $
 * @link       http://pear.php.net/package/PEAR
 * @since      File available since Pyrus 0.1
 */

// {{{ uname examples

// php_uname() without args returns the same as 'uname -a', or a PHP-custom
// string for Windows.
// PHP versions prior to 4.3 return the uname of the host where PHP was built,
// as of 4.3 it returns the uname of the host running the PHP code.
//
// PC RedHat Linux 7.1:
// Linux host.example.com 2.4.2-2 #1 Sun Apr 8 20:41:30 EDT 2001 i686 unknown
//
// PC Debian Potato:
// Linux host 2.4.17 #2 SMP Tue Feb 12 15:10:04 CET 2002 i686 unknown
//
// PC FreeBSD 3.3:
// FreeBSD host.example.com 3.3-STABLE FreeBSD 3.3-STABLE #0: Mon Feb 21 00:42:31 CET 2000     root@example.com:/usr/src/sys/compile/CONFIG  i386
//
// PC FreeBSD 4.3:
// FreeBSD host.example.com 4.3-RELEASE FreeBSD 4.3-RELEASE #1: Mon Jun 25 11:19:43 EDT 2001     root@example.com:/usr/src/sys/compile/CONFIG  i386
//
// PC FreeBSD 4.5:
// FreeBSD host.example.com 4.5-STABLE FreeBSD 4.5-STABLE #0: Wed Feb  6 23:59:23 CET 2002     root@example.com:/usr/src/sys/compile/CONFIG  i386
//
// PC FreeBSD 4.5 w/uname from GNU shellutils:
// FreeBSD host.example.com 4.5-STABLE FreeBSD 4.5-STABLE #0: Wed Feb  i386 unknown
//
// HP 9000/712 HP-UX 10:
// HP-UX iq B.10.10 A 9000/712 2008429113 two-user license
//
// HP 9000/712 HP-UX 10 w/uname from GNU shellutils:
// HP-UX host B.10.10 A 9000/712 unknown
//
// IBM RS6000/550 AIX 4.3:
// AIX host 3 4 000003531C00
//
// AIX 4.3 w/uname from GNU shellutils:
// AIX host 3 4 000003531C00 unknown
//
// SGI Onyx IRIX 6.5 w/uname from GNU shellutils:
// IRIX64 host 6.5 01091820 IP19 mips
//
// SGI Onyx IRIX 6.5:
// IRIX64 host 6.5 01091820 IP19
//
// SparcStation 20 Solaris 8 w/uname from GNU shellutils:
// SunOS host.example.com 5.8 Generic_108528-12 sun4m sparc
//
// SparcStation 20 Solaris 8:
// SunOS host.example.com 5.8 Generic_108528-12 sun4m sparc SUNW,SPARCstation-20
//
// Mac OS X (Darwin)
// Darwin home-eden.local 7.5.0 Darwin Kernel Version 7.5.0: Thu Aug  5 19:26:16 PDT 2004; root:xnu/xnu-517.7.21.obj~3/RELEASE_PPC  Power Macintosh
//
// Mac OS X early versions
//

// }}}

/* TODO:
 * - define endianness, to allow matchSignature("bigend") etc.
 */

/**
 * Retrieves information about the current operating system
 *
 * This class uses php_uname() to grok information about the current OS
 *
 * @category   pear
 * @package    PEAR
 * @author     Stig Bakken <ssb@php.net>
 * @author     Gregory Beaver <cellog@php.net>
 * @copyright  1997-2005 The PHP Group
 * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://pear.php.net/package/PEAR
 * @since      Class available since Release 0.1
 */
class PEAR2_Pyrus_OSGuess
{
    var $sysname;
    var $nodename;
    var $cpu;
    var $release;
    var $extra;

    function __construct($uname = null)
    {
        list($this->sysname,
             $this->release,
             $this->cpu,
             $this->extra,
             $this->nodename) = $this->parseSignature($uname);
    }

    function parseSignature($uname = null)
    {
        static $sysmap = array(
            'HP-UX' => 'hpux',
            'IRIX64' => 'irix',
        );
        static $cpumap = array(
            'i586' => 'i386',
            'i686' => 'i386',
            'ppc' => 'powerpc',
        );
        if ($uname === null) {
            $uname = php_uname();
        }
        $parts = preg_split('/\s+/', trim($uname));
        $n = count($parts);

        $release = $machine = $cpu = '';
        $sysname = $parts[0];
        $nodename = $parts[1];
        $cpu = $parts[$n-1];
        $extra = '';
        if ($cpu == 'unknown') {
            $cpu = $parts[$n-2];
        }

        switch ($sysname) {
            case 'AIX' :
                $release = "$parts[3].$parts[2]";
                break;
            case 'Windows' :
                switch ($parts[1]) {
                    case '95/98':
                        $release = '9x';
                        break;
                    default:
                        $release = $parts[1];
                        break;
                }
                $cpu = 'i386';
                break;
            case 'Linux' :
                $extra = $this->_detectGlibcVersion();
                // use only the first two digits from the kernel version
                $release = preg_replace('/^([0-9]+\.[0-9]+).*/', '\1', $parts[2]);
                break;
            case 'Mac' :
                $sysname = 'darwin';
                $nodename = $parts[2];
                $release = $parts[3];
                if ($cpu == 'Macintosh') {
                    if ($parts[$n - 2] == 'Power') {
                        $cpu = 'powerpc';
                    }
                }
                break;
            case 'Darwin' :
                if ($cpu == 'Macintosh') {
                    if ($parts[$n - 2] == 'Power') {
                        $cpu = 'powerpc';
                    }
                }
                $release = preg_replace('/^([0-9]+\.[0-9]+).*/', '\1', $parts[2]);
                break;
            default:
                $release = preg_replace('-.*', '', $parts[2]);
                break;
        }


        if (isset($sysmap[$sysname])) {
            $sysname = $sysmap[$sysname];
        } else {
            $sysname = strtolower($sysname);
        }
        if (isset($cpumap[$cpu])) {
            $cpu = $cpumap[$cpu];
        }
        return array($sysname, $release, $cpu, $extra, $nodename);
    }

    private function _detectGlibcVersion()
    {
        static $glibc = false;
        if ($glibc !== false) {
            return $glibc; // no need to run this multiple times
        }
        $major = $minor = 0;
        // Use glibc's <features.h> header file to
        // get major and minor version number:
        if (@file_exists('/usr/include/features.h') &&
              @is_readable('/usr/include/features.h')) {
            if (!@file_exists('/usr/bin/cpp') || !@is_executable('/usr/bin/cpp')) {
                $features_file = fopen('/usr/include/features.h', 'rb');
                while (!feof($features_file)) {
                    $line = fgets($features_file, 8192);
                    if (!$line || (strpos($line, '#define') === false)) {
                        continue;
                    }
                    if (strpos($line, '__GLIBC__')) {
                        // major version number #define __GLIBC__ version
                        $line = preg_split('/\s+/', $line);
                        $glibc_major = trim($line[2]);
                        if (isset($glibc_minor)) {
                            break;
                        }
                        continue;
                    }
                    if (strpos($line, '__GLIBC_MINOR__'))  {
                        // got the minor version number
                        // #define __GLIBC_MINOR__ version
                        $line = preg_split('/\s+/', $line);
                        $glibc_minor = trim($line[2]);
                        if (isset($glibc_major)) {
                            break;
                        }
                        continue;
                    }
                }
                fclose($features_file);
                if (!isset($glibc_major) || !isset($glibc_minor)) {
                    return $glibc = '';
                }
                return $glibc = 'glibc' . trim($glibc_major) . "." . trim($glibc_minor) ;
            } // no cpp
            $tmpfile = tempnam(sys_get_temp_dir(), "glibctest");
            $fp = fopen($tmpfile, "w");
            fwrite($fp, "#include <features.h>\n__GLIBC__ __GLIBC_MINOR__\n");
            fclose($fp);
            $cpp = popen("/usr/bin/cpp $tmpfile", "r");
            while ($line = fgets($cpp, 1024)) {
                if ($line{0} == '#' || trim($line) == '') {
                    continue;
                }
                if (list($major, $minor) = explode(' ', trim($line))) {
                    break;
                }
            }
            pclose($cpp);
            unlink($tmpfile);
        } // features.h
        if (!($major && $minor) && @is_link('/lib/libc.so.6')) {
            // Let's try reading the libc.so.6 symlink
            if (ereg('^libc-(.*)\.so$', basename(readlink('/lib/libc.so.6')), $matches)) {
                list($major, $minor) = explode('.', $matches[1]);
            }
        }
        if (!($major && $minor)) {
            return $glibc = '';
        }
        return $glibc = "glibc{$major}.{$minor}";
    }

    function getSignature()
    {
        if (empty($this->extra)) {
            return "{$this->sysname}-{$this->release}-{$this->cpu}";
        }
        return "{$this->sysname}-{$this->release}-{$this->cpu}-{$this->extra}";
    }

    function getSysname()
    {
        return $this->sysname;
    }

    function getNodename()
    {
        return $this->nodename;
    }

    function getCpu()
    {
        return $this->cpu;
    }

    function getRelease()
    {
        return $this->release;
    }

    function getExtra()
    {
        return $this->extra;
    }

    function matchSignature($match)
    {
        if (is_array($match)) {
            $fragments = $match;
        } else {
            $fragments = explode('-', $match);
        }
        $n = count($fragments);
        $matches = 0;
        if ($n > 0) {
            $matches += $this->_matchFragment($fragments[0], $this->sysname);
        }
        if ($n > 1) {
            $matches += $this->_matchFragment($fragments[1], $this->release);
        }
        if ($n > 2) {
            $matches += $this->_matchFragment($fragments[2], $this->cpu);
        }
        if ($n > 3) {
            $matches += $this->_matchFragment($fragments[3], $this->extra);
        }
        return ($matches == $n);
    }

    function _matchFragment($fragment, $value)
    {
        if (strcspn($fragment, '*?') < strlen($fragment)) {
            $reg = '/^' . str_replace(array('*', '?', '/'), array('.*', '.', '\\/'), $fragment) . '\\z/';
            return preg_match($reg, $value);
        }
        return ($fragment == '*' || !strcasecmp($fragment, $value));
    }

}
/*
 * Local Variables:
 * indent-tabs-mode: nil
 * c-basic-offset: 4
 * End:
 */
?>
<?php
/**
 * PEAR2_Pyrus_Package
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Abstract representation of a package
 *
 * specific package types are:
 *
 * - package.xml
 * - package.tgz/package.tar
 * - package.phar
 * - remote undownloaded package
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Package implements PEAR2_Pyrus_IPackage
{
    /**
     * This is strictly for unit-testing purposes
     * @var string
     */
    public $archivefile;
    /**
     * The actual package representation
     *
     * @var PEAR2_Pyrus_Package_Xml|PEAR2_Pyrus_Package_Tar|PEAR2_Pyrus_Package_Phar
     */
    protected $internal;
    protected $from;

    function __construct($packagedescription, $forceremote = false)
    {
        if (!$packagedescription) {
            return;
        }
        if ($forceremote) {
            $this->internal = new PEAR2_Pyrus_Package_Remote($packagedescription);
        } else {
            $class = $this->parsePackageDescription($packagedescription);
            $this->internal = new $class($packagedescription, $this);
        }
    }

    function setFrom($from)
    {
        $this->from = $from;
    }

    function __get($var)
    {
        return $this->internal->$var;
    }

    function __set($var, $value)
    {
        return $this->internal->__set($var, $value);
    }

    function __call($func, $args)
    {
        // delegate to the internal object
        return call_user_func_array(array($this->internal, $func), $args);
    }

    function getValidator()
    {
        return $this->internal->getValidator();
    }

    function toArray($forpackaging = false)
    {
        return $this->internal->toArray($forpackaging);
    }

    function getFileContents($file, $asstream = false)
    {
        return $this->internal->getFileContents($file, $asstream);
    }

    function getFilePath($file)
    {
        return $this->internal->getFilePath($file);
    }

    function isNewPackage()
    {
        return $this->internal->isNewPackage();
    }

    function isUpgradeable()
    {
        return $this->internal->isUpgradeable();
    }

    function getFrom()
    {
        if ($this->from) {
            return $this->from->getFrom();
        }
        return $this;
    }

    function getPackageFileObject()
    {
        return $this->internal->getPackageFileObject();
    }

    function getInternalPackage()
    {
        return $this->internal;
    }

    function setInternalPackage(PEAR2_Pyrus_IPackage $internal)
    {
        $this->internal = $internal;
    }

    function __toString()
    {
        return $this->internal->__toString();
    }

    function offsetExists($offset)
    {
        return isset($this->internal[$offset]);
    }

    function offsetGet($offset)
    {
        return $this->internal[$offset];
    }

    function offsetSet($offset, $value)
    {
        $this->internal[$offset] = $value;
    }

    function offsetUnset($offset)
    {
        unset($this->internal[$offset]);
    }

    function isStatic()
    {
        return $this->internal->isStatic();
    }

    function isRemote()
    {
        return $this->internal instanceof PEAR2_Pyrus_Package_Remote ||
                    $this->internal instanceof PEAR2_Pyrus_Channel_Remotepackage || (
                    $this->internal instanceof PEAR2_Pyrus_Package && $this->internal->isRemote());
    }

    function download()
    {
        if ($this->internal instanceof PEAR2_Pyrus_Package_Remote) {
            $this->internal = $this->internal->download();
        }
    }

    function copyTo($where)
    {
        $this->internal->copyTo($where);
    }

    static function parsePackageDescription($package)
    {
        if (strpos($package, 'http://') === 0 || strpos($package, 'https://') === 0) {
            return 'PEAR2_Pyrus_Package_Remote';
        }
        try {
            if (@file_exists($package) && @is_file($package)) {
                $info = pathinfo($package);
                if (!isset($info['extension']) || !strlen($info['extension'])) {
                    // guess based on first 4 characters
                    $f = @fopen($package, 'r');
                    if ($f) {
                        $first5 = fread($f, 5);
                        fclose($f);
                        if ($first5 == '<?xml') {
                            return 'PEAR2_Pyrus_Package_Xml';
                        }
                        return 'PEAR2_Pyrus_Package_Phar';
                    }
                } else {
                    if (extension_loaded('phar') && strtolower($info['extension']) != 'xml') {
                        return 'PEAR2_Pyrus_Package_Phar';
                    }
                    switch (strtolower($info['extension'])) {
                        case 'xml' :
                            return 'PEAR2_Pyrus_Package_Xml';
                        default:
                            throw new PEAR2_Pyrus_Package_Exception('Cannot read archives with phar extension');
                    }
                }
            }
            $info = PEAR2_Pyrus_Config::parsePackageName($package);
            return 'PEAR2_Pyrus_Package_Remote';
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Package_Exception('package "' . $package . '" is unknown', $e);
        }
    }
}
<?php
/**
 * PEAR2_Pyrus_PackageFile
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for a PEAR2 package file
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PackageFile
{
    public $info;
    public $path;
    function __construct($package, $class = 'PEAR2_Pyrus_PackageFile_v2', $isstring = false)
    {
        if ($package instanceof PEAR2_Pyrus_IPackageFile) {
            $this->path = $package->getFilePath();
            return $this->info = $package;
        }
        $this->path = $package;
        $parser = new PEAR2_Pyrus_PackageFile_Parser_v2;
        if ($isstring) {
            $data = $package;
        } else {
            $data = file_get_contents($package);
        }
        if ($data === false || empty($data)) {
            throw new PEAR2_Pyrus_PackageFile_Exception('Unable to open package xml file '
                . $package . ' or file was empty.');
        }
        $this->info = $parser->parse($data, $package, $class);
    }

    function __toString()
    {
        return $this->info->__toString();
    }

    function getValidator()
    {
        return $this->info->getValidator();
    }

    function getPackageFileObject()
    {
        return $this->info;
    }
}
<?php
/**
 * PEAR2_Pyrus_PECLBuild
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Class handling building of PECL packages
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PECLBuild
{
    protected $ui;
    protected $buildDirectory;
    /* don't think we need this, but will reserve judgement until I hear from internals@
    protected $zend_extension_api_no = 1;
    protected $zend_module_api_no = 1;
    protected $php_api_version = 1;
    */

    function __construct($ui)
    {
        $this->ui = $ui;
    }

    function installBuiltStuff(PEAR2_Pyrus_Registry_Package_Base $pkg, array $built)
    {
        foreach ($built as $ext) {
            $info = pathinfo($ext['file']);
            if ($info['extension'] === 'so' || $info['extension'] === 'dll') {
                if (extension_loaded(basename($ext['file'], $info['extension']))) {
                    $this->raiseError("Extension '" . basename($ext['file'], $info['extension']) .
                                      "' already loaded. " .
                                      'Please unload it in your php.ini file ' .
                                      'prior to install or upgrade');
                }
                $role = 'ext';
            } else {
                $role = 'src';
            }

            $copyto = $dest = $ext['dest'];
            $packagingroot = '';
            if (isset(PEAR2_Pyrus_Installer::$options['packagingroot'])) {
                $packagingroot = PEAR2_Pyrus_Installer::$options['packagingroot'];
                $copyto = $this->_prependPath($dest, $packagingroot);
            }

            if ($copyto != $dest) {
                $this->log(1, "Installing '$dest' as '$copyto'");
            } else {
                $this->log(1, "Installing '$dest'");
            }

            $copydir = dirname($copyto);
            if (file_exists($copydir)) {
                if (!is_dir($copydir)) {
                    throw new PEAR2_Pyrus_PECLBuild_Exception('Cannot install extension, ' .
                                                              $copydir . ' exists and is a file (should be directory)');
                }
            } else {
                $oldmode = umask(PEAR2_Pyrus_Config::current()->umask);
                if (!mkdir($copydir, 0777, true)) {
                    umask($oldmode);
                    throw new PEAR2_Pyrus_PECLBuild_Exception("failed to mkdir $copydir");
                }
                umask($oldmode);

                $this->log(3, "+ mkdir $copydir");
            }

            if (!@copy($ext['file'], $copyto)) {
                throw new PEAR2_Pyrus_PECLBuild_Exception("failed to write $copyto ($php_errormsg)");
            }

            $oldmode = umask(PEAR2_Pyrus_Config::current()->umask);
            if (!@chmod($copyto, 0777)) {
                $this->log(0, "failed to change mode of $copyto ($php_errormsg)");
            }
            umask($oldmode);

            $pkg->files[$ext['file']] = array('attribs' => array(
                'role' => $role,
                'name' => $ext['packagexml_name'],
                'installed_as' => $dest,
    /* don't think we need this, but will reserve judgement until I hear from internals@
                'php_api' => $ext['php_api'],
                'zend_mod_api' => $ext['zend_mod_api'],
                'zend_ext_api' => $ext['zend_ext_api'],
    */
                ));
        }
    }

    function listInstalledStuff($dir)
    {
        foreach (new \RecursiveIteratorIterator(
                            new \RecursiveDirectoryIterator($dir,
                                                            0|\RecursiveDirectoryIterator::SKIP_DOTS),
                            \RecursiveIteratorIterator::SELF_FIRST) as $file) {
            $info = stat($file);
            $uname = posix_getpwuid($info['uid']);
            $uname = $uname['name'];
            $gname = posix_getgrgid($info['gid']);
            $gname = $gname['name'];
            $perms = fileperms($file);
            foreach (array('s' => 0xC000, 'l' => 0xA000, '-' => 0x8000, 'b' => 0x6000,
                           'd' => 0x4000, 'c' => 0x2000, 'p' => 0x1000)
                     as $letter => $mask) {
                if (($perms & $mask) === $mask) {
                    $perminfo = $letter;
                    break;
                }
            }
            if (!isset($perminfo)) {
                $perminfo = 'u';
            }

            // Owner
            $perminfo .= (($perms & 0x0100) ? 'r' : '-');
            $perminfo .= (($perms & 0x0080) ? 'w' : '-');
            $perminfo .= (($perms & 0x0040) ?
                        (($perms & 0x0800) ? 's' : 'x' ) :
                        (($perms & 0x0800) ? 'S' : '-'));

            // Group
            $perminfo .= (($perms & 0x0020) ? 'r' : '-');
            $perminfo .= (($perms & 0x0010) ? 'w' : '-');
            $perminfo .= (($perms & 0x0008) ?
                        (($perms & 0x0400) ? 's' : 'x' ) :
                        (($perms & 0x0400) ? 'S' : '-'));

            // World
            $perminfo .= (($perms & 0x0004) ? 'r' : '-');
            $perminfo .= (($perms & 0x0002) ? 'w' : '-');
            $perminfo .= (($perms & 0x0001) ?
                        (($perms & 0x0200) ? 't' : 'x' ) :
                        (($perms & 0x0200) ? 'T' : '-'));
            $date = new DateTime;
            $date->setTimestamp($info['mtime']);
    
            echo $info['ino'], ' ', str_pad(($info['blocks']/2), 3, ' ', STR_PAD_LEFT), ' ', $perminfo, ' ',
                 $info['nlink'], ' ', $uname, ' ', $gname, ' ',
                 str_pad($info['size'], 10, ' ', STR_PAD_LEFT), ' ', $date->format('Y-m-d H:i'), ' ', $file, "\n";
        }
    }

    /**
     * @param string
     * @param string
     */
    protected function harvestInstDir($dest_prefix, $dirname, $instroot)
    {
        $defaultExtDir = PEAR2_Pyrus_Config::current()->defaultValue('ext_dir');
        $ext_dir = PEAR2_Pyrus_Config::current()->ext_dir;
        if ($ext_dir != $defaultExtDir) {
            $extReplace = $defaultExtDir;
        } else {
            $extReplace = '****';
        }
        $built_files = array();
        foreach (new \RecursiveIteratorIterator(
                    new \RecursiveDirectoryIterator($dirname,
                                                    0|\RecursiveDirectoryIterator::SKIP_DOTS)) as $file) {
            
            $built_files[] = array(
                        'file' => (string) $file,
                        'dest' => str_replace(
                                    $extReplace,
                                    $ext_dir,
                                    $dest_prefix . '/' . str_replace($dirname . DIRECTORY_SEPARATOR, '', $file)),
                        'packagexml_name' => substr($file, strlen($dirname) + 1),
    /* don't think we need this, but will reserve judgement until I hear from internals@
                        'php_api' => $this->php_api_version,
                        'zend_mod_api' => $this->zend_module_api_no,
                        'zend_ext_api' => $this->zend_extension_api_no,
    */
                        );
        }
        return $built_files;
    }

    /**
     * Build an extension from source.  Runs "phpize" in the source
     * directory, and compiles there.
     *
     * @param PEAR2_Pyrus_IPackage $pkg package object
     *
     * @param mixed $callback callback function used to report output,
     * see PEAR_Builder::_runCommand for details
     *
     * @return array an array of associative arrays with built files,
     * format:
     * array( array( 'file' => '/path/to/ext.so',
     *               'php_api' => YYYYMMDD,
     *               'zend_mod_api' => YYYYMMDD,
     *               'zend_ext_api' => YYYYMMDD ),
     *        ... )
     *
     * @access public
     *
     * @see PEAR_Builder::_runCommand
     */
    function build(PEAR2_Pyrus_Registry_Package_Base $pkg, $callback = null)
    {
        $config = PEAR2_Pyrus_Config::current();
        if (preg_match('/(\\/|\\\\|^)([^\\/\\\\]+)?php(.+)?$/',
                       $config->php_bin, $matches)) {
            if (isset($matches[2]) && strlen($matches[2]) &&
                trim($matches[2]) != trim($config->php_prefix)) {
                $this->log(0, 'WARNING: php_bin ' . $config->php_bin .
                           ' appears to have a prefix ' . $matches[2] . ', but' .
                           ' config variable php_prefix does not match');
            }
            if (isset($matches[3]) && strlen($matches[3]) &&
                trim($matches[3]) != trim($config->php_suffix)) {
                $this->log(0, 'WARNING: php_bin ' . $config->php_bin .
                           ' appears to have a suffix ' . $matches[3] . ', but' .
                           ' config variable php_suffix does not match');
            }
        }

        $this->current_callback = $callback;
        if ($pkg->isNewPackage()) {
            $dir = $config->src_dir . DIRECTORY_SEPARATOR .
                $pkg->channel . DIRECTORY_SEPARATOR . $pkg->name;
        } else {
            $dir = $config->src_dir . DIRECTORY_SEPARATOR . $pkg->name;
        }
        $this->buildDirectory = $dir;
        $old_cwd = getcwd();
        if (!file_exists($dir) || !is_dir($dir) || !chdir($dir)) {
            throw new PEAR2_Pyrus_PECLBuild_Exception('could not chdir to package directory ' . $dir);
        }
        if (!is_writable($dir)) {
            throw new PEAR2_Pyrus_PECLBuild_Exception('cannot build in package directory ' . $dir .
                                                      ', directory not writable');
        }
        $this->log(0, "cleaning build directory $dir");
        $this->_runCommand($config->php_prefix
                                . "phpize" .
                                $config->php_suffix . ' --clean',
                                null,
                                array('PATH' => $config->php_bin . ':' . getenv('PATH')));
        $this->log(0, "building in $dir");
        if (!$this->_runCommand($config->php_prefix
                                . "phpize" .
                                $config->php_suffix,
                                null, /*array($this, 'phpizeCallback'),*/
                                array('PATH' => $config->php_bin . ':' . getenv('PATH')))) {
            throw new PEAR2_Pyrus_PECLBuild_Exception('phpize failed - if running phpize manually from ' . $dir .
                                                      ' works, please open a bug for pyrus with details');
        }

        // {{{ start of interactive part
        $configure_command = "$dir/configure";
        if (count($pkg->configureoption)) {
            foreach ($pkg->configureoption as $o) {
                list($r) = $this->ui->ask($o->prompt, array(), $o->default);
                if (substr($o->name, 0, 5) == 'with-' &&
                    ($r == 'yes' || $r == 'autodetect')) {
                    $configure_command .= ' --' . $o->name;
                } else {
                    $configure_command .= ' --' . $o->name . '=' . trim($r);
                }
            }
        }
        // }}} end of interactive part

        $inst_dir = $dir . '/.install';
        $this->log(1, "building in $dir");
        if (!file_exists($inst_dir) && !mkdir($inst_dir, 0755, true) || !is_dir($inst_dir)) {
            throw new PEAR2_Pyrus_PECLBuild_Exception('could not create temporary install dir: ' . $inst_dir);
        }

        if (getenv('MAKE')) {
            $make_command = getenv('MAKE');
        } else {
            $make_command = 'make';
        }
        $to_run = array(
            $configure_command,
            $make_command,
            "$make_command INSTALL_ROOT=\"$inst_dir\" install",
            );
        if (!file_exists($dir) || !is_dir($dir) || !chdir($dir)) {
            throw new PEAR2_Pyrus_PECLBuild_Exception('could not chdir to ' . $dir);
        }
        $env = $_ENV;
        // this next line is modified by the installer at packaging time
        if ('@PEAR-VER@' == '@'.'PEAR-VER@') {
            // we're running from svn
            $env['PHP_PEAR_VERSION'] = '2.0.0a1';
        } else {
            $env['PHP_PEAR_VERSION'] = '@PEAR-VER@';
        }
        foreach ($to_run as $cmd) {
            try {
                if (!$this->_runCommand($cmd, $callback, $env)) {
                    throw new PEAR2_Pyrus_PECLBuild_Exception("`$cmd' failed");
                }
            } catch (\Exception $e) {
                chdir($old_cwd);
                throw $e;
            }
        }

        $this->listInstalledStuff($inst_dir);

        if (!file_exists('modules') || !is_dir('modules')) {
            chdir($old_cwd);
            throw new PEAR2_Pyrus_PECLBuild_Exception("no `modules' directory found");
        }
        $built_files = array();
        $prefix = exec($config->php_prefix
                        . "php-config" .
                       $config->php_suffix . " --prefix");
        $built_files = $this->harvestInstDir($prefix, $inst_dir . DIRECTORY_SEPARATOR . $prefix, $inst_dir);
        chdir($old_cwd);
        return $built_files;
    }

    /**
     * Message callback function used when running the "phpize"
     * program.  Extracts the API numbers used.  Ignores other message
     * types than "cmdoutput".
     *
     * @param string $what the type of message
     * @param mixed $data the message
     *
     * @return void
     *
     * @access public
     */
    /* don't think we need this, but will reserve judgement until I hear from internals@
    function phpizeCallback($what, $data)
    {
        if ($what != 'cmdoutput') {
            return;
        }
        $this->log(1, rtrim($data));
        if (preg_match('/You should update your .aclocal.m4/', $data)) {
            return;
        }
        $matches = array();
        if (preg_match('/^((?:[a-zA-Z]+ ?)+):\s+(\d+)/', $data, $matches)) {
            $member = preg_replace('/[^a-z]/', '_', strtolower($matches[1]));
            $apino = (int)$matches[2];
            if (isset($this->$member)) {
                $this->$member = $apino;
            }
        }
    }*/

    /**
     * Run an external command, using a message callback to report
     * output.  The command will be run through popen and output is
     * reported for every line with a "cmdoutput" message with the
     * line string, including newlines, as payload.
     *
     * @param string $command the command to run
     *
     * @param mixed $callback (optional) function to use as message
     * callback
     *
     * @return bool whether the command was successful (exit code 0
     * means success, any other means failure)
     *
     * @access private
     */
    function _runCommand($command, $callback = null, $env = null)
    {
        $this->log(1, "running: $command 2>&1");

        $exitcode = $this->system_with_timeout($command . ' 2>&1', $this->buildDirectory, $callback, $env);
        return ($exitcode == 0);
    }

    /**
     * Ported from PHP 5.3's run-tests.php
     */
    function system_with_timeout($commandline, $cwd, $callback = null, $env = null, $stdin = null, $timeout = 60)
    {
        $data = '';

        $bin_env = array();
        foreach((array)$env as $key => $value) {
            $bin_env[(binary)$key] = (binary)$value;
        }

        $proc = proc_open($commandline, array(
            0 => array('pipe', 'r'),
            1 => array('pipe', 'w'),
            2 => array('pipe', 'w')
            ), $pipes, $cwd, $bin_env, array('suppress_errors' => true, 'binary_pipes' => true));

        if (!$proc) {
            return false;
        }

        if (!is_null($stdin)) {
            fwrite($pipes[0], (binary) $stdin);
        }
        fclose($pipes[0]);

        while (true) {
            /* hide errors from interrupted syscalls */
            $r = $pipes;
            $w = null;
            $e = null;

            $n = @stream_select($r, $w, $e, $timeout);

            if ($n === false) {
                break;
            } else if ($n === 0) {
                /* timed out */
                proc_terminate($proc);
                throw new PEAR2_Pyrus_PECLBuild_Exception('Error: Process timed out');
            } else if ($n > 0) {
                $called = false;
                while ($line = fgets($pipes[1], 1024)) {
                    $called = true;
                    if ($callback) {
                        call_user_func($callback, 'cmdoutput', $line);
                    } else {
                        $this->log(0, rtrim($line));
                    }
                }
                if (!$called) {
                    break;
                }
            }
        }

        $stat = proc_get_status($proc);

        if ($stat['signaled']) {
            $code = proc_close($proc);
            throw new PEAR2_Pyrus_PECLBuild_Exception('Process was stopped with a signal: ' . $stat['stopsig']);
        }

        $code = proc_close($proc);
        $code = $stat['exitcode'];
        return $code;
    }

    function log($level, $msg)
    {
        if ($this->current_callback) {
            call_user_func($this->current_callback, 'output', $msg);
            return;
        }
        return PEAR2_Pyrus_Log::log($level, $msg);
    }
}<?php
/**
 * PEAR2_Pyrus_PluginRegistry
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Registry manager for Pyrus plugins
 *
 * The plugin manager is a standard Pyrus registry, but also has
 * specialized commands to retrieve command plugins, custom roles/tasks, and scripts
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_PluginRegistry extends PEAR2_Pyrus_Registry
{
    function retrieveCommands()
    {
    }

    function retrieveRoles()
    {
        
    }

    function retrieveTasks()
    {
    }

    function retrieveScripts()
    {
        
    }

    function getRole($role)
    {
    }

    function getTask($role)
    {
    }
}
<?php
/**
 * PEAR2_Pyrus_Registry
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Registry manager
 *
 * The registry for PEAR2 consists of four related components
 *
 *  - an sqlite database
 *  - saved original package.xml for each installed package
 *  - saved original channel.xml for each discovered channel
 *  - configuration values at package installation time
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Registry implements PEAR2_Pyrus_IRegistry, IteratorAggregate
{
    static protected $allRegistries = array();
    /**
     * Class to instantiate for singleton.
     *
     * This is useful for unit-testing and for extending the registry
     * @var string
     */
    static public $className = 'PEAR2_Pyrus_Registry';
    /**
     * The parent registry
     *
     * This is used to implement cascading registries
     * @var PEAR2_Pyrus_Registry
     */
    protected $parent;

    /**
     * The base path of this registry
     *
     * @var string
     */
    protected $path;
    /**
     * If true, this registry is a cascaded parent registry, and should be treated
     * as read-only.
     *
     * @var bool
     */
    protected $readonly;

    protected $registries = array();
    /**
     * The channel registry for this path
     *
     * @var PEAR2_PyruschannelRegistry
     */
    protected $channelRegistry;

    public function setChannelRegistry(PEAR2_Pyrus_ChannelRegistry $reg)
    {
        $this->channelRegistry = $reg;
    }

    public function setParent(PEAR2_Pyrus_Registry $parent = null)
    {
        $this->parent = $parent;
    }

    public function __construct($path, $registries = array('Sqlite3', 'Xml'), $readonly = false)
    {
        $this->path     = $path;
        $this->readonly = $readonly;
        $exceptions     = array();
        foreach ($registries as $registry) {
            try {
                $registry = ucfirst($registry);
                $registry = "PEAR2_Pyrus_Registry_$registry";
                if (!class_exists($registry, true)) {
                    $exceptions[] = new PEAR2_Pyrus_Registry_Exception(
                        'Unknown registry type: ' . $registry);
                    continue;
                }
                $this->registries[] = new $registry($path, $readonly);
            } catch (Exception $e) {
                $exceptions[] = $e;
            }
        }

        if (!count($this->registries)) {
            throw new PEAR2_Pyrus_Registry_Exception(
                'Unable to initialize registry for path "' . $path . '"',
                $exceptions);
        }

        $this->channelRegistry = new PEAR2_Pyrus_ChannelRegistry($path,
            $registries, $readonly);
    }

    public function replace(PEAR2_Pyrus_IPackageFile $info)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot install packages, registry is read-only');
        }

        foreach ($this->registries as $reg) {
            $reg->replace($info);
        }
    }

    public function install(PEAR2_Pyrus_IPackageFile $info, $replace = false)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot install packages, registry is read-only');
        }

        foreach ($this->registries as $reg) {
            $reg->install($info, $replace);
        }
    }

    public function uninstall($name, $channel)
    {
        if ($this->readonly) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot uninstall packages, registry is read-only');
        }

        foreach ($this->registries as $reg) {
            $reg->uninstall($name, $channel);
        }
    }

    /**
     * Determines whether a package exists
     *
     * @param string $package
     * @param string $channel
     * @param bool   $onlyMain if true, only check the primary registry
     * 
     * @return bool
     */
    public function exists($package, $channel, $onlyMain = false)
    {
        $ret = $this->registries[0]->exists($package, $channel);
        if ($onlyMain) {
            return $ret;
        }

        if (!$ret) {
            if (!$this->parent) {
                return false;
            }

            return $this->parent->exists($package, $channel);
        }

        return true;
    }

    public function info($package, $channel, $field, $onlyMain = false)
    {
        if ($onlyMain) {
            return $this->registries[0]->info($package, $channel, $field);
        }

        if ($this->exists($package, $channel, true)) {
            return $this->registries[0]->info($package, $channel, $field);
        }

        if ($this->exists($package, $channel, false)) {
            if (!$this->parent) {
                return null;
            }

            // installed in parent registry
            return $this->parent->info($package, $channel, $field);
        }

        return null;
    }

    public function listPackages($channel, $onlyMain = false)
    {
        $ret = array();
        foreach ($this->registries as $registry) {
            $packages = $registry->listPackages($channel);
            $ret = array_merge($ret, $packages);
        }
        $ret = array_unique($ret);
        if ($onlyMain) {
            return $ret;
        }
        if ($this->parent) {
            return array_unique(array_merge($ret, $this->parent->listPackages($channel)));
        }

        return $ret;
    }

    // TODO: fix to support cascading
    public function getIterator()
    {
        return $this->registries[0];
    }

    public function toPackageFile($package, $channel, $onlyMain = false)
    {
        if ($this->exists($package, $channel, true)) {
            foreach ($this->registries as $reg) {
                if ($reg instanceof PEAR2_Pyrus_Registry_Xml) {
                    // prefer xml for retrieving packagefile object
                    try {
                        return $reg->toPackageFile($package, $channel);
                    } catch (Exception $e) {
                        // failed, cascade to using default registry instead
                        break;
                    }
                }
            }

            return $this->registries[0]->toPackageFile($package, $channel);
        } elseif ($onlyMain || !$this->exists($package, $channel, false)) {
            throw new PEAR2_Pyrus_Registry_Exception('Cannot retrieve package file object ' .
                'for package ' . $channel . '/' . $package . ', it is not installed');
        }

        // installed in parent registry
        return $this->parent->toPackageFile($package, $channel);
    }

    function __get($var)
    {
        // first registry is always the primary registry
        if ($var == 'package') {
            return $this->registries[0]->package;
        }

        if ($var == 'allregistries') {
            return $this->registries;
        }
    }

    public function getParent()
    {
        return $this->parent;
    }

    public function getPath()
    {
        return $this->path;
    }

    public function getDependentPackages(PEAR2_Pyrus_IPackageFile $package)
    {
        return $this->registries[0]->getDependentPackages($package);
    }

    public function detectFileConflicts(PEAR2_Pyrus_IPackageFile $package)
    {
        return $this->registries[0]->detectFileConflicts($package);
    }

    /**
     * Returns a list of registries present in the PEAR installation at $path
     * @param string
     * @return array
     * @todo make it possible to extend the registries to add customized future registries
     */
    static public function detectRegistries($path)
    {
        if (!file_exists($path) || !is_dir($path)) {
            return array();
        }
        return array_merge(PEAR2_Pyrus_Registry_Sqlite3::detectRegistries($path),
                           PEAR2_Pyrus_Registry_Xml::detectRegistries($path),
                           PEAR2_Pyrus_Registry_Pear1::detectRegistries($path));
    }

    /**
     * Completely remove all traces of a registry
     */
    static public function removeRegistry($path, array $registries = array())
    {
        if (!count($registries)) {
            $registries = static::detectRegistries($path);
        }
        foreach ($registries as $reg) {
            $class = 'PEAR2_Pyrus_Registry_' . ucfirst(strtolower($reg));
            $class::removeRegistry($path);
        }
    }
}
<?php
/**
 * PEAR_REST
 *
 * PHP versions 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Intelligently retrieve data, following hyperlinks if necessary, and re-directing
 * as well
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_REST
{
    protected $config;
    protected $_options;
    /**
     * For easy unit testing
     */
    static public $downloadClass = 'PEAR2_HTTP_Request';

    function __construct()
    {
        $this->config = PEAR2_Pyrus_Config::current();
        $this->_options = PEAR2_Pyrus_Installer::$options;
    }

    /**
     * Retrieve REST data, but always retrieve the local cache if it is available.
     *
     * This is useful for elements that should never change, such as information on a particular
     * release
     * @param string full URL to this resource
     * @param array|false contents of the accept-encoding header
     * @param boolean     if true, xml will be returned as a string, otherwise, xml will be
     *                    parsed using PEAR_XMLParser
     * @return string|array
     */
    function retrieveCacheFirst($url, $accept = false, $forcestring = false)
    {
        $cachefile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
            md5($url) . 'rest.cachefile';
        if (file_exists($cachefile)) {
            return unserialize(implode('', file($cachefile)));
        }
        return $this->retrieveData($url, $accept, $forcestring);
    }

    /**
     * Retrieve a remote REST resource
     * @param string full URL to this resource
     * @param array|false contents of the accept-encoding header
     * @param boolean     if true, xml will be returned as a string, otherwise, xml will be
     *                    parsed using PEAR_XMLParser
     * @return string|array
     */
    function retrieveData($url, $accept = false, $forcestring = false)
    {
        $cacheId = $this->getCacheId($url);
        if ($ret = $this->useLocalCache($url, $cacheId)) {
            return $ret;
        }

        if (!isset($this->_options['offline'])) {
            $trieddownload = true;
            try {
                $file = $this->downloadHttp($url, $cacheId ? $cacheId['lastChange'] : false, $accept);
            } catch (PEAR2_HTTP_Request_Exception $e) {
                $trieddownload = false;
                $file = false;
            }
        } else {
            $trieddownload = false;
            $file = false;
        }
        if (!$file) {
            $ret = $this->getCache($url);
            if ($trieddownload) {
                // reset the age of the cache if the server says it was unmodified
                $this->saveCache($url, $ret, null, true, $cacheId);
            }
            return $ret;
        }
        if (is_array($file)) {
            $headers = $file[2];
            $lastmodified = $file[1];
            $content = $file[0];
        } else {
            $content = $file;
            $lastmodified = false;
            $headers = array();
        }
        if ($forcestring) {
            $this->saveCache($url, $content, $lastmodified, false, $cacheId);
            return $content;
        }
        if (isset($headers['content-type'])) {
            switch ($headers['content-type']) {
                case 'text/xml' :
                case 'application/xml' :
                    $parser = new PEAR2_Pyrus_XMLParser;
                    try {
                        $content = $parser->parseString($content);
                        $content = current($content);
                    } catch (Exception $e) {
                        throw new PEAR2_Pyrus_REST_Exception(
                            'Invalid xml downloaded from "' . $url . '"', $e);
                    }
                case 'text/html' :
                default :
                    // use it as a string
            }
        } else {
            // assume XML
            $parser = new PEAR2_Pyrus_XMLParser;
            try {
                $content = $parser->parseString($content);
                $content = current($content);
            } catch (Exception $e) {
                throw new PEAR2_Pyrus_REST_Exception(
                    'Invalid xml downloaded from "' . $url . '"', $e);
            }
        }
        $this->saveCache($url, $content, $lastmodified, false, $cacheId);
        return $content;
    }

    function useLocalCache($url, $cacheid = null)
    {
        if ($cacheid === null) {
            $cacheidfile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
                md5($url) . 'rest.cacheid';
            if (!file_exists($cacheidfile)) {
                return false;
            }

            $cacheid = unserialize(implode('', file($cacheidfile)));
        }
        $cachettl = $this->config->cache_ttl;
        // If cache is newer than $cachettl seconds, we use the cache!
        if (time() - $cacheid['age'] < $cachettl) {
            return $this->getCache($url);
        }
        return false;
    }

    function getCacheId($url)
    {
        $cacheidfile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
            md5($url) . 'rest.cacheid';
        if (file_exists($cacheidfile)) {
            $ret = unserialize(implode('', file($cacheidfile)));
            return $ret;
        }

        return false;
    }

    function getCache($url)
    {
        $cachefile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
            md5($url) . 'rest.cachefile';
        if (file_exists($cachefile)) {
            return unserialize(implode('', file($cachefile)));
        }

        throw new PEAR2_Pyrus_REST_Exception(
                'No cached content available for "' . $url . '"');
    }

    /**
     * @param string full URL to REST resource
     * @param string original contents of the REST resource
     * @param array  HTTP Last-Modified and ETag headers
     * @param bool   if true, then the cache id file should be regenerated to
     *               trigger a new time-to-live value
     */
    function saveCache($url, $contents, $lastmodified, $nochange = false, $cacheid = null)
    {
        $cacheidfile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
            md5($url) . 'rest.cacheid';
        $cachefile = $this->config->cache_dir . DIRECTORY_SEPARATOR .
            md5($url) . 'rest.cachefile';
        if ($cacheid === null && $nochange) {
            $cacheid = unserialize(implode('', file($cacheidfile)));
        }

        $fp = @fopen($cacheidfile, 'wb');
        if (!$fp) {
            $cache_dir = $this->config->cache_dir;
            if (is_dir($cache_dir)) {
                return false;
            }

            if (!@mkdir($cache_dir, 0755, true)) {
                throw new PEAR2_Pyrus_REST_Exception(
                    'Cannot create REST cache directory ' . $cache_dir);
            }

            $fp = @fopen($cacheidfile, 'wb');
            if (!$fp) {
                return false;
            }
        }

        if ($nochange) {
            fwrite($fp, serialize(array(
                'age'        => time(),
                'lastChange' => $cacheid['lastChange'],
                )));
            fclose($fp);
            return true;
        } else {
            fwrite($fp, serialize(array(
                'age'        => time(),
                'lastChange' => $lastmodified,
                )));
        }
        fclose($fp);

        $fp = @fopen($cachefile, 'wb');
        if (!$fp) {
            if (file_exists($cacheidfile)) {
                @unlink($cacheidfile);
            }
            return false;
        }
        fwrite($fp, serialize($contents));
        fclose($fp);
        return true;
    }

    /**
     * Efficiently Download a file through HTTP.  Returns downloaded file as a string in-memory
     * This is best used for small files
     *
     * If an HTTP proxy has been configured (http_proxy PEAR_Config
     * setting), the proxy will be used.
     *
     * @param string  $url       the URL to download
     * @param string  $save_dir  directory to save file in
     * @param false|string|array $lastmodified header values to check against for caching
     *                           use false to return the header values from this download
     * @param false|array $accept Accept headers to send
     * @return string|array  Returns the contents of the downloaded file or a PEAR
     *                       error on failure.  If the error is caused by
     *                       socket-related errors, the error object will
     *                       have the fsockopen error code available through
     *                       getCode().  If caching is requested, then return the header
     *                       values.
     *
     * @access public
     */
    function downloadHttp($url, $lastmodified = null, $accept = false)
    {
        $info = parse_url($url);
        if (!isset($info['scheme']) || !in_array($info['scheme'], array('http', 'https'))) {
            throw new PEAR2_Pyrus_REST_Exception('Cannot download non-http URL "' . $url . '"');
        }
        if (!isset($info['host'])) {
            throw new PEAR2_Pyrus_REST_Exception('Cannot download from non-URL "' . $url . '"');
        }
        $class = static::$downloadClass;
        $request = new $class($url);
        $host = $info['host'];
        if (!array_key_exists('port', $info)) {
            $info['port'] = null;
        }
        if (!array_key_exists('path', $info)) {
            $info['path'] = null;
        }
        $port = $info['port'];
        $path = $info['path'];
        $proxy_host = $proxy_port = $proxy_user = $proxy_pass = '';
        if ($this->config->http_proxy &&
              $proxy = parse_url($this->config->http_proxy)) {
            $proxy_host = isset($proxy['host']) ? $proxy['host'] : null;
            if (isset($proxy['scheme']) && $proxy['scheme'] == 'https') {
                $proxy_host = 'ssl://' . $proxy_host;
            }
            $proxy_port = isset($proxy['port']) ? $proxy['port'] : 8080;
            $proxy_user = isset($proxy['user']) ? urldecode($proxy['user']) : null;
            $proxy_pass = isset($proxy['pass']) ? urldecode($proxy['pass']) : null;
            // TODO: implement this when HTTP_Request supports it
        }
        if (empty($port)) {
            if (isset($info['scheme']) && $info['scheme'] == 'https') {
                $port = 443;
            } else {
                $port = 80;
            }
        }

        if (is_array($lastmodified)) {
            if (isset($lastmodified['Last-Modified'])) {
                $request->setHeader('If-Modified-Since', $lastmodified['Last-Modified']);
            }
            if (isset($lastmodified['ETag'])) {
                $request->setHeader('If-None-Match', $lastmodified['ETag']);
            }
        } elseif ($lastmodified) {
            $request->setHeader('If-Modified-Since', $lastmodified);
        }
        $request->setHeader('User-Agent', 'PEAR2_Pyrus/@PACKAGE_VERSION@/PHP/' . PHP_VERSION);
        $username = $this->config->username;
        $password = $this->config->password;
        if ($username && $password) {
            $tmp = base64_encode("$username:$password");
            $request->setHeader('Authorization', 'Basic ' . $tmp);
        }
        if ($proxy_host != '' && $proxy_user != '') {
            $request->setHeader('Proxy-Authorization', 'Basic ' .
                base64_encode($proxy_user . ':' . $proxy_pass));
        }
        if ($accept) {
            $request->setHeader('Accept', implode(', ', $accept));
        } else {
            $request->setHeader('Accept', '');
        }
        $request->setHeader('Connection', 'close');
        $response = $request->sendRequest();
        if ($response->code == 304 && ($lastmodified || ($lastmodified === false))) {
            return false;
        }
        if ($response->code != 200) {
            throw new PEAR2_Pyrus_REST_HTTPException(
                "File http://$host:$port$path not valid (received: {$response->body})", $response->code);
        }
        if (isset($response->headers['content-length'])) {
            $length = $response->headers['content-length'];
        } else {
            $length = -1;
        }
        $data = $response->body;
        if ($lastmodified === false || $lastmodified) {
            if (isset($response->headers['etag'])) {
                $lastmodified = array('ETag' => $response->headers['etag']);
            }
            if (isset($response->headers['last-modified'])) {
                if (is_array($lastmodified)) {
                    $lastmodified['Last-Modified'] = $response->headers['last-modified'];
                } else {
                    $lastmodified = $response->headers['last-modified'];
                }
            }
            return array($data, $lastmodified, $response->headers);
        }
        return $data;
    }
}<?php
/**
 * PEAR2_Pyrus_ScriptRunner
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Post-install script runner for Pyrus
 *
 * This class handles the logic of navigating a post-install script's XML,
 * determining what questions to ask, and then passes the information to the
 * actual class.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_ScriptRunner
{
    protected $frontend;
    static protected $skipSections;

    function __construct($frontend)
    {
        $this->frontend = $frontend;
    }

    function run(PEAR2_Pyrus_IPackageFile $package)
    {
        foreach ($package->scriptfiles as $file) {
            $this->runPostinstallScripts($file, $package);
        }
    }

    /**
     * Instruct the runInstallScript method to skip a paramgroup that matches the
     * id value passed in.
     *
     * This method is useful for dynamically configuring which sections of a post-install script
     * will be run based on the user's setup, which is very useful for making flexible
     * post-install scripts without losing the cross-Frontend ability to retrieve user input
     * @param string
     */
    static function skipParamgroup($id)
    {
        self::$skipSections[$id] = true;
    }

    function runPostinstallScripts(PEAR2_Pyrus_PackageFile_v2_Files_File $scriptfile,
                                   PEAR2_Pyrus_IPackageFile $package)
    {
        foreach ($scriptfile->postinstallscript as $script) {
            $script->setupPostInstall();
            $this->runInstallScript($script);
        }
    }

    /**
     * @param PEAR2_Pyrus_Task_Postinstallscript $info contents of postinstallscript tag
     * @param object $script post-installation script
     * @param string install|upgrade
     */
    function runInstallScript(PEAR2_Pyrus_Task_Postinstallscript $info)
    {
        self::$skipSections = array();
        if (!count($info->paramgroup)) {
            $info->scriptobject->run(array(), '_default');
            return;
        }

        $completedPhases = array();

        try {
            foreach ($info->paramgroup as $group) {
                if (isset(self::$skipSections[$group->id])) {
                    // the post-install script chose to skip this section dynamically
                    continue;
                }
    
                if (isset($lastgroup)) {
                    if (!isset($answers)) {
                        $answers = null;
                    }
                    if (!$group->matchesConditionType($answers)) {
                        continue;
                    }
                }
    
                if (isset($group->instructions)) {
                    $this->frontend->display($group->instructions);
                }

                if (isset($answers)) {
                    $oldanswers = $answers;
                    $answers = array();
                } else {
                    $oldanswers = $answers = array();
                }
                if (isset($group->param)) {
                    if (method_exists($info->scriptobject, 'postProcessPrompts')) {
                        $prompts = $info->scriptobject->postProcessPrompts($group->param->getPrompts(), $group->id);
                        if (!is_array($prompts) || count($prompts) != count($group->param)) {
                            throw new PEAR2_Pyrus_Task_Exception('Error: post-install script did not ' .
                                'return proper post-processed prompts');
                        } else {
                            $testprompts = $group->param->getPrompts();
                            foreach ($prompts as $i => $prompt) {
                                if (!is_array($prompt) || !isset($prompt['prompt']) ||
                                      !isset($prompt['name']) ||
                                      ($prompt['name'] != $testprompts[$i]['name']) ||
                                      ($prompt['type'] != $testprompts[$i]['type'])
                                ) {
                                    throw new PEAR2_Pyrus_Task_Exception('Error: post-install script ' .
                                        'modified the variables or prompts, severe security risk');
                                }
                            }
                        }
    
                        $answers = $this->frontend->confirmDialog($prompts);
                    } else {
                        $answers = $this->frontend->confirmDialog($group->param->getPrompts());
                    }
                }
    
                if ((isset($answers) && $answers) || !isset($group->param)) {
                    if (!isset($answers)) {
                        $answers = array();
                    }
    
                    array_unshift($completedPhases, $group->id);
                    // script should throw an exception on failure
                    $info->scriptobject->run(array_merge($answers, $oldanswers), $group->id);
                } else {
                    $info->scriptobject->run($completedPhases, '_undoOnError');
                    return;
                }
                $answers = $this->mergeOldAnswers($oldanswers, $answers, $group->id);
            }
        } catch (\Exception $e) {
            $info->scriptobject->run($completedPhases, '_undoOnError');
            throw $e;
        }
    }

    function mergeOldAnswers($answers, $newanswers, $section)
    {
        foreach ($newanswers as $prompt => $answer) {
            $answers[$section . '::' . $prompt] = $answer;
        }
        if (!count($answers)) {
            $answers = null;
        }
        return $answers;
    }
}
<?php
require __DIR__ .  '/../../../sandbox/Loader/src/PEAR2/Loader/PEAR2Svn.php';
$dev_directory = dirname(dirname(__DIR__));
PEAR2_Pyrus_Config::singleton('/home/cellog/testpear');
$a = new PEAR2_Pyrus_Package_Creator(array(
        //new PEAR2_Pyrus_Developer_Creator_Xml($dev_directory . 'newpyrus.xml'),
        //new PEAR2_Pyrus_Developer_Creator_Tar($dev_directory . 'newpyrus.tar'),
        //new PEAR2_Pyrus_Developer_Creator_Zip($dev_directory . 'PEAR2_Pyrus-0.1.0.zip'),
        new PEAR2_Pyrus_Developer_Creator_Phar_PHPArchive($dev_directory . '/pyrus.phar', '<?php
function __autoload($class)
{
    include \'phar://\' . PYRUS_PHAR_FILE . \'/src/\' . implode(\'/\', explode(\'_\', $class)) . \'.php\';
}
$frontend = new PEAR2_Pyrus_ScriptFrontend_Commands;
@array_shift($_SERVER[\'argv\']);
$frontend->run($_SERVER[\'argv\']);
'),
    ));
$b = new PEAR2_Pyrus_Package(__DIR__ . '/../../package.xml');
$rp = __DIR__ . '/../../../HTTP_Request/src/HTTP';
$a->render($b, array(
    'src/PEAR2/HTTP/Request.php' => $rp . '/Request.php',
    'src/PEAR2/HTTP/Request/Adapter.php' => $rp . '/Request/Adapter.php',
    'src/PEAR2/HTTP/Request/Adapter/Phpsocket.php' => $rp . '/Request/Adapter/Phpsocket.php',
    'src/PEAR2/HTTP/Request/Adapter/Phpstream.php' => $rp . '/Request/Adapter/Phpstream.php',
    'src/PEAR2/HTTP/Request/Exception.php' => $rp . '/Request/Exception.php',
    'src/PEAR2/HTTP/Request/Headers.php' => $rp . '/Request/Headers.php',
    'src/PEAR2/HTTP/Request/Response.php' => $rp . '/Request/Response.php',
    'src/PEAR2/HTTP/Request/Uri.php' => $rp . '/Request/Uri.php',
    'src/Net/URL2.php' => '/usr/local/lib/php/Net/URL2.php',
));
exit;
// this shows how it works
function __autoload($class)
{
    if (substr($class, 0, 5) != 'PEAR2') return false;
    $path = explode('_', substr($class, 11)); // strip PEAR2_Pyrus for CVS
    $path = dirname(__FILE__) . implode('/', $path) . '.php';
    include $path;
}
include $a = '/home/cellog/workspace/PEAR2/Exception/trunk/src/Exception.php';
include $b = '/home/cellog/workspace/PEAR2/MultiErrors/trunk/src/MultiErrors.php';
include '/home/cellog/workspace/PEAR2/MultiErrors/trunk/src/MultiErrors/Exception.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/v2.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN/Filter.php';
//new PEAR2_Pyrus_Developer_PackageFile_PEAR2SVN(
//    '/home/cellog/workspace/PEAR2/Pyrus_Developer', 'PEAR2_Pyrus_Developer', 'pear2.php.net', false, false);
//exit;
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/Creator/Zip.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/Creator/Phar.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/Creator/Xml.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/Creator/Exception.php';
//$a = new PEAR2_Pyrus_Package_Creator(array(
//        new PEAR2_Pyrus_Developer_Creator_Phar('/home/cellog/workspace/Pyrus/blah.phar',
//            '<?php echo "hi";__HALT_COMPILER();'),
//        new PEAR2_Pyrus_Developer_Creator_Tar('/tmp/blah.tgz'),
//        new PEAR2_Pyrus_Developer_Creator_Xml('/tmp/blah.xml'),
//    ), $a, '/home/cellog/workspace/PEAR2/Autoload/trunk/src/Autoload.php', $b);
//$b = new PEAR2_Pyrus_Package('/home/cellog/workspace/pear-core/PEAR-1.6.2.tgz');
//$a->render($b);
//exit;
define('OS_WINDOWS', false);
define('OS_UNIX', true);
include '/home/cellog/workspace/PEAR2/HTTP_Request/trunk/src/HTTP/Request/allfiles.php';
$g = new PEAR2_Pyrus_Config('/home/cellog/testpear');
try {
    PEAR2_Pyrus_Installer::begin();
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Autoload/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Exception/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/MultiErrors/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Pyrus_Developer/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/Pyrus/package.xml'));
    PEAR2_Pyrus_Installer::commit();
} catch (Exception $e) {
    PEAR2_Pyrus_Installer::rollback();
    echo $e;
}
exit;
//$g = new PEAR2_Pyrus_Config('C:/development/pear-core/testpear');
$g = new PEAR2_Pyrus_Config('/home/cellog/testpear');
$g->saveConfig();
$g->bin_dir = 'home/cellog/testpear';
//$a = new PEAR2_Pyrus_Package('C:/development/pear-core/PEAR-1.5.0a1.tgz');
$a = new PEAR2_Pyrus_Package('/tmp/blah.tgz');
$b = new PEAR2_Pyrus_Installer;
$b->install($a);<?php
// this shows how it works
function __autoload($class)
{
    if (substr($class, 0, 5) != 'PEAR2') return false;
    $path = explode('_', substr($class, 11)); // strip PEAR2_Pyrus for CVS
    $path = dirname(__FILE__) . implode('/', $path) . '.php';
    include $path;
}
include $a = '/home/cellog/workspace/PEAR2/Exception/trunk/src/Exception.php';
include $b = '/home/cellog/workspace/PEAR2/MultiErrors/trunk/src/MultiErrors.php';
include '/home/cellog/workspace/PEAR2/MultiErrors/trunk/src/MultiErrors/Exception.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/v2.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN.php';
include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN/Filter.php';
//new PEAR2_Pyrus_Developer_PackageFile_PEAR2SVN(
//    '/home/cellog/workspace/PEAR2/Pyrus_Developer', 'PEAR2_Pyrus_Developer', 'pear2.php.net', false, false);
//exit;
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/Creator/Zip.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/Creator/Phar.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/Creator/Xml.php';
//include '/home/cellog/workspace/PEAR2/Pyrus_Developer/src/Developer/Creator/Exception.php';
//$a = new PEAR2_Pyrus_Package_Creator(array(
//        new PEAR2_Pyrus_Developer_Creator_Phar('/home/cellog/workspace/Pyrus/blah.phar',
//            '<?php echo "hi";__HALT_COMPILER();'),
//        new PEAR2_Pyrus_Developer_Creator_Tar('/tmp/blah.tgz'),
//        new PEAR2_Pyrus_Developer_Creator_Xml('/tmp/blah.xml'),
//    ), $a, '/home/cellog/workspace/PEAR2/Autoload/trunk/src/Autoload.php', $b);
//$b = new PEAR2_Pyrus_Package('/home/cellog/workspace/pear-core/PEAR-1.6.2.tgz');
//$a->render($b);
//exit;
define('OS_WINDOWS', false);
define('OS_UNIX', true);
include '/home/cellog/workspace/PEAR2/HTTP_Request/trunk/src/HTTP/Request/allfiles.php';
$g = new PEAR2_Pyrus_Config('/home/cellog/testpear');
try {
    PEAR2_Pyrus_Installer::begin();
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Autoload/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Exception/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/MultiErrors/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/PEAR2/Pyrus_Developer/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('/home/cellog/workspace/Pyrus/package.xml'));
//    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('pear.php.net/Console_Getopt'));
    PEAR2_Pyrus_Installer::commit();
} catch (Exception $e) {
    PEAR2_Pyrus_Installer::rollback();
    echo $e;
}
exit;
//$g = new PEAR2_Pyrus_Config('C:/development/pear-core/testpear');
$g = new PEAR2_Pyrus_Config('/home/cellog/testpear');
$g->saveConfig();
$g->bin_dir = 'home/cellog/testpear';
//$a = new PEAR2_Pyrus_Package('C:/development/pear-core/PEAR-1.5.0a1.tgz');
$a = new PEAR2_Pyrus_Package('/tmp/blah.tgz');
$b = new PEAR2_Pyrus_Installer;
$b->install($a);<?php
function __autoload($class)
{
    if (substr($class, 0, 4) != 'PEAR') return false;
    $path = explode('_', substr($class, 11)); // strip PEAR2_Pyrus for CVS
    $path = dirname(__FILE__) . implode('\\', $path) . '.php';
    include $path;
}
include $a = 'C:/development/PEAR2/Exception/trunk/src/Exception.php';
include $b = 'C:/development/PEAR2/MultiErrors/trunk/src/MultiErrors.php';
include 'C:/development/PEAR2/MultiErrors/trunk/src/MultiErrors/Exception.php';
//include 'C:/development/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN.php';
//include 'C:/development/PEAR2/Pyrus_Developer/src/Developer/PackageFile/PEAR2SVN/Filter.php';
//include 'C:/development/PEAR2/Pyrus_Developer/src/Developer/PackageFile/v2.php';
//new PEAR2_Pyrus_Developer_PackageFile_PEAR2SVN(
//    'C:/development/PEAR2/Autoload', 'PEAR2_Autoload', 'pear2.php.net',
//        false, false);
////    'C:/development/PEAR2/Pyrus', 'PEAR2_Pyrus', 'pear2.php.net');
//new PEAR2_Pyrus_Package('C:/development/PEAR2/Pyrus_Developer/package.xml');
//exit;
//include 'C:/development/PEAR2/HTTP/Request/src/HTTP/Request/allfiles.php';
//include 'C:/development/PEAR2/Pyrus_Developer/Creator/Zip.php';
//include 'C:/development/PEAR2/Pyrus_Developer/Creator/Tar.php';
//include 'C:/development/PEAR2/Pyrus_Developer/Creator/Xml.php';
//include 'C:/development/PEAR2/Pyrus_Developer/Creator/Exception.php';
//$a = new PEAR2_Pyrus_Package_Creator(array(
//        new PEAR2_Pyrus_Developer_Creator_Zip('C:/development/PEAR2/blah.zip'),
//        new PEAR2_Pyrus_Developer_Creator_Tar('C:/development/PEAR2/blah.tgz'),
//        new PEAR2_Pyrus_Developer_Creator_Xml('C:/development/PEAR2/blah.xml'),
//    ), $a, 'C:/development/PEAR2/Autoload/Autoload.php', $b);
//$b = new PEAR2_Pyrus_Package('C:/development/pear-core/PEAR-1.6.0.tgz');
//$a->render($b);
//exit;
//$pf = new PEAR2_Pyrus_PackageFile_v2;
//$pf->name = 'test';
//$pf->channel = 'pear.php.net';
//$pf->summary = 'test';
//$pf->description = 'testing';
//$pf->maintainer['cellog']->name('Greg Beaver')->role('lead')->email('cellog@php.net')
//    ->active('yes');
//$a = new DateTime();
//$pf->date = $a->format('Y-m-d');
//$pf->version['release'] = '1.0.0';
//$pf->version['api'] = '1.0.0';
//$pf->stability['release'] = 'stable';
//$pf->stability['api'] = 'stable';
//$pf->license = 'PHP License';
//$pf->notes = 'test';
//$pf->dependencies->required->php = array('min' => '5.2.0');
//$pf->dependencies->required->pearinstaller = array('min' => '5.2.0', 'exclude' => '1.2.3');
//$pf->files['test/me.php'] = array('attribs' => array('role' => 'php'));
//$pf = new PEAR2_Pyrus_package(dirname(__FILE__) . '/test.xml');
//foreach ($pf->packagingcontents as $name => $file) {
//    var_dump($name, $file);
//}
//exit;
define('OS_WINDOWS', true);
define('OS_UNIX', false);
$g = PEAR2_Pyrus_Config::singleton('C:/development/pear-core/testpear');
//$g = new PEAR2_Pyrus_Config('/home/cellog/testpear');
try {
    PEAR2_Pyrus_Installer::$options['force'] = true;
    PEAR2_Pyrus_Installer::begin();
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/Autoload/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/Exception/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/MultiErrors/trunk/package.xml'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/Pyrus_Developer/package.xml'));
//    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/Pyrus/trunk/pyrus.phar'));
    PEAR2_Pyrus_Installer::prepare(new PEAR2_Pyrus_Package('C:/development/PEAR2/Pyrus/trunk/package.xml'));
    PEAR2_Pyrus_Installer::commit();
} catch (Exception $e) {
    PEAR2_Pyrus_Installer::rollback();
    echo $e;
}
exit;
<?php
/**
 * PEAR2_Pyrus_Uninstaller
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Pyrus Uninstaller class
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Uninstaller
{
    /**
     * Flag that determines the behavior of {@link begin()}
     *
     * If true, begin() will do nothing.  If false, then
     * {@link self::$installPackages} will be reset to an empty array
     * @var bool
     */
    protected static $inTransaction = false;
    /**
     * Packages that will be uninstalled
     *
     * This list is used when {@link commit()} is called to determine
     * the packages to install
     * @var array
     */
    protected static $uninstallPackages = array();

    /**
     * Packages that were uninstalled
     *
     * This list is used when {@link rollback()} is called to determine
     * the packages that should be restored
     * @var array
     */
    protected static $uninstalledPackages = array();

    /**
     * Packages that have been installed and also successfully registered as uninstalled
     *
     * This list is used when {@link rollback()} is called to determine
     * the packages that should be removed from the registry
     * @var array
     */
    protected static $registeredPackages = array();


    /**
     * Installer options.  Valid indices are:
     *
     * - ignore_errors
     * @var array
     */
    public static $options = array();
    /**
     * Prepare uninstallation of packages
     */
    static function begin()
    {
        if (!self::$inTransaction) {
            self::$uninstallPackages = array();
            self::$uninstalledPackages = array();
            self::$inTransaction = true;
        }
    }

    /**
     * Add a package to the list of packages to be removed
     *
     * This function checks to see if an identical package is already being downloaded,
     * and manages removing duplicates or erroring out on a conflict
     * @param PEAR2_Pyrus_Package $package
     */
    static function prepare($packageName)
    {
        try {
            $package = PEAR2_Pyrus_Config::current()->registry->package[$packageName];
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Uninstaller_Exception('Invalid package name ' .
                                                        $packageName, $e);
        }
        if (isset(self::$uninstallPackages[$package->channel . '/' . $package->name])) {
            return;
        }
        self::$uninstallPackages[$package->channel . '/' . $package->name] = $package;
        return $package;
    }

    /**
     * Cancel installation
     */
    static function rollback()
    {
        if (self::$inTransaction) {
            self::$inTransaction = false;
            $reg = PEAR2_Pyrus_Config::current()->registry;
            $err = new PEAR2_MultiErrors;
            foreach (self::$registeredPackages as $package) {
                try {
                    $reg->uninstall($package[0]->name, $package[0]->channel);
                    if ($package[1]) {
                        $reg->install($package[1]);
                    }
                } catch (Exception $e) {
                    $err->E_ERROR[] = $e;
                }
            }
            self::$uninstallPackages = array();
            self::$uninstalledPackages = array();
            self::$registeredPackages = array();
            if (count($err)) {
                throw new PEAR2_Pyrus_Installer_Exception('Could not successfully rollback', $err);
            }
        }
    }

    /**
     * Install packages slated for installation during transaction
     */
    static function commit()
    {
        if (!self::$inTransaction) {
            return false;
        }
        try {
            $installer = new PEAR2_Pyrus_Uninstaller;
            // validate dependencies
            $errs = new PEAR2_MultiErrors;
            foreach (self::$uninstallPackages as $package) {
                $package->validateUninstallDependencies(self::$uninstallPackages, $errs);
            }
            if (count($errs->E_ERROR)) {
                throw new PEAR2_Pyrus_Installer_Exception('Dependency validation failed ' .
                    'for some installed packages, installation aborted', $errs);
            }
            // create dependency connections and load them into the directed graph
            $graph = new PEAR2_Pyrus_DirectedGraph;
            foreach (self::$uninstallPackages as $package) {
                $package->makeUninstallConnections($graph, self::$uninstallPackages);
            }
            // topologically sort packages and install them via iterating over the graph
            PEAR2_Pyrus_AtomicFileTransaction::begin();
            $actual = array();
            foreach ($graph as $package) {
                $actual[] = $package;
            }
            $reg = PEAR2_Pyrus_Config::current()->registry;
            // easy reverse topological sort
            array_reverse($actual);
            foreach ($actual as $package) {
                $installer->uninstall($package, $reg);
                self::$uninstalledPackages[] = $package;
            }
            $dirtrees = array();
            foreach (self::$uninstalledPackages as $package) {
                $dirtrees[] = $reg->info($package->name, $package->channel, 'dirtree');
                $previous = $reg->toPackageFile($package->name, $package->channel, true);
                self::$registeredPackages[] = array($package, $previous);
                $reg->uninstall($package->name, $package->channel);
            }
            PEAR2_Pyrus_AtomicFileTransaction::rmEmptyDirs($dirtrees);
            PEAR2_Pyrus_AtomicFileTransaction::commit();
            PEAR2_Pyrus_AtomicFileTransaction::removeBackups();
            self::$uninstallPackages = array();
            PEAR2_Pyrus_Config::current()->saveConfig();
        } catch (Exception $e) {
            self::rollback();
            throw $e;
        }
    }

    /**
     * Uninstall a package
     *
     * Remove files
     * @param PEAR2_Pyrus_Package $package
     */
    function uninstall(PEAR2_Pyrus_IPackageFile $package, PEAR2_Pyrus_IRegistry $reg)
    {
        if (!empty($this->_options['register-only'])) {
            // pretty much nothing happens if we are only registering the install
            return;
        }
        try {
            $config = new PEAR2_Pyrus_Config_Snapshot($package->date . ' ' . $package->time);
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Installer_Exception('Cannot retrieve files, config ' .
                                    'snapshot could not be processed', $e);
        }
        $configpaths = array();
        foreach (PEAR2_Pyrus_Installer_Role::getValidRoles($package->getPackageType()) as $role) {
            // set up a list of file role => configuration variable
            // for storing in the registry
            $roleobj =
                PEAR2_Pyrus_Installer_Role::factory($package->getPackageType(), $role);
            $configpaths[$role] = $config->{$roleobj->getLocationConfig()};
        }
        $ret = array();
        foreach ($reg->info($package->name, $package->channel, 'installedfiles') as $file) {
            $transact = PEAR2_Pyrus_AtomicFileTransaction::getTransactionObject($file['configpath']);
            $transact->removePath($file['relativepath']);
        }
    }
}
<?php
/**
 * PEAR2_Pyrus_Validate
 *
 * PHP version 5
 *
 * LICENSE: This source file is subject to version 3.0 of the PHP license
 * that is available through the world-wide-web at the following URI:
 * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
 * the PHP License and are unable to obtain it through the web, please
 * send a note to license@php.net so we can mail you a copy immediately.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Validation class for package.xml - channel-level advanced validation
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_Validate
{
/**#@+
 * Constants for install stage
 */
    const INSTALLING = 1;
    const UNINSTALLING = 2; // this is not bit-mapped like the others
    const NORMAL = 3;
    const DOWNLOADING = 4; // this is not bit-mapped like the others
    const PACKAGING = 7;
/**#@-*/
    var $packageregex = '[A-Za-z][a-zA-Z0-9_]+';
    /**
     * @var PEAR2_Pyrus_IPackageFile
     */
    var $_packagexml;
    /**
     * @var PEAR2_Pyrus_IChannelFile
     */
    var $channel;
    /**
     * @var int one of the PEAR2_Pyrus_Validate::* constants
     */
    var $_state = PEAR2_Pyrus_Validate::NORMAL;
    /**
     * @var PEAR2_MultiErrors
     */
    protected $failures;

    /**
     * Override this method to handle validation of normal package names
     * @param string
     * @return bool
     * @access protected
     */
    protected function _validPackageName($name)
    {
        return (bool) preg_match('/^' . $this->packageregex . '$/', $name);
    }

    /**
     * @param string package name to validate
     * @param string name of channel-specific validation package
     * @final
     */
    final function validPackageName($name, $validatepackagename = false)
    {
        if ($validatepackagename) {
            if (strtolower($name) == strtolower($validatepackagename)) {
                return (bool) preg_match('/^[a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)*$/', $name);
            }
        }
        return $this->_validPackageName($name);
    }

    /**
     * This validates a bundle name, and bundle names must conform
     * to the PEAR naming convention, so the method is final and static.
     * @param string
     * @final
     * @static
     */
    static final function validGroupName($name)
    {
        return (bool) preg_match('/^[A-Za-z][a-zA-Z0-9_]+$/', $name);
    }

    /**
     * Determine whether $state represents a valid stability level
     * @param string
     * @return bool
     * @static
     * @final
     */
    static final function validState($state)
    {
        return in_array($state, array('snapshot', 'devel', 'alpha', 'beta', 'stable'));
    }

    /**
     * Get a list of valid stability levels
     * @return array
     * @static
     * @final
     */
    static final function getValidStates()
    {
        return array('snapshot', 'devel', 'alpha', 'beta', 'stable');
    }

    /**
     * Determine whether a version is a properly formatted version number that can be used
     * by version_compare
     * @param string
     * @return bool
     * @static
     * @final
     */
    static final function validVersion($ver)
    {
        return (bool) preg_match('/^\d+(?:\.\d+)*(?:[a-zA-Z]+\d*)?$/', $ver);
    }

    /**
     * @param PEAR2_Pyrus_IPackageFile
     */
    function setPackageFile(PEAR2_Pyrus_IPackageFile $pf)
    {
        $this->_packagexml = $pf;
    }

    function setChannel(PEAR2_Pyrus_IChannelFile $chan)
    {
        $this->channel = $chan;
    }

    /**
     * @access private
     */
    protected function _addFailure($field, $reason)
    {
        $this->failures->E_ERROR[] =
            new PEAR2_Pyrus_Validate_Exception($reason, $field);
    }

    /**
     * @access private
     */
    protected function _addWarning($field, $reason)
    {
        $this->failures->E_WARNING[] =
            new PEAR2_Pyrus_Validate_Exception($reason, $field);
    }

    function getFailures()
    {
        return $this->failures;
    }

    /**
     * @param int one of the PEAR2_Pyrus_Validate::* constants
     */
    function validate($state = null)
    {
        if (!isset($this->_packagexml)) {
            return false;
        }
        if ($state !== null) {
            $this->_state = $state;
        }
        $this->failures = new PEAR2_MultiErrors;
        $this->validatePackageName();
        $this->validateVersion();
        $this->validateMaintainers();
        $this->validateDate();
        $this->validateSummary();
        $this->validateDescription();
        $this->validateLicense();
        $this->validateNotes();
        $this->validateTime();
        $this->validateStability();
        $this->validateDependencies();
        $this->validateMainFilelist();
        $this->validateReleaseFilelist();
        //$this->validateGlobalTasks();
        $this->validateChangelog();
        return !((bool) count($this->failures->E_ERROR));
    }

    /**
     * @access protected
     */
    function validatePackageName()
    {
        if ($this->_state == PEAR2_Pyrus_Validate::PACKAGING ||
              $this->_state == PEAR2_Pyrus_Validate::NORMAL) {
            if ($this->_packagexml->extends) {
                $version = $this->_packagexml->version['release'] . '';
                $name = $this->_packagexml->name;
                $test = array_shift($a = explode('.', $version));
                if ($test == '0') {
                    return true;
                }
                $vlen = strlen($test);
                $majver = substr($name, strlen($name) - $vlen);
                while ($majver && !is_numeric($majver{0})) {
                    $majver = substr($majver, 1);
                }
                if ($majver != $test) {
                    $this->_addWarning('package', "package $name extends package " .
                        $this->_packagexml->extends . ' and so the name should ' .
                        'have a postfix equal to the major version like "' .
                        $this->_packagexml->extends . $test . '"');
                    return true;
                } elseif (substr($name, 0, strlen($name) - $vlen) !=
                            $this->_packagexml->extends) {
                    $this->_addWarning('package', "package $name extends package " .
                        $this->_packagexml->extends . ' and so the name must ' .
                        'be an extension like "' . $this->_packagexml->extends .
                        $test . '"');
                    return true;
                }
            }
        }
        $vpackage = $this->channel->getValidationPackage();
        if ($this->validPackageName($this->_packagexml->name, $vpackage['_content'])) {
            return true;
        }
        $this->_addFailure('package', 'package name "' .
            $this->_packagexml->name . '" is invalid');
        return false;
    }

    /**
     * @access protected
     */
    function validateVersion()
    {
        if ($this->_packagexml->stability['release'] == 'snapshot') {
            // allow any version
            return true;
        }
        if ($this->_state != PEAR2_Pyrus_Validate::PACKAGING) {
            if (!$this->validVersion($this->_packagexml->version['release'])) {
                $this->_addFailure('version',
                    'Invalid version number "' . $this->_packagexml->version['release'] . '"');
                return false;
            }
        }
        $version = $this->_packagexml->version['release'];
        $versioncomponents = explode('.', $version);
        if (count($versioncomponents) != 3) {
            $this->_addWarning('version',
                'A version number should have 3 decimals (x.y.z)');
            return true;
        }
        $name = $this->_packagexml->name;
        // version must be based upon state
        switch ($this->_packagexml->stability['release']) {
            case 'devel' :
                if ($versioncomponents[0] . 'a' == '0a') {
                    return true;
                }
                if ($versioncomponents[0] == 0) {
                    $versioncomponents[0] = '0';
                    $this->_addWarning('version',
                        'version "' . $version . '" should be "' .
                        implode('.' ,$versioncomponents) . '"');
                } else {
                    $this->_addWarning('version',
                        'packages with devel stability must be < version 1.0.0');
                }
                return true;
            break;
            case 'alpha' :
            case 'beta' :
                // check for a package that extends a package,
                // like Foo and Foo2
                if ($this->_state == PEAR2_Pyrus_Validate::PACKAGING) {
                    if (substr($versioncomponents[2], 1, 2) == 'rc') {
                        $this->_addFailure('version', 'Release Candidate versions ' .
                            'must have capital RC, not lower-case rc');
                        return false;
                    }
                }
                if (!$this->_packagexml->extends) {
                    if ($versioncomponents[0] == '1') {
                        if ($versioncomponents[2]{0} == '0') {
                            if ($versioncomponents[2] == '0') {
                                // version 1.*.0000
                                $this->_addWarning('version',
                                    'version 1.' . $versioncomponents[1] .
                                        '.0 probably should not be alpha or beta');
                                return true;
                            } elseif (strlen($versioncomponents[2]) > 1 && !is_numeric($versioncomponents[2])) {
                                // version 1.*.0RC1 or 1.*.0beta24 etc.
                                return true;
                            } else {
                                // version 1.*.001 or something
                                $this->_addWarning('version',
                                    'version 1.' . $versioncomponents[1] .
                                        '.' . $versioncomponents[2] . ' probably should not be alpha or beta');
                                return true;
                            }
                        } else {
                            $this->_addWarning('version',
                                'bugfix versions (1.3.x where x > 0) probably should ' .
                                'not be alpha or beta');
                            return true;
                        }
                    } elseif ($versioncomponents[0] != '0') {
                        $this->_addWarning('version',
                            'major versions greater than 1 are not allowed for packages ' .
                            'without an <extends> tag or an identical postfix (foo2 v2.0.0)');
                        return true;
                    }
                    if ($versioncomponents[0] . 'a' == '0a') {
                        return true;
                    }
                    if ($versioncomponents[0] == 0) {
                        $versioncomponents[0] = '0';
                        $this->_addWarning('version',
                            'version "' . $version . '" should be "' .
                            implode('.' ,$versioncomponents) . '"');
                    }
                } else {
                    $vlen = strlen($versioncomponents[0] . '');
                    $majver = substr($name, strlen($name) - $vlen);
                    while ($majver && !is_numeric($majver{0})) {
                        $majver = substr($majver, 1);
                    }
                    if (($versioncomponents[0] != 0) && $majver != $versioncomponents[0]) {
                        $this->_addWarning('version', 'first version number "' .
                            $versioncomponents[0] . '" must match the postfix of ' .
                            'package name "' . $name . '" (' .
                            $majver . ')');
                        return true;
                    }
                    if ($versioncomponents[0] == $majver) {
                        if ($versioncomponents[2]{0} == '0') {
                            if ($versioncomponents[2] == '0') {
                                // version 2.*.0000
                                $this->_addWarning('version',
                                    "version $majver." . $versioncomponents[1] .
                                        '.0 probably should not be alpha or beta');
                                return false;
                            } elseif (strlen($versioncomponents[2]) > 1 && !is_numeric($versioncomponents[2])) {
                                // version 2.*.0RC1 or 1.*.0beta24 etc.
                                return true;
                            } else {
                                // version 2.*.001 or something
                                $this->_addWarning('version',
                                    'version ' . $version . ' probably should not be alpha or beta');
                                return true;
                            }
                        } else {
                            $this->_addWarning('version',
                                "bugfix versions ($majver.x.y where y > 0) should " .
                                'not be alpha or beta');
                            return true;
                        }
                    }
                    if ($versioncomponents[0] . 'a' == '0a') {
                        return true;
                    }
                    if ($versioncomponents[0] == 0) {
                        $versioncomponents[0] = '0';
                        $this->_addWarning('version',
                            'version "' . $version . '" should be "' .
                            implode('.' ,$versioncomponents) . '"');
                    }
                }
                return true;
            break;
            case 'stable' :
                if ($versioncomponents[0] == '0') {
                    $this->_addWarning('version', 'versions less than 1.0.0 cannot ' .
                    'be stable');
                    return true;
                }
                if (!is_numeric($versioncomponents[2])) {
                    if (preg_match('/\d+(rc|a|alpha|b|beta)\d*/i',
                          $versioncomponents[2])) {
                        $this->_addWarning('version', 'version "' . $version . '" or any ' .
                            'RC/beta/alpha version cannot be stable');
                        return true;
                    }
                }
                // check for a package that extends a package,
                // like Foo and Foo2
                if ($this->_packagexml->extends) {
                    $vlen = strlen($versioncomponents[0] . '');
                    $majver = substr($name, strlen($name) - $vlen);
                    while ($majver && !is_numeric($majver{0})) {
                        $majver = substr($majver, 1);
                    }
                    if (($versioncomponents[0] != 0) && $majver != $versioncomponents[0]) {
                        $this->_addWarning('version', 'first version number "' .
                            $versioncomponents[0] . '" must match the postfix of ' .
                            'package name "' . $name . '" (' .
                            $majver . ')');
                        return true;
                    }
                } elseif ($versioncomponents[0] > 1) {
                    $this->_addWarning('version', 'major version x in x.y.z may not be greater than ' .
                        '1 for any package that does not have an <extends> tag');
                }
                return true;
            break;
            default :
                return false;
            break;
        }
    }

    /**
     * @access protected
     */
    function validateMaintainers()
    {
        // maintainers can only be truly validated server-side for most channels
        // but allow this customization for those who wish it
        return true;
    }

    /**
     * @access protected
     */
    function validateDate()
    {
        if ($this->_state == PEAR2_Pyrus_Validate::NORMAL ||
              $this->_state == PEAR2_Pyrus_Validate::PACKAGING) {

            if (!preg_match('/(\d\d\d\d)\-(\d\d)\-(\d\d)/',
                  $this->_packagexml->date, $res) ||
                  count($res) < 4
                  || !checkdate($res[2], $res[3], $res[1])
                ) {
                $this->_addFailure('date', 'invalid release date "' .
                    $this->_packagexml->date . '"');
                return false;
            }


            if ($this->_state == PEAR2_Pyrus_Validate::PACKAGING &&
                  $this->_packagexml->date != date('Y-m-d')) {
                $this->_addWarning('date', 'Release Date "' .
                    $this->_packagexml->date . '" is not today');
            }
        }
        return true;
    }

    /**
     * @access protected
     */
    function validateTime()
    {
        if (!$this->_packagexml->time) {
            // default of no time value set
            return true;
        }
        // packager automatically sets time, so only validate if
        // pear validate is called
        if ($this->_state = PEAR2_Pyrus_Validate::NORMAL) {
            if (!preg_match('/\d\d:\d\d:\d\d/',
                  $this->_packagexml->time)) {
                $this->_addFailure('time', 'invalid release time "' .
                    $this->_packagexml->time . '"');
                return false;
            }
            if (strtotime($this->_packagexml->time) == -1) {
                $this->_addFailure('time', 'invalid release time "' .
                    $this->_packagexml->time . '"');
                return false;
            }
        }
        return true;
    }

    /**
     * @access protected
     */
    function validateStability()
    {
        $ret = true;
        $packagestability = $this->_packagexml->stability['release'];
        $apistability = $this->_packagexml->stability['api'];
        if (!self::validState($packagestability)) {
            $this->_addFailure('state', 'invalid release stability "' .
                $this->_packagexml->stability['release'] . '", must be one of: ' .
                implode(', ', self::getValidStates()));
            $ret = false;
        }
        $apistates = self::getValidStates();
        array_shift($apistates); // snapshot is not allowed
        if (!in_array($apistability, $apistates)) {
            $this->_addFailure('state', 'invalid API stability "' .
                $this->_packagexml->stability['api'] . '", must be one of: ' .
                implode(', ', $apistates));
            $ret = false;
        }
        return $ret;
    }

    /**
     * @access protected
     */
    function validateSummary()
    {
        return true;
    }

    /**
     * @access protected
     */
    function validateDescription()
    {
        return true;
    }

    /**
     * @access protected
     */
    function validateLicense()
    {
        return true;
    }

    /**
     * @access protected
     */
    function validateNotes()
    {
        return true;
    }

    /**
     * for package.xml 2.0 only - channels can't use package.xml 1.0
     * @access protected
     */
    function validateDependencies()
    {
        return true;
    }

    /**
     * for package.xml 2.0 only
     * @access protected
     */
    function validateMainFilelist()
    {
        return true; // placeholder for now
    }

    /**
     * for package.xml 2.0 only
     * @access protected
     */
    function validateReleaseFilelist()
    {
        return true; // placeholder for now
    }

    /**
     * @access protected
     */
    function validateChangelog()
    {
        return true;
    }
}
?>
<?php
/**
 * Process an XML file, convert it to an array
 *
 * PHP version 5
 *
 * @category   PEAR2
 * @package    PEAR2_Pyrus
 * @subpackage XML
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  2008 The PEAR Group
 * @license    http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version    SVN: $Id$
 * @link       http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Process an XML file, convert it to an array
 *
 * @category   PEAR2
 * @package    PEAR2_Pyrus
 * @subpackage XML
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  2008 The PEAR Group
 * @license    http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link       http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_XMLParser
{
    protected $reader;
    function __construct()
    {
        $this->reader = new XMLReader;
    }

    /**
     * Parse a string containing XML
     *
     * @param string $string The raw XML data
     * @param string $schema Path to the xml schema file for validation
     *
     * @return array
     */
    function parseString($string, $schema = false)
    {
        $this->reader->XML($string);
        return $this->_parse($string, $schema, false);
    }

    /**
     * Using XMLReader, unserialize XML into an array
     *
     * This unserializer has limitations on the XML it can parse, for simplicity:
     *
     *  - Only a single text node (the last one) will be processed, so this code:
     *    <pre>
     *     <?xml version="1.0" ?><test>hi<tag/>there</test>
     *    </pre>
     *    results in <code>array('test' => array('tag' => '', '_content' => 'there'))</code>
     *  - tag ordering is not preserved in all cases:
     *    <pre>
     *     <?xml version="1.0" ?><test><tag /><another /> <tag /></test>
     *    </pre>
     *    results in
     *    <code>array('test' => array('tag' => array('', ''), 'another' => ''))</code>
     *
     * @param string $file   file URI to process
     * @param string $schema path to the xml schema file for validation
     *
     * @return array
     */
    function parse($file, $schema = false)
    {
        if (!$this->reader->open($file)) {
            throw new PEAR2_Pyrus_XMLParser_Exception('Cannot open ' . $file .
                ' for parsing');
        }
        return $this->_parse($file, $schema, true);
    }

    /**
     * Merge tag into the array
     *
     * @param array  $arr     The array representation of the XML
     * @param string $tag     The tag name
     * @param array  $attribs Associative array of attributes for this tag
     * @param string $name    The tag name
     * @param int    $depth   The current depth within the XML document
     *
     * @return array
     */
    protected function mergeTag($arr, $tag, $attribs, $name, $depth)
    {
        if ($attribs) {
            // tag has attributes
            if (is_string($tag) && $tag !== '') {
                $tag = array('attribs' => $attribs, '_content' => $tag);
            } else {
                if (!is_array($tag)) {
                    $tag = array();
                }
                $tag['attribs'] = $attribs;
            }
        }
        if (is_array($arr) && isset($arr[$name]) && is_array($arr[$name]) &&
              isset($arr[$name][0])) {
            // tag exists as a sibling
            $where = count($arr[$name]);
            if (!isset($arr[$name][$where])) {
                $arr[$name][$where] = $tag;
                return $arr;
            }
            if (!is_array($arr[$name][$where])) {
                if (strlen($arr[$name][$where])) {
                    $arr[$name][$where] = array('_content' => $arr[$name][$where]);
                } else {
                    $arr[$name][$where] = array();
                }
            }
            $arr[$name][$where] = $tag;
        } else {
            if (!is_array($arr)) {
                $arr = array();
            }
            if (isset($arr[$name])) {
                // new sibling
                $arr[$name] = array($arr[$name], $tag);
                return $arr;
            }
            $arr[$name] = $tag;
        }
        return $arr;
    }

    protected function mergeValue($arr, $value)
    {
        if (is_array($arr) && isset($arr[0])) {
            // multiple siblings
            $arr[count($arr) - 1] = $this->mergeActualValue(
                $arr[count($arr) - 1], $value);
        } elseif (is_array($arr)) {
            $arr = $this->mergeActualValue($arr, $value);
        } else {
            $arr = $value;
        }
        return $arr;
    }

    protected function mergeActualValue($me, $value)
    {
        if (count($me)) {
            $me['_content'] = $value;
        } else {
            $me = $value;
        }
        return $me;
    }

    private function _parse($file, $schema, $isfile)
    {
        libxml_use_internal_errors(true);
        libxml_clear_errors();
        $arr = $this->_recursiveParse();
        $this->reader->close();
        $causes = array();
        foreach (libxml_get_errors() as $error) {
            $causes[] = new PEAR2_Pyrus_XMLParser_Exception("Line " .
                 $error->line . ': ' . $error->message);
        }
        if (count($causes)) {
            throw new PEAR2_Pyrus_XMLParser_Exception('Invalid XML document', $causes);
        }
        if ($schema) {
            $a = new DOMDocument();
            if ($isfile) {
                $a->load($file);
            } else {
                $a->loadXML($file);
            }
            /*
             from Rob Richards talk, use
             $a->setSchema($schema);
             and then check $a->isValid() in the _recursiveParse() and
             log errors - much more efficient
            */
            libxml_use_internal_errors(true);
            libxml_clear_errors();
            $a->schemaValidate($schema);
            $causes = array();
            foreach (libxml_get_errors() as $error) {
                $causes[] = new PEAR2_Pyrus_XMLParser_Exception("Line " .
                     $error->line . ': ' . $error->message);
            }
            libxml_clear_errors();
            if (count($causes)) {
                throw new PEAR2_Pyrus_XMLParser_Exception('Invalid XML document', $causes);
            }
        }

        return $arr;
    }

    private function _recursiveParse($arr = array())
    {
        while (@$this->reader->read()) {
            $depth = $this->reader->depth;
            if ($this->reader->nodeType == XMLReader::ELEMENT) {
                $tag = $this->reader->name;

                $attribs = array();
                if ($this->reader->isEmptyElement) {
                    if ($this->reader->hasAttributes) {
                        $attr = $this->reader->moveToFirstAttribute();
                        while ($attr) {
                            $attribs[$this->reader->name] = $this->reader->value;
                            $attr = $this->reader->moveToNextAttribute();
                        }
                        $depth = $this->reader->depth;
                        $arr = $this->mergeTag($arr, '', $attribs, $tag, $depth);
                        continue;
                    }
                    $depth = $this->reader->depth;
                    $arr = $this->mergeTag($arr, '', array(), $tag, $depth);
                    continue;
                }
                if ($this->reader->hasAttributes) {
                    $attr = $this->reader->moveToFirstAttribute();
                    while ($attr) {
                        $attribs[$this->reader->name] = $this->reader->value;
                        $attr = $this->reader->moveToNextAttribute();
                    }
                }
                $depth = $this->reader->depth;
                $arr = $this->mergeTag($arr, '', $attribs, $tag, $depth);
                if (is_array($arr[$tag]) && isset($arr[$tag][0])) {
                    // seek to last sibling
                    $arr[$tag][count($arr[$tag]) - 1] =
                        $this->_recursiveParse($arr[$tag][count($arr[$tag]) - 1]);
                } else {
                    $arr[$tag] = $this->_recursiveParse($arr[$tag]);
                }
                continue;
            }
            if ($this->reader->nodeType == XMLReader::END_ELEMENT) {
                return $arr;
            }
            if ($this->reader->nodeType == XMLReader::TEXT ||
                  $this->reader->nodeType == XMLReader::CDATA) {
                $arr = $this->mergeValue($arr, $this->reader->value);
            }
        }
        return $arr;
    }
}
<?php
/**
 * PEAR2_Pyrus_XMLWriter
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Process an array, and serialize it into XML
 *
 * @category   PEAR2
 * @package    PEAR2_Pyrus
 * @subpackage XML
 * @author     Greg Beaver <cellog@php.net>
 * @copyright  2008 The PEAR Group
 * @license    http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link       http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus_XMLWriter
{
    private $_array;
    private $_state;
    /**
     * @var XMLWriter
     */
    private $_writer;
    private $_iter;
    private $_tagStack;
    private $_namespaces;
    private $_tag;
    private $_expectedDepth;
    private $_type;
    private $_lastkey;
    
    /**
     * Construct a new xml writer object.
     * <code>
     * $xmlarray = array('channel'=>array('name'=>'pear2.php.net'));
     * $channel = new PEAR2_Pyrus_XMLWriter($xmlarray);
     * </code>
     * 
     * @param array $array Array representing the XML data.
     */
    function __construct(array $array)
    {
        if (count($array) != 1) {
            throw new PEAR2_Pyrus_XMLWriter_Exception('Cannot serialize array to' .
                'XML, array must have exactly 1 element');
        }
        $this->_array  = $array;
        $this->_writer = new XMLWriter;
    }

    /**
     * Return the raw xml string representation.
     * 
     * @return string
     */
    function __toString()
    {
        $this->_writer->openMemory();
        return $this->_serialize();
    }

    function toFile($file)
    {
        $this->_writer->openUri($file);
        return $this->_serialize();
    }

    private function _pushState()
    {
        $this->_state[] = array($this->_type, $this->_tag, $this->_expectedDepth,
            $this->_namespaces);
    }

    private function _popState()
    {
        $save = $this->_namespaces;
        
        list($this->_type, $this->_tag, $this->_expectedDepth, $this->_namespaces) =
            array_pop($this->_state);
        foreach ($save as $ns) {
            if (!isset($this->_namespaces[$ns])) {
                // all namespaces must exist - only overriding is allowed
                $this->_namespaces = $save;
                return;
            }
        }
    }

    private function _finish($key, $values)
    {
        switch ($this->_type) {
        case 'Attribs' :
                $this->_popState();
                return false;
        case 'Tag' :
                $this->_popState();
                $this->_writer->endElement();
                return false;
        case 'Sibling' :
                $this->_popState();
                return false;
        }
    }

    private function _startElement($key, $values)
    {
        // new element
        if (strpos($key, ':')) {
            // namespaced element
            list($ns, $element) = explode(':', $key);
        }
        if (isset($element) && !isset($this->_namespaces[$ns])) {
            if (is_string($values)) {
                if (strlen($values)) {
                    $this->_writer->writeElementNs($ns, $element, $this->_namespaces[$ns], $values);
                } else {
                    $this->_writer->writeElementNs($ns, $element, $this->_namespaces[$ns]);
                }
            } else {
                $this->_writer->startElementNs($ns, $element, $this->_namespaces[$ns]);
            }
        } else {
            if (is_string($values) || is_int($values)) {
                if (strlen($values)) {
                    $this->_writer->writeElement($key, $values);
                } else {
                    $this->_writer->writeElement($key);
                }
            } else {
                $this->_writer->startElement($key);
            }
        }
    }

    /**
     * Handle an individual tag/element in the XML
     * 
     * @param mixed $key    The key for this element.
     * @param mixed $values The contents of this tag/element.
     */
    private function _handleTag($key, $values)
    {
        if (is_int($key)) {
            $this->_type          = 'Sibling';
            $this->_expectedDepth = $this->_iter->getDepth();
            $this->_pushState();
            // handle sibling tags
            return '_handleSibling';
        }
        $this->_startElement($key, $values);
        if (!is_string($values)) {
            $this->_expectedDepth = $this->_iter->getDepth();
            $this->_pushState();
            $this->_tag = $key;
        }
        // cycle to next key
        return false;
    }

    private function _handleSibling($key, $values)
    {
        if (is_int($key) && $this->_iter->getDepth() == $this->_expectedDepth) {
            if ($key) {
                $this->_startElement($this->_tag, $values);
                if (!is_string($values)) {
                    $this->_pushState();
                }
            } else {
                if (is_string($values)) {
                    $this->_writer->text($values);
                    $this->_writer->endElement();
                }
            }
        }
        if (!is_string($values)) {
            $this->_type          = 'Tag';
            $this->_expectedDepth = $this->_iter->getDepth() + 1;
            // handle internal tags
        }
        // cycle to next key
        return false;
    }

    private function _handleAttribs($key, $values)
    {
        // xmlwriter converts these to &#10; and &#13;.  Bad.
        $values = str_replace(array("\n","\r"), array('', ''), $values);
        if (strpos($key, ':')) {
            // namespaced
            list($ns, $attr) = explode(':', $key);
            if ($ns == 'xmlns' || isset($this->_namespaces[$ns])) {
                if ($ns == 'xmlns') {
                    // new namespace declaration
                    $this->_namespaces[$attr] = $values;
                }
                $this->_writer->writeAttribute($key, $values);
            } else {
                $this->_writer->writeAttributeNS($ns, $attr, $values, $values);
            }
        } else { // default namespace
            $this->_writer->writeAttribute($key, $values);
        }
        // cycle to next key
        return false;
    }

    /**
     * @access private
     * 
     * @return bool
     */
    public static function _filter($a)
    {
        if ($a === false) {
            return false;
        }
        return true;
    }

    /**
     * Utilize custom serialization for XMLWriter object, to convert object
     * to SQL.
     * 
     * @return string
     */
    private function _serialize()
    {
        $this->_writer->setIndent(true);
        $this->_writer->setIndentString(' ');
        $this->_writer->startDocument('1.0', 'UTF-8');
        $this->_namespaces    = array();
        $this->_tagStack      = array();
        $this->_state         = array();
        $this->_type          = 'Tag';
        $this->_expectedDepth = 0;
        $this->_lastkey       = array();
        $lastdepth            = 0;
        foreach ($this->_iter = new RecursiveIteratorIterator(
                        new RecursiveArrayIterator($this->_array),
                        RecursiveIteratorIterator::SELF_FIRST) as $key => $values) {
            $depth = $this->_iter->getDepth();
            while ($depth < $this->_expectedDepth) {
                // finished with this tag
                $this->_finish($key, $values);
                $lastdepth--;
            }
            if (isset($this->_lastkey[$depth]) && $key != $this->_lastkey[$depth]) {
                while ($lastdepth > $depth) {
                    $this->_finish($key, $values);
                    $lastdepth--;
                }
            }
            $this->_lastkey[$depth] = $key;
            foreach ($this->_lastkey as $d => &$k) {
                if ($d > $depth) {
                    $k = false;
                }
            }
            $this->_lastkey = array_filter($this->_lastkey,
                array('PEAR2_Pyrus_XMLWriter', '_filter'));
            $lastdepth = $depth;
            if ($this->_type !== 'Attribs') {
                if ($key === '_content') {
                    $this->_writer->text($values);
                    continue;
                }
                if ($key === 'attribs') {
                    // attributes are 1 depth higher
                    $this->_pushState();
                    $this->_expectedDepth = $this->_iter->getDepth() + 1;
                    $this->_type          = 'Attribs';
                    // cycle to first attribute
                    continue;
                }
            }
            $next = '_handle' . $this->_type;
            while ($next = $this->{$next}($key, $values));
        }
        while ($lastdepth) {
            $this->_finish($key, $values);
            $lastdepth--;
        }
        $this->_writer->endDocument();
        return $this->_writer->flush();
    }
}<?php
/**
 * PEAR2_Pyrus
 *
 * PHP version 5
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */

/**
 * Base class for Pyrus.
 *
 * @category  PEAR2
 * @package   PEAR2_Pyrus
 * @author    Greg Beaver <cellog@php.net>
 * @copyright 2008 The PEAR Group
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://svn.pear.php.net/wsvn/PEARSVN/Pyrus/
 */
class PEAR2_Pyrus
{
    static function getDataPath()
    {
        static $val = false;
        if ($val) return $val;
        $val = dirname(dirname(dirname(__FILE__))) . '/data/pear2.php.net/PEAR2_Pyrus';
        return $val;
    }
}
?>
<?php
if (!class_exists('Phar')) {
    if (!class_exists('PHP_Archive')) {
@PHPARCHIVE@
    }
    if (!in_array('phar', stream_get_wrappers(), true)) {
        stream_wrapper_register('phar', 'PHP_Archive');
    }
}
define('PYRUS_PHAR_FILE', __FILE__);
include 'phar://' . __FILE__ . '/__index.php';
__HALT_COMPILER();<?php
if (!class_exists('Phar')) {
    if (!class_exists('PHP_Archive')) {
@PHPARCHIVE@
    }
    if (!in_array('phar', stream_get_wrappers(), true)) {
        stream_wrapper_register('phar', 'PHP_Archive');
    }
}
define('PYRUS_PHAR_FILE', __FILE__);
include 'phar://' . __FILE__ . '/__index.php';
__HALT_COMPILER();<?php
/**
 * Create a phar with PHP_Archive embedded
 */
class PEAR2_Pyrus_Developer_Creator_Phar_PHPArchive extends PEAR2_Pyrus_Developer_Creator_Phar
{
    /**
     * @var Phar
     */
    protected $phar;
    protected $path;
    protected $stub;
    protected $startup;
    function __construct($path, $startupfile = false, $fileformat = Phar::PHAR, $compression = Phar::NONE,
                         array $others = null)
    {
        parent::__construct($path, false, $fileformat, $compression, $others);
        $phparchive = @file_get_contents('PHP/Archive.php', true);
        if (!$phparchive) {
            throw new PEAR2_Pyrus_Developer_Creator_Exception('Could not locate' .
                ' PHP_Archive class for phar creation');
        }
        $phparchive = '?>' . $phparchive . '<?php';
        $template = @file_get_contents(dirname(__FILE__) . '/../../../../../../data/pear2.php.net/PEAR2_Pyrus_Developer/phartemplate.php');
        if (!$template) {
            $template = file_get_contents(__DIR__ . '/../../../../../data/phartemplate.php');
        }
        $this->stub = str_replace('@PHPARCHIVE@', $phparchive, $template);
        if ($startupfile === false) {
            $startupfile = '<?php
$extract = getcwd();
$loc = dirname(__FILE__);
foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator(dirname(__FILE__))) as $path => $file) {
    if ($file->getFileName() === \'__index.php\') {
        continue;
    }
    $newpath = str_replace(\'/\', DIRECTORY_SEPARATOR, $extract . str_replace($loc, \'\', $path));
    if (!file_exists(dirname($newpath))) {
        mkdir(dirname($newpath), 0755, true);
    }
    file_put_contents($newpath, file_get_contents($path));
}
echo "Extracted files available in current directory\n";';
        }
        $this->startup = $startupfile;
    }

    /**
     * Initialize the package creator
     */
    function init()
    {
        parent::init();
        $this->phar['__index.php'] = $this->startup;
    }
}
<?php
class PEAR2_Pyrus_Developer_Creator_Exception extends PEAR2_Exception {}<?php
class PEAR2_Pyrus_Developer_Creator_Phar implements PEAR2_Pyrus_Package_ICreator
{
    /**
     * @var Phar
     */
    protected $phar;
    protected $others;
    protected $path;
    protected $stub;
    protected $format;
    protected $compression;
    private $_classname = 'Phar';
    private $_started = false;

    /**
     * Archive creator for phar, tar, tgz and zip archives.
     *
     * @param string path to primary archive
     * @param string|false stub or false to use default stub of phar archives
     * @param int one of Phar::TAR, Phar::PHAR, or Phar::ZIP
     * @param int if the archive can be compressed (phar and tar), one of Phar::GZ, Phar::BZ2 or Phar::NONE
     *            for no compression
     * @param array an array of arrays containing information on additional archives to create.  The indices are:
     *
     *               0. extension (tar/tgz/zip)
     *               1. format (Phar::TAR, Phar::ZIP, Phar::PHAR)
     *               2. compression (Phar::GZ, Phar::BZ2, Phar::NONE)
     */
    function __construct($path, $stub = false, $fileformat = Phar::TAR, $compression = Phar::GZ, array $others = null)
    {
        if (!class_exists('Phar')) {
            throw new PEAR2_Pyrus_Developer_Creator_Exception(
                'Phar extension is not available');
        }
        if (!Phar::canWrite() || !Phar::isValidPharFilename($path, true)) {
            $this->_classname = 'PharData';
        }
        $this->path = $path;
        $this->compression = $compression;
        $this->format = $fileformat;
        $this->others = $others;
        $this->stub = $stub;
    }

    /**
     * save a file inside this package
     * @param string relative path within the package
     * @param string|resource file contents or open file handle
     */
    function addFile($path, $fileOrStream)
    {
        if (!$this->_started) {
            // save package.xml name
            $this->phar->setMetadata($path);
            $this->_started = true;
        }
        $this->phar[$path] = $fileOrStream;
    }

    function addDir($path)
    {
        $this->phar->buildFromDirectory($path);
    }

    /**
     * Initialize the package creator
     */
    function init()
    {
        try {
            if (file_exists($this->path)) {
                @unlink($this->path);
            }
            $ext = strstr(strrchr($this->path, '-'), '.');
            if (!$ext) {
                $ext = strstr(strrchr($this->path, '/'), '.');
                if (!$ext) {
                    $ext = strstr(strrchr($this->path, '\\'), '.');
                }
            }
            if (!$ext) {
                $ext = strstr($this->path, '.');
            }
            $a = $this->_classname;
            $this->phar = new $a($this->path);
            if ($this->phar instanceof Phar) {
                $this->phar = $this->phar->convertToExecutable($this->format,
                                                               $this->compression, $ext);
            } else {
                $this->phar = $this->phar->convertToData($this->format,
                                                         $this->compression, $ext);
            }
            $this->phar->startBuffering();
            if ($this->phar instanceof Phar) {
                $this->phar->setStub($this->stub);
            }
            if ($this->format == Phar::ZIP) {
                $this->compression = $comp;
            }
        } catch (Exception $e) {
            throw new PEAR2_Pyrus_Developer_Creator_Exception(
                'Cannot open Phar archive ' . $this->path, $e
            );
        }
        $this->_started = false;
    }

    /**
     * Create an internal directory, creating parent directories as needed
     *
     * @param string $dir
     */
    function mkdir($dir)
    {
        $this->phar->addEmptyDir($dir);
    }

    /**
     * Finish saving the package
     */
    function close()
    {
        if ($this->phar->isFileFormat(Phar::ZIP) && $this->compression !== Phar::NONE) {
            $this->phar->compressFiles($this->compression);
        }
        $this->phar->stopBuffering();
        $newphar = $this->phar;
        $ext = str_replace(array('.tar', '.zip', '.tgz', '.phar'), array('', '', '', ''), basename($this->path)) . '.';
        $ext = substr($ext, strpos($ext, '.'));
        if (count($this->others)) {
            foreach ($this->others as $pathinfo) {
                // remove the old file
                $newpath = str_replace(array('.tar', '.zip', '.tgz', '.phar'), array('', '', '', ''), $this->path);
                $newpath .= '.' .$pathinfo[0];
                if (file_exists($newpath)) {
                    unlink($newpath);
                }
                $extension = $ext . $pathinfo[0];
                $fileformat = $pathinfo[1];
                $compression = $pathinfo[2];

                if ($fileformat != Phar::PHAR) {
                    $newphar = $newphar->convertToData($fileformat, $compression, $extension);
                } else {
                    $newphar = $newphar->convertToExecutable($fileformat, $compression, $extension);
                }
            }
        }
    }
}
<?php
class PEAR2_Pyrus_Developer_Creator_Tar implements PEAR2_Pyrus_Package_ICreator
{
    /**
     * Path to archive file
     *
     * @var string
     */
    protected $archive;
    /**
     * Temporary stream used for creating the archive
     *
     * @var stream
     */
    protected $tmp;
    protected $path;
    protected $compress;
    function __construct($path, $compress = 'zlib')
    {
        $this->compress = $compress;
        if ($compress === 'bz2' && !function_exists('bzopen')) {
            throw new PEAR2_Pyrus_Developer_Creator_Exception(
                'bzip2 extension not available');
        }
        if ($compress === 'zlib' && !function_exists('gzopen')) {
            throw new PEAR2_Pyrus_Developer_Creator_Exception(
                'zlib extension not available');
        }
        $this->path = $path;
    }

    /**
     * save a file inside this package
     * 
     * This code is modified from Vincent Lascaux's File_Archive
     * package, which is licensed under the LGPL license.
     * @param string relative path within the package
     * @param string|resource file contents or open file handle
     */
    function addFile($path, $fileOrStream)
    {
        clearstatcache();
        if (is_resource($fileOrStream)) {
            $stat = fstat($fileOrStream);
        } else {
            $stat = array(
                'mode' => 0x8000 + 0644,
                'uid' => 0,
                'gid' => 0,
                'size' => strlen($fileOrStream),
                'mtime' => time(),
            );
        }

        $link = null;
        if ($stat['mode'] & 0x4000) {
            $type = 5;        // Directory
        } else if ($stat['mode'] & 0x8000) {
            $type = 0;        // Regular
        } else if ($stat['mode'] & 0xA000) {
            $type = 1;        // Link
            $link = @readlink($current);
        } else {
            $type = 9;        // Unknown
        }

        $filePrefix = '';
        if (strlen($path) > 255) {
            throw new PEAR2_Pyrus_Developer_Creator_Exception(
                "$path is too long, must be 255 characters or less"
            );
        } else if (strlen($path) > 100) {
            $filePrefix = substr($path, 0, strlen($path)-100);
            $path = substr($path, -100);
        }

        $block = pack('a100a8a8a8a12A12',
                $path,
                decoct($stat['mode']),
                sprintf('%6s ',decoct($stat['uid'])),
                sprintf('%6s ',decoct($stat['gid'])),
                sprintf('%11s ',decoct($stat['size'])),
                sprintf('%11s ',decoct($stat['mtime']))
            );

        $blockend = pack('a1a100a6a2a32a32a8a8a155a12',
            $type,
            $link,
            'ustar',
            '00',
            'Pyrus',
            'Pyrus',
            '',
            '',
            $filePrefix,
            '');

        $checkheader = array_merge(str_split($block), str_split($blockend));
        if (!function_exists('_pear2tarchecksum')) {
            function _pear2tarchecksum($a, $b) {return $a + ord($b);}
        }
        $checksum = 256; // 8 * ord(' ');
        $checksum += array_reduce($checkheader, '_pear2tarchecksum');

        $checksum = pack('a8', sprintf('%6s ', decoct($checksum)));

        fwrite($this->tmp, $block . $checksum . $blockend, 512);
        if (is_resource($fileOrStream)) {
            stream_copy_to_stream($fileOrStream, $this->tmp);
            if ($stat['size'] % 512) {
                fwrite($this->tmp, str_repeat("\0", 512 - $stat['size'] % 512));
            }
        } else {
            fwrite($this->tmp, $fileOrStream);
            if (strlen($fileOrStream) % 512) {
                fwrite($this->tmp, str_repeat("\0", 512 - strlen($fileOrStream) % 512));
            }
        }
    }

    function addDir($path)
    {
        foreach (new RecursiveIteratorIterator(
                    new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS)) as $file) {
            $contents = file_get_contents((string)$file);
            $relpath = str_replace($path . DIRECTORY_SEPARATOR, '', $file);
            $this->addFile($relpath, $contents);
        }
    }

    /**
     * Initialize the package creator
     */
    function init()
    {
        switch ($this->compress) {
            case 'zlib' :
                $this->tmp = gzopen($this->path, 'wb');
                break;
            case 'bz2' :
                $this->tmp = bzopen($this->path, 'wb');
                break;
            case 'none' :
                $this->tmp = fopen($this->path, 'wb');
                break;
            default :
                throw new PEAR2_Pyrus_Developer_Creator_Exception(
                    'unknown compression type ' . $this->compress);
        }
    }

    /**
     * Create an internal directory, creating parent directories as needed
     * 
     * This is a no-op for the tar creator
     * @param string $dir
     */
    function mkdir($dir)
    {
    }

    /**
     * Finish saving the package
     */
    function close()
    {
        fwrite($this->tmp, pack('a1024', ''));
        fclose($this->tmp);
    }
}<?php
/**
 * For debugging purposes, see what the package.xml that would be put into the package
 * will be.
 *
 */
class PEAR2_Pyrus_Developer_Creator_Xml implements PEAR2_Pyrus_Package_ICreator
{
    private $_done;
    private $_path;

    function __construct($path)
    {
        if (!($this->_path = @fopen($path, 'w'))) {
            throw new PEAR2_Pyrus_Developer_Creator_Exception('Cannot open path ' .
                $path . ' for writing');
        }
    }

    /**
     * save a file inside this package
     * 
     * This only saves package.xml, which is always the first file sent by the creator.
     * @param string relative path within the package
     * @param string|resource file contents or open file handle
     */
    function addFile($path, $fileOrStream)
    {
        if (!$this->_done) {
            $this->_done = true;
            if (is_resource($fileOrStream)) {
                stream_copy_to_stream($fileOrStream, $this->_path);
            } else {
                fwrite($this->_path, $fileOrStream);
            }
        }
    }

    function addDir($path)
    {
        foreach (new RecursiveIteratorIterator(
                    new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS)) as $file) {
            $file = (string) $file;
            $relpath = str_replace($path . DIRECTORY_SEPARATOR, '', $file);
            $this->addFile($relpath, $file);
        }
    }

    /**
     * Initialize the package creator
     */
    function init()
    {
        $this->_done = false;
    }

    /**
     * Create an internal directory, creating parent directories as needed
     * 
     * This is a no-op for the tar creator
     * @param string $dir
     */
    function mkdir($dir)
    {
    }

    /**
     * Finish saving the package
     */
    function close()
    {
        fclose($this->_path);
    }
}<?php
class PEAR2_Pyrus_Developer_Creator_Zip implements PEAR2_Pyrus_Package_ICreator
{
    /**
     * Path to archive file
     *
     * @var string
     */
    protected $archive;
    /**
     * @var ZIPArchive
     */
    protected $zip;
    protected $path;
    function __construct($path)
    {
        if (!class_exists('ZIPArchive')) {
            throw new PEAR2_Pyrus_Developer_Creator_Exception(
                'Zip extension is not available');
        }
        $this->path = $path;
    }

    /**
     * save a file inside this package
     * @param string relative path within the package
     * @param string|resource file contents or open file handle
     */
    function addFile($path, $fileOrStream)
    {
        if (is_resource($fileOrStream)) {
            $this->zip->addFromString($path, stream_get_contents($fileOrStream));
        } else {
            $this->zip->addFromString($path, $fileOrStream);
        }
    }

    function addDir($path)
    {
        foreach (new RecursiveIteratorIterator(
                    new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS)) as $file) {
            $contents = file_get_contents((string)$file);
            $relpath = str_replace($path . DIRECTORY_SEPARATOR, '', $file);
            $this->addFile($relpath, $contents);
        }
    }

    /**
     * Initialize the package creator
     */
    function init()
    {
        $this->zip = new ZipArchive;
        if (true !== $this->zip->open($this->path, ZIPARCHIVE::CREATE)) {
            throw new PEAR2_Pyrus_Developer_Creator_Exception(
                'Cannot open ZIP archive ' . $this->path
            );
        }
    }

    /**
     * Create an internal directory, creating parent directories as needed
     * 
     * This is a no-op for the tar creator
     * @param string $dir
     */
    function mkdir($dir)
    {
    }

    /**
     * Finish saving the package
     */
    function close()
    {
        $this->zip->close();
    }
}<?php
class PEAR2_Pyrus_Developer_PackageFile_PEAR2SVN_Filter extends FilterIterator
{
    protected $path;
    protected $role;
    function __construct($path, $it, $role)
    {
        $this->path = $path;
        $this->role = $role;
        parent::__construct($it);
    }

    public function accept()
    {
    	if ($this->getInnerIterator()->isDot()) {
    	    return false;
    	}
    
    	$path = str_replace('\\', '/', $this->path);
        $path = str_replace($path, '', $this->getInnerIterator()->current()->getPathName());
        if ($path && $path[0] === DIRECTORY_SEPARATOR) {
            $path = substr($path, 1);
        }
        
        if (preg_match('@/?\.svn/@', $path)) {
        	return false;
        }
        
        switch($this->role) {
	    case 'test':
		    return $this->filterTestsDir();
        }
        return true;
    }
    
    function filterTestsDir()
    {
	if ($this->getInnerIterator()->current()->getBasename() == 'pear2coverage.db') {
	    return false;
	}
    	$invalid_extensions = array('diff','exp','log','out', 'xdebug');
	$info = pathinfo($this->getInnerIterator()->current()->getPathName());
	if (!isset($info['extension'])) {
	    return true;
	}
	return !in_array($info['extension'], $invalid_extensions);
    }
}
<?php
/**
 * Create a brand new package.xml from the subversion layout of a PEAR2 package
 *
 * This class assumes:
 *
 *  1. the source layout is:
 *     <pre>
 *     PackageName/src      [role="php"]
 *                /examples [role="doc"]
 *                /doc      [role="doc"]
 *                /data     [role="data"]
 *                /tests    [role="test"]
 *                /www      [role="www"]
 *                /scripts  [role="script"]
 *     </pre>
 *  2. if file PackageName/README exists, it contains the summary as the first line,
 *     and the description as the rest of the file
 *  3. if file PackageName/CREDITS exists, it contains the maintainers in this format:
 *     ; comment ignored
 *     Name [handle] <email> (role)
 *     Name2 [handle2] <email> (role/inactive)
 *
 * All maintainers are assumed to be lead maintainers in CREDITS.
 */
class PEAR2_Pyrus_Developer_PackageFile_PEAR2SVN
{
    protected $path;
    protected $package;
    protected $pxml;
    /**
     * Create or update a package.xml from CVS
     *
     * @param string $path full path to the SVN checkout
     * @param string $packagename Package name (PEAR2_Pyrus, for example)
     * @param string $channel Channel (pear2.php.net)
     * @param bool $return if true, creation is not attempted in the constructor,
     *                     otherwise, the constructor writes package.xml to disk
     *                     if possible
     * @param bool $fullpathsused if true, for package PEAR2_Package_Name it is
     *                            assumed that src/PEAR2/Package/ exists in SVN,
     *                            otherwise, we assume src/ is used and baseinstalldir
     *                            should be PEAR2/Package for "/" directory
     */
    function __construct($path, $packagename = '##set me##', $channel = 'pear2.php.net',
                         $return = false, $fullpathsused = true)
    {
        if (file_exists($path . DIRECTORY_SEPARATOR . 'package.xml')) {
            try {
                $this->pxml = new PEAR2_Pyrus_PackageFile(
                    $path . DIRECTORY_SEPARATOR . 'package.xml',
                    'PEAR2_Pyrus_Developer_PackageFile_v2');
                $this->pxml = $this->pxml->info;
                $this->pxml->setFilelist(array());
            } catch (Exception $e) {
                $this->pxml = new PEAR2_Pyrus_Developer_PackageFile_v2;
                $this->pxml->name = $packagename;
                $this->pxml->channel = $channel;
            }
        } else {
            $this->pxml = new PEAR2_Pyrus_Developer_PackageFile_v2;
            $this->pxml->name = $packagename;
            $this->pxml->channel = $channel;
        }
        $this->path = $path;
        
        $this->parseREADME();
        $this->parseCREDITS();
        $this->parseRELEASE();
        
        $packagepath = explode('_', $packagename);

        if ($fullpathsused) {
            $packagepath = array('PEAR2');
        } else {
            array_pop($packagepath);
        }

        $this->scanFiles($packagepath);
        
        try {
            if (!$return) {
                file_put_contents($path . DIRECTORY_SEPARATOR . 'package.xml', $this->pxml);
            }
        } catch (Exception $e) {
            // ignore - we'll let the user do this business
            echo 'WARNING: validation failed in constructor, you must fix the package.xml ' .
                'manually:', $e;
        }
    }
    
    /**
     * Scan the directories top populate the package file contents.
     *
     * @param string $packagepath
     */
    function scanFiles($packagepath)
    {
        $this->pxml->setBaseInstallDirs(array(
            'src'     => implode('/', $packagepath),
            'data'    => '/',
            'doc'     => '/',
            'tests'   => '/',
            'scripts' => '/'
        ));
        
        $rolemap = array(
            'src'      => 'php',
            'data'     => 'data',
            'doc'      => 'doc',
            'tests'    => 'test',
            'examples' => 'doc',
            'scripts'  => 'script');
        foreach ($rolemap as $dir => $role) {
            if (file_exists($this->path . DIRECTORY_SEPARATOR . $dir)) {
                $basepath = ($dir === 'examples') ? 'examples' : '';
                foreach (new PEAR2_Pyrus_Developer_PackageFile_PEAR2SVN_Filter(
                            $this->path . DIRECTORY_SEPARATOR . $dir,
                         new RecursiveIteratorIterator(
                         new RecursiveDirectoryIterator($this->path . DIRECTORY_SEPARATOR . $dir),
                         RecursiveIteratorIterator::LEAVES_ONLY), $role) as $file) {
                    $curpath = str_replace($this->path . DIRECTORY_SEPARATOR . $dir, '',
                        $file->getPathName());
                    if ($curpath && $curpath[0] === DIRECTORY_SEPARATOR) {
                        $curpath = substr($curpath, 1);
                    }
                    $curpath = $dir . '/' . $curpath;
                    $curpath = str_replace('\\', '/', $curpath);
                    $curpath = str_replace('//', '/', $curpath);
                    $this->pxml->files[$curpath] =
                        array(
                            'attribs' => array('role' => $role)
                        );
                }
            }
        }
    }
    
    /**
     * Parse the README file to populate the package summary and description.
     *
     */
    function parseREADME()
    {
        $description = '';
        if (file_exists($this->path . DIRECTORY_SEPARATOR . 'README')) {
            $a = new SplFileInfo($this->path . DIRECTORY_SEPARATOR . 'README');
            foreach ($a->openFile('r') as $num => $line) {
                if (!$num) {
                    $this->pxml->summary = $line;
                    continue;
                }
                $description .= $line;
            }
            $this->pxml->description = $description;
        }
    }
    
    /**
     * Parse the CREDITS file to populate the package developers, roles and email.
     *
     */
    function parseCREDITS()
    {
        if (file_exists($this->path . DIRECTORY_SEPARATOR . 'CREDITS')) {
            $a = new SplFileInfo($this->path . DIRECTORY_SEPARATOR . 'CREDITS');
            foreach ($a->openFile('r') as $line) {
                if ($line && $line[0] === ';') {
                    continue;
                }
                if (preg_match('/^(.+) \[(.+)\] \<(.+)\> \((.+?)(\/inactive)?\)/', $line, $match)) {
                    $this->pxml->maintainer[$match[2]]
                        ->role($match[4])
                        ->name($match[1])
                        ->email($match[3])
                        ->active(isset($match[5]) ? 'no' : 'yes');
                }
            }
        }
    }
    
    /**
     * Parse the RELEASE file to populate the release notes.
     *
     */
    function parseRELEASE()
    {
        if (file_exists($this->path . DIRECTORY_SEPARATOR . 'RELEASE-' . $this->pxml->version['release'])) {
            $this->pxml->notes = file_get_contents(
                $this->path . DIRECTORY_SEPARATOR . 'RELEASE-' . $this->pxml->version['release']);
        }
    }

    function __toString()
    {
        echo $this->pxml;
    }

    function __set($var, $value)
    {
        $this->pxml->$var = $value;
    }

    function __get($var)
    {
        return $this->pxml->$var;
    }
}<?php
class PEAR2_Pyrus_Developer_PackageFile_v2 extends PEAR2_Pyrus_PackageFile_v2
{
    function toArray($forpackaging = false)
    {
        if ($forpackaging) {
            return parent::toArray($forpackaging);
        }
        $a = parent::toArray();
        if (isset($a['package']['contents']['dir'])) {
            $a['package']['contents']['dir'] =
                $this->_recursiveXmlFilelist();
        }
        return $a;
    }

    function _recursiveXmlFilelist()
    {
        $dirs = array();
        foreach ($this->filelist as $file => $attribs) {
            $dirs = $this->_addDir($dirs, explode('/', dirname($file)), $file, $attribs);
        }
        $dirs = $this->_formatDir($dirs);
        $dirs = $this->_deFormat($dirs);
        $temp = $dirs;
        $dirs = array('attribs' => array('name' => '/'));
        if (isset($this->baseinstalldirs['/'])) {
            $dirs['attribs']['baseinstalldir'] = $this->baseinstalldirs['/'];
        } elseif (isset($this->baseinstalldirs[''])) {
            $dirs['attribs']['baseinstalldir'] = $this->baseinstalldirs[''];
        }
        foreach ($temp as $key => $info) {
            $dirs[$key] = $info;
        }
        return $dirs;
    }

    function _addDir($dirs, $dir, $file = null, $attributes = null)
    {
        if ($dir == array() || $dir == array('.')) {
            $attributes['attribs']['name'] = basename($file);
            $dirs['file'][basename($file)] = $attributes;
            return $dirs;
        }
        $curdir = array_shift($dir);
        if (!isset($dirs['dir'][$curdir])) {
            $dirs['dir'][$curdir] = array();
        }
        $dirs['dir'][$curdir] = $this->_addDir($dirs['dir'][$curdir], $dir, $file, $attributes);
        return $dirs;
    }

    function _formatDir($dirs)
    {
        if (!count($dirs)) {
            return array();
        }
        $newdirs = array();
        if (isset($dirs['attribs'])) {
            $newdirs['attribs'] = $dirs['attribs'];
        }
        if (isset($dirs['dir'])) {
            $newdirs['dir'] = $dirs['dir'];
        }
        if (isset($dirs['file'])) {
            $newdirs['file'] = $dirs['file'];
        }
        $dirs = $newdirs;
        if (isset($dirs['dir'])) {
            uksort($dirs['dir'], 'strnatcasecmp');
            foreach ($dirs['dir'] as $dir => $contents) {
                $dirs['dir'][$dir] = $this->_formatDir($dirs['dir'][$dir]);
            }
        }
        if (isset($dirs['file'])) {
            uksort($dirs['file'], 'strnatcasecmp');
        };
        return $dirs;
    }

    function _deFormat($dirs)
    {
        if (!count($dirs)) {
            return array();
        }
        $newdirs = array();
        if (isset($dirs['attribs'])) {
            $newdirs['attribs'] = $dirs['attribs'];
        }
        if (isset($dirs['dir'])) {
            foreach ($dirs['dir'] as $dir => $contents) {
                $newdir = array();
                $newdir['attribs']['name'] = $dir;
                if (isset($this->baseinstalldirs[$dir])) {
                    $newdir['attribs']['baseinstalldir'] = $this->baseinstalldirs[$dir];
                }
                $contents = $this->_deFormat($contents);
                foreach ($contents as $tag => $val) {
                    $newdir[$tag] = $val;
                }
                $newdirs['dir'][] = $newdir;
            }
            if (count($newdirs['dir']) == 1) {
                $newdirs['dir'] = $newdirs['dir'][0];
            }
        }
        if (isset($dirs['file'])) {
            foreach ($dirs['file'] as $name => $file) {
                $newdirs['file'][] = $file;
            }
            if (count($newdirs['file']) == 1) {
                $newdirs['file'] = $newdirs['file'][0];
            }
        }
        return $newdirs;
    }
}Ÿ{ú‡_+í·%î|
n‡"éûo   GBMB